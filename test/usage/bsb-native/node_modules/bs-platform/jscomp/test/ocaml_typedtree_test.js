'use strict';

var Arg                     = require("../../lib/js/arg.js");
var Sys                     = require("../../lib/js/sys.js");
var Char                    = require("../../lib/js/char.js");
var List                    = require("../../lib/js/list.js");
var Path                    = require("path");
var $$Array                 = require("../../lib/js/array.js");
var Block                   = require("../../lib/js/block.js");
var Bytes                   = require("../../lib/js/bytes.js");
var Curry                   = require("../../lib/js/curry.js");
var Int32                   = require("../../lib/js/int32.js");
var Int64                   = require("../../lib/js/int64.js");
var Buffer                  = require("../../lib/js/buffer.js");
var Digest                  = require("../../lib/js/digest.js");
var Format                  = require("../../lib/js/format.js");
var Js_exn                  = require("../../lib/js/js_exn.js");
var Lexing                  = require("../../lib/js/lexing.js");
var Printf                  = require("../../lib/js/printf.js");
var $$String                = require("../../lib/js/string.js");
var Assert                  = require("assert");
var Caml_io                 = require("../../lib/js/caml_io.js");
var Hashtbl                 = require("../../lib/js/hashtbl.js");
var Marshal                 = require("../../lib/js/marshal.js");
var Parsing                 = require("../../lib/js/parsing.js");
var Process                 = require("process");
var Caml_obj                = require("../../lib/js/caml_obj.js");
var Caml_sys                = require("../../lib/js/caml_sys.js");
var Filename                = require("../../lib/js/filename.js");
var Caml_weak               = require("../../lib/js/caml_weak.js");
var Nativeint               = require("../../lib/js/nativeint.js");
var Caml_array              = require("../../lib/js/caml_array.js");
var Caml_bytes              = require("../../lib/js/caml_bytes.js");
var Caml_float              = require("../../lib/js/caml_float.js");
var Caml_int32              = require("../../lib/js/caml_int32.js");
var Caml_int64              = require("../../lib/js/caml_int64.js");
var Pervasives              = require("../../lib/js/pervasives.js");
var Caml_format             = require("../../lib/js/caml_format.js");
var Caml_string             = require("../../lib/js/caml_string.js");
var Caml_exceptions         = require("../../lib/js/caml_exceptions.js");
var CamlinternalLazy        = require("../../lib/js/camlinternalLazy.js");
var CamlinternalFormat      = require("../../lib/js/camlinternalFormat.js");
var Caml_missing_polyfill   = require("../../lib/js/caml_missing_polyfill.js");
var Caml_builtin_exceptions = require("../../lib/js/caml_builtin_exceptions.js");

var cmi_magic_number = "Caml1999I017";

var load_path = [/* [] */0];

var interface_suffix = [".mli"];

var print_types = [/* false */0];

var debug = /* false */0;

var fast = [/* false */0];

var classic = [/* false */0];

var nopervasives = /* false */0;

var annotations = [/* false */0];

var binary_annotations = [/* false */0];

var principal = [/* false */0];

var real_paths = [/* true */1];

var recursive_types = [/* false */0];

var strict_sequence = [/* false */0];

var strict_formats = [/* false */0];

var applicative_functors = [/* true */1];

var error_size = [500];

var transparent_modules = [/* false */0];

var native_code = [/* false */0];

var dont_write_files = [/* false */0];

var keep_docs = [/* false */0];

var keep_locs = [/* false */0];

var unsafe_string = /* true */1;

var assume_no_mli = [/* Mli_na */0];

var record_event_when_debug = /* true */1;

var bs_vscode;

try {
  Caml_sys.caml_sys_getenv("BS_VSCODE");
  bs_vscode = /* true */1;
}
catch (exn){
  bs_vscode = /* false */0;
}

var color = [/* Auto */0];

var Fatal_error = Caml_exceptions.create("Ocaml_typedtree_test.Misc.Fatal_error");

function fatal_error(msg) {
  Pervasives.prerr_string(">> Fatal error: ");
  console.error(msg);
  throw Fatal_error;
}

function try_finally(work, cleanup) {
  var result;
  try {
    result = Curry._1(work, /* () */0);
  }
  catch (e){
    Curry._1(cleanup, /* () */0);
    throw e;
  }
  Curry._1(cleanup, /* () */0);
  return result;
}

function map_end(f, l1, l2) {
  if (l1) {
    return /* :: */[
            Curry._1(f, l1[0]),
            map_end(f, l1[1], l2)
          ];
  } else {
    return l2;
  }
}

function for_all2(pred, _l1, _l2) {
  while(true) {
    var l2 = _l2;
    var l1 = _l1;
    if (l1) {
      if (l2) {
        if (Curry._2(pred, l1[0], l2[0])) {
          _l2 = l2[1];
          _l1 = l1[1];
          continue ;
          
        } else {
          return /* false */0;
        }
      } else {
        return /* false */0;
      }
    } else if (l2) {
      return /* false */0;
    } else {
      return /* true */1;
    }
  };
}

function replicate_list(elem, n) {
  if (n <= 0) {
    return /* [] */0;
  } else {
    return /* :: */[
            elem,
            replicate_list(elem, n - 1 | 0)
          ];
  }
}

function split_last(param) {
  if (param) {
    var tl = param[1];
    var x = param[0];
    if (tl) {
      var match = split_last(tl);
      return /* tuple */[
              /* :: */[
                x,
                match[0]
              ],
              match[1]
            ];
    } else {
      return /* tuple */[
              /* [] */0,
              x
            ];
    }
  } else {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "misc.ml",
            54,
            10
          ]
        ];
  }
}

function may(f, param) {
  if (param) {
    return Curry._1(f, param[0]);
  } else {
    return /* () */0;
  }
}

function may_map(f, param) {
  if (param) {
    return /* Some */[Curry._1(f, param[0])];
  } else {
    return /* None */0;
  }
}

function find_in_path_uncap(path, name) {
  var uname = Caml_string.bytes_to_string(Bytes.uncapitalize(Caml_string.bytes_of_string(name)));
  var _param = path;
  while(true) {
    var param = _param;
    if (param) {
      var dir = param[0];
      var fullname = Filename.concat(dir, name);
      var ufullname = Filename.concat(dir, uname);
      if (Caml_missing_polyfill.not_implemented("caml_sys_file_exists not implemented by bucklescript yet\n")) {
        return ufullname;
      } else if (Caml_missing_polyfill.not_implemented("caml_sys_file_exists not implemented by bucklescript yet\n")) {
        return fullname;
      } else {
        _param = param[1];
        continue ;
        
      }
    } else {
      throw Caml_builtin_exceptions.not_found;
    }
  };
}

function remove_file() {
  try {
    return Caml_missing_polyfill.not_implemented("caml_sys_remove not implemented by bucklescript yet\n");
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === Caml_builtin_exceptions.sys_error) {
      return /* () */0;
    } else {
      throw exn;
    }
  }
}

function create_hashtable(size, init) {
  var tbl = Hashtbl.create(/* None */0, size);
  List.iter((function (param) {
          return Hashtbl.add(tbl, param[0], param[1]);
        }), init);
  return tbl;
}

function chop_extension_if_any(fname) {
  try {
    return Filename.chop_extension(fname);
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === Caml_builtin_exceptions.invalid_argument) {
      return fname;
    } else {
      throw exn;
    }
  }
}

function get_ref(r) {
  var v = r[0];
  r[0] = /* [] */0;
  return v;
}

function edit_distance(a, b, cutoff) {
  var match_000 = a.length;
  var match_001 = b.length;
  var lb = match_001;
  var la = match_000;
  var cutoff$1 = Pervasives.min(Pervasives.max(la, lb), cutoff);
  if (Pervasives.abs(la - lb | 0) > cutoff$1) {
    return /* None */0;
  } else {
    var m = $$Array.make_matrix(la + 1 | 0, lb + 1 | 0, cutoff$1 + 1 | 0);
    Caml_array.caml_array_set(Caml_array.caml_array_get(m, 0), 0, 0);
    for(var i = 1; i <= la; ++i){
      Caml_array.caml_array_set(Caml_array.caml_array_get(m, i), 0, i);
    }
    for(var j = 1; j <= lb; ++j){
      Caml_array.caml_array_set(Caml_array.caml_array_get(m, 0), j, j);
    }
    for(var i$1 = 1; i$1 <= la; ++i$1){
      for(var j$1 = Pervasives.max(1, (i$1 - cutoff$1 | 0) - 1 | 0) ,j_finish = Pervasives.min(lb, (i$1 + cutoff$1 | 0) + 1 | 0); j$1 <= j_finish; ++j$1){
        var cost = Caml_string.get(a, i$1 - 1 | 0) === Caml_string.get(b, j$1 - 1 | 0) ? 0 : 1;
        var best = Pervasives.min(1 + Pervasives.min(Caml_array.caml_array_get(Caml_array.caml_array_get(m, i$1 - 1 | 0), j$1), Caml_array.caml_array_get(Caml_array.caml_array_get(m, i$1), j$1 - 1 | 0)) | 0, Caml_array.caml_array_get(Caml_array.caml_array_get(m, i$1 - 1 | 0), j$1 - 1 | 0) + cost | 0);
        var best$1 = i$1 > 1 && j$1 > 1 && Caml_string.get(a, i$1 - 1 | 0) === Caml_string.get(b, j$1 - 2 | 0) && Caml_string.get(a, i$1 - 2 | 0) === Caml_string.get(b, j$1 - 1 | 0) ? Pervasives.min(best, Caml_array.caml_array_get(Caml_array.caml_array_get(m, i$1 - 2 | 0), j$1 - 2 | 0) + cost | 0) : best;
        Caml_array.caml_array_set(Caml_array.caml_array_get(m, i$1), j$1, best$1);
      }
    }
    var result = Caml_array.caml_array_get(Caml_array.caml_array_get(m, la), lb);
    if (result > cutoff$1) {
      return /* None */0;
    } else {
      return /* Some */[result];
    }
  }
}

function ansi_of_color(param) {
  switch (param) {
    case 0 : 
        return "0";
    case 1 : 
        return "1";
    case 2 : 
        return "2";
    case 3 : 
        return "3";
    case 4 : 
        return "4";
    case 5 : 
        return "5";
    case 6 : 
        return "6";
    case 7 : 
        return "7";
    
  }
}

function code_of_style(param) {
  if (typeof param === "number") {
    if (param) {
      return "0";
    } else {
      return "1";
    }
  } else if (param.tag) {
    return "4" + ansi_of_color(param[0]);
  } else {
    return "3" + ansi_of_color(param[0]);
  }
}

function ansi_of_style_l(l) {
  var s = l ? (
      l[1] ? $$String.concat(";", List.map(code_of_style, l)) : code_of_style(l[0])
    ) : "0";
  return "\x1b[" + (s + "m");
}

var default_styles = /* record */[
  /* error : :: */[
    /* Bold */0,
    /* :: */[
      /* FG */Block.__(0, [/* Red */1]),
      /* [] */0
    ]
  ],
  /* warning : :: */[
    /* Bold */0,
    /* :: */[
      /* FG */Block.__(0, [/* Magenta */5]),
      /* [] */0
    ]
  ],
  /* loc : :: */[
    /* Bold */0,
    /* [] */0
  ]
];

var cur_styles = [default_styles];

function get_styles() {
  return cur_styles[0];
}

function set_styles(s) {
  cur_styles[0] = s;
  return /* () */0;
}

function style_of_tag(s) {
  switch (s) {
    case "error" : 
        return cur_styles[0][/* error */0];
    case "loc" : 
        return cur_styles[0][/* loc */2];
    case "warning" : 
        return cur_styles[0][/* warning */1];
    default:
      throw Caml_builtin_exceptions.not_found;
  }
}

var color_enabled = [/* true */1];

function set_color_tag_handling(ppf) {
  var functions = Format.pp_get_formatter_tag_functions(ppf, /* () */0);
  var partial_arg = functions[/* mark_open_tag */0];
  var partial_arg$1 = functions[/* mark_close_tag */1];
  var functions$prime_000 = function (param) {
    var or_else = partial_arg;
    var s = param;
    try {
      var style = style_of_tag(s);
      if (color_enabled[0]) {
        return ansi_of_style_l(style);
      } else {
        return "";
      }
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        return Curry._1(or_else, s);
      } else {
        throw exn;
      }
    }
  };
  var functions$prime_001 = function (param) {
    var or_else = partial_arg$1;
    var s = param;
    try {
      style_of_tag(s);
      if (color_enabled[0]) {
        return ansi_of_style_l(/* :: */[
                    /* Reset */1,
                    /* [] */0
                  ]);
      } else {
        return "";
      }
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        return Curry._1(or_else, s);
      } else {
        throw exn;
      }
    }
  };
  var functions$prime_002 = /* print_open_tag */functions[/* print_open_tag */2];
  var functions$prime_003 = /* print_close_tag */functions[/* print_close_tag */3];
  var functions$prime = /* record */[
    functions$prime_000,
    functions$prime_001,
    functions$prime_002,
    functions$prime_003
  ];
  ppf[/* pp_mark_tags */21] = /* true */1;
  return Format.pp_set_formatter_tag_functions(ppf, functions$prime);
}

var first = [/* true */1];

var formatter_l_001 = /* :: */[
  Format.err_formatter,
  /* :: */[
    Format.str_formatter,
    /* [] */0
  ]
];

var formatter_l = /* :: */[
  Format.std_formatter,
  formatter_l_001
];

function setup(o) {
  if (first[0]) {
    first[0] = /* false */0;
    Format.set_mark_tags(/* true */1);
    List.iter(set_color_tag_handling, formatter_l);
    var $js;
    switch (o) {
      case 1 : 
          $js = /* true */1;
          break;
      case 0 : 
      case 2 : 
          $js = /* false */0;
          break;
      
    }
    color_enabled[0] = $js;
  }
  return /* () */0;
}

var Misc_043 = /* Color */[
  ansi_of_style_l,
  default_styles,
  get_styles,
  set_styles,
  setup,
  set_color_tag_handling
];

function number(param) {
  if (typeof param === "number") {
    switch (param) {
      case 0 : 
          return 1;
      case 1 : 
          return 2;
      case 2 : 
          return 5;
      case 3 : 
          return 6;
      case 4 : 
          return 10;
      case 5 : 
          return 11;
      case 6 : 
          return 12;
      case 7 : 
          return 14;
      case 8 : 
          return 16;
      case 9 : 
          return 20;
      case 10 : 
          return 21;
      case 11 : 
          return 23;
      case 12 : 
          return 25;
      case 13 : 
          return 28;
      case 14 : 
          return 29;
      case 15 : 
          return 39;
      
    }
  } else {
    switch (param.tag | 0) {
      case 0 : 
          return 3;
      case 1 : 
          return 4;
      case 2 : 
          return 7;
      case 3 : 
          return 8;
      case 4 : 
          return 9;
      case 5 : 
          return 13;
      case 6 : 
          return 15;
      case 7 : 
          return 17;
      case 8 : 
          return 18;
      case 9 : 
          return 19;
      case 10 : 
          return 22;
      case 11 : 
          return 24;
      case 12 : 
          return 26;
      case 13 : 
          return 27;
      case 14 : 
          return 30;
      case 15 : 
          return 31;
      case 16 : 
          return 32;
      case 17 : 
          return 33;
      case 18 : 
          return 34;
      case 19 : 
          return 35;
      case 20 : 
          return 36;
      case 21 : 
          return 37;
      case 22 : 
          return 38;
      case 23 : 
          return 40;
      case 24 : 
          return 41;
      case 25 : 
          return 42;
      case 26 : 
          return 43;
      case 27 : 
          return 44;
      case 28 : 
          return 45;
      case 29 : 
          return 46;
      case 30 : 
          return 47;
      case 31 : 
          return 48;
      case 32 : 
          return 49;
      case 33 : 
          return 50;
      
    }
  }
}

function letter(param) {
  var switcher = param - 97 | 0;
  if (switcher > 25 || switcher < 0) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "warnings.ml",
            164,
            9
          ]
        ];
  } else {
    switch (switcher) {
      case 0 : 
          var loop = function (i) {
            if (i) {
              return /* :: */[
                      i,
                      loop(i - 1 | 0)
                    ];
            } else {
              return /* [] */0;
            }
          };
          return loop(50);
      case 2 : 
          return /* :: */[
                  1,
                  /* :: */[
                    2,
                    /* [] */0
                  ]
                ];
      case 3 : 
          return /* :: */[
                  3,
                  /* [] */0
                ];
      case 4 : 
          return /* :: */[
                  4,
                  /* [] */0
                ];
      case 5 : 
          return /* :: */[
                  5,
                  /* [] */0
                ];
      case 10 : 
          return /* :: */[
                  32,
                  /* :: */[
                    33,
                    /* :: */[
                      34,
                      /* :: */[
                        35,
                        /* :: */[
                          36,
                          /* :: */[
                            37,
                            /* :: */[
                              38,
                              /* :: */[
                                39,
                                /* [] */0
                              ]
                            ]
                          ]
                        ]
                      ]
                    ]
                  ]
                ];
      case 11 : 
          return /* :: */[
                  6,
                  /* [] */0
                ];
      case 12 : 
          return /* :: */[
                  7,
                  /* [] */0
                ];
      case 15 : 
          return /* :: */[
                  8,
                  /* [] */0
                ];
      case 17 : 
          return /* :: */[
                  9,
                  /* [] */0
                ];
      case 18 : 
          return /* :: */[
                  10,
                  /* [] */0
                ];
      case 20 : 
          return /* :: */[
                  11,
                  /* :: */[
                    12,
                    /* [] */0
                  ]
                ];
      case 21 : 
          return /* :: */[
                  13,
                  /* [] */0
                ];
      case 1 : 
      case 6 : 
      case 7 : 
      case 8 : 
      case 9 : 
      case 13 : 
      case 14 : 
      case 16 : 
      case 19 : 
      case 22 : 
          return /* [] */0;
      case 23 : 
          return /* :: */[
                  14,
                  /* :: */[
                    15,
                    /* :: */[
                      16,
                      /* :: */[
                        17,
                        /* :: */[
                          18,
                          /* :: */[
                            19,
                            /* :: */[
                              20,
                              /* :: */[
                                21,
                                /* :: */[
                                  22,
                                  /* :: */[
                                    23,
                                    /* :: */[
                                      24,
                                      /* :: */[
                                        25,
                                        /* :: */[
                                          30,
                                          /* [] */0
                                        ]
                                      ]
                                    ]
                                  ]
                                ]
                              ]
                            ]
                          ]
                        ]
                      ]
                    ]
                  ]
                ];
      case 24 : 
          return /* :: */[
                  26,
                  /* [] */0
                ];
      case 25 : 
          return /* :: */[
                  27,
                  /* [] */0
                ];
      
    }
  }
}

var current = [/* record */[
    /* active */Caml_array.caml_make_vect(51, /* true */1),
    /* error */Caml_array.caml_make_vect(51, /* false */0)
  ]];

function is_active(x) {
  return Caml_array.caml_array_get(current[0][/* active */0], number(x));
}

function parse_opt(error, active, flags, s) {
  var set = function (i) {
    return Caml_array.caml_array_set(flags, i, /* true */1);
  };
  var clear = function (i) {
    return Caml_array.caml_array_set(flags, i, /* false */0);
  };
  var set_all = function (i) {
    Caml_array.caml_array_set(active, i, /* true */1);
    return Caml_array.caml_array_set(error, i, /* true */1);
  };
  var get_num = function (_n, _i) {
    while(true) {
      var i = _i;
      var n = _n;
      if (i >= s.length) {
        return /* tuple */[
                i,
                n
              ];
      } else {
        var match = Caml_string.get(s, i);
        if (match > 57 || match < 48) {
          return /* tuple */[
                  i,
                  n
                ];
        } else {
          _i = i + 1 | 0;
          _n = (Caml_int32.imul(10, n) + Caml_string.get(s, i) | 0) - /* "0" */48 | 0;
          continue ;
          
        }
      }
    };
  };
  var get_range = function (i) {
    var match = get_num(0, i);
    var n1 = match[1];
    var i$1 = match[0];
    if ((i$1 + 2 | 0) < s.length && Caml_string.get(s, i$1) === /* "." */46 && Caml_string.get(s, i$1 + 1 | 0) === /* "." */46) {
      var match$1 = get_num(0, i$1 + 2 | 0);
      var n2 = match$1[1];
      if (n2 < n1) {
        throw [
              Arg.Bad,
              "Ill-formed list of warnings"
            ];
      }
      return /* tuple */[
              match$1[0],
              n1,
              n2
            ];
    } else {
      return /* tuple */[
              i$1,
              n1,
              n1
            ];
    }
  };
  var loop = function (_i) {
    while(true) {
      var i = _i;
      if (i >= s.length) {
        return /* () */0;
      } else {
        var c = Caml_string.get(s, i);
        if (c >= 65) {
          if (c >= 97) {
            if (c >= 123) {
              throw [
                    Arg.Bad,
                    "Ill-formed list of warnings"
                  ];
            } else {
              List.iter(clear, letter(Caml_string.get(s, i)));
              _i = i + 1 | 0;
              continue ;
              
            }
          } else if (c >= 91) {
            throw [
                  Arg.Bad,
                  "Ill-formed list of warnings"
                ];
          } else {
            List.iter(set, letter(Char.lowercase(Caml_string.get(s, i))));
            _i = i + 1 | 0;
            continue ;
            
          }
        } else if (c >= 46) {
          if (c >= 64) {
            return loop_letter_num(set_all, i + 1 | 0);
          } else {
            throw [
                  Arg.Bad,
                  "Ill-formed list of warnings"
                ];
          }
        } else if (c >= 43) {
          switch (c - 43 | 0) {
            case 0 : 
                return loop_letter_num(set, i + 1 | 0);
            case 1 : 
                throw [
                      Arg.Bad,
                      "Ill-formed list of warnings"
                    ];
            case 2 : 
                return loop_letter_num(clear, i + 1 | 0);
            
          }
        } else {
          throw [
                Arg.Bad,
                "Ill-formed list of warnings"
              ];
        }
      }
    };
  };
  var loop_letter_num = function (myset, i) {
    if (i >= s.length) {
      throw [
            Arg.Bad,
            "Ill-formed list of warnings"
          ];
    } else {
      var match = Caml_string.get(s, i);
      if (match >= 65) {
        if (match >= 97) {
          if (match >= 123) {
            throw [
                  Arg.Bad,
                  "Ill-formed list of warnings"
                ];
          } else {
            List.iter(myset, letter(Caml_string.get(s, i)));
            return loop(i + 1 | 0);
          }
        } else if (match >= 91) {
          throw [
                Arg.Bad,
                "Ill-formed list of warnings"
              ];
        } else {
          List.iter(myset, letter(Char.lowercase(Caml_string.get(s, i))));
          return loop(i + 1 | 0);
        }
      } else if (match > 57 || match < 48) {
        throw [
              Arg.Bad,
              "Ill-formed list of warnings"
            ];
      } else {
        var match$1 = get_range(i);
        for(var n = match$1[1] ,n_finish = Pervasives.min(match$1[2], 50); n <= n_finish; ++n){
          Curry._1(myset, n);
        }
        return loop(match$1[0]);
      }
    }
  };
  return loop(0);
}

function parse_options(errflag, s) {
  var error = $$Array.copy(current[0][/* error */1]);
  var active = $$Array.copy(current[0][/* active */0]);
  parse_opt(error, active, errflag ? error : active, s);
  current[0] = /* record */[
    /* active */active,
    /* error */error
  ];
  return /* () */0;
}

parse_options(/* false */0, "+a-4-6-7-9-27-29-32..39-41..42-44-45-48-50");

parse_options(/* true */1, "-a");

function message(param) {
  if (typeof param === "number") {
    switch (param) {
      case 0 : 
          return "this is the start of a comment.";
      case 1 : 
          return "this is not the end of a comment.";
      case 2 : 
          return "this function application is partial,\nmaybe some arguments are missing.";
      case 3 : 
          return "labels were omitted in the application of this function.";
      case 4 : 
          return "this expression should have type unit.";
      case 5 : 
          return "this match case is unused.";
      case 6 : 
          return "this sub-pattern is unused.";
      case 7 : 
          return "illegal backslash escape in string.";
      case 8 : 
          return "this optional argument cannot be erased.";
      case 9 : 
          return "this argument will not be used by the function.";
      case 10 : 
          return "this statement never returns (or has an unsound type.)";
      case 11 : 
          return "all the fields are explicitly listed in this record:\nthe 'with' clause is useless.";
      case 12 : 
          return "bad style, all clauses in this pattern-matching are guarded.";
      case 13 : 
          return "wildcard pattern given as argument to a constant constructor";
      case 14 : 
          return "unescaped end-of-line in a string constant (non-portable code)";
      case 15 : 
          return "unused rec flag.";
      
    }
  } else {
    switch (param.tag | 0) {
      case 0 : 
          return "deprecated: " + param[0];
      case 1 : 
          var s = param[0];
          if (s === "") {
            return "this pattern-matching is fragile.";
          } else {
            return "this pattern-matching is fragile.\nIt will remain exhaustive when constructors are added to type " + (s + ".");
          }
          break;
      case 2 : 
          var match = param[0];
          if (match) {
            var slist = match[1];
            var lab = match[0];
            if (slist) {
              return $$String.concat(" ", /* :: */[
                          "the following methods are overridden by the class",
                          /* :: */[
                            lab,
                            /* :: */[
                              ":\n ",
                              slist
                            ]
                          ]
                        ]);
            } else {
              return "the method " + (lab + " is overridden.");
            }
          } else {
            throw [
                  Caml_builtin_exceptions.assert_failure,
                  [
                    "warnings.ml",
                    271,
                    26
                  ]
                ];
          }
          break;
      case 3 : 
          var s$1 = param[0];
          if (s$1 === "") {
            return "this pattern-matching is not exhaustive.";
          } else {
            return "this pattern-matching is not exhaustive.\nHere is an example of a value that is not matched:\n" + s$1;
          }
          break;
      case 4 : 
          return "the following labels are not bound in this record pattern:\n" + (param[0] + "\nEither bind these labels explicitly or add '; _' to the pattern.");
      case 5 : 
          var match$1 = param[0];
          if (match$1) {
            var slist$1 = match$1[1];
            var lab$1 = match$1[0];
            if (slist$1) {
              return $$String.concat(" ", /* :: */[
                          "the following instance variables are overridden by the class",
                          /* :: */[
                            lab$1,
                            /* :: */[
                              ":\n ",
                              slist$1
                            ]
                          ]
                        ]) + "\nThe behaviour changed in ocaml 3.10 (previous behaviour was hiding.)";
            } else {
              return "the instance variable " + (lab$1 + " is overridden.\nThe behaviour changed in ocaml 3.10 (previous behaviour was hiding.)");
            }
          } else {
            throw [
                  Caml_builtin_exceptions.assert_failure,
                  [
                    "warnings.ml",
                    291,
                    37
                  ]
                ];
          }
          break;
      case 6 : 
          return "the following private methods were made public implicitly:\n " + ($$String.concat(" ", param[0]) + ".");
      case 7 : 
          return "the virtual method " + (param[0] + " is not declared.");
      case 8 : 
          return param[0] + " is not principal.";
      case 9 : 
          return param[0] + " without principality.";
      case 10 : 
          return param[0];
      case 11 : 
          return "bad source file name: \"" + (param[0] + "\" is not a valid module name.");
      case 12 : 
      case 13 : 
          return "unused variable " + (param[0] + ".");
      case 14 : 
          return Curry._4(Printf.sprintf(/* Format */[
                          /* String_literal */Block.__(11, [
                              "the ",
                              /* String */Block.__(2, [
                                  /* No_padding */0,
                                  /* Char_literal */Block.__(12, [
                                      /* " " */32,
                                      /* String */Block.__(2, [
                                          /* No_padding */0,
                                          /* String_literal */Block.__(11, [
                                              " is defined in both types ",
                                              /* String */Block.__(2, [
                                                  /* No_padding */0,
                                                  /* String_literal */Block.__(11, [
                                                      " and ",
                                                      /* String */Block.__(2, [
                                                          /* No_padding */0,
                                                          /* Char_literal */Block.__(12, [
                                                              /* "." */46,
                                                              /* End_of_format */0
                                                            ])
                                                        ])
                                                    ])
                                                ])
                                            ])
                                        ])
                                    ])
                                ])
                            ]),
                          "the %s %s is defined in both types %s and %s."
                        ]), param[0], param[1], param[2], param[3]);
      case 15 : 
          return Curry._3(Printf.sprintf(/* Format */[
                          /* String_literal */Block.__(11, [
                              "files ",
                              /* String */Block.__(2, [
                                  /* No_padding */0,
                                  /* String_literal */Block.__(11, [
                                      " and ",
                                      /* String */Block.__(2, [
                                          /* No_padding */0,
                                          /* String_literal */Block.__(11, [
                                              " both define a module named ",
                                              /* String */Block.__(2, [
                                                  /* No_padding */0,
                                                  /* End_of_format */0
                                                ])
                                            ])
                                        ])
                                    ])
                                ])
                            ]),
                          "files %s and %s both define a module named %s"
                        ]), param[1], param[2], param[0]);
      case 16 : 
          return "unused value " + (param[0] + ".");
      case 17 : 
          return "unused open " + (param[0] + ".");
      case 18 : 
          return "unused type " + (param[0] + ".");
      case 19 : 
          return "unused for-loop index " + (param[0] + ".");
      case 20 : 
          return "unused ancestor variable " + (param[0] + ".");
      case 21 : 
          var s$2 = param[0];
          if (param[1] !== 0) {
            return "constructor " + (s$2 + " is never used to build values.\n(However, this constructor appears in patterns.)");
          } else if (param[2] !== 0) {
            return "constructor " + (s$2 + " is never used to build values.\nIts type is exported as a private type.");
          } else {
            return "unused constructor " + (s$2 + ".");
          }
      case 22 : 
          var s$3 = param[0];
          if (param[1] !== 0) {
            return "extension constructor " + (s$3 + " is never used to build values.\n(However, this constructor appears in patterns.)");
          } else if (param[2] !== 0) {
            return "extension constructor " + (s$3 + " is never used to build values.\nIt is exported or rebound as a private extension.");
          } else {
            return "unused extension constructor " + (s$3 + ".");
          }
      case 23 : 
          var slist$2 = param[1];
          var ty = param[0];
          var exit = 0;
          if (slist$2) {
            if (slist$2[1]) {
              exit = 1;
            } else if (param[2] !== 0) {
              exit = 1;
            } else {
              return slist$2[0] + (" was selected from type " + (ty + ".\nIt is not visible in the current scope, and will not \nbe selected if the type becomes unknown."));
            }
          } else {
            exit = 1;
          }
          if (exit === 1) {
            if (param[2] !== 0) {
              return "this record of type " + (ty + (" contains fields that are \nnot visible in the current scope: " + ($$String.concat(" ", slist$2) + ".\nThey will not be selected if the type becomes unknown.")));
            } else {
              throw [
                    Caml_builtin_exceptions.assert_failure,
                    [
                      "warnings.ml",
                      353,
                      39
                    ]
                  ];
            }
          }
          break;
      case 24 : 
          var slist$3 = param[0];
          var exit$1 = 0;
          if (slist$3) {
            if (slist$3[1]) {
              exit$1 = 1;
            } else if (param[2] !== 0) {
              exit$1 = 1;
            } else {
              return slist$3[0] + (" belongs to several types: " + ($$String.concat(" ", param[1]) + "\nThe first one was selected. Please disambiguate if this is wrong."));
            }
          } else {
            exit$1 = 1;
          }
          if (exit$1 === 1) {
            if (param[2] !== 0) {
              return "these field labels belong to several types: " + ($$String.concat(" ", param[1]) + "\nThe first one was selected. Please disambiguate if this is wrong.");
            } else {
              throw [
                    Caml_builtin_exceptions.assert_failure,
                    [
                      "warnings.ml",
                      362,
                      36
                    ]
                  ];
            }
          }
          break;
      case 25 : 
          return "this use of " + (param[0] + " required disambiguation.");
      case 26 : 
          return "the label " + (param[0] + " is not optional.");
      case 27 : 
          return Curry._2(Printf.sprintf(/* Format */[
                          /* String_literal */Block.__(11, [
                              "this open statement shadows the ",
                              /* String */Block.__(2, [
                                  /* No_padding */0,
                                  /* String_literal */Block.__(11, [
                                      " identifier ",
                                      /* String */Block.__(2, [
                                          /* No_padding */0,
                                          /* String_literal */Block.__(11, [
                                              " (which is later used)",
                                              /* End_of_format */0
                                            ])
                                        ])
                                    ])
                                ])
                            ]),
                          "this open statement shadows the %s identifier %s (which is later used)"
                        ]), param[0], param[1]);
      case 28 : 
          return Curry._2(Printf.sprintf(/* Format */[
                          /* String_literal */Block.__(11, [
                              "this open statement shadows the ",
                              /* String */Block.__(2, [
                                  /* No_padding */0,
                                  /* Char_literal */Block.__(12, [
                                      /* " " */32,
                                      /* String */Block.__(2, [
                                          /* No_padding */0,
                                          /* String_literal */Block.__(11, [
                                              " (which is later used)",
                                              /* End_of_format */0
                                            ])
                                        ])
                                    ])
                                ])
                            ]),
                          "this open statement shadows the %s %s (which is later used)"
                        ]), param[0], param[1]);
      case 29 : 
          return Curry._2(Printf.sprintf(/* Format */[
                          /* String_literal */Block.__(11, [
                              "illegal environment variable ",
                              /* String */Block.__(2, [
                                  /* No_padding */0,
                                  /* String_literal */Block.__(11, [
                                      " : ",
                                      /* String */Block.__(2, [
                                          /* No_padding */0,
                                          /* End_of_format */0
                                        ])
                                    ])
                                ])
                            ]),
                          "illegal environment variable %s : %s"
                        ]), param[0], param[1]);
      case 30 : 
          return Curry._2(Printf.sprintf(/* Format */[
                          /* String_literal */Block.__(11, [
                              "illegal payload for attribute '",
                              /* String */Block.__(2, [
                                  /* No_padding */0,
                                  /* String_literal */Block.__(11, [
                                      "'.\n",
                                      /* String */Block.__(2, [
                                          /* No_padding */0,
                                          /* End_of_format */0
                                        ])
                                    ])
                                ])
                            ]),
                          "illegal payload for attribute '%s'.\n%s"
                        ]), param[0], param[1]);
      case 31 : 
          var sl = param[0];
          return Curry._2(Printf.sprintf(/* Format */[
                          /* String_literal */Block.__(11, [
                              "implicit elimination of optional argument",
                              /* String */Block.__(2, [
                                  /* No_padding */0,
                                  /* Char_literal */Block.__(12, [
                                      /* " " */32,
                                      /* String */Block.__(2, [
                                          /* No_padding */0,
                                          /* End_of_format */0
                                        ])
                                    ])
                                ])
                            ]),
                          "implicit elimination of optional argument%s %s"
                        ]), List.length(sl) === 1 ? "" : "s", $$String.concat(", ", sl));
      case 32 : 
          return "no cmi file was found in path for module " + param[0];
      case 33 : 
          if (param[0]) {
            return "unattached documentation comment (ignored)";
          } else {
            return "ambiguous documentation comment";
          }
      
    }
  }
}

var nerrors = [0];

function print(ppf, w) {
  var msg = message(w);
  var num = number(w);
  Curry._2(Format.fprintf(ppf, /* Format */[
            /* Int */Block.__(4, [
                /* Int_d */0,
                /* No_padding */0,
                /* No_precision */0,
                /* String_literal */Block.__(11, [
                    ": ",
                    /* String */Block.__(2, [
                        /* No_padding */0,
                        /* End_of_format */0
                      ])
                  ])
              ]),
            "%d: %s"
          ]), num, msg);
  Format.pp_print_flush(ppf, /* () */0);
  if (Caml_array.caml_array_get(current[0][/* error */1], num)) {
    nerrors[0] = nerrors[0] + 1 | 0;
    return /* () */0;
  } else {
    return 0;
  }
}

var Errors = Caml_exceptions.create("Ocaml_typedtree_test.Warnings.Errors");

var absname = [/* false */0];

function in_file(name) {
  var loc = /* record */[
    /* pos_fname */name,
    /* pos_lnum */1,
    /* pos_bol */0,
    /* pos_cnum */-1
  ];
  return /* record */[
          /* loc_start */loc,
          /* loc_end */loc,
          /* loc_ghost : true */1
        ];
}

var none = in_file("_none_");

function curr(lexbuf) {
  return /* record */[
          /* loc_start */lexbuf[/* lex_start_p */10],
          /* loc_end */lexbuf[/* lex_curr_p */11],
          /* loc_ghost : false */0
        ];
}

function symbol_rloc() {
  return /* record */[
          /* loc_start */Parsing.symbol_start_pos(/* () */0),
          /* loc_end */Parsing.symbol_end_pos(/* () */0),
          /* loc_ghost : false */0
        ];
}

function symbol_gloc() {
  return /* record */[
          /* loc_start */Parsing.symbol_start_pos(/* () */0),
          /* loc_end */Parsing.symbol_end_pos(/* () */0),
          /* loc_ghost : true */1
        ];
}

function rhs_loc(n) {
  return /* record */[
          /* loc_start */Parsing.rhs_start_pos(n),
          /* loc_end */Parsing.rhs_end_pos(n),
          /* loc_ghost : false */0
        ];
}

var input_name = ["_none_"];

var input_lexbuf = [/* None */0];

var status = [/* Uninitialised */0];

var num_loc_lines = [0];

function highlight_terminfo(ppf, num_lines, lb, locs) {
  Format.pp_print_flush(ppf, /* () */0);
  var pos0 = -lb[/* lex_abs_pos */3] | 0;
  if (pos0 < 0) {
    throw Pervasives.Exit;
  }
  var lines = num_loc_lines[0];
  for(var i = pos0 ,i_finish = lb[/* lex_buffer_len */2] - 1 | 0; i <= i_finish; ++i){
    if (Caml_bytes.get(lb[/* lex_buffer */1], i) === /* "\n" */10) {
      lines = lines + 1 | 0;
    }
    
  }
  if (lines >= (num_lines - 2 | 0)) {
    throw Pervasives.Exit;
  }
  Caml_io.caml_ml_flush(Pervasives.stdout);
  Caml_missing_polyfill.not_implemented("caml_terminfo_backup not implemented by bucklescript yet\n");
  var bol = /* false */0;
  Pervasives.print_string("# ");
  for(var pos = 0 ,pos_finish = (lb[/* lex_buffer_len */2] - pos0 | 0) - 1 | 0; pos <= pos_finish; ++pos){
    if (bol) {
      Pervasives.print_string("  ");
      bol = /* false */0;
    }
    if (List.exists((function(pos){
          return function (loc) {
            return +(pos === loc[/* loc_start */0][/* pos_cnum */3]);
          }
          }(pos)), locs)) {
      Caml_missing_polyfill.not_implemented("caml_terminfo_standout not implemented by bucklescript yet\n");
    }
    if (List.exists((function(pos){
          return function (loc) {
            return +(pos === loc[/* loc_end */1][/* pos_cnum */3]);
          }
          }(pos)), locs)) {
      Caml_missing_polyfill.not_implemented("caml_terminfo_standout not implemented by bucklescript yet\n");
    }
    var c = Caml_bytes.get(lb[/* lex_buffer */1], pos + pos0 | 0);
    Pervasives.print_char(c);
    bol = +(c === /* "\n" */10);
  }
  Caml_missing_polyfill.not_implemented("caml_terminfo_standout not implemented by bucklescript yet\n");
  Caml_missing_polyfill.not_implemented("caml_terminfo_resume not implemented by bucklescript yet\n");
  return Caml_io.caml_ml_flush(Pervasives.stdout);
}

function highlight_dumb(ppf, lb, loc) {
  var pos0 = -lb[/* lex_abs_pos */3] | 0;
  if (pos0 < 0) {
    throw Pervasives.Exit;
  }
  var end_pos = (lb[/* lex_buffer_len */2] - pos0 | 0) - 1 | 0;
  var line_start = 0;
  var line_end = 0;
  for(var pos = 0; pos <= end_pos; ++pos){
    if (Caml_bytes.get(lb[/* lex_buffer */1], pos + pos0 | 0) === /* "\n" */10) {
      if (loc[/* loc_start */0][/* pos_cnum */3] > pos) {
        line_start = line_start + 1 | 0;
      }
      if (loc[/* loc_end */1][/* pos_cnum */3] > pos) {
        line_end = line_end + 1 | 0;
      }
      
    }
    
  }
  Curry._2(Format.fprintf(ppf, /* Format */[
            /* String_literal */Block.__(11, [
                "Characters ",
                /* Int */Block.__(4, [
                    /* Int_i */3,
                    /* No_padding */0,
                    /* No_precision */0,
                    /* Char_literal */Block.__(12, [
                        /* "-" */45,
                        /* Int */Block.__(4, [
                            /* Int_i */3,
                            /* No_padding */0,
                            /* No_precision */0,
                            /* Char_literal */Block.__(12, [
                                /* ":" */58,
                                /* Formatting_lit */Block.__(17, [
                                    /* Flush_newline */4,
                                    /* End_of_format */0
                                  ])
                              ])
                          ])
                      ])
                  ])
              ]),
            "Characters %i-%i:@."
          ]), loc[/* loc_start */0][/* pos_cnum */3], loc[/* loc_end */1][/* pos_cnum */3]);
  Format.pp_print_string(ppf, "  ");
  var line = 0;
  var pos_at_bol = 0;
  for(var pos$1 = 0; pos$1 <= end_pos; ++pos$1){
    var c = Caml_bytes.get(lb[/* lex_buffer */1], pos$1 + pos0 | 0);
    if (c !== 10) {
      if (c !== 13) {
        if (line === line_start && line === line_end) {
          Format.pp_print_char(ppf, c);
        } else if (line === line_start) {
          if (pos$1 < loc[/* loc_start */0][/* pos_cnum */3]) {
            Format.pp_print_char(ppf, /* "." */46);
          } else {
            Format.pp_print_char(ppf, c);
          }
        } else if (line === line_end) {
          if (pos$1 < loc[/* loc_end */1][/* pos_cnum */3]) {
            Format.pp_print_char(ppf, c);
          } else {
            Format.pp_print_char(ppf, /* "." */46);
          }
        } else if (line > line_start && line < line_end) {
          Format.pp_print_char(ppf, c);
        }
        
      }
      
    } else {
      if (line === line_start && line === line_end) {
        Format.fprintf(ppf, /* Format */[
              /* Formatting_lit */Block.__(17, [
                  /* Flush_newline */4,
                  /* String_literal */Block.__(11, [
                      "  ",
                      /* End_of_format */0
                    ])
                ]),
              "@.  "
            ]);
        for(var _i = pos_at_bol ,_i_finish = loc[/* loc_start */0][/* pos_cnum */3] - 1 | 0; _i <= _i_finish; ++_i){
          Format.pp_print_char(ppf, /* " " */32);
        }
        for(var _i$1 = loc[/* loc_start */0][/* pos_cnum */3] ,_i_finish$1 = loc[/* loc_end */1][/* pos_cnum */3] - 1 | 0; _i$1 <= _i_finish$1; ++_i$1){
          Format.pp_print_char(ppf, /* "^" */94);
        }
      }
      if (line >= line_start && line <= line_end) {
        Format.fprintf(ppf, /* Format */[
              /* Formatting_lit */Block.__(17, [
                  /* Flush_newline */4,
                  /* End_of_format */0
                ]),
              "@."
            ]);
        if (pos$1 < loc[/* loc_end */1][/* pos_cnum */3]) {
          Format.pp_print_string(ppf, "  ");
        }
        
      }
      line = line + 1 | 0;
      pos_at_bol = pos$1 + 1 | 0;
    }
  }
  return /* () */0;
}

function highlight_locations(ppf, locs) {
  while(true) {
    var match = status[0];
    if (typeof match === "number") {
      if (match !== 0) {
        var match$1 = input_lexbuf[0];
        if (match$1) {
          var norepeat;
          try {
            norepeat = +(Caml_sys.caml_sys_getenv("TERM") === "norepeat");
          }
          catch (exn){
            if (exn === Caml_builtin_exceptions.not_found) {
              norepeat = /* false */0;
            } else {
              throw exn;
            }
          }
          if (norepeat) {
            return /* false */0;
          } else {
            var loc1 = List.hd(locs);
            try {
              highlight_dumb(ppf, match$1[0], loc1);
              return /* true */1;
            }
            catch (exn$1){
              if (exn$1 === Pervasives.Exit) {
                return /* false */0;
              } else {
                throw exn$1;
              }
            }
          }
        } else {
          return /* false */0;
        }
      } else {
        status[0] = Caml_missing_polyfill.not_implemented("caml_terminfo_setup not implemented by bucklescript yet\n");
        continue ;
        
      }
    } else {
      var match$2 = input_lexbuf[0];
      if (match$2) {
        try {
          highlight_terminfo(ppf, match[0], match$2[0], locs);
          return /* true */1;
        }
        catch (exn$2){
          if (exn$2 === Pervasives.Exit) {
            return /* false */0;
          } else {
            throw exn$2;
          }
        }
      } else {
        return /* false */0;
      }
    }
  };
}

function show_filename(file) {
  if (absname[0]) {
    var s = file;
    var s$1 = Curry._1(Filename.is_relative, s) ? Filename.concat(Caml_sys.caml_sys_getcwd(/* () */0), s) : s;
    var aux = function (_s) {
      while(true) {
        var s = _s;
        var base = Curry._1(Filename.basename, s);
        var dir = Curry._1(Filename.dirname, s);
        if (dir === s) {
          return dir;
        } else if (base === Filename.current_dir_name) {
          _s = dir;
          continue ;
          
        } else if (base === Filename.parent_dir_name) {
          return Curry._1(Filename.dirname, aux(dir));
        } else {
          return Filename.concat(aux(dir), base);
        }
      };
    };
    return aux(s$1);
  } else {
    return file;
  }
}

function print_filename(ppf, file) {
  return Curry._1(Format.fprintf(ppf, /* Format */[
                  /* String */Block.__(2, [
                      /* No_padding */0,
                      /* End_of_format */0
                    ]),
                  "%s"
                ]), show_filename(file));
}

function get_pos_info(pos) {
  return /* tuple */[
          pos[/* pos_fname */0],
          pos[/* pos_lnum */1],
          pos[/* pos_cnum */3] - pos[/* pos_bol */2] | 0
        ];
}

function setup_colors() {
  return Curry._1(Misc_043[/* setup */4], color[0]);
}

function print_loc(ppf, loc) {
  setup_colors(/* () */0);
  var match = get_pos_info(loc[/* loc_start */0]);
  var startchar = match[2];
  var file = match[0];
  var startchar$1 = bs_vscode ? startchar + 1 | 0 : startchar;
  var endchar = (loc[/* loc_end */1][/* pos_cnum */3] - loc[/* loc_start */0][/* pos_cnum */3] | 0) + startchar$1 | 0;
  if (file === "//toplevel//") {
    if (highlight_locations(ppf, /* :: */[
            loc,
            /* [] */0
          ])) {
      return /* () */0;
    } else {
      return Curry._2(Format.fprintf(ppf, /* Format */[
                      /* String_literal */Block.__(11, [
                          "Characters ",
                          /* Int */Block.__(4, [
                              /* Int_i */3,
                              /* No_padding */0,
                              /* No_precision */0,
                              /* Char_literal */Block.__(12, [
                                  /* "-" */45,
                                  /* Int */Block.__(4, [
                                      /* Int_i */3,
                                      /* No_padding */0,
                                      /* No_precision */0,
                                      /* End_of_format */0
                                    ])
                                ])
                            ])
                        ]),
                      "Characters %i-%i"
                    ]), loc[/* loc_start */0][/* pos_cnum */3], loc[/* loc_end */1][/* pos_cnum */3]);
    }
  } else {
    Curry._5(Format.fprintf(ppf, /* Format */[
              /* String */Block.__(2, [
                  /* No_padding */0,
                  /* Formatting_gen */Block.__(18, [
                      /* Open_tag */Block.__(0, [/* Format */[
                            /* String_literal */Block.__(11, [
                                "<loc>",
                                /* End_of_format */0
                              ]),
                            "<loc>"
                          ]]),
                      /* Alpha */Block.__(15, [/* String */Block.__(2, [
                              /* No_padding */0,
                              /* Int */Block.__(4, [
                                  /* Int_i */3,
                                  /* No_padding */0,
                                  /* No_precision */0,
                                  /* End_of_format */0
                                ])
                            ])])
                    ])
                ]),
              "%s@{<loc>%a%s%i"
            ]), "File \"", print_filename, file, "\", line ", match[1]);
    if (startchar$1 >= 0) {
      Curry._4(Format.fprintf(ppf, /* Format */[
                /* String */Block.__(2, [
                    /* No_padding */0,
                    /* Int */Block.__(4, [
                        /* Int_i */3,
                        /* No_padding */0,
                        /* No_precision */0,
                        /* String */Block.__(2, [
                            /* No_padding */0,
                            /* Int */Block.__(4, [
                                /* Int_i */3,
                                /* No_padding */0,
                                /* No_precision */0,
                                /* End_of_format */0
                              ])
                          ])
                      ])
                  ]),
                "%s%i%s%i"
              ]), ", characters ", startchar$1, "-", endchar);
    }
    return Format.fprintf(ppf, /* Format */[
                /* Formatting_lit */Block.__(17, [
                    /* Close_tag */1,
                    /* End_of_format */0
                  ]),
                "@}"
              ]);
  }
}

function print$1(ppf, loc) {
  setup_colors(/* () */0);
  if (loc[/* loc_start */0][/* pos_fname */0] === "//toplevel//" && highlight_locations(ppf, /* :: */[
          loc,
          /* [] */0
        ])) {
    return /* () */0;
  } else {
    return Curry._3(Format.fprintf(ppf, /* Format */[
                    /* Formatting_gen */Block.__(18, [
                        /* Open_tag */Block.__(0, [/* Format */[
                              /* String_literal */Block.__(11, [
                                  "<loc>",
                                  /* End_of_format */0
                                ]),
                              "<loc>"
                            ]]),
                        /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                /* Close_tag */1,
                                /* String */Block.__(2, [
                                    /* No_padding */0,
                                    /* Formatting_lit */Block.__(17, [
                                        /* Flush_newline */4,
                                        /* End_of_format */0
                                      ])
                                  ])
                              ])])
                      ]),
                    "@{<loc>%a@}%s@."
                  ]), print_loc, loc, ":");
  }
}

var error_prefix = "Error";

function print_error(ppf, loc) {
  print$1(ppf, loc);
  var ppf$1 = ppf;
  setup_colors(/* () */0);
  Curry._1(Format.fprintf(ppf$1, /* Format */[
            /* Formatting_gen */Block.__(18, [
                /* Open_tag */Block.__(0, [/* Format */[
                      /* String_literal */Block.__(11, [
                          "<error>",
                          /* End_of_format */0
                        ]),
                      "<error>"
                    ]]),
                /* String */Block.__(2, [
                    /* No_padding */0,
                    /* Formatting_lit */Block.__(17, [
                        /* Close_tag */1,
                        /* Char_literal */Block.__(12, [
                            /* ":" */58,
                            /* End_of_format */0
                          ])
                      ])
                  ])
              ]),
            "@{<error>%s@}:"
          ]), error_prefix);
  return /* () */0;
}

function default_warning_printer(loc, ppf, w) {
  if (is_active(w)) {
    setup_colors(/* () */0);
    print$1(ppf, loc);
    return Curry._3(Format.fprintf(ppf, /* Format */[
                    /* Formatting_gen */Block.__(18, [
                        /* Open_tag */Block.__(0, [/* Format */[
                              /* String_literal */Block.__(11, [
                                  "<warning>",
                                  /* End_of_format */0
                                ]),
                              "<warning>"
                            ]]),
                        /* String */Block.__(2, [
                            /* No_padding */0,
                            /* Formatting_lit */Block.__(17, [
                                /* Close_tag */1,
                                /* Char_literal */Block.__(12, [
                                    /* " " */32,
                                    /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                            /* Flush_newline */4,
                                            /* End_of_format */0
                                          ])])
                                  ])
                              ])
                          ])
                      ]),
                    "@{<warning>%s@} %a@."
                  ]), "Warning", print, w);
  } else {
    return 0;
  }
}

var warning_printer = [default_warning_printer];

var formatter_for_warnings = [Format.err_formatter];

function prerr_warning(loc, w) {
  var loc$1 = loc;
  var ppf = formatter_for_warnings[0];
  var w$1 = w;
  var ppf$1 = ppf;
  var f = Curry._1(warning_printer[0], loc$1);
  var arg = w$1;
  var out_functions = Format.pp_get_formatter_out_functions(ppf$1, /* () */0);
  var out_string = function (str, start, len) {
    var count = function (_i, _c) {
      while(true) {
        var c = _c;
        var i = _i;
        if (i === (start + len | 0)) {
          return c;
        } else if (Caml_string.get(str, i) === /* "\n" */10) {
          _c = c + 1 | 0;
          _i = i + 1 | 0;
          continue ;
          
        } else {
          _i = i + 1 | 0;
          continue ;
          
        }
      };
    };
    num_loc_lines[0] = num_loc_lines[0] + count(start, 0) | 0;
    return Curry._3(out_functions[/* out_string */0], str, start, len);
  };
  Format.pp_set_formatter_out_functions(ppf$1, /* record */[
        /* out_string */out_string,
        /* out_flush */out_functions[/* out_flush */1],
        /* out_newline */out_functions[/* out_newline */2],
        /* out_spaces */out_functions[/* out_spaces */3]
      ]);
  Curry._2(f, ppf$1, arg);
  Format.pp_print_flush(ppf$1, /* () */0);
  return Format.pp_set_formatter_out_functions(ppf$1, out_functions);
}

function print_phanton_error_prefix(ppf) {
  return Format.pp_print_as(ppf, error_prefix.length + 2 | 0, "");
}

function errorf($staropt$star, $staropt$star$1, $staropt$star$2, fmt) {
  var loc = $staropt$star ? $staropt$star[0] : none;
  var sub = $staropt$star$1 ? $staropt$star$1[0] : /* [] */0;
  var if_highlight = $staropt$star$2 ? $staropt$star$2[0] : "";
  var before = /* Some */[print_phanton_error_prefix];
  var k = function (msg) {
    return /* record */[
            /* loc */loc,
            /* msg */msg,
            /* sub */sub,
            /* if_highlight */if_highlight
          ];
  };
  var fmt$1 = fmt;
  var buf = Buffer.create(64);
  var ppf = Format.formatter_of_buffer(buf);
  Curry._1(Misc_043[/* set_color_tag_handling */5], ppf);
  if (before) {
    Curry._1(before[0], ppf);
  }
  return Format.kfprintf((function () {
                Format.pp_print_flush(ppf, /* () */0);
                return Curry._1(k, Buffer.contents(buf));
              }), ppf, fmt$1);
}

function error($staropt$star, $staropt$star$1, $staropt$star$2, msg) {
  var loc = $staropt$star ? $staropt$star[0] : none;
  var sub = $staropt$star$1 ? $staropt$star$1[0] : /* [] */0;
  var if_highlight = $staropt$star$2 ? $staropt$star$2[0] : "";
  return /* record */[
          /* loc */loc,
          /* msg */msg,
          /* sub */sub,
          /* if_highlight */if_highlight
        ];
}

var error_of_exn = [/* [] */0];

function register_error_of_exn(f) {
  error_of_exn[0] = /* :: */[
    f,
    error_of_exn[0]
  ];
  return /* () */0;
}

function error_of_printer(loc, print, x) {
  return Curry._2(errorf(/* Some */[loc], /* None */0, /* None */0, /* Format */[
                  /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                          /* FFlush */2,
                          /* End_of_format */0
                        ])]),
                  "%a@?"
                ]), print, x);
}

function error_of_printer_file(print, x) {
  return error_of_printer(in_file(input_name[0]), print, x);
}

register_error_of_exn((function (param) {
        if (param[0] === Caml_builtin_exceptions.sys_error) {
          return /* Some */[Curry._1(errorf(/* Some */[in_file(input_name[0])], /* None */0, /* None */0, /* Format */[
                            /* String_literal */Block.__(11, [
                                "I/O error: ",
                                /* String */Block.__(2, [
                                    /* No_padding */0,
                                    /* End_of_format */0
                                  ])
                              ]),
                            "I/O error: %s"
                          ]), param[1])];
        } else if (param[0] === Errors) {
          return /* Some */[Curry._1(errorf(/* Some */[in_file(input_name[0])], /* None */0, /* None */0, /* Format */[
                            /* String_literal */Block.__(11, [
                                "Some fatal warnings were triggered (",
                                /* Int */Block.__(4, [
                                    /* Int_d */0,
                                    /* No_padding */0,
                                    /* No_precision */0,
                                    /* String_literal */Block.__(11, [
                                        " occurrences)",
                                        /* End_of_format */0
                                      ])
                                  ])
                              ]),
                            "Some fatal warnings were triggered (%d occurrences)"
                          ]), param[1])];
        } else {
          return /* None */0;
        }
      }));

var $$Error = Caml_exceptions.create("Ocaml_typedtree_test.Location.Error");

register_error_of_exn((function (param) {
        if (param[0] === $$Error) {
          return /* Some */[param[1]];
        } else {
          return /* None */0;
        }
      }));

var currentstamp = [0];

function create(s) {
  currentstamp[0] = currentstamp[0] + 1 | 0;
  return /* record */[
          /* stamp */currentstamp[0],
          /* name */s,
          /* flags */0
        ];
}

function create_predef_exn(s) {
  currentstamp[0] = currentstamp[0] + 1 | 0;
  return /* record */[
          /* stamp */currentstamp[0],
          /* name */s,
          /* flags */2
        ];
}

function rename(i) {
  currentstamp[0] = currentstamp[0] + 1 | 0;
  return /* record */[
          /* stamp */currentstamp[0],
          /* name */i[/* name */1],
          /* flags */i[/* flags */2]
        ];
}

function unique_toplevel_name(i) {
  return i[/* name */1] + ("/" + i[/* stamp */0]);
}

function equal(i1, i2) {
  return +(i1[/* name */1] === i2[/* name */1]);
}

function set_current_time(t) {
  currentstamp[0] = Pervasives.max(currentstamp[0], t);
  return /* () */0;
}

function hide(i) {
  return /* record */[
          /* stamp */-1,
          /* name */i[/* name */1],
          /* flags */i[/* flags */2]
        ];
}

function make_global(i) {
  i[/* flags */2] = i[/* flags */2] | 1;
  return /* () */0;
}

function $$global(i) {
  return +((i[/* flags */2] & 1) !== 0);
}

function print$2(ppf, i) {
  var n = i[/* stamp */0];
  if (n !== -1) {
    if (n !== 0) {
      return Curry._3(Format.fprintf(ppf, /* Format */[
                      /* String */Block.__(2, [
                          /* No_padding */0,
                          /* Char_literal */Block.__(12, [
                              /* "/" */47,
                              /* Int */Block.__(4, [
                                  /* Int_i */3,
                                  /* No_padding */0,
                                  /* No_precision */0,
                                  /* String */Block.__(2, [
                                      /* No_padding */0,
                                      /* End_of_format */0
                                    ])
                                ])
                            ])
                        ]),
                      "%s/%i%s"
                    ]), i[/* name */1], n, $$global(i) ? "g" : "");
    } else {
      return Curry._1(Format.fprintf(ppf, /* Format */[
                      /* String */Block.__(2, [
                          /* No_padding */0,
                          /* Char_literal */Block.__(12, [
                              /* "!" */33,
                              /* End_of_format */0
                            ])
                        ]),
                      "%s!"
                    ]), i[/* name */1]);
    }
  } else {
    return Curry._1(Format.fprintf(ppf, /* Format */[
                    /* String */Block.__(2, [
                        /* No_padding */0,
                        /* Char_literal */Block.__(12, [
                            /* "#" */35,
                            /* End_of_format */0
                          ])
                      ]),
                    "%s#"
                  ]), i[/* name */1]);
  }
}

function mknode(l, d, r) {
  var hl = l ? l[3] : 0;
  var hr = r ? r[3] : 0;
  return /* Node */[
          l,
          d,
          r,
          hl >= hr ? hl + 1 | 0 : hr + 1 | 0
        ];
}

function balance(l, d, r) {
  var hl = l ? l[3] : 0;
  var hr = r ? r[3] : 0;
  if (hl > (hr + 1 | 0)) {
    if (l) {
      var lr = l[2];
      var ld = l[1];
      var ll = l[0];
      if ((
          ll ? ll[3] : 0
        ) >= (
          lr ? lr[3] : 0
        )) {
        return mknode(ll, ld, mknode(lr, d, r));
      } else if (lr) {
        return mknode(mknode(ll, ld, lr[0]), lr[1], mknode(lr[2], d, r));
      } else {
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "ident.ml",
                120,
                11
              ]
            ];
      }
    } else {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "ident.ml",
              120,
              11
            ]
          ];
    }
  } else if (hr > (hl + 1 | 0)) {
    if (r) {
      var rl = r[0];
      var rr = r[2];
      if ((
          rr ? rr[3] : 0
        ) >= (
          rl ? rl[3] : 0
        )) {
        return mknode(mknode(l, d, rl), r[1], rr);
      } else if (rl) {
        return mknode(mknode(l, d, rl[0]), rl[1], mknode(rl[2], r[1], r[2]));
      } else {
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "ident.ml",
                129,
                11
              ]
            ];
      }
    } else {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "ident.ml",
              129,
              11
            ]
          ];
    }
  } else {
    return mknode(l, d, r);
  }
}

function add(id, data, param) {
  if (param) {
    var r = param[2];
    var k = param[1];
    var l = param[0];
    var c = Caml_string.caml_string_compare(id[/* name */1], k[/* ident */0][/* name */1]);
    if (c) {
      if (c < 0) {
        return balance(add(id, data, l), k, r);
      } else {
        return balance(l, k, add(id, data, r));
      }
    } else {
      return /* Node */[
              l,
              /* record */[
                /* ident */id,
                /* data */data,
                /* previous : Some */[k]
              ],
              r,
              param[3]
            ];
    }
  } else {
    return /* Node */[
            /* Empty */0,
            /* record */[
              /* ident */id,
              /* data */data,
              /* previous : None */0
            ],
            /* Empty */0,
            1
          ];
  }
}

function find_same(id, _param) {
  while(true) {
    var param = _param;
    if (param) {
      var k = param[1];
      var c = Caml_string.caml_string_compare(id[/* name */1], k[/* ident */0][/* name */1]);
      if (c) {
        _param = c < 0 ? param[0] : param[2];
        continue ;
        
      } else if (id[/* stamp */0] === k[/* ident */0][/* stamp */0]) {
        return k[/* data */1];
      } else {
        var s = id[/* stamp */0];
        var _param$1 = k[/* previous */2];
        while(true) {
          var param$1 = _param$1;
          if (param$1) {
            var k$1 = param$1[0];
            if (k$1[/* ident */0][/* stamp */0] === s) {
              return k$1[/* data */1];
            } else {
              _param$1 = k$1[/* previous */2];
              continue ;
              
            }
          } else {
            throw Caml_builtin_exceptions.not_found;
          }
        };
      }
    } else {
      throw Caml_builtin_exceptions.not_found;
    }
  };
}

function find_name(name, _param) {
  while(true) {
    var param = _param;
    if (param) {
      var k = param[1];
      var c = Caml_string.caml_string_compare(name, k[/* ident */0][/* name */1]);
      if (c) {
        _param = c < 0 ? param[0] : param[2];
        continue ;
        
      } else {
        return k[/* data */1];
      }
    } else {
      throw Caml_builtin_exceptions.not_found;
    }
  };
}

function get_all(param) {
  if (param) {
    var k = param[0];
    return /* :: */[
            k[/* data */1],
            get_all(k[/* previous */2])
          ];
  } else {
    return /* [] */0;
  }
}

function find_all(name, _param) {
  while(true) {
    var param = _param;
    if (param) {
      var k = param[1];
      var c = Caml_string.caml_string_compare(name, k[/* ident */0][/* name */1]);
      if (c) {
        _param = c < 0 ? param[0] : param[2];
        continue ;
        
      } else {
        return /* :: */[
                k[/* data */1],
                get_all(k[/* previous */2])
              ];
      }
    } else {
      return /* [] */0;
    }
  };
}

function iter(f, _param) {
  while(true) {
    var param = _param;
    if (param) {
      var k = param[1];
      iter(f, param[0]);
      Curry._2(f, k[/* ident */0], k[/* data */1]);
      _param = param[2];
      continue ;
      
    } else {
      return /* () */0;
    }
  };
}

function same(_p1, _p2) {
  while(true) {
    var p2 = _p2;
    var p1 = _p1;
    switch (p1.tag | 0) {
      case 0 : 
          switch (p2.tag | 0) {
            case 0 : 
                return Caml_obj.caml_equal(p1[0], p2[0]);
            case 1 : 
            case 2 : 
                return /* false */0;
            
          }
          break;
      case 1 : 
          switch (p2.tag | 0) {
            case 1 : 
                if (p1[1] === p2[1]) {
                  _p2 = p2[0];
                  _p1 = p1[0];
                  continue ;
                  
                } else {
                  return /* false */0;
                }
                break;
            case 0 : 
            case 2 : 
                return /* false */0;
            
          }
          break;
      case 2 : 
          switch (p2.tag | 0) {
            case 0 : 
            case 1 : 
                return /* false */0;
            case 2 : 
                if (same(p1[0], p2[0])) {
                  _p2 = p2[1];
                  _p1 = p1[1];
                  continue ;
                  
                } else {
                  return /* false */0;
                }
                break;
            
          }
          break;
      
    }
  };
}

function isfree(id, _param) {
  while(true) {
    var param = _param;
    switch (param.tag | 0) {
      case 0 : 
          return Caml_obj.caml_equal(id, param[0]);
      case 1 : 
          _param = param[0];
          continue ;
          case 2 : 
          if (isfree(id, param[0])) {
            return /* true */1;
          } else {
            _param = param[1];
            continue ;
            
          }
          break;
      
    }
  };
}

function binding_time(_param) {
  while(true) {
    var param = _param;
    switch (param.tag | 0) {
      case 0 : 
          return param[0][/* stamp */0];
      case 1 : 
          _param = param[0];
          continue ;
          case 2 : 
          return Pervasives.max(binding_time(param[0]), binding_time(param[1]));
      
    }
  };
}

function kfalse() {
  return /* false */0;
}

function name($staropt$star, param) {
  var paren = $staropt$star ? $staropt$star[0] : kfalse;
  switch (param.tag | 0) {
    case 0 : 
        return param[0][/* name */1];
    case 1 : 
        var s = param[1];
        return name(/* Some */[paren], param[0]) + (
                Curry._1(paren, s) ? ".( " + (s + " )") : "." + s
              );
    case 2 : 
        return name(/* Some */[paren], param[0]) + ("(" + (name(/* Some */[paren], param[1]) + ")"));
    
  }
}

function head(_param) {
  while(true) {
    var param = _param;
    switch (param.tag | 0) {
      case 0 : 
          return param[0];
      case 1 : 
          _param = param[0];
          continue ;
          case 2 : 
          throw [
                Caml_builtin_exceptions.assert_failure,
                [
                  "path.ml",
                  49,
                  22
                ]
              ];
      
    }
  };
}

function last(_param) {
  while(true) {
    var param = _param;
    switch (param.tag | 0) {
      case 0 : 
          return param[0][/* name */1];
      case 1 : 
          return param[1];
      case 2 : 
          _param = param[1];
          continue ;
          
    }
  };
}

function flat(_accu, _param) {
  while(true) {
    var param = _param;
    var accu = _accu;
    switch (param.tag | 0) {
      case 0 : 
          return /* :: */[
                  param[0],
                  accu
                ];
      case 1 : 
          _param = param[0];
          _accu = /* :: */[
            param[1],
            accu
          ];
          continue ;
          case 2 : 
          return fatal_error("Longident.flat");
      
    }
  };
}

function flatten(lid) {
  return flat(/* [] */0, lid);
}

function last$1(param) {
  switch (param.tag | 0) {
    case 0 : 
        return param[0];
    case 1 : 
        return param[1];
    case 2 : 
        return fatal_error("Longident.last");
    
  }
}

function parse_declaration(arity, decl) {
  if (decl) {
    var match = decl[1];
    var name = decl[0];
    if (match) {
      var name2 = match[0];
      var exit = 0;
      if (name2 === "noalloc") {
        var match$1 = match[1];
        if (match$1) {
          var match$2 = match$1[1];
          var name2$1 = match$1[0];
          if (match$2) {
            if (match$2[0] === "float") {
              return /* record */[
                      /* prim_name */name,
                      /* prim_arity */arity,
                      /* prim_alloc : false */0,
                      /* prim_native_name */name2$1,
                      /* prim_native_float : true */1
                    ];
            } else {
              return /* record */[
                      /* prim_name */name,
                      /* prim_arity */arity,
                      /* prim_alloc : false */0,
                      /* prim_native_name */name2$1,
                      /* prim_native_float : false */0
                    ];
            }
          } else {
            return /* record */[
                    /* prim_name */name,
                    /* prim_arity */arity,
                    /* prim_alloc : false */0,
                    /* prim_native_name */name2$1,
                    /* prim_native_float : false */0
                  ];
          }
        } else {
          exit = 1;
        }
      } else {
        var match$3 = match[1];
        if (match$3) {
          if (match$3[0] === "float") {
            return /* record */[
                    /* prim_name */name,
                    /* prim_arity */arity,
                    /* prim_alloc : true */1,
                    /* prim_native_name */name2,
                    /* prim_native_float : true */1
                  ];
          } else {
            exit = 1;
          }
        } else {
          exit = 1;
        }
      }
      if (exit === 1) {
        if (name2 === "noalloc") {
          return /* record */[
                  /* prim_name */name,
                  /* prim_arity */arity,
                  /* prim_alloc : false */0,
                  /* prim_native_name */"",
                  /* prim_native_float : false */0
                ];
        } else {
          return /* record */[
                  /* prim_name */name,
                  /* prim_arity */arity,
                  /* prim_alloc : true */1,
                  /* prim_native_name */name2,
                  /* prim_native_float : false */0
                ];
        }
      }
      
    } else {
      return /* record */[
              /* prim_name */name,
              /* prim_arity */arity,
              /* prim_alloc : true */1,
              /* prim_native_name */"",
              /* prim_native_float : false */0
            ];
    }
  } else {
    return fatal_error("Primitive.parse_declaration");
  }
}

function description_list(p) {
  var list_000 = p[/* prim_name */0];
  var list = /* :: */[
    list_000,
    /* [] */0
  ];
  var list$1 = p[/* prim_alloc */2] ? list : /* :: */[
      "noalloc",
      list
    ];
  var list$2 = p[/* prim_native_name */3] !== "" ? /* :: */[
      p[/* prim_native_name */3],
      list$1
    ] : list$1;
  return List.rev(p[/* prim_native_float */4] ? /* :: */[
                "float",
                list$2
              ] : list$2);
}

function compare(t1, t2) {
  return t1[/* id */2] - t2[/* id */2] | 0;
}

function hash(t) {
  return t[/* id */2];
}

function equal$1(t1, t2) {
  return +(t1 === t2);
}

function height(param) {
  if (param) {
    return param[4];
  } else {
    return 0;
  }
}

function create$1(l, x, d, r) {
  var hl = height(l);
  var hr = height(r);
  return /* Node */[
          l,
          x,
          d,
          r,
          hl >= hr ? hl + 1 | 0 : hr + 1 | 0
        ];
}

function bal(l, x, d, r) {
  var hl = l ? l[4] : 0;
  var hr = r ? r[4] : 0;
  if (hl > (hr + 2 | 0)) {
    if (l) {
      var lr = l[3];
      var ld = l[2];
      var lv = l[1];
      var ll = l[0];
      if (height(ll) >= height(lr)) {
        return create$1(ll, lv, ld, create$1(lr, x, d, r));
      } else if (lr) {
        return create$1(create$1(ll, lv, ld, lr[0]), lr[1], lr[2], create$1(lr[3], x, d, r));
      } else {
        throw [
              Caml_builtin_exceptions.invalid_argument,
              "Map.bal"
            ];
      }
    } else {
      throw [
            Caml_builtin_exceptions.invalid_argument,
            "Map.bal"
          ];
    }
  } else if (hr > (hl + 2 | 0)) {
    if (r) {
      var rr = r[3];
      var rd = r[2];
      var rv = r[1];
      var rl = r[0];
      if (height(rr) >= height(rl)) {
        return create$1(create$1(l, x, d, rl), rv, rd, rr);
      } else if (rl) {
        return create$1(create$1(l, x, d, rl[0]), rl[1], rl[2], create$1(rl[3], rv, rd, rr));
      } else {
        throw [
              Caml_builtin_exceptions.invalid_argument,
              "Map.bal"
            ];
      }
    } else {
      throw [
            Caml_builtin_exceptions.invalid_argument,
            "Map.bal"
          ];
    }
  } else {
    return /* Node */[
            l,
            x,
            d,
            r,
            hl >= hr ? hl + 1 | 0 : hr + 1 | 0
          ];
  }
}

function add$1(x, data, param) {
  if (param) {
    var r = param[3];
    var d = param[2];
    var v = param[1];
    var l = param[0];
    var c = Caml_string.caml_string_compare(x, v);
    if (c) {
      if (c < 0) {
        return bal(add$1(x, data, l), v, d, r);
      } else {
        return bal(l, v, d, add$1(x, data, r));
      }
    } else {
      return /* Node */[
              l,
              x,
              data,
              r,
              param[4]
            ];
    }
  } else {
    return /* Node */[
            /* Empty */0,
            x,
            data,
            /* Empty */0,
            1
          ];
  }
}

function find(x, _param) {
  while(true) {
    var param = _param;
    if (param) {
      var c = Caml_string.caml_string_compare(x, param[1]);
      if (c) {
        _param = c < 0 ? param[0] : param[3];
        continue ;
        
      } else {
        return param[2];
      }
    } else {
      throw Caml_builtin_exceptions.not_found;
    }
  };
}

function mem(x, _param) {
  while(true) {
    var param = _param;
    if (param) {
      var c = Caml_string.caml_string_compare(x, param[1]);
      if (c) {
        _param = c < 0 ? param[0] : param[3];
        continue ;
        
      } else {
        return /* true */1;
      }
    } else {
      return /* false */0;
    }
  };
}

function iter$1(f, _param) {
  while(true) {
    var param = _param;
    if (param) {
      iter$1(f, param[0]);
      Curry._2(f, param[1], param[2]);
      _param = param[3];
      continue ;
      
    } else {
      return /* () */0;
    }
  };
}

function map(f, param) {
  if (param) {
    var l$prime = map(f, param[0]);
    var d$prime = Curry._1(f, param[2]);
    var r$prime = map(f, param[3]);
    return /* Node */[
            l$prime,
            param[1],
            d$prime,
            r$prime,
            param[4]
          ];
  } else {
    return /* Empty */0;
  }
}

function fold(f, _m, _accu) {
  while(true) {
    var accu = _accu;
    var m = _m;
    if (m) {
      _accu = Curry._3(f, m[1], m[2], fold(f, m[0], accu));
      _m = m[3];
      continue ;
      
    } else {
      return accu;
    }
  };
}

function single(param) {
  switch (param) {
    case 0 : 
        return 1;
    case 1 : 
        return 2;
    case 2 : 
        return 4;
    case 3 : 
        return 8;
    case 4 : 
        return 16;
    case 5 : 
        return 32;
    case 6 : 
        return 64;
    
  }
}

function union(v1, v2) {
  return v1 | v2;
}

function inter(v1, v2) {
  return v1 & v2;
}

function subset(v1, v2) {
  return +((v1 & v2) === v1);
}

function set(x, b, v) {
  if (b) {
    return v | single(x);
  } else {
    return v & (single(x) ^ -1);
  }
}

function mem$1(x) {
  var partial_arg = single(x);
  return (function (param) {
      return subset(partial_arg, param);
    });
}

function swap(f1, f2, v) {
  var partial_arg = single(f2);
  var v$prime = set(f1, (function (param) {
            return subset(partial_arg, param);
          })(v), v);
  var partial_arg$1 = single(f1);
  return set(f2, (function (param) {
                  return subset(partial_arg$1, param);
                })(v), v$prime);
}

function conjugate(v) {
  return swap(/* May_pos */0, /* May_neg */1, swap(/* Pos */4, /* Neg */5, v));
}

function get_upper(v) {
  return /* tuple */[
          subset(1, v),
          subset(2, v)
        ];
}

function get_lower(v) {
  return /* tuple */[
          subset(16, v),
          subset(32, v),
          subset(64, v),
          subset(8, v)
        ];
}

function height$1(param) {
  if (param) {
    return param[3];
  } else {
    return 0;
  }
}

function create$2(l, v, r) {
  var hl = l ? l[3] : 0;
  var hr = r ? r[3] : 0;
  return /* Node */[
          l,
          v,
          r,
          hl >= hr ? hl + 1 | 0 : hr + 1 | 0
        ];
}

function bal$1(l, v, r) {
  var hl = l ? l[3] : 0;
  var hr = r ? r[3] : 0;
  if (hl > (hr + 2 | 0)) {
    if (l) {
      var lr = l[2];
      var lv = l[1];
      var ll = l[0];
      if (height$1(ll) >= height$1(lr)) {
        return create$2(ll, lv, create$2(lr, v, r));
      } else if (lr) {
        return create$2(create$2(ll, lv, lr[0]), lr[1], create$2(lr[2], v, r));
      } else {
        throw [
              Caml_builtin_exceptions.invalid_argument,
              "Set.bal"
            ];
      }
    } else {
      throw [
            Caml_builtin_exceptions.invalid_argument,
            "Set.bal"
          ];
    }
  } else if (hr > (hl + 2 | 0)) {
    if (r) {
      var rr = r[2];
      var rv = r[1];
      var rl = r[0];
      if (height$1(rr) >= height$1(rl)) {
        return create$2(create$2(l, v, rl), rv, rr);
      } else if (rl) {
        return create$2(create$2(l, v, rl[0]), rl[1], create$2(rl[2], rv, rr));
      } else {
        throw [
              Caml_builtin_exceptions.invalid_argument,
              "Set.bal"
            ];
      }
    } else {
      throw [
            Caml_builtin_exceptions.invalid_argument,
            "Set.bal"
          ];
    }
  } else {
    return /* Node */[
            l,
            v,
            r,
            hl >= hr ? hl + 1 | 0 : hr + 1 | 0
          ];
  }
}

function add$2(x, t) {
  if (t) {
    var r = t[2];
    var v = t[1];
    var l = t[0];
    var c = Caml_string.caml_string_compare(x, v);
    if (c) {
      if (c < 0) {
        return bal$1(add$2(x, l), v, r);
      } else {
        return bal$1(l, v, add$2(x, r));
      }
    } else {
      return t;
    }
  } else {
    return /* Node */[
            /* Empty */0,
            x,
            /* Empty */0,
            1
          ];
  }
}

function singleton(x) {
  return /* Node */[
          /* Empty */0,
          x,
          /* Empty */0,
          1
        ];
}

function add_min_element(v, param) {
  if (param) {
    return bal$1(add_min_element(v, param[0]), param[1], param[2]);
  } else {
    return singleton(v);
  }
}

function add_max_element(v, param) {
  if (param) {
    return bal$1(param[0], param[1], add_max_element(v, param[2]));
  } else {
    return singleton(v);
  }
}

function join(l, v, r) {
  if (l) {
    if (r) {
      var rh = r[3];
      var lh = l[3];
      if (lh > (rh + 2 | 0)) {
        return bal$1(l[0], l[1], join(l[2], v, r));
      } else if (rh > (lh + 2 | 0)) {
        return bal$1(join(l, v, r[0]), r[1], r[2]);
      } else {
        return create$2(l, v, r);
      }
    } else {
      return add_max_element(v, l);
    }
  } else {
    return add_min_element(v, r);
  }
}

function min_elt(_param) {
  while(true) {
    var param = _param;
    if (param) {
      var l = param[0];
      if (l) {
        _param = l;
        continue ;
        
      } else {
        return param[1];
      }
    } else {
      throw Caml_builtin_exceptions.not_found;
    }
  };
}

function remove_min_elt(param) {
  if (param) {
    var l = param[0];
    if (l) {
      return bal$1(remove_min_elt(l), param[1], param[2]);
    } else {
      return param[2];
    }
  } else {
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "Set.remove_min_elt"
        ];
  }
}

function concat(t1, t2) {
  if (t1) {
    if (t2) {
      return join(t1, min_elt(t2), remove_min_elt(t2));
    } else {
      return t1;
    }
  } else {
    return t2;
  }
}

function split(x, param) {
  if (param) {
    var r = param[2];
    var v = param[1];
    var l = param[0];
    var c = Caml_string.caml_string_compare(x, v);
    if (c) {
      if (c < 0) {
        var match = split(x, l);
        return /* tuple */[
                match[0],
                match[1],
                join(match[2], v, r)
              ];
      } else {
        var match$1 = split(x, r);
        return /* tuple */[
                join(l, v, match$1[0]),
                match$1[1],
                match$1[2]
              ];
      }
    } else {
      return /* tuple */[
              l,
              /* true */1,
              r
            ];
    }
  } else {
    return /* tuple */[
            /* Empty */0,
            /* false */0,
            /* Empty */0
          ];
  }
}

function mem$2(x, _param) {
  while(true) {
    var param = _param;
    if (param) {
      var c = Caml_string.caml_string_compare(x, param[1]);
      if (c) {
        _param = c < 0 ? param[0] : param[2];
        continue ;
        
      } else {
        return /* true */1;
      }
    } else {
      return /* false */0;
    }
  };
}

function union$1(s1, s2) {
  if (s1) {
    if (s2) {
      var h2 = s2[3];
      var v2 = s2[1];
      var h1 = s1[3];
      var v1 = s1[1];
      if (h1 >= h2) {
        if (h2 === 1) {
          return add$2(v2, s1);
        } else {
          var match = split(v1, s2);
          return join(union$1(s1[0], match[0]), v1, union$1(s1[2], match[2]));
        }
      } else if (h1 === 1) {
        return add$2(v1, s2);
      } else {
        var match$1 = split(v2, s1);
        return join(union$1(match$1[0], s2[0]), v2, union$1(match$1[2], s2[2]));
      }
    } else {
      return s1;
    }
  } else {
    return s2;
  }
}

function inter$1(s1, s2) {
  if (s1) {
    if (s2) {
      var r1 = s1[2];
      var v1 = s1[1];
      var l1 = s1[0];
      var match = split(v1, s2);
      var l2 = match[0];
      if (match[1] !== 0) {
        return join(inter$1(l1, l2), v1, inter$1(r1, match[2]));
      } else {
        return concat(inter$1(l1, l2), inter$1(r1, match[2]));
      }
    } else {
      return /* Empty */0;
    }
  } else {
    return /* Empty */0;
  }
}

function diff(s1, s2) {
  if (s1) {
    if (s2) {
      var r1 = s1[2];
      var v1 = s1[1];
      var l1 = s1[0];
      var match = split(v1, s2);
      var l2 = match[0];
      if (match[1] !== 0) {
        return concat(diff(l1, l2), diff(r1, match[2]));
      } else {
        return join(diff(l1, l2), v1, diff(r1, match[2]));
      }
    } else {
      return s1;
    }
  } else {
    return /* Empty */0;
  }
}

function cons_enum(_s, _e) {
  while(true) {
    var e = _e;
    var s = _s;
    if (s) {
      _e = /* More */[
        s[1],
        s[2],
        e
      ];
      _s = s[0];
      continue ;
      
    } else {
      return e;
    }
  };
}

function compare$1(s1, s2) {
  var _e1 = cons_enum(s1, /* End */0);
  var _e2 = cons_enum(s2, /* End */0);
  while(true) {
    var e2 = _e2;
    var e1 = _e1;
    if (e1) {
      if (e2) {
        var c = Caml_string.caml_string_compare(e1[0], e2[0]);
        if (c !== 0) {
          return c;
        } else {
          _e2 = cons_enum(e2[1], e2[2]);
          _e1 = cons_enum(e1[1], e1[2]);
          continue ;
          
        }
      } else {
        return 1;
      }
    } else if (e2) {
      return -1;
    } else {
      return 0;
    }
  };
}

function equal$2(s1, s2) {
  return +(compare$1(s1, s2) === 0);
}

function fold$1(f, _s, _accu) {
  while(true) {
    var accu = _accu;
    var s = _s;
    if (s) {
      _accu = Curry._2(f, s[1], fold$1(f, s[0], accu));
      _s = s[2];
      continue ;
      
    } else {
      return accu;
    }
  };
}

function elements_aux(_accu, _param) {
  while(true) {
    var param = _param;
    var accu = _accu;
    if (param) {
      _param = param[0];
      _accu = /* :: */[
        param[1],
        elements_aux(accu, param[2])
      ];
      continue ;
      
    } else {
      return accu;
    }
  };
}

function equal_tag(t1, t2) {
  switch (t1.tag | 0) {
    case 0 : 
        switch (t2.tag | 0) {
          case 0 : 
              return +(t2[0] === t1[0]);
          case 1 : 
          case 2 : 
              return /* false */0;
          
        }
        break;
    case 1 : 
        switch (t2.tag | 0) {
          case 1 : 
              return +(t2[0] === t1[0]);
          case 0 : 
          case 2 : 
              return /* false */0;
          
        }
        break;
    case 2 : 
        switch (t2.tag | 0) {
          case 0 : 
          case 1 : 
              return /* false */0;
          case 2 : 
              if (same(t1[0], t2[0])) {
                return Caml_obj.caml_equal(t1[1], t2[1]);
              } else {
                return /* false */0;
              }
          
        }
        break;
    
  }
}

var Types_000 = /* TypeOps */[
  compare,
  equal$1,
  hash
];

var Types_003 = /* Variance */[
  0,
  127,
  25,
  7,
  union,
  inter,
  subset,
  set,
  mem$1,
  conjugate,
  get_upper,
  get_lower
];

var $$let = Types_000;

var funarg = [$$let[0]];

function height$2(param) {
  if (param) {
    return param[3];
  } else {
    return 0;
  }
}

function create$3(l, v, r) {
  var hl = l ? l[3] : 0;
  var hr = r ? r[3] : 0;
  return /* Node */[
          l,
          v,
          r,
          hl >= hr ? hl + 1 | 0 : hr + 1 | 0
        ];
}

function bal$2(l, v, r) {
  var hl = l ? l[3] : 0;
  var hr = r ? r[3] : 0;
  if (hl > (hr + 2 | 0)) {
    if (l) {
      var lr = l[2];
      var lv = l[1];
      var ll = l[0];
      if (height$2(ll) >= height$2(lr)) {
        return create$3(ll, lv, create$3(lr, v, r));
      } else if (lr) {
        return create$3(create$3(ll, lv, lr[0]), lr[1], create$3(lr[2], v, r));
      } else {
        throw [
              Caml_builtin_exceptions.invalid_argument,
              "Set.bal"
            ];
      }
    } else {
      throw [
            Caml_builtin_exceptions.invalid_argument,
            "Set.bal"
          ];
    }
  } else if (hr > (hl + 2 | 0)) {
    if (r) {
      var rr = r[2];
      var rv = r[1];
      var rl = r[0];
      if (height$2(rr) >= height$2(rl)) {
        return create$3(create$3(l, v, rl), rv, rr);
      } else if (rl) {
        return create$3(create$3(l, v, rl[0]), rl[1], create$3(rl[2], rv, rr));
      } else {
        throw [
              Caml_builtin_exceptions.invalid_argument,
              "Set.bal"
            ];
      }
    } else {
      throw [
            Caml_builtin_exceptions.invalid_argument,
            "Set.bal"
          ];
    }
  } else {
    return /* Node */[
            l,
            v,
            r,
            hl >= hr ? hl + 1 | 0 : hr + 1 | 0
          ];
  }
}

function add$3(x, t) {
  if (t) {
    var r = t[2];
    var v = t[1];
    var l = t[0];
    var c = Curry._2(funarg[/* compare */0], x, v);
    if (c) {
      if (c < 0) {
        return bal$2(add$3(x, l), v, r);
      } else {
        return bal$2(l, v, add$3(x, r));
      }
    } else {
      return t;
    }
  } else {
    return /* Node */[
            /* Empty */0,
            x,
            /* Empty */0,
            1
          ];
  }
}

function singleton$1(x) {
  return /* Node */[
          /* Empty */0,
          x,
          /* Empty */0,
          1
        ];
}

function add_min_element$1(v, param) {
  if (param) {
    return bal$2(add_min_element$1(v, param[0]), param[1], param[2]);
  } else {
    return singleton$1(v);
  }
}

function add_max_element$1(v, param) {
  if (param) {
    return bal$2(param[0], param[1], add_max_element$1(v, param[2]));
  } else {
    return singleton$1(v);
  }
}

function join$1(l, v, r) {
  if (l) {
    if (r) {
      var rh = r[3];
      var lh = l[3];
      if (lh > (rh + 2 | 0)) {
        return bal$2(l[0], l[1], join$1(l[2], v, r));
      } else if (rh > (lh + 2 | 0)) {
        return bal$2(join$1(l, v, r[0]), r[1], r[2]);
      } else {
        return create$3(l, v, r);
      }
    } else {
      return add_max_element$1(v, l);
    }
  } else {
    return add_min_element$1(v, r);
  }
}

function min_elt$1(_param) {
  while(true) {
    var param = _param;
    if (param) {
      var l = param[0];
      if (l) {
        _param = l;
        continue ;
        
      } else {
        return param[1];
      }
    } else {
      throw Caml_builtin_exceptions.not_found;
    }
  };
}

function remove_min_elt$1(param) {
  if (param) {
    var l = param[0];
    if (l) {
      return bal$2(remove_min_elt$1(l), param[1], param[2]);
    } else {
      return param[2];
    }
  } else {
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "Set.remove_min_elt"
        ];
  }
}

function concat$1(t1, t2) {
  if (t1) {
    if (t2) {
      return join$1(t1, min_elt$1(t2), remove_min_elt$1(t2));
    } else {
      return t1;
    }
  } else {
    return t2;
  }
}

function split$1(x, param) {
  if (param) {
    var r = param[2];
    var v = param[1];
    var l = param[0];
    var c = Curry._2(funarg[/* compare */0], x, v);
    if (c) {
      if (c < 0) {
        var match = split$1(x, l);
        return /* tuple */[
                match[0],
                match[1],
                join$1(match[2], v, r)
              ];
      } else {
        var match$1 = split$1(x, r);
        return /* tuple */[
                join$1(l, v, match$1[0]),
                match$1[1],
                match$1[2]
              ];
      }
    } else {
      return /* tuple */[
              l,
              /* true */1,
              r
            ];
    }
  } else {
    return /* tuple */[
            /* Empty */0,
            /* false */0,
            /* Empty */0
          ];
  }
}

function mem$3(x, _param) {
  while(true) {
    var param = _param;
    if (param) {
      var c = Curry._2(funarg[/* compare */0], x, param[1]);
      if (c) {
        _param = c < 0 ? param[0] : param[2];
        continue ;
        
      } else {
        return /* true */1;
      }
    } else {
      return /* false */0;
    }
  };
}

function union$2(s1, s2) {
  if (s1) {
    if (s2) {
      var h2 = s2[3];
      var v2 = s2[1];
      var h1 = s1[3];
      var v1 = s1[1];
      if (h1 >= h2) {
        if (h2 === 1) {
          return add$3(v2, s1);
        } else {
          var match = split$1(v1, s2);
          return join$1(union$2(s1[0], match[0]), v1, union$2(s1[2], match[2]));
        }
      } else if (h1 === 1) {
        return add$3(v1, s2);
      } else {
        var match$1 = split$1(v2, s1);
        return join$1(union$2(match$1[0], s2[0]), v2, union$2(match$1[2], s2[2]));
      }
    } else {
      return s1;
    }
  } else {
    return s2;
  }
}

function inter$2(s1, s2) {
  if (s1) {
    if (s2) {
      var r1 = s1[2];
      var v1 = s1[1];
      var l1 = s1[0];
      var match = split$1(v1, s2);
      var l2 = match[0];
      if (match[1] !== 0) {
        return join$1(inter$2(l1, l2), v1, inter$2(r1, match[2]));
      } else {
        return concat$1(inter$2(l1, l2), inter$2(r1, match[2]));
      }
    } else {
      return /* Empty */0;
    }
  } else {
    return /* Empty */0;
  }
}

function diff$1(s1, s2) {
  if (s1) {
    if (s2) {
      var r1 = s1[2];
      var v1 = s1[1];
      var l1 = s1[0];
      var match = split$1(v1, s2);
      var l2 = match[0];
      if (match[1] !== 0) {
        return concat$1(diff$1(l1, l2), diff$1(r1, match[2]));
      } else {
        return join$1(diff$1(l1, l2), v1, diff$1(r1, match[2]));
      }
    } else {
      return s1;
    }
  } else {
    return /* Empty */0;
  }
}

function subset$1(_s1, _s2) {
  while(true) {
    var s2 = _s2;
    var s1 = _s1;
    if (s1) {
      if (s2) {
        var r2 = s2[2];
        var l2 = s2[0];
        var r1 = s1[2];
        var v1 = s1[1];
        var l1 = s1[0];
        var c = Curry._2(funarg[/* compare */0], v1, s2[1]);
        if (c) {
          if (c < 0) {
            if (subset$1(/* Node */[
                    l1,
                    v1,
                    /* Empty */0,
                    0
                  ], l2)) {
              _s1 = r1;
              continue ;
              
            } else {
              return /* false */0;
            }
          } else if (subset$1(/* Node */[
                  /* Empty */0,
                  v1,
                  r1,
                  0
                ], r2)) {
            _s1 = l1;
            continue ;
            
          } else {
            return /* false */0;
          }
        } else if (subset$1(l1, l2)) {
          _s2 = r2;
          _s1 = r1;
          continue ;
          
        } else {
          return /* false */0;
        }
      } else {
        return /* false */0;
      }
    } else {
      return /* true */1;
    }
  };
}

function fold$2(f, _s, _accu) {
  while(true) {
    var accu = _accu;
    var s = _s;
    if (s) {
      _accu = Curry._2(f, s[1], fold$2(f, s[0], accu));
      _s = s[2];
      continue ;
      
    } else {
      return accu;
    }
  };
}

function exists(p, _param) {
  while(true) {
    var param = _param;
    if (param) {
      if (Curry._1(p, param[1])) {
        return /* true */1;
      } else if (exists(p, param[0])) {
        return /* true */1;
      } else {
        _param = param[2];
        continue ;
        
      }
    } else {
      return /* false */0;
    }
  };
}

function elements_aux$1(_accu, _param) {
  while(true) {
    var param = _param;
    var accu = _accu;
    if (param) {
      _param = param[0];
      _accu = /* :: */[
        param[1],
        elements_aux$1(accu, param[2])
      ];
      continue ;
      
    } else {
      return accu;
    }
  };
}

var $$let$1 = Types_000;

var funarg$1 = [$$let$1[0]];

function height$3(param) {
  if (param) {
    return param[4];
  } else {
    return 0;
  }
}

function create$4(l, x, d, r) {
  var hl = height$3(l);
  var hr = height$3(r);
  return /* Node */[
          l,
          x,
          d,
          r,
          hl >= hr ? hl + 1 | 0 : hr + 1 | 0
        ];
}

function bal$3(l, x, d, r) {
  var hl = l ? l[4] : 0;
  var hr = r ? r[4] : 0;
  if (hl > (hr + 2 | 0)) {
    if (l) {
      var lr = l[3];
      var ld = l[2];
      var lv = l[1];
      var ll = l[0];
      if (height$3(ll) >= height$3(lr)) {
        return create$4(ll, lv, ld, create$4(lr, x, d, r));
      } else if (lr) {
        return create$4(create$4(ll, lv, ld, lr[0]), lr[1], lr[2], create$4(lr[3], x, d, r));
      } else {
        throw [
              Caml_builtin_exceptions.invalid_argument,
              "Map.bal"
            ];
      }
    } else {
      throw [
            Caml_builtin_exceptions.invalid_argument,
            "Map.bal"
          ];
    }
  } else if (hr > (hl + 2 | 0)) {
    if (r) {
      var rr = r[3];
      var rd = r[2];
      var rv = r[1];
      var rl = r[0];
      if (height$3(rr) >= height$3(rl)) {
        return create$4(create$4(l, x, d, rl), rv, rd, rr);
      } else if (rl) {
        return create$4(create$4(l, x, d, rl[0]), rl[1], rl[2], create$4(rl[3], rv, rd, rr));
      } else {
        throw [
              Caml_builtin_exceptions.invalid_argument,
              "Map.bal"
            ];
      }
    } else {
      throw [
            Caml_builtin_exceptions.invalid_argument,
            "Map.bal"
          ];
    }
  } else {
    return /* Node */[
            l,
            x,
            d,
            r,
            hl >= hr ? hl + 1 | 0 : hr + 1 | 0
          ];
  }
}

function add$4(x, data, param) {
  if (param) {
    var r = param[3];
    var d = param[2];
    var v = param[1];
    var l = param[0];
    var c = Curry._2(funarg$1[/* compare */0], x, v);
    if (c) {
      if (c < 0) {
        return bal$3(add$4(x, data, l), v, d, r);
      } else {
        return bal$3(l, v, d, add$4(x, data, r));
      }
    } else {
      return /* Node */[
              l,
              x,
              data,
              r,
              param[4]
            ];
    }
  } else {
    return /* Node */[
            /* Empty */0,
            x,
            data,
            /* Empty */0,
            1
          ];
  }
}

function find$1(x, _param) {
  while(true) {
    var param = _param;
    if (param) {
      var c = Curry._2(funarg$1[/* compare */0], x, param[1]);
      if (c) {
        _param = c < 0 ? param[0] : param[3];
        continue ;
        
      } else {
        return param[2];
      }
    } else {
      throw Caml_builtin_exceptions.not_found;
    }
  };
}

function fold$3(f, _m, _accu) {
  while(true) {
    var accu = _accu;
    var m = _m;
    if (m) {
      _accu = Curry._3(f, m[1], m[2], fold$3(f, m[0], accu));
      _m = m[3];
      continue ;
      
    } else {
      return accu;
    }
  };
}

var $$let$2 = Types_000;

var TypeHash = Hashtbl.Make([
      $$let$2[1],
      $$let$2[2]
    ]);

function print_raw() {
  throw [
        Caml_builtin_exceptions.assert_failure,
        [
          "btype.ml",
          27,
          16
        ]
      ];
}

var pivot_level = -1;

var new_id = [-1];

function newty2(level, desc) {
  new_id[0] = new_id[0] + 1 | 0;
  return /* record */[
          /* desc */desc,
          /* level */level,
          /* id */new_id[0]
        ];
}

function is_Tvar(param) {
  var match = param[/* desc */0];
  if (typeof match === "number" || match.tag) {
    return /* false */0;
  } else {
    return /* true */1;
  }
}

function is_Tunivar(param) {
  var match = param[/* desc */0];
  if (typeof match === "number" || match.tag !== 9) {
    return /* false */0;
  } else {
    return /* true */1;
  }
}

var dummy_method = "*dummy method*";

function default_mty(param) {
  if (param) {
    return param[0];
  } else {
    return /* Mty_signature */Block.__(1, [/* [] */0]);
  }
}

function field_kind_repr(_kind) {
  while(true) {
    var kind = _kind;
    if (typeof kind === "number") {
      return kind;
    } else {
      var match = kind[0][/* contents */0];
      if (match) {
        _kind = match[0];
        continue ;
        
      } else {
        return kind;
      }
    }
  };
}

function repr(_t) {
  while(true) {
    var t = _t;
    var match = t[/* desc */0];
    if (typeof match === "number") {
      return t;
    } else {
      switch (match.tag | 0) {
        case 5 : 
            if (field_kind_repr(match[1]) === /* Fabsent */1) {
              _t = match[3];
              continue ;
              
            } else {
              return t;
            }
            break;
        case 6 : 
            _t = match[0];
            continue ;
            default:
          return t;
      }
    }
  };
}

function commu_repr(_c) {
  while(true) {
    var c = _c;
    if (typeof c === "number") {
      return c;
    } else {
      var r = c[0];
      if (r[0] !== /* Cunknown */1) {
        _c = r[0];
        continue ;
        
      } else {
        return c;
      }
    }
  };
}

function row_field_repr_aux(_tl, _fi) {
  while(true) {
    var fi = _fi;
    var tl = _tl;
    if (typeof fi === "number") {
      return fi;
    } else if (fi.tag) {
      var r = fi[3];
      var tl$prime = fi[1];
      var match = r[/* contents */0];
      if (match) {
        _fi = match[0];
        _tl = Pervasives.$at(tl, tl$prime);
        continue ;
        
      } else {
        return /* Reither */Block.__(1, [
                  fi[0],
                  Pervasives.$at(tl, tl$prime),
                  fi[2],
                  r
                ]);
      }
    } else if (fi[0] && tl !== /* [] */0) {
      return /* Rpresent */Block.__(0, [/* Some */[List.hd(tl)]]);
    } else {
      return fi;
    }
  };
}

function rev_concat(_l, _ll) {
  while(true) {
    var ll = _ll;
    var l = _l;
    if (ll) {
      _ll = ll[1];
      _l = Pervasives.$at(ll[0], l);
      continue ;
      
    } else {
      return l;
    }
  };
}

function row_repr_aux(_ll, _row) {
  while(true) {
    var row = _row;
    var ll = _ll;
    var match = repr(row[/* row_more */1])[/* desc */0];
    var exit = 0;
    if (typeof match === "number") {
      exit = 1;
    } else if (match.tag === 8) {
      var f = row[/* row_fields */0];
      _row = match[0];
      _ll = f ? /* :: */[
          f,
          ll
        ] : ll;
      continue ;
      
    } else {
      exit = 1;
    }
    if (exit === 1) {
      if (ll) {
        var newrecord = row.slice();
        newrecord[/* row_fields */0] = rev_concat(row[/* row_fields */0], ll);
        return newrecord;
      } else {
        return row;
      }
    }
    
  };
}

function row_field(tag, row) {
  var _param = row[/* row_fields */0];
  while(true) {
    var param = _param;
    if (param) {
      var match = param[0];
      if (tag === match[0]) {
        return row_field_repr_aux(/* [] */0, match[1]);
      } else {
        _param = param[1];
        continue ;
        
      }
    } else {
      var match$1 = repr(row[/* row_more */1]);
      var match$2 = match$1[/* desc */0];
      if (typeof match$2 === "number" || match$2.tag !== 8) {
        return /* Rabsent */0;
      } else {
        return row_field(tag, match$2[0]);
      }
    }
  };
}

function row_more(_row) {
  while(true) {
    var row = _row;
    var ty = repr(row[/* row_more */1]);
    var match = ty[/* desc */0];
    if (typeof match === "number") {
      return ty;
    } else if (match.tag === 8) {
      _row = match[0];
      continue ;
      
    } else {
      return ty;
    }
  };
}

function row_fixed(row) {
  var row$1 = row_repr_aux(/* [] */0, row);
  if (row$1[/* row_fixed */4]) {
    return /* true */1;
  } else {
    var match = repr(row$1[/* row_more */1])[/* desc */0];
    if (typeof match === "number") {
      if (match) {
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "btype.ml",
                137,
                9
              ]
            ];
      } else {
        return /* false */0;
      }
    } else {
      switch (match.tag | 0) {
        case 0 : 
            return /* false */0;
        case 3 : 
        case 9 : 
            return /* true */1;
        default:
          throw [
                Caml_builtin_exceptions.assert_failure,
                [
                  "btype.ml",
                  137,
                  9
                ]
              ];
      }
    }
  }
}

function static_row(row) {
  var row$1 = row_repr_aux(/* [] */0, row);
  if (row$1[/* row_closed */3]) {
    return List.for_all((function (param) {
                  var match = row_field_repr_aux(/* [] */0, param[1]);
                  if (typeof match === "number" || !match.tag) {
                    return /* true */1;
                  } else {
                    return /* false */0;
                  }
                }), row$1[/* row_fields */0]);
  } else {
    return /* false */0;
  }
}

function hash_variant(s) {
  var accu = 0;
  for(var i = 0 ,i_finish = s.length - 1 | 0; i <= i_finish; ++i){
    accu = Caml_int32.imul(223, accu) + Caml_string.get(s, i) | 0;
  }
  accu = accu & 2147483647;
  if (accu > 1073741823) {
    return accu - -2147483648 | 0;
  } else {
    return accu;
  }
}

function proxy(ty) {
  var ty0 = repr(ty);
  var match = ty0[/* desc */0];
  if (typeof match === "number") {
    return ty0;
  } else {
    switch (match.tag | 0) {
      case 4 : 
          var _ty = match[0];
          while(true) {
            var ty$1 = _ty;
            var match$1 = ty$1[/* desc */0];
            if (typeof match$1 === "number") {
              if (match$1) {
                throw [
                      Caml_builtin_exceptions.assert_failure,
                      [
                        "btype.ml",
                        167,
                        15
                      ]
                    ];
              } else {
                return ty0;
              }
            } else {
              switch (match$1.tag | 0) {
                case 5 : 
                    _ty = match$1[3];
                    continue ;
                    case 6 : 
                    _ty = match$1[0];
                    continue ;
                    case 0 : 
                case 3 : 
                case 9 : 
                    return ty$1;
                default:
                  throw [
                        Caml_builtin_exceptions.assert_failure,
                        [
                          "btype.ml",
                          167,
                          15
                        ]
                      ];
              }
            }
          };
      case 8 : 
          var row = match[0];
          if (static_row(row)) {
            return ty0;
          } else {
            return row_more(row);
          }
      default:
        return ty0;
    }
  }
}

function has_constr_row(t) {
  var match = repr(t)[/* desc */0];
  if (typeof match === "number") {
    return /* false */0;
  } else {
    switch (match.tag | 0) {
      case 4 : 
          var _t = match[0];
          while(true) {
            var t$1 = _t;
            var match$1 = repr(t$1)[/* desc */0];
            if (typeof match$1 === "number") {
              return /* false */0;
            } else {
              switch (match$1.tag | 0) {
                case 3 : 
                    return /* true */1;
                case 5 : 
                    _t = match$1[3];
                    continue ;
                    default:
                  return /* false */0;
              }
            }
          };
      case 8 : 
          var match$2 = row_more(match[0]);
          var match$3 = match$2[/* desc */0];
          if (typeof match$3 === "number" || match$3.tag !== 3) {
            return /* false */0;
          } else {
            return /* true */1;
          }
          break;
      default:
        return /* false */0;
    }
  }
}

function is_row_name(s) {
  var l = s.length;
  if (l < 4) {
    return /* false */0;
  } else {
    return +($$String.sub(s, l - 4 | 0, 4) === "#row");
  }
}

function is_constr_row(t) {
  var match = t[/* desc */0];
  if (typeof match === "number") {
    return /* false */0;
  } else if (match.tag === 3) {
    var match$1 = match[0];
    switch (match$1.tag | 0) {
      case 0 : 
          return is_row_name(match$1[0][/* name */1]);
      case 1 : 
          return is_row_name(match$1[1]);
      case 2 : 
          return /* false */0;
      
    }
  } else {
    return /* false */0;
  }
}

function iter_row(f, _row) {
  while(true) {
    var row = _row;
    List.iter((function (param) {
            var match = row_field_repr_aux(/* [] */0, param[1]);
            if (typeof match === "number") {
              return /* () */0;
            } else if (match.tag) {
              return List.iter(f, match[1]);
            } else {
              var match$1 = match[0];
              if (match$1) {
                return Curry._1(f, match$1[0]);
              } else {
                return /* () */0;
              }
            }
          }), row[/* row_fields */0]);
    var match = repr(row[/* row_more */1])[/* desc */0];
    var exit = 0;
    if (typeof match === "number") {
      if (match) {
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "btype.ml",
                214,
                9
              ]
            ];
      } else {
        exit = 1;
      }
    } else {
      switch (match.tag | 0) {
        case 8 : 
            _row = match[0];
            continue ;
            case 0 : 
        case 3 : 
        case 7 : 
        case 9 : 
            exit = 1;
            break;
        default:
          throw [
                Caml_builtin_exceptions.assert_failure,
                [
                  "btype.ml",
                  214,
                  9
                ]
              ];
      }
    }
    if (exit === 1) {
      return may((function (param) {
                    return List.iter(f, param[1]);
                  }), row[/* row_name */5]);
    }
    
  };
}

function iter_type_expr(f, ty) {
  var match = ty[/* desc */0];
  if (typeof match === "number") {
    return /* () */0;
  } else {
    switch (match.tag | 0) {
      case 1 : 
          Curry._1(f, match[1]);
          return Curry._1(f, match[2]);
      case 2 : 
          return List.iter(f, match[0]);
      case 3 : 
          return List.iter(f, match[1]);
      case 4 : 
          var ty$1 = match[0];
          var match$1 = match[1][/* contents */0];
          if (match$1) {
            Curry._1(f, ty$1);
            return List.iter(f, match$1[0][1]);
          } else {
            return Curry._1(f, ty$1);
          }
      case 5 : 
          Curry._1(f, match[2]);
          return Curry._1(f, match[3]);
      case 6 : 
      case 7 : 
          return Curry._1(f, match[0]);
      case 8 : 
          var row = match[0];
          iter_row(f, row);
          return Curry._1(f, row_more(row));
      case 10 : 
          Curry._1(f, match[0]);
          return List.iter(f, match[1]);
      case 11 : 
          return List.iter(f, match[2]);
      default:
        return /* () */0;
    }
  }
}

function iter_abbrev(f, _param) {
  while(true) {
    var param = _param;
    if (typeof param === "number") {
      return /* () */0;
    } else if (param.tag) {
      _param = param[0][0];
      continue ;
      
    } else {
      Curry._1(f, param[2]);
      Curry._1(f, param[3]);
      _param = param[4];
      continue ;
      
    }
  };
}

function it_signature(it) {
  var partial_arg = Curry._1(it[/* it_signature_item */1], it);
  return (function (param) {
      return List.iter(partial_arg, param);
    });
}

function it_signature_item(it, param) {
  switch (param.tag | 0) {
    case 0 : 
        return Curry._2(it[/* it_value_description */2], it, param[1]);
    case 1 : 
        return Curry._2(it[/* it_type_declaration */3], it, param[1]);
    case 2 : 
        return Curry._2(it[/* it_extension_constructor */4], it, param[1]);
    case 3 : 
        return Curry._2(it[/* it_module_declaration */5], it, param[1]);
    case 4 : 
        return Curry._2(it[/* it_modtype_declaration */6], it, param[1]);
    case 5 : 
        return Curry._2(it[/* it_class_declaration */7], it, param[1]);
    case 6 : 
        return Curry._2(it[/* it_class_type_declaration */8], it, param[1]);
    
  }
}

function it_value_description(it, vd) {
  return Curry._2(it[/* it_type_expr */13], it, vd[/* val_type */0]);
}

function it_type_declaration(it, td) {
  List.iter(Curry._1(it[/* it_type_expr */13], it), td[/* type_params */0]);
  may(Curry._1(it[/* it_type_expr */13], it), td[/* type_manifest */4]);
  return Curry._2(it[/* it_type_kind */11], it, td[/* type_kind */2]);
}

function it_extension_constructor(it, td) {
  Curry._1(it[/* it_path */14], td[/* ext_type_path */0]);
  List.iter(Curry._1(it[/* it_type_expr */13], it), td[/* ext_type_params */1]);
  List.iter(Curry._1(it[/* it_type_expr */13], it), td[/* ext_args */2]);
  return may(Curry._1(it[/* it_type_expr */13], it), td[/* ext_ret_type */3]);
}

function it_module_declaration(it, md) {
  return Curry._2(it[/* it_module_type */9], it, md[/* md_type */0]);
}

function it_modtype_declaration(it, mtd) {
  return may(Curry._1(it[/* it_module_type */9], it), mtd[/* mtd_type */0]);
}

function it_class_declaration(it, cd) {
  List.iter(Curry._1(it[/* it_type_expr */13], it), cd[/* cty_params */0]);
  Curry._2(it[/* it_class_type */10], it, cd[/* cty_type */1]);
  may(Curry._1(it[/* it_type_expr */13], it), cd[/* cty_new */3]);
  return Curry._1(it[/* it_path */14], cd[/* cty_path */2]);
}

function it_class_type_declaration(it, ctd) {
  List.iter(Curry._1(it[/* it_type_expr */13], it), ctd[/* clty_params */0]);
  Curry._2(it[/* it_class_type */10], it, ctd[/* clty_type */1]);
  return Curry._1(it[/* it_path */14], ctd[/* clty_path */2]);
}

function it_module_type(it, param) {
  switch (param.tag | 0) {
    case 1 : 
        return Curry._2(it[/* it_signature */0], it, param[0]);
    case 2 : 
        may(Curry._1(it[/* it_module_type */9], it), param[1]);
        return Curry._2(it[/* it_module_type */9], it, param[2]);
    case 0 : 
    case 3 : 
        return Curry._1(it[/* it_path */14], param[0]);
    
  }
}

function it_class_type(it, param) {
  switch (param.tag | 0) {
    case 0 : 
        Curry._1(it[/* it_path */14], param[0]);
        List.iter(Curry._1(it[/* it_type_expr */13], it), param[1]);
        return Curry._2(it[/* it_class_type */10], it, param[2]);
    case 1 : 
        var cs = param[0];
        Curry._2(it[/* it_type_expr */13], it, cs[/* csig_self */0]);
        iter$1((function (_, param) {
                return Curry._2(it[/* it_type_expr */13], it, param[2]);
              }), cs[/* csig_vars */1]);
        return List.iter((function (param) {
                      Curry._1(it[/* it_path */14], param[0]);
                      return List.iter(Curry._1(it[/* it_type_expr */13], it), param[1]);
                    }), cs[/* csig_inher */3]);
    case 2 : 
        Curry._2(it[/* it_type_expr */13], it, param[1]);
        return Curry._2(it[/* it_class_type */10], it, param[2]);
    
  }
}

function it_type_kind(it, param) {
  if (typeof param === "number") {
    return /* () */0;
  } else if (param.tag) {
    return List.iter((function (cd) {
                  List.iter(Curry._1(it[/* it_type_expr */13], it), cd[/* cd_args */1]);
                  return may(Curry._1(it[/* it_type_expr */13], it), cd[/* cd_res */2]);
                }), param[0]);
  } else {
    return List.iter((function (ld) {
                  return Curry._2(it[/* it_type_expr */13], it, ld[/* ld_type */2]);
                }), param[0]);
  }
}

function it_do_type_expr(it, ty) {
  iter_type_expr(Curry._1(it[/* it_type_expr */13], it), ty);
  var match = ty[/* desc */0];
  if (typeof match === "number") {
    return /* () */0;
  } else {
    switch (match.tag | 0) {
      case 4 : 
          var match$1 = match[1][/* contents */0];
          if (match$1) {
            return Curry._1(it[/* it_path */14], match$1[0][0]);
          } else {
            return /* () */0;
          }
      case 8 : 
          return may((function (param) {
                        return Curry._1(it[/* it_path */14], param[0]);
                      }), row_repr_aux(/* [] */0, match[0])[/* row_name */5]);
      case 3 : 
      case 11 : 
          return Curry._1(it[/* it_path */14], match[0]);
      default:
        return /* () */0;
    }
  }
}

function it_path() {
  return /* () */0;
}

var type_iterators = /* record */[
  /* it_signature */it_signature,
  /* it_signature_item */it_signature_item,
  /* it_value_description */it_value_description,
  /* it_type_declaration */it_type_declaration,
  /* it_extension_constructor */it_extension_constructor,
  /* it_module_declaration */it_module_declaration,
  /* it_modtype_declaration */it_modtype_declaration,
  /* it_class_declaration */it_class_declaration,
  /* it_class_type_declaration */it_class_type_declaration,
  /* it_module_type */it_module_type,
  /* it_class_type */it_class_type,
  /* it_type_kind */it_type_kind,
  /* it_do_type_expr */it_do_type_expr,
  /* it_type_expr */it_do_type_expr,
  /* it_path */it_path
];

function copy_row(f, fixed, row, keep, more) {
  var fields = List.map((function (param) {
          var fi = param[1];
          var match = row_field_repr_aux(/* [] */0, fi);
          var $js;
          if (typeof match === "number") {
            $js = fi;
          } else if (match.tag) {
            var e = keep ? match[3] : [/* None */0];
            var m = row[/* row_fixed */4] ? fixed : match[2];
            var tl = List.map(f, match[1]);
            $js = /* Reither */Block.__(1, [
                match[0],
                tl,
                m,
                e
              ]);
          } else {
            var match$1 = match[0];
            $js = match$1 ? /* Rpresent */Block.__(0, [/* Some */[Curry._1(f, match$1[0])]]) : fi;
          }
          return /* tuple */[
                  param[0],
                  $js
                ];
        }), row[/* row_fields */0]);
  var match = row[/* row_name */5];
  var name;
  if (match) {
    var match$1 = match[0];
    name = /* Some */[/* tuple */[
        match$1[0],
        List.map(f, match$1[1])
      ]];
  } else {
    name = /* None */0;
  }
  return /* record */[
          /* row_fields */fields,
          /* row_more */more,
          /* row_bound : () */0,
          /* row_closed */row[/* row_closed */3],
          /* row_fixed */row[/* row_fixed */4] && fixed,
          /* row_name */name
        ];
}

function copy_kind(_param) {
  while(true) {
    var param = _param;
    if (typeof param === "number") {
      if (param !== 0) {
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "btype.ml",
                363,
                16
              ]
            ];
      } else {
        return /* Fpresent */0;
      }
    } else {
      var match = param[0][/* contents */0];
      if (match) {
        _param = match[0];
        continue ;
        
      } else {
        return /* Fvar */[[/* None */0]];
      }
    }
  };
}

function copy_commu(c) {
  if (commu_repr(c)) {
    return /* Clink */[[/* Cunknown */1]];
  } else {
    return /* Cok */0;
  }
}

function copy_type_desc(_$staropt$star, f, _ty) {
  while(true) {
    var ty = _ty;
    var $staropt$star = _$staropt$star;
    var keep_names = $staropt$star ? $staropt$star[0] : /* false */0;
    if (typeof ty === "number") {
      return /* Tnil */0;
    } else {
      switch (ty.tag | 0) {
        case 0 : 
            if (keep_names) {
              return ty;
            } else {
              return /* Tvar */Block.__(0, [/* None */0]);
            }
        case 1 : 
            return /* Tarrow */Block.__(1, [
                      ty[0],
                      Curry._1(f, ty[1]),
                      Curry._1(f, ty[2]),
                      copy_commu(ty[3])
                    ]);
        case 2 : 
            return /* Ttuple */Block.__(2, [List.map(f, ty[0])]);
        case 3 : 
            return /* Tconstr */Block.__(3, [
                      ty[0],
                      List.map(f, ty[1]),
                      [/* Mnil */0]
                    ]);
        case 4 : 
            var ty$1 = ty[0];
            var match = ty[1][/* contents */0];
            if (match) {
              var match$1 = match[0];
              return /* Tobject */Block.__(4, [
                        Curry._1(f, ty$1),
                        [/* Some */[/* tuple */[
                              match$1[0],
                              List.map(f, match$1[1])
                            ]]]
                      ]);
            } else {
              return /* Tobject */Block.__(4, [
                        Curry._1(f, ty$1),
                        [/* None */0]
                      ]);
            }
            break;
        case 5 : 
            return /* Tfield */Block.__(5, [
                      ty[0],
                      field_kind_repr(ty[1]),
                      Curry._1(f, ty[2]),
                      Curry._1(f, ty[3])
                    ]);
        case 6 : 
            _ty = ty[0][/* desc */0];
            _$staropt$star = /* None */0;
            continue ;
            case 7 : 
            throw [
                  Caml_builtin_exceptions.assert_failure,
                  [
                    "btype.ml",
                    390,
                    27
                  ]
                ];
        case 8 : 
            throw [
                  Caml_builtin_exceptions.assert_failure,
                  [
                    "btype.ml",
                    385,
                    27
                  ]
                ];
        case 9 : 
            return ty;
        case 10 : 
            var tyl = List.map((function (x) {
                    var _ty = Curry._1(f, x);
                    while(true) {
                      var ty = _ty;
                      var match = ty[/* desc */0];
                      var exit = 0;
                      if (typeof match === "number") {
                        exit = 1;
                      } else {
                        switch (match.tag | 0) {
                          case 2 : 
                              var match$1 = match[0];
                              if (match$1) {
                                _ty = match$1[0];
                                continue ;
                                
                              } else {
                                exit = 1;
                              }
                              break;
                          case 6 : 
                              _ty = match[0];
                              continue ;
                              case 7 : 
                          case 9 : 
                              return ty;
                          default:
                            exit = 1;
                        }
                      }
                      if (exit === 1) {
                        throw [
                              Caml_builtin_exceptions.assert_failure,
                              [
                                "btype.ml",
                                375,
                                26
                              ]
                            ];
                      }
                      
                    };
                  }), ty[1]);
            return /* Tpoly */Block.__(10, [
                      Curry._1(f, ty[0]),
                      tyl
                    ]);
        case 11 : 
            return /* Tpackage */Block.__(11, [
                      ty[0],
                      ty[1],
                      List.map(f, ty[2])
                    ]);
        
      }
    }
  };
}

var saved_desc = [/* [] */0];

function save_desc(ty, desc) {
  saved_desc[0] = /* :: */[
    /* tuple */[
      ty,
      desc
    ],
    saved_desc[0]
  ];
  return /* () */0;
}

var saved_kinds = [/* [] */0];

var new_kinds = [/* [] */0];

function dup_kind(r) {
  var match = r[0];
  if (match) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "btype.ml",
            408,
            40
          ]
        ];
  }
  if (List.memq(r, new_kinds[0])) {
    return 0;
  } else {
    saved_kinds[0] = /* :: */[
      r,
      saved_kinds[0]
    ];
    var r$prime = [/* None */0];
    new_kinds[0] = /* :: */[
      r$prime,
      new_kinds[0]
    ];
    r[0] = /* Some */[/* Fvar */[r$prime]];
    return /* () */0;
  }
}

function cleanup_types() {
  List.iter((function (param) {
          param[0][/* desc */0] = param[1];
          return /* () */0;
        }), saved_desc[0]);
  List.iter((function (r) {
          r[0] = /* None */0;
          return /* () */0;
        }), saved_kinds[0]);
  saved_desc[0] = /* [] */0;
  saved_kinds[0] = /* [] */0;
  new_kinds[0] = /* [] */0;
  return /* () */0;
}

function mark_type(ty) {
  var ty$1 = repr(ty);
  if (ty$1[/* level */1] >= 0) {
    ty$1[/* level */1] = pivot_level - ty$1[/* level */1] | 0;
    return iter_type_expr(mark_type, ty$1);
  } else {
    return 0;
  }
}

function mark_type_node(ty) {
  var ty$1 = repr(ty);
  if (ty$1[/* level */1] >= 0) {
    ty$1[/* level */1] = pivot_level - ty$1[/* level */1] | 0;
    return /* () */0;
  } else {
    return 0;
  }
}

function it_type_expr(it, ty) {
  var ty$1 = repr(ty);
  if (ty$1[/* level */1] >= 0) {
    mark_type_node(ty$1);
    return Curry._2(it[/* it_do_type_expr */12], it, ty$1);
  } else {
    return 0;
  }
}

var newrecord = type_iterators.slice();

newrecord[/* it_type_expr */13] = it_type_expr;

function unmark_type(ty) {
  var ty$1 = repr(ty);
  if (ty$1[/* level */1] < 0) {
    ty$1[/* level */1] = pivot_level - ty$1[/* level */1] | 0;
    return iter_type_expr(unmark_type, ty$1);
  } else {
    return 0;
  }
}

function it_type_expr$1(_, ty) {
  return unmark_type(ty);
}

var newrecord$1 = newrecord.slice();

newrecord$1[/* it_type_expr */13] = it_type_expr$1;

function unmark_extension_constructor(ext) {
  List.iter(unmark_type, ext[/* ext_type_params */1]);
  List.iter(unmark_type, ext[/* ext_args */2]);
  return may(unmark_type, ext[/* ext_ret_type */3]);
}

function unmark_class_signature(sign) {
  unmark_type(sign[/* csig_self */0]);
  return iter$1((function (_, param) {
                return unmark_type(param[2]);
              }), sign[/* csig_vars */1]);
}

function find_expans(priv, p1, _param) {
  while(true) {
    var param = _param;
    if (typeof param === "number") {
      return /* None */0;
    } else if (param.tag) {
      var rem = param[0][/* contents */0];
      _param = rem;
      continue ;
      
    } else if (Caml_obj.caml_greaterequal(param[0], priv) && same(p1, param[1])) {
      return /* Some */[param[3]];
    } else {
      _param = param[4];
      continue ;
      
    }
  };
}

var memo = [/* [] */0];

function cleanup_abbrev() {
  List.iter((function (abbr) {
          abbr[0] = /* Mnil */0;
          return /* () */0;
        }), memo[0]);
  memo[0] = /* [] */0;
  return /* () */0;
}

function memorize_abbrev(mem, priv, path, v, v$prime) {
  mem[0] = /* Mcons */Block.__(0, [
      priv,
      path,
      v,
      v$prime,
      mem[0]
    ]);
  memo[0] = /* :: */[
    mem,
    memo[0]
  ];
  return /* () */0;
}

function forget_abbrev_rec(mem, path) {
  if (typeof mem === "number") {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "btype.ml",
            520,
            6
          ]
        ];
  } else if (mem.tag) {
    var mem$prime = mem[0];
    mem$prime[0] = forget_abbrev_rec(mem$prime[0], path);
    throw Pervasives.Exit;
  } else {
    var rem = mem[4];
    var path$prime = mem[1];
    if (same(path, path$prime)) {
      return rem;
    } else {
      return /* Mcons */Block.__(0, [
                mem[0],
                path$prime,
                mem[2],
                mem[3],
                forget_abbrev_rec(rem, path)
              ]);
    }
  }
}

function forget_abbrev(mem, path) {
  try {
    mem[0] = forget_abbrev_rec(mem[0], path);
    return /* () */0;
  }
  catch (exn){
    if (exn === Pervasives.Exit) {
      return /* () */0;
    } else {
      throw exn;
    }
  }
}

function is_optional(l) {
  if (l.length) {
    return +(Caml_string.get(l, 0) === /* "?" */63);
  } else {
    return /* false */0;
  }
}

function label_name(l) {
  if (is_optional(l)) {
    return $$String.sub(l, 1, l.length - 1 | 0);
  } else {
    return l;
  }
}

function prefixed_label_name(l) {
  if (is_optional(l)) {
    return l;
  } else {
    return "~" + l;
  }
}

function extract_label_aux(_hd, l, _param) {
  while(true) {
    var param = _param;
    var hd = _hd;
    if (param) {
      var ls = param[1];
      var p = param[0];
      var l$prime = p[0];
      if (label_name(l$prime) === l) {
        return /* tuple */[
                l$prime,
                p[1],
                List.rev(hd),
                ls
              ];
      } else {
        _param = ls;
        _hd = /* :: */[
          p,
          hd
        ];
        continue ;
        
      }
    } else {
      throw Caml_builtin_exceptions.not_found;
    }
  };
}

function undo_change(param) {
  switch (param.tag | 0) {
    case 0 : 
        param[0][/* desc */0] = param[1];
        return /* () */0;
    case 1 : 
        param[0][/* level */1] = param[1];
        return /* () */0;
    default:
      param[0][0] = param[1];
      return /* () */0;
  }
}

var trail = Caml_weak.caml_weak_create(1);

var last_snapshot = [0];

function log_change(ch) {
  var match = Caml_weak.caml_weak_get(trail, 0);
  if (match) {
    var r$prime = [/* Unchanged */0];
    match[0][0] = /* Change */[
      ch,
      r$prime
    ];
    return Caml_weak.caml_weak_set(trail, 0, /* Some */[r$prime]);
  } else {
    return /* () */0;
  }
}

function log_type(ty) {
  if (ty[/* id */2] <= last_snapshot[0]) {
    return log_change(/* Ctype */Block.__(0, [
                  ty,
                  ty[/* desc */0]
                ]));
  } else {
    return 0;
  }
}

function link_type(ty, ty$prime) {
  log_type(ty);
  var desc = ty[/* desc */0];
  ty[/* desc */0] = /* Tlink */Block.__(6, [ty$prime]);
  var match = ty$prime[/* desc */0];
  if (typeof desc === "number") {
    return /* () */0;
  } else if (desc.tag) {
    return /* () */0;
  } else if (typeof match === "number") {
    return /* () */0;
  } else if (match.tag) {
    return /* () */0;
  } else {
    var name = desc[0];
    if (name) {
      if (match[0]) {
        if (ty[/* level */1] < ty$prime[/* level */1]) {
          log_type(ty$prime);
          ty$prime[/* desc */0] = /* Tvar */Block.__(0, [name]);
          return /* () */0;
        } else {
          return 0;
        }
      } else {
        log_type(ty$prime);
        ty$prime[/* desc */0] = /* Tvar */Block.__(0, [name]);
        return /* () */0;
      }
    } else {
      return /* () */0;
    }
  }
}

function set_level(ty, level) {
  if (ty[/* id */2] <= last_snapshot[0]) {
    log_change(/* Clevel */Block.__(1, [
            ty,
            ty[/* level */1]
          ]));
  }
  ty[/* level */1] = level;
  return /* () */0;
}

function set_univar(rty, ty) {
  log_change(/* Cuniv */Block.__(6, [
          rty,
          rty[0]
        ]));
  rty[0] = /* Some */[ty];
  return /* () */0;
}

function set_name(nm, v) {
  log_change(/* Cname */Block.__(2, [
          nm,
          nm[0]
        ]));
  nm[0] = v;
  return /* () */0;
}

function set_row_field(e, v) {
  log_change(/* Crow */Block.__(3, [
          e,
          e[0]
        ]));
  e[0] = /* Some */[v];
  return /* () */0;
}

function set_kind(rk, k) {
  log_change(/* Ckind */Block.__(4, [
          rk,
          rk[0]
        ]));
  rk[0] = /* Some */[k];
  return /* () */0;
}

function set_commu(rc, c) {
  log_change(/* Ccommu */Block.__(5, [
          rc,
          rc[0]
        ]));
  rc[0] = c;
  return /* () */0;
}

function set_typeset(rs, s) {
  log_change(/* Ctypeset */Block.__(7, [
          rs,
          rs[0]
        ]));
  rs[0] = s;
  return /* () */0;
}

function snapshot() {
  var old = last_snapshot[0];
  last_snapshot[0] = new_id[0];
  var match = Caml_weak.caml_weak_get(trail, 0);
  if (match) {
    return /* tuple */[
            match[0],
            old
          ];
  } else {
    var r = [/* Unchanged */0];
    Caml_weak.caml_weak_set(trail, 0, /* Some */[r]);
    return /* tuple */[
            r,
            old
          ];
  }
}

function rev_log(_accu, _param) {
  while(true) {
    var param = _param;
    var accu = _accu;
    if (typeof param === "number") {
      if (param !== 0) {
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "btype.ml",
                656,
                15
              ]
            ];
      } else {
        return accu;
      }
    } else {
      var next = param[1];
      var d = next[0];
      next[0] = /* Invalid */1;
      _param = d;
      _accu = /* :: */[
        param[0],
        accu
      ];
      continue ;
      
    }
  };
}

function backtrack(param) {
  var old = param[1];
  var changes = param[0];
  var change = changes[0];
  if (typeof change === "number") {
    if (change !== 0) {
      throw [
            Caml_builtin_exceptions.failure,
            "Btype.backtrack"
          ];
    } else {
      last_snapshot[0] = old;
      return /* () */0;
    }
  } else {
    cleanup_abbrev(/* () */0);
    var backlog = rev_log(/* [] */0, change);
    List.iter(undo_change, backlog);
    changes[0] = /* Unchanged */0;
    last_snapshot[0] = old;
    return Caml_weak.caml_weak_set(trail, 0, /* Some */[changes]);
  }
}

var $$Error$1 = Caml_exceptions.create("Ocaml_typedtree_test.Cmi_format.Error");

function input_cmi() {
  var match = Caml_missing_polyfill.not_implemented("caml_input_value not implemented by bucklescript yet\n");
  var crcs = Caml_missing_polyfill.not_implemented("caml_input_value not implemented by bucklescript yet\n");
  var flags = Caml_missing_polyfill.not_implemented("caml_input_value not implemented by bucklescript yet\n");
  return /* record */[
          /* cmi_name */match[0],
          /* cmi_sign */match[1],
          /* cmi_crcs */crcs,
          /* cmi_flags */flags
        ];
}

function read_cmi(filename) {
  var ic = Pervasives.open_in_bin(filename);
  try {
    var buffer = Pervasives.really_input_string(ic, cmi_magic_number.length);
    if (buffer !== cmi_magic_number) {
      Caml_missing_polyfill.not_implemented("caml_ml_close_channel not implemented by bucklescript yet\n");
      var pre_len = cmi_magic_number.length - 3 | 0;
      if ($$String.sub(buffer, 0, pre_len) === $$String.sub(cmi_magic_number, 0, pre_len)) {
        var msg = buffer < cmi_magic_number ? "an older" : "a newer";
        throw [
              $$Error$1,
              /* Wrong_version_interface */Block.__(1, [
                  filename,
                  msg
                ])
            ];
      } else {
        throw [
              $$Error$1,
              /* Not_an_interface */Block.__(0, [filename])
            ];
      }
    }
    var cmi = input_cmi(ic);
    Caml_missing_polyfill.not_implemented("caml_ml_close_channel not implemented by bucklescript yet\n");
    return cmi;
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn === Caml_builtin_exceptions.end_of_file) {
      Caml_missing_polyfill.not_implemented("caml_ml_close_channel not implemented by bucklescript yet\n");
      throw [
            $$Error$1,
            /* Corrupted_interface */Block.__(2, [filename])
          ];
    } else if (exn[0] === Caml_builtin_exceptions.failure) {
      Caml_missing_polyfill.not_implemented("caml_ml_close_channel not implemented by bucklescript yet\n");
      throw [
            $$Error$1,
            /* Corrupted_interface */Block.__(2, [filename])
          ];
    } else if (exn[0] === $$Error$1) {
      Caml_missing_polyfill.not_implemented("caml_ml_close_channel not implemented by bucklescript yet\n");
      throw [
            $$Error$1,
            exn[1]
          ];
    } else {
      throw exn;
    }
  }
}

function output_cmi(filename, oc, _) {
  Pervasives.output_string(oc, cmi_magic_number);
  Caml_missing_polyfill.not_implemented("caml_output_value not implemented by bucklescript yet\n");
  Caml_io.caml_ml_flush(oc);
  var crc = Digest.file(filename);
  Caml_missing_polyfill.not_implemented("caml_output_value not implemented by bucklescript yet\n");
  Caml_missing_polyfill.not_implemented("caml_output_value not implemented by bucklescript yet\n");
  return crc;
}

function report_error(ppf, param) {
  switch (param.tag | 0) {
    case 0 : 
        return Curry._2(Format.fprintf(ppf, /* Format */[
                        /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                /* Break */Block.__(0, [
                                    "@ ",
                                    1,
                                    0
                                  ]),
                                /* String_literal */Block.__(11, [
                                    "is not a compiled interface",
                                    /* End_of_format */0
                                  ])
                              ])]),
                        "%a@ is not a compiled interface"
                      ]), print_filename, param[0]);
    case 1 : 
        return Curry._3(Format.fprintf(ppf, /* Format */[
                        /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                /* Break */Block.__(0, [
                                    "@ ",
                                    1,
                                    0
                                  ]),
                                /* String_literal */Block.__(11, [
                                    "is not a compiled interface for this version of OCaml.",
                                    /* Formatting_lit */Block.__(17, [
                                        /* Flush_newline */4,
                                        /* String_literal */Block.__(11, [
                                            "It seems to be for ",
                                            /* String */Block.__(2, [
                                                /* No_padding */0,
                                                /* String_literal */Block.__(11, [
                                                    " version of OCaml.",
                                                    /* End_of_format */0
                                                  ])
                                              ])
                                          ])
                                      ])
                                  ])
                              ])]),
                        "%a@ is not a compiled interface for this version of OCaml.@.It seems to be for %s version of OCaml."
                      ]), print_filename, param[0], param[1]);
    case 2 : 
        return Curry._2(Format.fprintf(ppf, /* Format */[
                        /* String_literal */Block.__(11, [
                            "Corrupted compiled interface",
                            /* Formatting_lit */Block.__(17, [
                                /* Break */Block.__(0, [
                                    "@ ",
                                    1,
                                    0
                                  ]),
                                /* Alpha */Block.__(15, [/* End_of_format */0])
                              ])
                          ]),
                        "Corrupted compiled interface@ %a"
                      ]), print_filename, param[0]);
    
  }
}

register_error_of_exn((function (param) {
        if (param[0] === $$Error$1) {
          return /* Some */[error_of_printer_file(report_error, param[1])];
        } else {
          return /* None */0;
        }
      }));

var Inconsistency = Caml_exceptions.create("Ocaml_typedtree_test.Consistbl.Inconsistency");

function set$1(tbl, name, crc, source) {
  return Hashtbl.add(tbl, name, /* tuple */[
              crc,
              source
            ]);
}

function free_vars(ty) {
  var ret = [/* Empty */0];
  var loop = function (_ty) {
    while(true) {
      var ty = _ty;
      var ty$1 = repr(ty);
      if (ty$1[/* level */1] >= 0) {
        ty$1[/* level */1] = pivot_level - ty$1[/* level */1] | 0;
        var match = ty$1[/* desc */0];
        if (typeof match === "number") {
          return iter_type_expr(loop, ty$1);
        } else {
          switch (match.tag | 0) {
            case 0 : 
                ret[0] = add$3(ty$1, ret[0]);
                return /* () */0;
            case 8 : 
                var row = row_repr_aux(/* [] */0, match[0]);
                iter_row(loop, row);
                if (static_row(row)) {
                  return 0;
                } else {
                  _ty = row[/* row_more */1];
                  continue ;
                  
                }
                break;
            default:
              return iter_type_expr(loop, ty$1);
          }
        }
      } else {
        return 0;
      }
    };
  };
  loop(ty);
  unmark_type(ty);
  return ret[0];
}

function extension_descr(path_ext, ext) {
  var match = ext[/* ext_ret_type */3];
  var ty_res = match ? match[0] : newty2(100000000, /* Tconstr */Block.__(3, [
            ext[/* ext_type_path */0],
            ext[/* ext_type_params */1],
            [/* Mnil */0]
          ]));
  var tag_001 = +(ext[/* ext_args */2] === /* [] */0);
  var tag = /* Cstr_extension */Block.__(2, [
      path_ext,
      tag_001
    ]);
  var match$1 = ext[/* ext_ret_type */3];
  var existentials;
  if (match$1) {
    var ret_vars = free_vars(match$1[0]);
    var arg_vars = free_vars(newty2(100000000, /* Ttuple */Block.__(2, [ext[/* ext_args */2]])));
    existentials = elements_aux$1(/* [] */0, diff$1(arg_vars, ret_vars));
  } else {
    existentials = /* [] */0;
  }
  return /* record */[
          /* cstr_name */last(path_ext),
          /* cstr_res */ty_res,
          /* cstr_existentials */existentials,
          /* cstr_args */ext[/* ext_args */2],
          /* cstr_arity */List.length(ext[/* ext_args */2]),
          /* cstr_tag */tag,
          /* cstr_consts */-1,
          /* cstr_nonconsts */-1,
          /* cstr_normal */-1,
          /* cstr_generalized */+(ext[/* ext_ret_type */3] !== /* None */0),
          /* cstr_private */ext[/* ext_private */4],
          /* cstr_loc */ext[/* ext_loc */5],
          /* cstr_attributes */ext[/* ext_attributes */6]
        ];
}

var none$1 = /* record */[
  /* desc : Ttuple */Block.__(2, [/* [] */0]),
  /* level */-1,
  /* id */-1
];

var dummy_label_005 = /* lbl_all : array */[];

var dummy_label = /* record */[
  /* lbl_name */"",
  /* lbl_res */none$1,
  /* lbl_arg */none$1,
  /* lbl_mut : Immutable */0,
  /* lbl_pos */-1,
  dummy_label_005,
  /* lbl_repres : Record_regular */0,
  /* lbl_private : Public */1,
  /* lbl_loc */none,
  /* lbl_attributes : [] */0
];

var builtin_idents = [/* [] */0];

function wrap(create, s) {
  var id = Curry._1(create, s);
  builtin_idents[0] = /* :: */[
    /* tuple */[
      s,
      id
    ],
    builtin_idents[0]
  ];
  return id;
}

var ident_int = wrap(create, "int");

var ident_char = wrap(create, "char");

var ident_string = wrap(create, "string");

var ident_float = wrap(create, "float");

var ident_bool = wrap(create, "bool");

var ident_unit = wrap(create, "unit");

var ident_exn = wrap(create, "exn");

var ident_array = wrap(create, "array");

var ident_list = wrap(create, "list");

var ident_option = wrap(create, "option");

var ident_nativeint = wrap(create, "nativeint");

var ident_int32 = wrap(create, "int32");

var ident_int64 = wrap(create, "int64");

var ident_lazy_t = wrap(create, "lazy_t");

var ident_bytes = wrap(create, "bytes");

var path_int = /* Pident */Block.__(0, [ident_int]);

var path_char = /* Pident */Block.__(0, [ident_char]);

var path_string = /* Pident */Block.__(0, [ident_string]);

var path_float = /* Pident */Block.__(0, [ident_float]);

var path_bool = /* Pident */Block.__(0, [ident_bool]);

var path_unit = /* Pident */Block.__(0, [ident_unit]);

var path_exn = /* Pident */Block.__(0, [ident_exn]);

var path_array = /* Pident */Block.__(0, [ident_array]);

var path_list = /* Pident */Block.__(0, [ident_list]);

var path_option = /* Pident */Block.__(0, [ident_option]);

var path_nativeint = /* Pident */Block.__(0, [ident_nativeint]);

var path_int32 = /* Pident */Block.__(0, [ident_int32]);

var path_int64 = /* Pident */Block.__(0, [ident_int64]);

var path_lazy_t = /* Pident */Block.__(0, [ident_lazy_t]);

var path_bytes = /* Pident */Block.__(0, [ident_bytes]);

var type_int = newty2(100000000, /* Tconstr */Block.__(3, [
        path_int,
        /* [] */0,
        [/* Mnil */0]
      ]));

var type_char = newty2(100000000, /* Tconstr */Block.__(3, [
        path_char,
        /* [] */0,
        [/* Mnil */0]
      ]));

var type_string = newty2(100000000, /* Tconstr */Block.__(3, [
        path_string,
        /* [] */0,
        [/* Mnil */0]
      ]));

var type_float = newty2(100000000, /* Tconstr */Block.__(3, [
        path_float,
        /* [] */0,
        [/* Mnil */0]
      ]));

var type_bool = newty2(100000000, /* Tconstr */Block.__(3, [
        path_bool,
        /* [] */0,
        [/* Mnil */0]
      ]));

var type_unit = newty2(100000000, /* Tconstr */Block.__(3, [
        path_unit,
        /* [] */0,
        [/* Mnil */0]
      ]));

var type_exn = newty2(100000000, /* Tconstr */Block.__(3, [
        path_exn,
        /* [] */0,
        [/* Mnil */0]
      ]));

function type_array(t) {
  return newty2(100000000, /* Tconstr */Block.__(3, [
                path_array,
                /* :: */[
                  t,
                  /* [] */0
                ],
                [/* Mnil */0]
              ]));
}

function type_list(t) {
  return newty2(100000000, /* Tconstr */Block.__(3, [
                path_list,
                /* :: */[
                  t,
                  /* [] */0
                ],
                [/* Mnil */0]
              ]));
}

function type_option(t) {
  return newty2(100000000, /* Tconstr */Block.__(3, [
                path_option,
                /* :: */[
                  t,
                  /* [] */0
                ],
                [/* Mnil */0]
              ]));
}

var type_nativeint = newty2(100000000, /* Tconstr */Block.__(3, [
        path_nativeint,
        /* [] */0,
        [/* Mnil */0]
      ]));

var type_int32 = newty2(100000000, /* Tconstr */Block.__(3, [
        path_int32,
        /* [] */0,
        [/* Mnil */0]
      ]));

var type_int64 = newty2(100000000, /* Tconstr */Block.__(3, [
        path_int64,
        /* [] */0,
        [/* Mnil */0]
      ]));

function type_lazy_t(t) {
  return newty2(100000000, /* Tconstr */Block.__(3, [
                path_lazy_t,
                /* :: */[
                  t,
                  /* [] */0
                ],
                [/* Mnil */0]
              ]));
}

newty2(100000000, /* Tconstr */Block.__(3, [
        path_bytes,
        /* [] */0,
        [/* Mnil */0]
      ]));

var ident_match_failure = wrap(create_predef_exn, "Match_failure");

var ident_out_of_memory = wrap(create_predef_exn, "Out_of_memory");

var ident_invalid_argument = wrap(create_predef_exn, "Invalid_argument");

var ident_failure = wrap(create_predef_exn, "Failure");

var ident_not_found = wrap(create_predef_exn, "Not_found");

var ident_sys_error = wrap(create_predef_exn, "Sys_error");

var ident_end_of_file = wrap(create_predef_exn, "End_of_file");

var ident_division_by_zero = wrap(create_predef_exn, "Division_by_zero");

var ident_stack_overflow = wrap(create_predef_exn, "Stack_overflow");

var ident_sys_blocked_io = wrap(create_predef_exn, "Sys_blocked_io");

var ident_assert_failure = wrap(create_predef_exn, "Assert_failure");

var ident_undefined_recursive_module = wrap(create_predef_exn, "Undefined_recursive_module");

var decl_abstr = /* record */[
  /* type_params : [] */0,
  /* type_arity */0,
  /* type_kind : Type_abstract */0,
  /* type_private : Public */1,
  /* type_manifest : None */0,
  /* type_variance : [] */0,
  /* type_newtype_level : None */0,
  /* type_loc */none,
  /* type_attributes : [] */0
];

function cstr(id, args) {
  return /* record */[
          /* cd_id */id,
          /* cd_args */args,
          /* cd_res : None */0,
          /* cd_loc */none,
          /* cd_attributes : [] */0
        ];
}

var ident_false = wrap(create, "false");

var ident_true = wrap(create, "true");

var ident_void = wrap(create, "()");

var ident_nil = wrap(create, "[]");

var ident_cons = wrap(create, "::");

var ident_none = wrap(create, "None");

var ident_some = wrap(create, "Some");

function common_initial_env(add_type, add_extension, empty_env) {
  var newrecord = decl_abstr.slice();
  newrecord[/* type_kind */2] = /* Type_variant */Block.__(1, [/* :: */[
        cstr(ident_false, /* [] */0),
        /* :: */[
          cstr(ident_true, /* [] */0),
          /* [] */0
        ]
      ]]);
  var newrecord$1 = decl_abstr.slice();
  newrecord$1[/* type_kind */2] = /* Type_variant */Block.__(1, [/* :: */[
        cstr(ident_void, /* [] */0),
        /* [] */0
      ]]);
  var newrecord$2 = decl_abstr.slice();
  newrecord$2[/* type_kind */2] = /* Type_open */1;
  var tvar = newty2(100000000, /* Tvar */Block.__(0, [/* None */0]));
  var decl_array_000 = /* type_params : :: */[
    tvar,
    /* [] */0
  ];
  var decl_array_005 = /* type_variance : :: */[
    Types_003[/* full */1],
    /* [] */0
  ];
  var decl_array = /* record */[
    decl_array_000,
    /* type_arity */1,
    /* type_kind : Type_abstract */0,
    /* type_private : Public */1,
    /* type_manifest : None */0,
    decl_array_005,
    /* type_newtype_level : None */0,
    /* type_loc */none,
    /* type_attributes : [] */0
  ];
  var tvar$1 = newty2(100000000, /* Tvar */Block.__(0, [/* None */0]));
  var decl_list_000 = /* type_params : :: */[
    tvar$1,
    /* [] */0
  ];
  var decl_list_002 = /* type_kind : Type_variant */Block.__(1, [/* :: */[
        cstr(ident_nil, /* [] */0),
        /* :: */[
          cstr(ident_cons, /* :: */[
                tvar$1,
                /* :: */[
                  type_list(tvar$1),
                  /* [] */0
                ]
              ]),
          /* [] */0
        ]
      ]]);
  var decl_list_005 = /* type_variance : :: */[
    Types_003[/* covariant */2],
    /* [] */0
  ];
  var decl_list = /* record */[
    decl_list_000,
    /* type_arity */1,
    decl_list_002,
    /* type_private : Public */1,
    /* type_manifest : None */0,
    decl_list_005,
    /* type_newtype_level : None */0,
    /* type_loc */none,
    /* type_attributes : [] */0
  ];
  var tvar$2 = newty2(100000000, /* Tvar */Block.__(0, [/* None */0]));
  var decl_option_000 = /* type_params : :: */[
    tvar$2,
    /* [] */0
  ];
  var decl_option_002 = /* type_kind : Type_variant */Block.__(1, [/* :: */[
        cstr(ident_none, /* [] */0),
        /* :: */[
          cstr(ident_some, /* :: */[
                tvar$2,
                /* [] */0
              ]),
          /* [] */0
        ]
      ]]);
  var decl_option_005 = /* type_variance : :: */[
    Types_003[/* covariant */2],
    /* [] */0
  ];
  var decl_option = /* record */[
    decl_option_000,
    /* type_arity */1,
    decl_option_002,
    /* type_private : Public */1,
    /* type_manifest : None */0,
    decl_option_005,
    /* type_newtype_level : None */0,
    /* type_loc */none,
    /* type_attributes : [] */0
  ];
  var tvar$3 = newty2(100000000, /* Tvar */Block.__(0, [/* None */0]));
  var decl_lazy_t_000 = /* type_params : :: */[
    tvar$3,
    /* [] */0
  ];
  var decl_lazy_t_005 = /* type_variance : :: */[
    Types_003[/* covariant */2],
    /* [] */0
  ];
  var decl_lazy_t = /* record */[
    decl_lazy_t_000,
    /* type_arity */1,
    /* type_kind : Type_abstract */0,
    /* type_private : Public */1,
    /* type_manifest : None */0,
    decl_lazy_t_005,
    /* type_newtype_level : None */0,
    /* type_loc */none,
    /* type_attributes : [] */0
  ];
  var add_extension$1 = function (id, l) {
    return Curry._2(add_extension, id, /* record */[
                /* ext_type_path */path_exn,
                /* ext_type_params : [] */0,
                /* ext_args */l,
                /* ext_ret_type : None */0,
                /* ext_private : Public */1,
                /* ext_loc */none,
                /* ext_attributes : [] */0
              ]);
  };
  return Curry._1(add_extension$1(ident_match_failure, /* :: */[
                  newty2(100000000, /* Ttuple */Block.__(2, [/* :: */[
                            type_string,
                            /* :: */[
                              type_int,
                              /* :: */[
                                type_int,
                                /* [] */0
                              ]
                            ]
                          ]])),
                  /* [] */0
                ]), Curry._1(add_extension$1(ident_out_of_memory, /* [] */0), Curry._1(add_extension$1(ident_stack_overflow, /* [] */0), Curry._1(add_extension$1(ident_invalid_argument, /* :: */[
                              type_string,
                              /* [] */0
                            ]), Curry._1(add_extension$1(ident_failure, /* :: */[
                                  type_string,
                                  /* [] */0
                                ]), Curry._1(add_extension$1(ident_not_found, /* [] */0), Curry._1(add_extension$1(ident_sys_blocked_io, /* [] */0), Curry._1(add_extension$1(ident_sys_error, /* :: */[
                                              type_string,
                                              /* [] */0
                                            ]), Curry._1(add_extension$1(ident_end_of_file, /* [] */0), Curry._1(add_extension$1(ident_division_by_zero, /* [] */0), Curry._1(add_extension$1(ident_assert_failure, /* :: */[
                                                          newty2(100000000, /* Ttuple */Block.__(2, [/* :: */[
                                                                    type_string,
                                                                    /* :: */[
                                                                      type_int,
                                                                      /* :: */[
                                                                        type_int,
                                                                        /* [] */0
                                                                      ]
                                                                    ]
                                                                  ]])),
                                                          /* [] */0
                                                        ]), Curry._1(add_extension$1(ident_undefined_recursive_module, /* :: */[
                                                              newty2(100000000, /* Ttuple */Block.__(2, [/* :: */[
                                                                        type_string,
                                                                        /* :: */[
                                                                          type_int,
                                                                          /* :: */[
                                                                            type_int,
                                                                            /* [] */0
                                                                          ]
                                                                        ]
                                                                      ]])),
                                                              /* [] */0
                                                            ]), Curry._3(add_type, ident_int64, decl_abstr, Curry._3(add_type, ident_int32, decl_abstr, Curry._3(add_type, ident_nativeint, decl_abstr, Curry._3(add_type, ident_lazy_t, decl_lazy_t, Curry._3(add_type, ident_option, decl_option, Curry._3(add_type, ident_list, decl_list, Curry._3(add_type, ident_array, decl_array, Curry._3(add_type, ident_exn, newrecord$2, Curry._3(add_type, ident_unit, newrecord$1, Curry._3(add_type, ident_bool, newrecord, Curry._3(add_type, ident_float, decl_abstr, Curry._3(add_type, ident_string, decl_abstr, Curry._3(add_type, ident_char, decl_abstr, Curry._3(add_type, ident_int, decl_abstr, empty_env))))))))))))))))))))))))));
}

function build_initial_env(add_type, add_exception, empty_env) {
  var common = common_initial_env(add_type, add_exception, empty_env);
  var safe_string = Curry._3(add_type, ident_bytes, decl_abstr, common);
  var newrecord = decl_abstr.slice();
  newrecord[/* type_manifest */4] = /* Some */[type_string];
  var unsafe_string = Curry._3(add_type, ident_bytes, newrecord, common);
  return /* tuple */[
          safe_string,
          unsafe_string
        ];
}

List.map((function (id) {
        make_global(id);
        return /* tuple */[
                id[/* name */1],
                id
              ];
      }), /* :: */[
      ident_match_failure,
      /* :: */[
        ident_out_of_memory,
        /* :: */[
          ident_stack_overflow,
          /* :: */[
            ident_invalid_argument,
            /* :: */[
              ident_failure,
              /* :: */[
                ident_not_found,
                /* :: */[
                  ident_sys_error,
                  /* :: */[
                    ident_end_of_file,
                    /* :: */[
                      ident_division_by_zero,
                      /* :: */[
                        ident_sys_blocked_io,
                        /* :: */[
                          ident_assert_failure,
                          /* :: */[
                            ident_undefined_recursive_module,
                            /* [] */0
                          ]
                        ]
                      ]
                    ]
                  ]
                ]
              ]
            ]
          ]
        ]
      ]
    ]);

set_current_time(999);

List.rev(builtin_idents[0]);

var docstrings = [/* [] */0];

function warn_bad_docstrings() {
  if (is_active(/* Bad_docstring */Block.__(33, [/* true */1]))) {
    return List.iter((function (ds) {
                  var match = ds[/* ds_attached */2];
                  switch (match) {
                    case 0 : 
                        return prerr_warning(ds[/* ds_loc */1], /* Bad_docstring */Block.__(33, [/* true */1]));
                    case 1 : 
                        return /* () */0;
                    case 2 : 
                        var match$1 = ds[/* ds_associated */3];
                        if (match$1 >= 2) {
                          return prerr_warning(ds[/* ds_loc */1], /* Bad_docstring */Block.__(33, [/* false */0]));
                        } else {
                          return /* () */0;
                        }
                    
                  }
                }), List.rev(docstrings[0]));
  } else {
    return 0;
  }
}

function docstring(body, loc) {
  var ds = /* record */[
    /* ds_body */body,
    /* ds_loc */loc,
    /* ds_attached : Unattached */0,
    /* ds_associated : Zero */0
  ];
  docstrings[0] = /* :: */[
    ds,
    docstrings[0]
  ];
  return ds;
}

var empty_docs = /* record */[
  /* docs_pre : None */0,
  /* docs_post : None */0
];

var doc_loc = /* record */[
  /* txt */"ocaml.doc",
  /* loc */none
];

function docs_attr(ds) {
  var exp_000 = /* pexp_desc : Pexp_constant */Block.__(1, [/* Const_string */Block.__(2, [
          ds[/* ds_body */0],
          /* None */0
        ])]);
  var exp_001 = /* pexp_loc */ds[/* ds_loc */1];
  var exp = /* record */[
    exp_000,
    exp_001,
    /* pexp_attributes : [] */0
  ];
  var item_000 = /* pstr_desc : Pstr_eval */Block.__(0, [
      exp,
      /* [] */0
    ]);
  var item_001 = exp_001;
  var item = /* record */[
    item_000,
    item_001
  ];
  return /* tuple */[
          doc_loc,
          /* PStr */Block.__(0, [/* :: */[
                item,
                /* [] */0
              ]])
        ];
}

function add_docs_attrs(docs, attrs) {
  var match = docs[/* docs_pre */0];
  var attrs$1 = match ? /* :: */[
      docs_attr(match[0]),
      attrs
    ] : attrs;
  var match$1 = docs[/* docs_post */1];
  if (match$1) {
    return Pervasives.$at(attrs$1, /* :: */[
                docs_attr(match$1[0]),
                /* [] */0
              ]);
  } else {
    return attrs$1;
  }
}

function add_info_attrs(info, attrs) {
  if (info) {
    return Pervasives.$at(attrs, /* :: */[
                docs_attr(info[0]),
                /* [] */0
              ]);
  } else {
    return attrs;
  }
}

var text_loc = /* record */[
  /* txt */"ocaml.text",
  /* loc */none
];

function text_attr(ds) {
  var exp_000 = /* pexp_desc : Pexp_constant */Block.__(1, [/* Const_string */Block.__(2, [
          ds[/* ds_body */0],
          /* None */0
        ])]);
  var exp_001 = /* pexp_loc */ds[/* ds_loc */1];
  var exp = /* record */[
    exp_000,
    exp_001,
    /* pexp_attributes : [] */0
  ];
  var item_000 = /* pstr_desc : Pstr_eval */Block.__(0, [
      exp,
      /* [] */0
    ]);
  var item_001 = exp_001;
  var item = /* record */[
    item_000,
    item_001
  ];
  return /* tuple */[
          text_loc,
          /* PStr */Block.__(0, [/* :: */[
                item,
                /* [] */0
              ]])
        ];
}

function add_text_attrs(dsl, attrs) {
  return Pervasives.$at(List.map(text_attr, dsl), attrs);
}

function get_docstring(info, dsl) {
  var _param = dsl;
  while(true) {
    var param = _param;
    if (param) {
      var ds = param[0];
      var match = ds[/* ds_attached */2];
      if (match !== 1) {
        ds[/* ds_attached */2] = info ? /* Info */1 : /* Docs */2;
        return /* Some */[ds];
      } else {
        _param = param[1];
        continue ;
        
      }
    } else {
      return /* None */0;
    }
  };
}

function get_docstrings(dsl) {
  var _acc = /* [] */0;
  var _param = dsl;
  while(true) {
    var param = _param;
    var acc = _acc;
    if (param) {
      var ds = param[0];
      var match = ds[/* ds_attached */2];
      if (match !== 1) {
        ds[/* ds_attached */2] = /* Docs */2;
        _param = param[1];
        _acc = /* :: */[
          ds,
          acc
        ];
        continue ;
        
      } else {
        _param = param[1];
        continue ;
        
      }
    } else {
      return List.rev(acc);
    }
  };
}

function associate_docstrings(dsl) {
  return List.iter((function (ds) {
                var match = ds[/* ds_associated */3];
                if (match !== 0) {
                  ds[/* ds_associated */3] = /* Many */2;
                  return /* () */0;
                } else {
                  ds[/* ds_associated */3] = /* One */1;
                  return /* () */0;
                }
              }), dsl);
}

var pre_table = Hashtbl.create(/* None */0, 50);

function set_pre_docstrings(pos, dsl) {
  if (dsl !== /* [] */0) {
    return Hashtbl.add(pre_table, pos, dsl);
  } else {
    return 0;
  }
}

function get_pre_docs(pos) {
  try {
    var dsl = Hashtbl.find(pre_table, pos);
    associate_docstrings(dsl);
    return get_docstring(/* false */0, dsl);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return /* None */0;
    } else {
      throw exn;
    }
  }
}

function mark_pre_docs(pos) {
  try {
    return associate_docstrings(Hashtbl.find(pre_table, pos));
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return /* () */0;
    } else {
      throw exn;
    }
  }
}

var post_table = Hashtbl.create(/* None */0, 50);

function set_post_docstrings(pos, dsl) {
  if (dsl !== /* [] */0) {
    return Hashtbl.add(post_table, pos, dsl);
  } else {
    return 0;
  }
}

function get_post_docs(pos) {
  try {
    var dsl = Hashtbl.find(post_table, pos);
    associate_docstrings(dsl);
    return get_docstring(/* false */0, dsl);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return /* None */0;
    } else {
      throw exn;
    }
  }
}

function mark_post_docs(pos) {
  try {
    return associate_docstrings(Hashtbl.find(post_table, pos));
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return /* () */0;
    } else {
      throw exn;
    }
  }
}

function get_info(pos) {
  try {
    var dsl = Hashtbl.find(post_table, pos);
    return get_docstring(/* true */1, dsl);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return /* None */0;
    } else {
      throw exn;
    }
  }
}

var floating_table = Hashtbl.create(/* None */0, 50);

function set_floating_docstrings(pos, dsl) {
  if (dsl !== /* [] */0) {
    return Hashtbl.add(floating_table, pos, dsl);
  } else {
    return 0;
  }
}

function get_text(pos) {
  try {
    return get_docstrings(Hashtbl.find(floating_table, pos));
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return /* [] */0;
    } else {
      throw exn;
    }
  }
}

var pre_extra_table = Hashtbl.create(/* None */0, 50);

function set_pre_extra_docstrings(pos, dsl) {
  if (dsl !== /* [] */0) {
    return Hashtbl.add(pre_extra_table, pos, dsl);
  } else {
    return 0;
  }
}

function get_pre_extra_text(pos) {
  try {
    return get_docstrings(Hashtbl.find(pre_extra_table, pos));
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return /* [] */0;
    } else {
      throw exn;
    }
  }
}

var post_extra_table = Hashtbl.create(/* None */0, 50);

function set_post_extra_docstrings(pos, dsl) {
  if (dsl !== /* [] */0) {
    return Hashtbl.add(post_extra_table, pos, dsl);
  } else {
    return 0;
  }
}

function get_post_extra_text(pos) {
  try {
    return get_docstrings(Hashtbl.find(post_extra_table, pos));
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return /* [] */0;
    } else {
      throw exn;
    }
  }
}

function symbol_docs() {
  return /* record */[
          /* docs_pre */get_pre_docs(Parsing.symbol_start_pos(/* () */0)),
          /* docs_post */get_post_docs(Parsing.symbol_end_pos(/* () */0))
        ];
}

function symbol_docs_lazy() {
  var p1 = Parsing.symbol_start_pos(/* () */0);
  var p2 = Parsing.symbol_end_pos(/* () */0);
  return Block.__(246, [(function () {
                return /* record */[
                        /* docs_pre */get_pre_docs(p1),
                        /* docs_post */get_post_docs(p2)
                      ];
              })]);
}

function mark_symbol_docs() {
  mark_pre_docs(Parsing.symbol_start_pos(/* () */0));
  return mark_post_docs(Parsing.symbol_end_pos(/* () */0));
}

function mark_rhs_docs(pos1, pos2) {
  mark_pre_docs(Parsing.rhs_start_pos(pos1));
  return mark_post_docs(Parsing.rhs_end_pos(pos2));
}

function symbol_text_lazy() {
  var pos = Parsing.symbol_start_pos(/* () */0);
  return Block.__(246, [(function () {
                return get_text(pos);
              })]);
}

function init() {
  docstrings[0] = /* [] */0;
  Hashtbl.reset(pre_table);
  Hashtbl.reset(post_table);
  Hashtbl.reset(floating_table);
  Hashtbl.reset(pre_extra_table);
  return Hashtbl.reset(post_extra_table);
}

var default_loc = [none];

function mk($staropt$star, $staropt$star$1, d) {
  var loc = $staropt$star ? $staropt$star[0] : default_loc[0];
  var attrs = $staropt$star$1 ? $staropt$star$1[0] : /* [] */0;
  return /* record */[
          /* ptyp_desc */d,
          /* ptyp_loc */loc,
          /* ptyp_attributes */attrs
        ];
}

function attr(d, a) {
  return /* record */[
          /* ptyp_desc */d[/* ptyp_desc */0],
          /* ptyp_loc */d[/* ptyp_loc */1],
          /* ptyp_attributes */Pervasives.$at(d[/* ptyp_attributes */2], /* :: */[
                a,
                /* [] */0
              ])
        ];
}

function $$var(loc, attrs, a) {
  return mk(loc, attrs, /* Ptyp_var */Block.__(0, [a]));
}

function arrow(loc, attrs, a, b, c) {
  return mk(loc, attrs, /* Ptyp_arrow */Block.__(1, [
                a,
                b,
                c
              ]));
}

function tuple(loc, attrs, a) {
  return mk(loc, attrs, /* Ptyp_tuple */Block.__(2, [a]));
}

function constr(loc, attrs, a, b) {
  return mk(loc, attrs, /* Ptyp_constr */Block.__(3, [
                a,
                b
              ]));
}

function object_(loc, attrs, a, b) {
  return mk(loc, attrs, /* Ptyp_object */Block.__(4, [
                a,
                b
              ]));
}

function class_(loc, attrs, a, b) {
  return mk(loc, attrs, /* Ptyp_class */Block.__(5, [
                a,
                b
              ]));
}

function alias(loc, attrs, a, b) {
  return mk(loc, attrs, /* Ptyp_alias */Block.__(6, [
                a,
                b
              ]));
}

function variant(loc, attrs, a, b, c) {
  return mk(loc, attrs, /* Ptyp_variant */Block.__(7, [
                a,
                b,
                c
              ]));
}

function poly(loc, attrs, a, b) {
  return mk(loc, attrs, /* Ptyp_poly */Block.__(8, [
                a,
                b
              ]));
}

function $$package(loc, attrs, a, b) {
  return mk(loc, attrs, /* Ptyp_package */Block.__(9, [/* tuple */[
                  a,
                  b
                ]]));
}

function extension(loc, attrs, a) {
  return mk(loc, attrs, /* Ptyp_extension */Block.__(10, [a]));
}

function force_poly(t) {
  var match = t[/* ptyp_desc */0];
  var exit = 0;
  if (typeof match === "number") {
    exit = 1;
  } else if (match.tag === 8) {
    return t;
  } else {
    exit = 1;
  }
  if (exit === 1) {
    return poly(/* Some */[t[/* ptyp_loc */1]], /* None */0, /* [] */0, t);
  }
  
}

function mk$1($staropt$star, $staropt$star$1, d) {
  var loc = $staropt$star ? $staropt$star[0] : default_loc[0];
  var attrs = $staropt$star$1 ? $staropt$star$1[0] : /* [] */0;
  return /* record */[
          /* ppat_desc */d,
          /* ppat_loc */loc,
          /* ppat_attributes */attrs
        ];
}

function attr$1(d, a) {
  return /* record */[
          /* ppat_desc */d[/* ppat_desc */0],
          /* ppat_loc */d[/* ppat_loc */1],
          /* ppat_attributes */Pervasives.$at(d[/* ppat_attributes */2], /* :: */[
                a,
                /* [] */0
              ])
        ];
}

function $$var$1(loc, attrs, a) {
  return mk$1(loc, attrs, /* Ppat_var */Block.__(0, [a]));
}

function alias$1(loc, attrs, a, b) {
  return mk$1(loc, attrs, /* Ppat_alias */Block.__(1, [
                a,
                b
              ]));
}

function constant(loc, attrs, a) {
  return mk$1(loc, attrs, /* Ppat_constant */Block.__(2, [a]));
}

function interval(loc, attrs, a, b) {
  return mk$1(loc, attrs, /* Ppat_interval */Block.__(3, [
                a,
                b
              ]));
}

function tuple$1(loc, attrs, a) {
  return mk$1(loc, attrs, /* Ppat_tuple */Block.__(4, [a]));
}

function construct(loc, attrs, a, b) {
  return mk$1(loc, attrs, /* Ppat_construct */Block.__(5, [
                a,
                b
              ]));
}

function variant$1(loc, attrs, a, b) {
  return mk$1(loc, attrs, /* Ppat_variant */Block.__(6, [
                a,
                b
              ]));
}

function record(loc, attrs, a, b) {
  return mk$1(loc, attrs, /* Ppat_record */Block.__(7, [
                a,
                b
              ]));
}

function array(loc, attrs, a) {
  return mk$1(loc, attrs, /* Ppat_array */Block.__(8, [a]));
}

function or_(loc, attrs, a, b) {
  return mk$1(loc, attrs, /* Ppat_or */Block.__(9, [
                a,
                b
              ]));
}

function constraint_(loc, attrs, a, b) {
  return mk$1(loc, attrs, /* Ppat_constraint */Block.__(10, [
                a,
                b
              ]));
}

function type_(loc, attrs, a) {
  return mk$1(loc, attrs, /* Ppat_type */Block.__(11, [a]));
}

function lazy_(loc, attrs, a) {
  return mk$1(loc, attrs, /* Ppat_lazy */Block.__(12, [a]));
}

function unpack(loc, attrs, a) {
  return mk$1(loc, attrs, /* Ppat_unpack */Block.__(13, [a]));
}

function exception_(loc, attrs, a) {
  return mk$1(loc, attrs, /* Ppat_exception */Block.__(14, [a]));
}

function extension$1(loc, attrs, a) {
  return mk$1(loc, attrs, /* Ppat_extension */Block.__(15, [a]));
}

function mk$2($staropt$star, $staropt$star$1, d) {
  var loc = $staropt$star ? $staropt$star[0] : default_loc[0];
  var attrs = $staropt$star$1 ? $staropt$star$1[0] : /* [] */0;
  return /* record */[
          /* pexp_desc */d,
          /* pexp_loc */loc,
          /* pexp_attributes */attrs
        ];
}

function attr$2(d, a) {
  return /* record */[
          /* pexp_desc */d[/* pexp_desc */0],
          /* pexp_loc */d[/* pexp_loc */1],
          /* pexp_attributes */Pervasives.$at(d[/* pexp_attributes */2], /* :: */[
                a,
                /* [] */0
              ])
        ];
}

function ident(loc, attrs, a) {
  return mk$2(loc, attrs, /* Pexp_ident */Block.__(0, [a]));
}

function constant$1(loc, attrs, a) {
  return mk$2(loc, attrs, /* Pexp_constant */Block.__(1, [a]));
}

function let_(loc, attrs, a, b, c) {
  return mk$2(loc, attrs, /* Pexp_let */Block.__(2, [
                a,
                b,
                c
              ]));
}

function fun_(loc, attrs, a, b, c, d) {
  return mk$2(loc, attrs, /* Pexp_fun */Block.__(4, [
                a,
                b,
                c,
                d
              ]));
}

function function_(loc, attrs, a) {
  return mk$2(loc, attrs, /* Pexp_function */Block.__(3, [a]));
}

function apply(loc, attrs, a, b) {
  return mk$2(loc, attrs, /* Pexp_apply */Block.__(5, [
                a,
                b
              ]));
}

function match_(loc, attrs, a, b) {
  return mk$2(loc, attrs, /* Pexp_match */Block.__(6, [
                a,
                b
              ]));
}

function try_(loc, attrs, a, b) {
  return mk$2(loc, attrs, /* Pexp_try */Block.__(7, [
                a,
                b
              ]));
}

function tuple$2(loc, attrs, a) {
  return mk$2(loc, attrs, /* Pexp_tuple */Block.__(8, [a]));
}

function construct$1(loc, attrs, a, b) {
  return mk$2(loc, attrs, /* Pexp_construct */Block.__(9, [
                a,
                b
              ]));
}

function variant$2(loc, attrs, a, b) {
  return mk$2(loc, attrs, /* Pexp_variant */Block.__(10, [
                a,
                b
              ]));
}

function record$1(loc, attrs, a, b) {
  return mk$2(loc, attrs, /* Pexp_record */Block.__(11, [
                a,
                b
              ]));
}

function field(loc, attrs, a, b) {
  return mk$2(loc, attrs, /* Pexp_field */Block.__(12, [
                a,
                b
              ]));
}

function setfield(loc, attrs, a, b, c) {
  return mk$2(loc, attrs, /* Pexp_setfield */Block.__(13, [
                a,
                b,
                c
              ]));
}

function array$1(loc, attrs, a) {
  return mk$2(loc, attrs, /* Pexp_array */Block.__(14, [a]));
}

function ifthenelse(loc, attrs, a, b, c) {
  return mk$2(loc, attrs, /* Pexp_ifthenelse */Block.__(15, [
                a,
                b,
                c
              ]));
}

function sequence(loc, attrs, a, b) {
  return mk$2(loc, attrs, /* Pexp_sequence */Block.__(16, [
                a,
                b
              ]));
}

function while_(loc, attrs, a, b) {
  return mk$2(loc, attrs, /* Pexp_while */Block.__(17, [
                a,
                b
              ]));
}

function for_(loc, attrs, a, b, c, d, e) {
  return mk$2(loc, attrs, /* Pexp_for */Block.__(18, [
                a,
                b,
                c,
                d,
                e
              ]));
}

function constraint_$1(loc, attrs, a, b) {
  return mk$2(loc, attrs, /* Pexp_constraint */Block.__(19, [
                a,
                b
              ]));
}

function coerce(loc, attrs, a, b, c) {
  return mk$2(loc, attrs, /* Pexp_coerce */Block.__(20, [
                a,
                b,
                c
              ]));
}

function send(loc, attrs, a, b) {
  return mk$2(loc, attrs, /* Pexp_send */Block.__(21, [
                a,
                b
              ]));
}

function new_(loc, attrs, a) {
  return mk$2(loc, attrs, /* Pexp_new */Block.__(22, [a]));
}

function setinstvar(loc, attrs, a, b) {
  return mk$2(loc, attrs, /* Pexp_setinstvar */Block.__(23, [
                a,
                b
              ]));
}

function override(loc, attrs, a) {
  return mk$2(loc, attrs, /* Pexp_override */Block.__(24, [a]));
}

function letmodule(loc, attrs, a, b, c) {
  return mk$2(loc, attrs, /* Pexp_letmodule */Block.__(25, [
                a,
                b,
                c
              ]));
}

function assert_(loc, attrs, a) {
  return mk$2(loc, attrs, /* Pexp_assert */Block.__(26, [a]));
}

function lazy_$1(loc, attrs, a) {
  return mk$2(loc, attrs, /* Pexp_lazy */Block.__(27, [a]));
}

function poly$1(loc, attrs, a, b) {
  return mk$2(loc, attrs, /* Pexp_poly */Block.__(28, [
                a,
                b
              ]));
}

function object_$1(loc, attrs, a) {
  return mk$2(loc, attrs, /* Pexp_object */Block.__(29, [a]));
}

function newtype(loc, attrs, a, b) {
  return mk$2(loc, attrs, /* Pexp_newtype */Block.__(30, [
                a,
                b
              ]));
}

function pack(loc, attrs, a) {
  return mk$2(loc, attrs, /* Pexp_pack */Block.__(31, [a]));
}

function open_(loc, attrs, a, b, c) {
  return mk$2(loc, attrs, /* Pexp_open */Block.__(32, [
                a,
                b,
                c
              ]));
}

function extension$2(loc, attrs, a) {
  return mk$2(loc, attrs, /* Pexp_extension */Block.__(33, [a]));
}

function $$case(lhs, guard, rhs) {
  return /* record */[
          /* pc_lhs */lhs,
          /* pc_guard */guard,
          /* pc_rhs */rhs
        ];
}

function mk$3($staropt$star, $staropt$star$1, d) {
  var loc = $staropt$star ? $staropt$star[0] : default_loc[0];
  var attrs = $staropt$star$1 ? $staropt$star$1[0] : /* [] */0;
  return /* record */[
          /* pmty_desc */d,
          /* pmty_loc */loc,
          /* pmty_attributes */attrs
        ];
}

function attr$3(d, a) {
  return /* record */[
          /* pmty_desc */d[/* pmty_desc */0],
          /* pmty_loc */d[/* pmty_loc */1],
          /* pmty_attributes */Pervasives.$at(d[/* pmty_attributes */2], /* :: */[
                a,
                /* [] */0
              ])
        ];
}

function ident$1(loc, attrs, a) {
  return mk$3(loc, attrs, /* Pmty_ident */Block.__(0, [a]));
}

function alias$2(loc, attrs, a) {
  return mk$3(loc, attrs, /* Pmty_alias */Block.__(6, [a]));
}

function signature(loc, attrs, a) {
  return mk$3(loc, attrs, /* Pmty_signature */Block.__(1, [a]));
}

function functor_(loc, attrs, a, b, c) {
  return mk$3(loc, attrs, /* Pmty_functor */Block.__(2, [
                a,
                b,
                c
              ]));
}

function with_(loc, attrs, a, b) {
  return mk$3(loc, attrs, /* Pmty_with */Block.__(3, [
                a,
                b
              ]));
}

function typeof_(loc, attrs, a) {
  return mk$3(loc, attrs, /* Pmty_typeof */Block.__(4, [a]));
}

function extension$3(loc, attrs, a) {
  return mk$3(loc, attrs, /* Pmty_extension */Block.__(5, [a]));
}

function mk$4($staropt$star, $staropt$star$1, d) {
  var loc = $staropt$star ? $staropt$star[0] : default_loc[0];
  var attrs = $staropt$star$1 ? $staropt$star$1[0] : /* [] */0;
  return /* record */[
          /* pmod_desc */d,
          /* pmod_loc */loc,
          /* pmod_attributes */attrs
        ];
}

function attr$4(d, a) {
  return /* record */[
          /* pmod_desc */d[/* pmod_desc */0],
          /* pmod_loc */d[/* pmod_loc */1],
          /* pmod_attributes */Pervasives.$at(d[/* pmod_attributes */2], /* :: */[
                a,
                /* [] */0
              ])
        ];
}

function ident$2(loc, attrs, x) {
  return mk$4(loc, attrs, /* Pmod_ident */Block.__(0, [x]));
}

function structure(loc, attrs, x) {
  return mk$4(loc, attrs, /* Pmod_structure */Block.__(1, [x]));
}

function functor_$1(loc, attrs, arg, arg_ty, body) {
  return mk$4(loc, attrs, /* Pmod_functor */Block.__(2, [
                arg,
                arg_ty,
                body
              ]));
}

function apply$1(loc, attrs, m1, m2) {
  return mk$4(loc, attrs, /* Pmod_apply */Block.__(3, [
                m1,
                m2
              ]));
}

function constraint_$2(loc, attrs, m, mty) {
  return mk$4(loc, attrs, /* Pmod_constraint */Block.__(4, [
                m,
                mty
              ]));
}

function unpack$1(loc, attrs, e) {
  return mk$4(loc, attrs, /* Pmod_unpack */Block.__(5, [e]));
}

function extension$4(loc, attrs, a) {
  return mk$4(loc, attrs, /* Pmod_extension */Block.__(6, [a]));
}

function mk$5($staropt$star, d) {
  var loc = $staropt$star ? $staropt$star[0] : default_loc[0];
  return /* record */[
          /* psig_desc */d,
          /* psig_loc */loc
        ];
}

function extension$5(loc, $staropt$star, a) {
  var attrs = $staropt$star ? $staropt$star[0] : /* [] */0;
  return mk$5(loc, /* Psig_extension */Block.__(12, [
                a,
                attrs
              ]));
}

function text(txt) {
  return List.map((function (ds) {
                var a = text_attr(ds);
                var loc = /* Some */[ds[/* ds_loc */1]];
                return mk$5(loc, /* Psig_attribute */Block.__(11, [a]));
              }), txt);
}

function mk$6($staropt$star, d) {
  var loc = $staropt$star ? $staropt$star[0] : default_loc[0];
  return /* record */[
          /* pstr_desc */d,
          /* pstr_loc */loc
        ];
}

function $$eval(loc, $staropt$star, a) {
  var attrs = $staropt$star ? $staropt$star[0] : /* [] */0;
  return mk$6(loc, /* Pstr_eval */Block.__(0, [
                a,
                attrs
              ]));
}

function value(loc, a, b) {
  return mk$6(loc, /* Pstr_value */Block.__(1, [
                a,
                b
              ]));
}

function extension$6(loc, $staropt$star, a) {
  var attrs = $staropt$star ? $staropt$star[0] : /* [] */0;
  return mk$6(loc, /* Pstr_extension */Block.__(14, [
                a,
                attrs
              ]));
}

function text$1(txt) {
  return List.map((function (ds) {
                var a = text_attr(ds);
                var loc = /* Some */[ds[/* ds_loc */1]];
                return mk$6(loc, /* Pstr_attribute */Block.__(13, [a]));
              }), txt);
}

function mk$7($staropt$star, $staropt$star$1, d) {
  var loc = $staropt$star ? $staropt$star[0] : default_loc[0];
  var attrs = $staropt$star$1 ? $staropt$star$1[0] : /* [] */0;
  return /* record */[
          /* pcl_desc */d,
          /* pcl_loc */loc,
          /* pcl_attributes */attrs
        ];
}

function attr$5(d, a) {
  return /* record */[
          /* pcl_desc */d[/* pcl_desc */0],
          /* pcl_loc */d[/* pcl_loc */1],
          /* pcl_attributes */Pervasives.$at(d[/* pcl_attributes */2], /* :: */[
                a,
                /* [] */0
              ])
        ];
}

function constr$1(loc, attrs, a, b) {
  return mk$7(loc, attrs, /* Pcl_constr */Block.__(0, [
                a,
                b
              ]));
}

function structure$1(loc, attrs, a) {
  return mk$7(loc, attrs, /* Pcl_structure */Block.__(1, [a]));
}

function fun_$1(loc, attrs, a, b, c, d) {
  return mk$7(loc, attrs, /* Pcl_fun */Block.__(2, [
                a,
                b,
                c,
                d
              ]));
}

function apply$2(loc, attrs, a, b) {
  return mk$7(loc, attrs, /* Pcl_apply */Block.__(3, [
                a,
                b
              ]));
}

function let_$1(loc, attrs, a, b, c) {
  return mk$7(loc, attrs, /* Pcl_let */Block.__(4, [
                a,
                b,
                c
              ]));
}

function constraint_$3(loc, attrs, a, b) {
  return mk$7(loc, attrs, /* Pcl_constraint */Block.__(5, [
                a,
                b
              ]));
}

function extension$7(loc, attrs, a) {
  return mk$7(loc, attrs, /* Pcl_extension */Block.__(6, [a]));
}

function mk$8($staropt$star, $staropt$star$1, d) {
  var loc = $staropt$star ? $staropt$star[0] : default_loc[0];
  var attrs = $staropt$star$1 ? $staropt$star$1[0] : /* [] */0;
  return /* record */[
          /* pcty_desc */d,
          /* pcty_loc */loc,
          /* pcty_attributes */attrs
        ];
}

function attr$6(d, a) {
  return /* record */[
          /* pcty_desc */d[/* pcty_desc */0],
          /* pcty_loc */d[/* pcty_loc */1],
          /* pcty_attributes */Pervasives.$at(d[/* pcty_attributes */2], /* :: */[
                a,
                /* [] */0
              ])
        ];
}

function constr$2(loc, attrs, a, b) {
  return mk$8(loc, attrs, /* Pcty_constr */Block.__(0, [
                a,
                b
              ]));
}

function signature$1(loc, attrs, a) {
  return mk$8(loc, attrs, /* Pcty_signature */Block.__(1, [a]));
}

function arrow$1(loc, attrs, a, b, c) {
  return mk$8(loc, attrs, /* Pcty_arrow */Block.__(2, [
                a,
                b,
                c
              ]));
}

function extension$8(loc, attrs, a) {
  return mk$8(loc, attrs, /* Pcty_extension */Block.__(3, [a]));
}

function mk$9($staropt$star, $staropt$star$1, $staropt$star$2, d) {
  var loc = $staropt$star ? $staropt$star[0] : default_loc[0];
  var attrs = $staropt$star$1 ? $staropt$star$1[0] : /* [] */0;
  var docs = $staropt$star$2 ? $staropt$star$2[0] : empty_docs;
  return /* record */[
          /* pctf_desc */d,
          /* pctf_loc */loc,
          /* pctf_attributes */add_docs_attrs(docs, attrs)
        ];
}

function inherit_(loc, attrs, a) {
  return mk$9(loc, attrs, /* None */0, /* Pctf_inherit */Block.__(0, [a]));
}

function val_(loc, attrs, a, b, c, d) {
  return mk$9(loc, attrs, /* None */0, /* Pctf_val */Block.__(1, [/* tuple */[
                  a,
                  b,
                  c,
                  d
                ]]));
}

function method_(loc, attrs, a, b, c, d) {
  return mk$9(loc, attrs, /* None */0, /* Pctf_method */Block.__(2, [/* tuple */[
                  a,
                  b,
                  c,
                  d
                ]]));
}

function constraint_$4(loc, attrs, a, b) {
  return mk$9(loc, attrs, /* None */0, /* Pctf_constraint */Block.__(3, [/* tuple */[
                  a,
                  b
                ]]));
}

function extension$9(loc, attrs, a) {
  return mk$9(loc, attrs, /* None */0, /* Pctf_extension */Block.__(5, [a]));
}

function attribute(loc, a) {
  return mk$9(loc, /* None */0, /* None */0, /* Pctf_attribute */Block.__(4, [a]));
}

function text$2(txt) {
  return List.map((function (ds) {
                return attribute(/* Some */[ds[/* ds_loc */1]], text_attr(ds));
              }), txt);
}

function attr$7(d, a) {
  return /* record */[
          /* pctf_desc */d[/* pctf_desc */0],
          /* pctf_loc */d[/* pctf_loc */1],
          /* pctf_attributes */Pervasives.$at(d[/* pctf_attributes */2], /* :: */[
                a,
                /* [] */0
              ])
        ];
}

function mk$10($staropt$star, $staropt$star$1, $staropt$star$2, d) {
  var loc = $staropt$star ? $staropt$star[0] : default_loc[0];
  var attrs = $staropt$star$1 ? $staropt$star$1[0] : /* [] */0;
  var docs = $staropt$star$2 ? $staropt$star$2[0] : empty_docs;
  return /* record */[
          /* pcf_desc */d,
          /* pcf_loc */loc,
          /* pcf_attributes */add_docs_attrs(docs, attrs)
        ];
}

function inherit_$1(loc, attrs, a, b, c) {
  return mk$10(loc, attrs, /* None */0, /* Pcf_inherit */Block.__(0, [
                a,
                b,
                c
              ]));
}

function val_$1(loc, attrs, a, b, c) {
  return mk$10(loc, attrs, /* None */0, /* Pcf_val */Block.__(1, [/* tuple */[
                  a,
                  b,
                  c
                ]]));
}

function method_$1(loc, attrs, a, b, c) {
  return mk$10(loc, attrs, /* None */0, /* Pcf_method */Block.__(2, [/* tuple */[
                  a,
                  b,
                  c
                ]]));
}

function constraint_$5(loc, attrs, a, b) {
  return mk$10(loc, attrs, /* None */0, /* Pcf_constraint */Block.__(3, [/* tuple */[
                  a,
                  b
                ]]));
}

function initializer_(loc, attrs, a) {
  return mk$10(loc, attrs, /* None */0, /* Pcf_initializer */Block.__(4, [a]));
}

function extension$10(loc, attrs, a) {
  return mk$10(loc, attrs, /* None */0, /* Pcf_extension */Block.__(6, [a]));
}

function attribute$1(loc, a) {
  return mk$10(loc, /* None */0, /* None */0, /* Pcf_attribute */Block.__(5, [a]));
}

function text$3(txt) {
  return List.map((function (ds) {
                return attribute$1(/* Some */[ds[/* ds_loc */1]], text_attr(ds));
              }), txt);
}

function virtual_(ct) {
  return /* Cfk_virtual */Block.__(0, [ct]);
}

function concrete(o, e) {
  return /* Cfk_concrete */Block.__(1, [
            o,
            e
          ]);
}

function attr$8(d, a) {
  return /* record */[
          /* pcf_desc */d[/* pcf_desc */0],
          /* pcf_loc */d[/* pcf_loc */1],
          /* pcf_attributes */Pervasives.$at(d[/* pcf_attributes */2], /* :: */[
                a,
                /* [] */0
              ])
        ];
}

function mk$11($staropt$star, $staropt$star$1, $staropt$star$2, $staropt$star$3, name, typ) {
  var loc = $staropt$star ? $staropt$star[0] : default_loc[0];
  var attrs = $staropt$star$1 ? $staropt$star$1[0] : /* [] */0;
  var docs = $staropt$star$2 ? $staropt$star$2[0] : empty_docs;
  var prim = $staropt$star$3 ? $staropt$star$3[0] : /* [] */0;
  return /* record */[
          /* pval_name */name,
          /* pval_type */typ,
          /* pval_prim */prim,
          /* pval_attributes */add_docs_attrs(docs, attrs),
          /* pval_loc */loc
        ];
}

function mk$12($staropt$star, $staropt$star$1, $staropt$star$2, $staropt$star$3, name, typ) {
  var loc = $staropt$star ? $staropt$star[0] : default_loc[0];
  var attrs = $staropt$star$1 ? $staropt$star$1[0] : /* [] */0;
  var docs = $staropt$star$2 ? $staropt$star$2[0] : empty_docs;
  var text = $staropt$star$3 ? $staropt$star$3[0] : /* [] */0;
  return /* record */[
          /* pmd_name */name,
          /* pmd_type */typ,
          /* pmd_attributes */add_text_attrs(text, add_docs_attrs(docs, attrs)),
          /* pmd_loc */loc
        ];
}

function mk$13($staropt$star, $staropt$star$1, $staropt$star$2, $staropt$star$3, typ, name) {
  var loc = $staropt$star ? $staropt$star[0] : default_loc[0];
  var attrs = $staropt$star$1 ? $staropt$star$1[0] : /* [] */0;
  var docs = $staropt$star$2 ? $staropt$star$2[0] : empty_docs;
  var text = $staropt$star$3 ? $staropt$star$3[0] : /* [] */0;
  return /* record */[
          /* pmtd_name */name,
          /* pmtd_type */typ,
          /* pmtd_attributes */add_text_attrs(text, add_docs_attrs(docs, attrs)),
          /* pmtd_loc */loc
        ];
}

function mk$14($staropt$star, $staropt$star$1, $staropt$star$2, $staropt$star$3, name, expr) {
  var loc = $staropt$star ? $staropt$star[0] : default_loc[0];
  var attrs = $staropt$star$1 ? $staropt$star$1[0] : /* [] */0;
  var docs = $staropt$star$2 ? $staropt$star$2[0] : empty_docs;
  var text = $staropt$star$3 ? $staropt$star$3[0] : /* [] */0;
  return /* record */[
          /* pmb_name */name,
          /* pmb_expr */expr,
          /* pmb_attributes */add_text_attrs(text, add_docs_attrs(docs, attrs)),
          /* pmb_loc */loc
        ];
}

function mk$15($staropt$star, $staropt$star$1, $staropt$star$2, $staropt$star$3, lid) {
  var loc = $staropt$star ? $staropt$star[0] : default_loc[0];
  var attrs = $staropt$star$1 ? $staropt$star$1[0] : /* [] */0;
  var docs = $staropt$star$2 ? $staropt$star$2[0] : empty_docs;
  var override = $staropt$star$3 ? $staropt$star$3[0] : /* Fresh */1;
  return /* record */[
          /* popen_lid */lid,
          /* popen_override */override,
          /* popen_loc */loc,
          /* popen_attributes */add_docs_attrs(docs, attrs)
        ];
}

function mk$16($staropt$star, $staropt$star$1, $staropt$star$2, mexpr) {
  var loc = $staropt$star ? $staropt$star[0] : default_loc[0];
  var attrs = $staropt$star$1 ? $staropt$star$1[0] : /* [] */0;
  var docs = $staropt$star$2 ? $staropt$star$2[0] : empty_docs;
  return /* record */[
          /* pincl_mod */mexpr,
          /* pincl_loc */loc,
          /* pincl_attributes */add_docs_attrs(docs, attrs)
        ];
}

function mk$17($staropt$star, $staropt$star$1, $staropt$star$2, $staropt$star$3, pat, expr) {
  var loc = $staropt$star ? $staropt$star[0] : default_loc[0];
  var attrs = $staropt$star$1 ? $staropt$star$1[0] : /* [] */0;
  var docs = $staropt$star$2 ? $staropt$star$2[0] : empty_docs;
  var text = $staropt$star$3 ? $staropt$star$3[0] : /* [] */0;
  return /* record */[
          /* pvb_pat */pat,
          /* pvb_expr */expr,
          /* pvb_attributes */add_text_attrs(text, add_docs_attrs(docs, attrs)),
          /* pvb_loc */loc
        ];
}

function mk$18($staropt$star, $staropt$star$1, $staropt$star$2, $staropt$star$3, $staropt$star$4, $staropt$star$5, name, expr) {
  var loc = $staropt$star ? $staropt$star[0] : default_loc[0];
  var attrs = $staropt$star$1 ? $staropt$star$1[0] : /* [] */0;
  var docs = $staropt$star$2 ? $staropt$star$2[0] : empty_docs;
  var text = $staropt$star$3 ? $staropt$star$3[0] : /* [] */0;
  var virt = $staropt$star$4 ? $staropt$star$4[0] : /* Concrete */1;
  var params = $staropt$star$5 ? $staropt$star$5[0] : /* [] */0;
  return /* record */[
          /* pci_virt */virt,
          /* pci_params */params,
          /* pci_name */name,
          /* pci_expr */expr,
          /* pci_loc */loc,
          /* pci_attributes */add_text_attrs(text, add_docs_attrs(docs, attrs))
        ];
}

function mk$19($staropt$star, $staropt$star$1, $staropt$star$2, $staropt$star$3, $staropt$star$4, $staropt$star$5, $staropt$star$6, $staropt$star$7, manifest, name) {
  var loc = $staropt$star ? $staropt$star[0] : default_loc[0];
  var attrs = $staropt$star$1 ? $staropt$star$1[0] : /* [] */0;
  var docs = $staropt$star$2 ? $staropt$star$2[0] : empty_docs;
  var text = $staropt$star$3 ? $staropt$star$3[0] : /* [] */0;
  var params = $staropt$star$4 ? $staropt$star$4[0] : /* [] */0;
  var cstrs = $staropt$star$5 ? $staropt$star$5[0] : /* [] */0;
  var kind = $staropt$star$6 ? $staropt$star$6[0] : /* Ptype_abstract */0;
  var priv = $staropt$star$7 ? $staropt$star$7[0] : /* Public */1;
  return /* record */[
          /* ptype_name */name,
          /* ptype_params */params,
          /* ptype_cstrs */cstrs,
          /* ptype_kind */kind,
          /* ptype_private */priv,
          /* ptype_manifest */manifest,
          /* ptype_attributes */add_text_attrs(text, add_docs_attrs(docs, attrs)),
          /* ptype_loc */loc
        ];
}

function constructor($staropt$star, $staropt$star$1, $staropt$star$2, $staropt$star$3, res, name) {
  var loc = $staropt$star ? $staropt$star[0] : default_loc[0];
  var attrs = $staropt$star$1 ? $staropt$star$1[0] : /* [] */0;
  var info = $staropt$star$2 ? $staropt$star$2[0] : /* None */0;
  var args = $staropt$star$3 ? $staropt$star$3[0] : /* [] */0;
  return /* record */[
          /* pcd_name */name,
          /* pcd_args */args,
          /* pcd_res */res,
          /* pcd_loc */loc,
          /* pcd_attributes */add_info_attrs(info, attrs)
        ];
}

function field$1($staropt$star, $staropt$star$1, $staropt$star$2, $staropt$star$3, name, typ) {
  var loc = $staropt$star ? $staropt$star[0] : default_loc[0];
  var attrs = $staropt$star$1 ? $staropt$star$1[0] : /* [] */0;
  var info = $staropt$star$2 ? $staropt$star$2[0] : /* None */0;
  var mut = $staropt$star$3 ? $staropt$star$3[0] : /* Immutable */0;
  return /* record */[
          /* pld_name */name,
          /* pld_mutable */mut,
          /* pld_type */typ,
          /* pld_loc */loc,
          /* pld_attributes */add_info_attrs(info, attrs)
        ];
}

function mk$20($staropt$star, $staropt$star$1, $staropt$star$2, $staropt$star$3, path, constructors) {
  var attrs = $staropt$star ? $staropt$star[0] : /* [] */0;
  var docs = $staropt$star$1 ? $staropt$star$1[0] : empty_docs;
  var params = $staropt$star$2 ? $staropt$star$2[0] : /* [] */0;
  var priv = $staropt$star$3 ? $staropt$star$3[0] : /* Public */1;
  return /* record */[
          /* ptyext_path */path,
          /* ptyext_params */params,
          /* ptyext_constructors */constructors,
          /* ptyext_private */priv,
          /* ptyext_attributes */add_docs_attrs(docs, attrs)
        ];
}

function constructor$1($staropt$star, $staropt$star$1, $staropt$star$2, $staropt$star$3, name, kind) {
  var loc = $staropt$star ? $staropt$star[0] : default_loc[0];
  var attrs = $staropt$star$1 ? $staropt$star$1[0] : /* [] */0;
  var docs = $staropt$star$2 ? $staropt$star$2[0] : empty_docs;
  var info = $staropt$star$3 ? $staropt$star$3[0] : /* None */0;
  return /* record */[
          /* pext_name */name,
          /* pext_kind */kind,
          /* pext_loc */loc,
          /* pext_attributes */add_docs_attrs(docs, add_info_attrs(info, attrs))
        ];
}

function decl($staropt$star, $staropt$star$1, $staropt$star$2, $staropt$star$3, $staropt$star$4, res, name) {
  var loc = $staropt$star ? $staropt$star[0] : default_loc[0];
  var attrs = $staropt$star$1 ? $staropt$star$1[0] : /* [] */0;
  var docs = $staropt$star$2 ? $staropt$star$2[0] : empty_docs;
  var info = $staropt$star$3 ? $staropt$star$3[0] : /* None */0;
  var args = $staropt$star$4 ? $staropt$star$4[0] : /* [] */0;
  return /* record */[
          /* pext_name */name,
          /* pext_kind : Pext_decl */Block.__(0, [
              args,
              res
            ]),
          /* pext_loc */loc,
          /* pext_attributes */add_docs_attrs(docs, add_info_attrs(info, attrs))
        ];
}

function rebind($staropt$star, $staropt$star$1, $staropt$star$2, $staropt$star$3, name, lid) {
  var loc = $staropt$star ? $staropt$star[0] : default_loc[0];
  var attrs = $staropt$star$1 ? $staropt$star$1[0] : /* [] */0;
  var docs = $staropt$star$2 ? $staropt$star$2[0] : empty_docs;
  var info = $staropt$star$3 ? $staropt$star$3[0] : /* None */0;
  return /* record */[
          /* pext_name */name,
          /* pext_kind : Pext_rebind */Block.__(1, [lid]),
          /* pext_loc */loc,
          /* pext_attributes */add_docs_attrs(docs, add_info_attrs(info, attrs))
        ];
}

var Ast_helper_004 = /* Exp */[
  mk$2,
  attr$2,
  ident,
  constant$1,
  let_,
  fun_,
  function_,
  apply,
  match_,
  try_,
  tuple$2,
  construct$1,
  variant$2,
  record$1,
  field,
  setfield,
  array$1,
  ifthenelse,
  sequence,
  while_,
  for_,
  coerce,
  constraint_$1,
  send,
  new_,
  setinstvar,
  override,
  letmodule,
  assert_,
  lazy_$1,
  poly$1,
  object_$1,
  newtype,
  pack,
  open_,
  extension$2,
  $$case
];

var Ast_helper_019 = /* Ctf */[
  mk$9,
  attr$7,
  inherit_,
  val_,
  method_,
  constraint_$4,
  extension$9,
  attribute,
  text$2
];

var Ast_helper_021 = /* Cf */[
  mk$10,
  attr$8,
  inherit_$1,
  val_$1,
  method_$1,
  constraint_$5,
  initializer_,
  extension$10,
  attribute$1,
  text$3,
  virtual_,
  concrete
];

function map_fst(f, param) {
  return /* tuple */[
          Curry._1(f, param[0]),
          param[1]
        ];
}

function map_snd(f, param) {
  return /* tuple */[
          param[0],
          Curry._1(f, param[1])
        ];
}

function map_tuple(f1, f2, param) {
  return /* tuple */[
          Curry._1(f1, param[0]),
          Curry._1(f2, param[1])
        ];
}

function map_opt(f, param) {
  if (param) {
    return /* Some */[Curry._1(f, param[0])];
  } else {
    return /* None */0;
  }
}

function map_loc(sub, param) {
  return /* record */[
          /* txt */param[/* txt */0],
          /* loc */Curry._2(sub[/* location */20], sub, param[/* loc */1])
        ];
}

function map$1(sub, param) {
  var desc = param[/* ptyp_desc */0];
  var loc = Curry._2(sub[/* location */20], sub, param[/* ptyp_loc */1]);
  var attrs = Curry._2(sub[/* attributes */1], sub, param[/* ptyp_attributes */2]);
  if (typeof desc === "number") {
    return mk(/* Some */[loc], /* Some */[attrs], /* Ptyp_any */0);
  } else {
    switch (desc.tag | 0) {
      case 0 : 
          return $$var(/* Some */[loc], /* Some */[attrs], desc[0]);
      case 1 : 
          return arrow(/* Some */[loc], /* Some */[attrs], desc[0], Curry._2(sub[/* typ */33], sub, desc[1]), Curry._2(sub[/* typ */33], sub, desc[2]));
      case 2 : 
          return tuple(/* Some */[loc], /* Some */[attrs], List.map(Curry._1(sub[/* typ */33], sub), desc[0]));
      case 3 : 
          return constr(/* Some */[loc], /* Some */[attrs], map_loc(sub, desc[0]), List.map(Curry._1(sub[/* typ */33], sub), desc[1]));
      case 4 : 
          var f = function (param) {
            return /* tuple */[
                    param[0],
                    Curry._2(sub[/* attributes */1], sub, param[1]),
                    Curry._2(sub[/* typ */33], sub, param[2])
                  ];
          };
          return object_(/* Some */[loc], /* Some */[attrs], List.map(f, desc[0]), desc[1]);
      case 5 : 
          return class_(/* Some */[loc], /* Some */[attrs], map_loc(sub, desc[0]), List.map(Curry._1(sub[/* typ */33], sub), desc[1]));
      case 6 : 
          return alias(/* Some */[loc], /* Some */[attrs], Curry._2(sub[/* typ */33], sub, desc[0]), desc[1]);
      case 7 : 
          return variant(/* Some */[loc], /* Some */[attrs], List.map((function (param) {
                            var sub$1 = sub;
                            var param$1 = param;
                            if (param$1.tag) {
                              return /* Rinherit */Block.__(1, [Curry._2(sub$1[/* typ */33], sub$1, param$1[0])]);
                            } else {
                              return /* Rtag */Block.__(0, [
                                        param$1[0],
                                        Curry._2(sub$1[/* attributes */1], sub$1, param$1[1]),
                                        param$1[2],
                                        List.map(Curry._1(sub$1[/* typ */33], sub$1), param$1[3])
                                      ]);
                            }
                          }), desc[0]), desc[1], desc[2]);
      case 8 : 
          return poly(/* Some */[loc], /* Some */[attrs], desc[0], Curry._2(sub[/* typ */33], sub, desc[1]));
      case 9 : 
          var match = desc[0];
          var partial_arg = Curry._1(sub[/* typ */33], sub);
          return $$package(/* Some */[loc], /* Some */[attrs], map_loc(sub, match[0]), List.map((function (param) {
                            return map_tuple((function (param) {
                                          return map_loc(sub, param);
                                        }), partial_arg, param);
                          }), match[1]));
      case 10 : 
          return extension(/* Some */[loc], /* Some */[attrs], Curry._2(sub[/* extension */15], sub, desc[0]));
      
    }
  }
}

function map_type_declaration(sub, param) {
  var partial_arg = Curry._1(sub[/* typ */33], sub);
  var partial_arg$1 = Curry._1(sub[/* location */20], sub);
  var partial_arg$2 = Curry._1(sub[/* typ */33], sub);
  var partial_arg$3 = Curry._1(sub[/* typ */33], sub);
  return mk$19(/* Some */[Curry._2(sub[/* location */20], sub, param[/* ptype_loc */7])], /* Some */[Curry._2(sub[/* attributes */1], sub, param[/* ptype_attributes */6])], /* None */0, /* None */0, /* Some */[List.map((function (param) {
                      return map_fst(partial_arg, param);
                    }), param[/* ptype_params */1])], /* Some */[List.map((function (param) {
                      var f1 = partial_arg$3;
                      var f2 = partial_arg$2;
                      var f3 = partial_arg$1;
                      var param$1 = param;
                      return /* tuple */[
                              Curry._1(f1, param$1[0]),
                              Curry._1(f2, param$1[1]),
                              Curry._1(f3, param$1[2])
                            ];
                    }), param[/* ptype_cstrs */2])], /* Some */[Curry._2(sub[/* type_kind */36], sub, param[/* ptype_kind */3])], /* Some */[param[/* ptype_private */4]], map_opt(Curry._1(sub[/* typ */33], sub), param[/* ptype_manifest */5]), map_loc(sub, param[/* ptype_name */0]));
}

function map_type_kind(sub, param) {
  if (typeof param === "number") {
    if (param) {
      return /* Ptype_open */1;
    } else {
      return /* Ptype_abstract */0;
    }
  } else if (param.tag) {
    return /* Ptype_record */Block.__(1, [List.map(Curry._1(sub[/* label_declaration */19], sub), param[0])]);
  } else {
    return /* Ptype_variant */Block.__(0, [List.map(Curry._1(sub[/* constructor_declaration */13], sub), param[0])]);
  }
}

function map_type_extension(sub, param) {
  var partial_arg = Curry._1(sub[/* typ */33], sub);
  return mk$20(/* Some */[Curry._2(sub[/* attributes */1], sub, param[/* ptyext_attributes */4])], /* None */0, /* Some */[List.map((function (param) {
                      return map_fst(partial_arg, param);
                    }), param[/* ptyext_params */1])], /* Some */[param[/* ptyext_private */3]], map_loc(sub, param[/* ptyext_path */0]), List.map(Curry._1(sub[/* extension_constructor */16], sub), param[/* ptyext_constructors */2]));
}

function map_extension_constructor_kind(sub, param) {
  if (param.tag) {
    return /* Pext_rebind */Block.__(1, [map_loc(sub, param[0])]);
  } else {
    return /* Pext_decl */Block.__(0, [
              List.map(Curry._1(sub[/* typ */33], sub), param[0]),
              map_opt(Curry._1(sub[/* typ */33], sub), param[1])
            ]);
  }
}

function map_extension_constructor(sub, param) {
  return constructor$1(/* Some */[Curry._2(sub[/* location */20], sub, param[/* pext_loc */2])], /* Some */[Curry._2(sub[/* attributes */1], sub, param[/* pext_attributes */3])], /* None */0, /* None */0, map_loc(sub, param[/* pext_name */0]), map_extension_constructor_kind(sub, param[/* pext_kind */1]));
}

function map$2(sub, param) {
  var desc = param[/* pcty_desc */0];
  var loc = Curry._2(sub[/* location */20], sub, param[/* pcty_loc */1]);
  var attrs = Curry._2(sub[/* attributes */1], sub, param[/* pcty_attributes */2]);
  switch (desc.tag | 0) {
    case 0 : 
        return constr$2(/* Some */[loc], /* Some */[attrs], map_loc(sub, desc[0]), List.map(Curry._1(sub[/* typ */33], sub), desc[1]));
    case 1 : 
        return signature$1(/* Some */[loc], /* Some */[attrs], Curry._2(sub[/* class_signature */8], sub, desc[0]));
    case 2 : 
        return arrow$1(/* Some */[loc], /* Some */[attrs], desc[0], Curry._2(sub[/* typ */33], sub, desc[1]), Curry._2(sub[/* class_type */10], sub, desc[2]));
    case 3 : 
        return extension$8(/* Some */[loc], /* Some */[attrs], Curry._2(sub[/* extension */15], sub, desc[0]));
    
  }
}

function map_field(sub, param) {
  var desc = param[/* pctf_desc */0];
  var loc = Curry._2(sub[/* location */20], sub, param[/* pctf_loc */1]);
  var attrs = Curry._2(sub[/* attributes */1], sub, param[/* pctf_attributes */2]);
  switch (desc.tag | 0) {
    case 0 : 
        return Curry._3(Ast_helper_019[/* inherit_ */2], /* Some */[loc], /* Some */[attrs], Curry._2(sub[/* class_type */10], sub, desc[0]));
    case 1 : 
        var match = desc[0];
        return Curry._6(Ast_helper_019[/* val_ */3], /* Some */[loc], /* Some */[attrs], match[0], match[1], match[2], Curry._2(sub[/* typ */33], sub, match[3]));
    case 2 : 
        var match$1 = desc[0];
        return Curry._6(Ast_helper_019[/* method_ */4], /* Some */[loc], /* Some */[attrs], match$1[0], match$1[1], match$1[2], Curry._2(sub[/* typ */33], sub, match$1[3]));
    case 3 : 
        var match$2 = desc[0];
        return Curry._4(Ast_helper_019[/* constraint_ */5], /* Some */[loc], /* Some */[attrs], Curry._2(sub[/* typ */33], sub, match$2[0]), Curry._2(sub[/* typ */33], sub, match$2[1]));
    case 4 : 
        return Curry._2(Ast_helper_019[/* attribute */7], /* Some */[loc], Curry._2(sub[/* attribute */0], sub, desc[0]));
    case 5 : 
        return Curry._3(Ast_helper_019[/* extension */6], /* Some */[loc], /* Some */[attrs], Curry._2(sub[/* extension */15], sub, desc[0]));
    
  }
}

function map_signature(sub, param) {
  return /* record */[
          /* pcsig_self */Curry._2(sub[/* typ */33], sub, param[/* pcsig_self */0]),
          /* pcsig_fields */List.map(Curry._1(sub[/* class_type_field */12], sub), param[/* pcsig_fields */1])
        ];
}

function map$3(sub, param) {
  var desc = param[/* pmty_desc */0];
  var loc = Curry._2(sub[/* location */20], sub, param[/* pmty_loc */1]);
  var attrs = Curry._2(sub[/* attributes */1], sub, param[/* pmty_attributes */2]);
  switch (desc.tag | 0) {
    case 0 : 
        return ident$1(/* Some */[loc], /* Some */[attrs], map_loc(sub, desc[0]));
    case 1 : 
        return signature(/* Some */[loc], /* Some */[attrs], Curry._2(sub[/* signature */29], sub, desc[0]));
    case 2 : 
        return functor_(/* Some */[loc], /* Some */[attrs], map_loc(sub, desc[0]), may_map(Curry._1(sub[/* module_type */24], sub), desc[1]), Curry._2(sub[/* module_type */24], sub, desc[2]));
    case 3 : 
        return with_(/* Some */[loc], /* Some */[attrs], Curry._2(sub[/* module_type */24], sub, desc[0]), List.map(Curry._1(sub[/* with_constraint */39], sub), desc[1]));
    case 4 : 
        return typeof_(/* Some */[loc], /* Some */[attrs], Curry._2(sub[/* module_expr */23], sub, desc[0]));
    case 5 : 
        return extension$3(/* Some */[loc], /* Some */[attrs], Curry._2(sub[/* extension */15], sub, desc[0]));
    case 6 : 
        return alias$2(/* Some */[loc], /* Some */[attrs], map_loc(sub, desc[0]));
    
  }
}

function map_with_constraint(sub, param) {
  switch (param.tag | 0) {
    case 0 : 
        return /* Pwith_type */Block.__(0, [
                  map_loc(sub, param[0]),
                  Curry._2(sub[/* type_declaration */34], sub, param[1])
                ]);
    case 1 : 
        return /* Pwith_module */Block.__(1, [
                  map_loc(sub, param[0]),
                  map_loc(sub, param[1])
                ]);
    case 2 : 
        return /* Pwith_typesubst */Block.__(2, [Curry._2(sub[/* type_declaration */34], sub, param[0])]);
    case 3 : 
        return /* Pwith_modsubst */Block.__(3, [
                  map_loc(sub, param[0]),
                  map_loc(sub, param[1])
                ]);
    
  }
}

function map_signature_item(sub, param) {
  var desc = param[/* psig_desc */0];
  var loc = Curry._2(sub[/* location */20], sub, param[/* psig_loc */1]);
  switch (desc.tag | 0) {
    case 0 : 
        var a = Curry._2(sub[/* value_description */38], sub, desc[0]);
        return mk$5(/* Some */[loc], /* Psig_value */Block.__(0, [a]));
    case 1 : 
        var a$1 = List.map(Curry._1(sub[/* type_declaration */34], sub), desc[0]);
        return mk$5(/* Some */[loc], /* Psig_type */Block.__(1, [a$1]));
    case 2 : 
        var a$2 = Curry._2(sub[/* type_extension */35], sub, desc[0]);
        return mk$5(/* Some */[loc], /* Psig_typext */Block.__(2, [a$2]));
    case 3 : 
        var a$3 = Curry._2(sub[/* extension_constructor */16], sub, desc[0]);
        return mk$5(/* Some */[loc], /* Psig_exception */Block.__(3, [a$3]));
    case 4 : 
        var a$4 = Curry._2(sub[/* module_declaration */22], sub, desc[0]);
        return mk$5(/* Some */[loc], /* Psig_module */Block.__(4, [a$4]));
    case 5 : 
        var a$5 = List.map(Curry._1(sub[/* module_declaration */22], sub), desc[0]);
        return mk$5(/* Some */[loc], /* Psig_recmodule */Block.__(5, [a$5]));
    case 6 : 
        var a$6 = Curry._2(sub[/* module_type_declaration */25], sub, desc[0]);
        return mk$5(/* Some */[loc], /* Psig_modtype */Block.__(6, [a$6]));
    case 7 : 
        var a$7 = Curry._2(sub[/* open_description */26], sub, desc[0]);
        return mk$5(/* Some */[loc], /* Psig_open */Block.__(7, [a$7]));
    case 8 : 
        var a$8 = Curry._2(sub[/* include_description */18], sub, desc[0]);
        return mk$5(/* Some */[loc], /* Psig_include */Block.__(8, [a$8]));
    case 9 : 
        var a$9 = List.map(Curry._1(sub[/* class_description */5], sub), desc[0]);
        return mk$5(/* Some */[loc], /* Psig_class */Block.__(9, [a$9]));
    case 10 : 
        var a$10 = List.map(Curry._1(sub[/* class_type_declaration */11], sub), desc[0]);
        return mk$5(/* Some */[loc], /* Psig_class_type */Block.__(10, [a$10]));
    case 11 : 
        var a$11 = Curry._2(sub[/* attribute */0], sub, desc[0]);
        return mk$5(/* Some */[loc], /* Psig_attribute */Block.__(11, [a$11]));
    case 12 : 
        return extension$5(/* Some */[loc], /* Some */[Curry._2(sub[/* attributes */1], sub, desc[1])], Curry._2(sub[/* extension */15], sub, desc[0]));
    
  }
}

function map$4(sub, param) {
  var desc = param[/* pmod_desc */0];
  var loc = Curry._2(sub[/* location */20], sub, param[/* pmod_loc */1]);
  var attrs = Curry._2(sub[/* attributes */1], sub, param[/* pmod_attributes */2]);
  switch (desc.tag | 0) {
    case 0 : 
        return ident$2(/* Some */[loc], /* Some */[attrs], map_loc(sub, desc[0]));
    case 1 : 
        return structure(/* Some */[loc], /* Some */[attrs], Curry._2(sub[/* structure */31], sub, desc[0]));
    case 2 : 
        return functor_$1(/* Some */[loc], /* Some */[attrs], map_loc(sub, desc[0]), may_map(Curry._1(sub[/* module_type */24], sub), desc[1]), Curry._2(sub[/* module_expr */23], sub, desc[2]));
    case 3 : 
        return apply$1(/* Some */[loc], /* Some */[attrs], Curry._2(sub[/* module_expr */23], sub, desc[0]), Curry._2(sub[/* module_expr */23], sub, desc[1]));
    case 4 : 
        return constraint_$2(/* Some */[loc], /* Some */[attrs], Curry._2(sub[/* module_expr */23], sub, desc[0]), Curry._2(sub[/* module_type */24], sub, desc[1]));
    case 5 : 
        return unpack$1(/* Some */[loc], /* Some */[attrs], Curry._2(sub[/* expr */14], sub, desc[0]));
    case 6 : 
        return extension$4(/* Some */[loc], /* Some */[attrs], Curry._2(sub[/* extension */15], sub, desc[0]));
    
  }
}

function map_structure_item(sub, param) {
  var desc = param[/* pstr_desc */0];
  var loc = Curry._2(sub[/* location */20], sub, param[/* pstr_loc */1]);
  switch (desc.tag | 0) {
    case 0 : 
        return $$eval(/* Some */[loc], /* Some */[Curry._2(sub[/* attributes */1], sub, desc[1])], Curry._2(sub[/* expr */14], sub, desc[0]));
    case 1 : 
        return value(/* Some */[loc], desc[0], List.map(Curry._1(sub[/* value_binding */37], sub), desc[1]));
    case 2 : 
        var a = Curry._2(sub[/* value_description */38], sub, desc[0]);
        return mk$6(/* Some */[loc], /* Pstr_primitive */Block.__(2, [a]));
    case 3 : 
        var a$1 = List.map(Curry._1(sub[/* type_declaration */34], sub), desc[0]);
        return mk$6(/* Some */[loc], /* Pstr_type */Block.__(3, [a$1]));
    case 4 : 
        var a$2 = Curry._2(sub[/* type_extension */35], sub, desc[0]);
        return mk$6(/* Some */[loc], /* Pstr_typext */Block.__(4, [a$2]));
    case 5 : 
        var a$3 = Curry._2(sub[/* extension_constructor */16], sub, desc[0]);
        return mk$6(/* Some */[loc], /* Pstr_exception */Block.__(5, [a$3]));
    case 6 : 
        var a$4 = Curry._2(sub[/* module_binding */21], sub, desc[0]);
        return mk$6(/* Some */[loc], /* Pstr_module */Block.__(6, [a$4]));
    case 7 : 
        var a$5 = List.map(Curry._1(sub[/* module_binding */21], sub), desc[0]);
        return mk$6(/* Some */[loc], /* Pstr_recmodule */Block.__(7, [a$5]));
    case 8 : 
        var a$6 = Curry._2(sub[/* module_type_declaration */25], sub, desc[0]);
        return mk$6(/* Some */[loc], /* Pstr_modtype */Block.__(8, [a$6]));
    case 9 : 
        var a$7 = Curry._2(sub[/* open_description */26], sub, desc[0]);
        return mk$6(/* Some */[loc], /* Pstr_open */Block.__(9, [a$7]));
    case 10 : 
        var a$8 = List.map(Curry._1(sub[/* class_declaration */4], sub), desc[0]);
        return mk$6(/* Some */[loc], /* Pstr_class */Block.__(10, [a$8]));
    case 11 : 
        var a$9 = List.map(Curry._1(sub[/* class_type_declaration */11], sub), desc[0]);
        return mk$6(/* Some */[loc], /* Pstr_class_type */Block.__(11, [a$9]));
    case 12 : 
        var a$10 = Curry._2(sub[/* include_declaration */17], sub, desc[0]);
        return mk$6(/* Some */[loc], /* Pstr_include */Block.__(12, [a$10]));
    case 13 : 
        var a$11 = Curry._2(sub[/* attribute */0], sub, desc[0]);
        return mk$6(/* Some */[loc], /* Pstr_attribute */Block.__(13, [a$11]));
    case 14 : 
        return extension$6(/* Some */[loc], /* Some */[Curry._2(sub[/* attributes */1], sub, desc[1])], Curry._2(sub[/* extension */15], sub, desc[0]));
    
  }
}

function map$5(sub, param) {
  var desc = param[/* pexp_desc */0];
  var loc = Curry._2(sub[/* location */20], sub, param[/* pexp_loc */1]);
  var attrs = Curry._2(sub[/* attributes */1], sub, param[/* pexp_attributes */2]);
  switch (desc.tag | 0) {
    case 0 : 
        return Curry._3(Ast_helper_004[/* ident */2], /* Some */[loc], /* Some */[attrs], map_loc(sub, desc[0]));
    case 1 : 
        return Curry._3(Ast_helper_004[/* constant */3], /* Some */[loc], /* Some */[attrs], desc[0]);
    case 2 : 
        return Curry._5(Ast_helper_004[/* let_ */4], /* Some */[loc], /* Some */[attrs], desc[0], List.map(Curry._1(sub[/* value_binding */37], sub), desc[1]), Curry._2(sub[/* expr */14], sub, desc[2]));
    case 3 : 
        return Curry._3(Ast_helper_004[/* function_ */6], /* Some */[loc], /* Some */[attrs], Curry._2(sub[/* cases */3], sub, desc[0]));
    case 4 : 
        return Curry._6(Ast_helper_004[/* fun_ */5], /* Some */[loc], /* Some */[attrs], desc[0], map_opt(Curry._1(sub[/* expr */14], sub), desc[1]), Curry._2(sub[/* pat */27], sub, desc[2]), Curry._2(sub[/* expr */14], sub, desc[3]));
    case 5 : 
        var partial_arg = Curry._1(sub[/* expr */14], sub);
        return Curry._4(Ast_helper_004[/* apply */7], /* Some */[loc], /* Some */[attrs], Curry._2(sub[/* expr */14], sub, desc[0]), List.map((function (param) {
                          return map_snd(partial_arg, param);
                        }), desc[1]));
    case 6 : 
        return Curry._4(Ast_helper_004[/* match_ */8], /* Some */[loc], /* Some */[attrs], Curry._2(sub[/* expr */14], sub, desc[0]), Curry._2(sub[/* cases */3], sub, desc[1]));
    case 7 : 
        return Curry._4(Ast_helper_004[/* try_ */9], /* Some */[loc], /* Some */[attrs], Curry._2(sub[/* expr */14], sub, desc[0]), Curry._2(sub[/* cases */3], sub, desc[1]));
    case 8 : 
        return Curry._3(Ast_helper_004[/* tuple */10], /* Some */[loc], /* Some */[attrs], List.map(Curry._1(sub[/* expr */14], sub), desc[0]));
    case 9 : 
        return Curry._4(Ast_helper_004[/* construct */11], /* Some */[loc], /* Some */[attrs], map_loc(sub, desc[0]), map_opt(Curry._1(sub[/* expr */14], sub), desc[1]));
    case 10 : 
        return Curry._4(Ast_helper_004[/* variant */12], /* Some */[loc], /* Some */[attrs], desc[0], map_opt(Curry._1(sub[/* expr */14], sub), desc[1]));
    case 11 : 
        var partial_arg$1 = Curry._1(sub[/* expr */14], sub);
        return Curry._4(Ast_helper_004[/* record */13], /* Some */[loc], /* Some */[attrs], List.map((function (param) {
                          return map_tuple((function (param) {
                                        return map_loc(sub, param);
                                      }), partial_arg$1, param);
                        }), desc[0]), map_opt(Curry._1(sub[/* expr */14], sub), desc[1]));
    case 12 : 
        return Curry._4(Ast_helper_004[/* field */14], /* Some */[loc], /* Some */[attrs], Curry._2(sub[/* expr */14], sub, desc[0]), map_loc(sub, desc[1]));
    case 13 : 
        return Curry._5(Ast_helper_004[/* setfield */15], /* Some */[loc], /* Some */[attrs], Curry._2(sub[/* expr */14], sub, desc[0]), map_loc(sub, desc[1]), Curry._2(sub[/* expr */14], sub, desc[2]));
    case 14 : 
        return Curry._3(Ast_helper_004[/* array */16], /* Some */[loc], /* Some */[attrs], List.map(Curry._1(sub[/* expr */14], sub), desc[0]));
    case 15 : 
        return Curry._5(Ast_helper_004[/* ifthenelse */17], /* Some */[loc], /* Some */[attrs], Curry._2(sub[/* expr */14], sub, desc[0]), Curry._2(sub[/* expr */14], sub, desc[1]), map_opt(Curry._1(sub[/* expr */14], sub), desc[2]));
    case 16 : 
        return Curry._4(Ast_helper_004[/* sequence */18], /* Some */[loc], /* Some */[attrs], Curry._2(sub[/* expr */14], sub, desc[0]), Curry._2(sub[/* expr */14], sub, desc[1]));
    case 17 : 
        return Curry._4(Ast_helper_004[/* while_ */19], /* Some */[loc], /* Some */[attrs], Curry._2(sub[/* expr */14], sub, desc[0]), Curry._2(sub[/* expr */14], sub, desc[1]));
    case 18 : 
        return Curry._7(Ast_helper_004[/* for_ */20], /* Some */[loc], /* Some */[attrs], Curry._2(sub[/* pat */27], sub, desc[0]), Curry._2(sub[/* expr */14], sub, desc[1]), Curry._2(sub[/* expr */14], sub, desc[2]), desc[3], Curry._2(sub[/* expr */14], sub, desc[4]));
    case 19 : 
        return Curry._4(Ast_helper_004[/* constraint_ */22], /* Some */[loc], /* Some */[attrs], Curry._2(sub[/* expr */14], sub, desc[0]), Curry._2(sub[/* typ */33], sub, desc[1]));
    case 20 : 
        return Curry._5(Ast_helper_004[/* coerce */21], /* Some */[loc], /* Some */[attrs], Curry._2(sub[/* expr */14], sub, desc[0]), map_opt(Curry._1(sub[/* typ */33], sub), desc[1]), Curry._2(sub[/* typ */33], sub, desc[2]));
    case 21 : 
        return Curry._4(Ast_helper_004[/* send */23], /* Some */[loc], /* Some */[attrs], Curry._2(sub[/* expr */14], sub, desc[0]), desc[1]);
    case 22 : 
        return Curry._3(Ast_helper_004[/* new_ */24], /* Some */[loc], /* Some */[attrs], map_loc(sub, desc[0]));
    case 23 : 
        return Curry._4(Ast_helper_004[/* setinstvar */25], /* Some */[loc], /* Some */[attrs], map_loc(sub, desc[0]), Curry._2(sub[/* expr */14], sub, desc[1]));
    case 24 : 
        var partial_arg$2 = Curry._1(sub[/* expr */14], sub);
        return Curry._3(Ast_helper_004[/* override */26], /* Some */[loc], /* Some */[attrs], List.map((function (param) {
                          return map_tuple((function (param) {
                                        return map_loc(sub, param);
                                      }), partial_arg$2, param);
                        }), desc[0]));
    case 25 : 
        return Curry._5(Ast_helper_004[/* letmodule */27], /* Some */[loc], /* Some */[attrs], map_loc(sub, desc[0]), Curry._2(sub[/* module_expr */23], sub, desc[1]), Curry._2(sub[/* expr */14], sub, desc[2]));
    case 26 : 
        return Curry._3(Ast_helper_004[/* assert_ */28], /* Some */[loc], /* Some */[attrs], Curry._2(sub[/* expr */14], sub, desc[0]));
    case 27 : 
        return Curry._3(Ast_helper_004[/* lazy_ */29], /* Some */[loc], /* Some */[attrs], Curry._2(sub[/* expr */14], sub, desc[0]));
    case 28 : 
        return Curry._4(Ast_helper_004[/* poly */30], /* Some */[loc], /* Some */[attrs], Curry._2(sub[/* expr */14], sub, desc[0]), map_opt(Curry._1(sub[/* typ */33], sub), desc[1]));
    case 29 : 
        return Curry._3(Ast_helper_004[/* object_ */31], /* Some */[loc], /* Some */[attrs], Curry._2(sub[/* class_structure */9], sub, desc[0]));
    case 30 : 
        return Curry._4(Ast_helper_004[/* newtype */32], /* Some */[loc], /* Some */[attrs], desc[0], Curry._2(sub[/* expr */14], sub, desc[1]));
    case 31 : 
        return Curry._3(Ast_helper_004[/* pack */33], /* Some */[loc], /* Some */[attrs], Curry._2(sub[/* module_expr */23], sub, desc[0]));
    case 32 : 
        return Curry._5(Ast_helper_004[/* open_ */34], /* Some */[loc], /* Some */[attrs], desc[0], map_loc(sub, desc[1]), Curry._2(sub[/* expr */14], sub, desc[2]));
    case 33 : 
        return Curry._3(Ast_helper_004[/* extension */35], /* Some */[loc], /* Some */[attrs], Curry._2(sub[/* extension */15], sub, desc[0]));
    
  }
}

function map$6(sub, param) {
  var desc = param[/* ppat_desc */0];
  var loc = Curry._2(sub[/* location */20], sub, param[/* ppat_loc */1]);
  var attrs = Curry._2(sub[/* attributes */1], sub, param[/* ppat_attributes */2]);
  if (typeof desc === "number") {
    return mk$1(/* Some */[loc], /* Some */[attrs], /* Ppat_any */0);
  } else {
    switch (desc.tag | 0) {
      case 0 : 
          return $$var$1(/* Some */[loc], /* Some */[attrs], map_loc(sub, desc[0]));
      case 1 : 
          return alias$1(/* Some */[loc], /* Some */[attrs], Curry._2(sub[/* pat */27], sub, desc[0]), map_loc(sub, desc[1]));
      case 2 : 
          return constant(/* Some */[loc], /* Some */[attrs], desc[0]);
      case 3 : 
          return interval(/* Some */[loc], /* Some */[attrs], desc[0], desc[1]);
      case 4 : 
          return tuple$1(/* Some */[loc], /* Some */[attrs], List.map(Curry._1(sub[/* pat */27], sub), desc[0]));
      case 5 : 
          return construct(/* Some */[loc], /* Some */[attrs], map_loc(sub, desc[0]), map_opt(Curry._1(sub[/* pat */27], sub), desc[1]));
      case 6 : 
          return variant$1(/* Some */[loc], /* Some */[attrs], desc[0], map_opt(Curry._1(sub[/* pat */27], sub), desc[1]));
      case 7 : 
          var partial_arg = Curry._1(sub[/* pat */27], sub);
          return record(/* Some */[loc], /* Some */[attrs], List.map((function (param) {
                            return map_tuple((function (param) {
                                          return map_loc(sub, param);
                                        }), partial_arg, param);
                          }), desc[0]), desc[1]);
      case 8 : 
          return array(/* Some */[loc], /* Some */[attrs], List.map(Curry._1(sub[/* pat */27], sub), desc[0]));
      case 9 : 
          return or_(/* Some */[loc], /* Some */[attrs], Curry._2(sub[/* pat */27], sub, desc[0]), Curry._2(sub[/* pat */27], sub, desc[1]));
      case 10 : 
          return constraint_(/* Some */[loc], /* Some */[attrs], Curry._2(sub[/* pat */27], sub, desc[0]), Curry._2(sub[/* typ */33], sub, desc[1]));
      case 11 : 
          return type_(/* Some */[loc], /* Some */[attrs], map_loc(sub, desc[0]));
      case 12 : 
          return lazy_(/* Some */[loc], /* Some */[attrs], Curry._2(sub[/* pat */27], sub, desc[0]));
      case 13 : 
          return unpack(/* Some */[loc], /* Some */[attrs], map_loc(sub, desc[0]));
      case 14 : 
          return exception_(/* Some */[loc], /* Some */[attrs], Curry._2(sub[/* pat */27], sub, desc[0]));
      case 15 : 
          return extension$1(/* Some */[loc], /* Some */[attrs], Curry._2(sub[/* extension */15], sub, desc[0]));
      
    }
  }
}

function map$7(sub, param) {
  var desc = param[/* pcl_desc */0];
  var loc = Curry._2(sub[/* location */20], sub, param[/* pcl_loc */1]);
  var attrs = Curry._2(sub[/* attributes */1], sub, param[/* pcl_attributes */2]);
  switch (desc.tag | 0) {
    case 0 : 
        return constr$1(/* Some */[loc], /* Some */[attrs], map_loc(sub, desc[0]), List.map(Curry._1(sub[/* typ */33], sub), desc[1]));
    case 1 : 
        return structure$1(/* Some */[loc], /* Some */[attrs], Curry._2(sub[/* class_structure */9], sub, desc[0]));
    case 2 : 
        return fun_$1(/* Some */[loc], /* Some */[attrs], desc[0], map_opt(Curry._1(sub[/* expr */14], sub), desc[1]), Curry._2(sub[/* pat */27], sub, desc[2]), Curry._2(sub[/* class_expr */6], sub, desc[3]));
    case 3 : 
        var partial_arg = Curry._1(sub[/* expr */14], sub);
        return apply$2(/* Some */[loc], /* Some */[attrs], Curry._2(sub[/* class_expr */6], sub, desc[0]), List.map((function (param) {
                          return map_snd(partial_arg, param);
                        }), desc[1]));
    case 4 : 
        return let_$1(/* Some */[loc], /* Some */[attrs], desc[0], List.map(Curry._1(sub[/* value_binding */37], sub), desc[1]), Curry._2(sub[/* class_expr */6], sub, desc[2]));
    case 5 : 
        return constraint_$3(/* Some */[loc], /* Some */[attrs], Curry._2(sub[/* class_expr */6], sub, desc[0]), Curry._2(sub[/* class_type */10], sub, desc[1]));
    case 6 : 
        return extension$7(/* Some */[loc], /* Some */[attrs], Curry._2(sub[/* extension */15], sub, desc[0]));
    
  }
}

function map_kind(sub, param) {
  if (param.tag) {
    return /* Cfk_concrete */Block.__(1, [
              param[0],
              Curry._2(sub[/* expr */14], sub, param[1])
            ]);
  } else {
    return /* Cfk_virtual */Block.__(0, [Curry._2(sub[/* typ */33], sub, param[0])]);
  }
}

function map_field$1(sub, param) {
  var desc = param[/* pcf_desc */0];
  var loc = Curry._2(sub[/* location */20], sub, param[/* pcf_loc */1]);
  var attrs = Curry._2(sub[/* attributes */1], sub, param[/* pcf_attributes */2]);
  switch (desc.tag | 0) {
    case 0 : 
        return Curry._5(Ast_helper_021[/* inherit_ */2], /* Some */[loc], /* Some */[attrs], desc[0], Curry._2(sub[/* class_expr */6], sub, desc[1]), desc[2]);
    case 1 : 
        var match = desc[0];
        return Curry._5(Ast_helper_021[/* val_ */3], /* Some */[loc], /* Some */[attrs], map_loc(sub, match[0]), match[1], map_kind(sub, match[2]));
    case 2 : 
        var match$1 = desc[0];
        return Curry._5(Ast_helper_021[/* method_ */4], /* Some */[loc], /* Some */[attrs], map_loc(sub, match$1[0]), match$1[1], map_kind(sub, match$1[2]));
    case 3 : 
        var match$2 = desc[0];
        return Curry._4(Ast_helper_021[/* constraint_ */5], /* Some */[loc], /* Some */[attrs], Curry._2(sub[/* typ */33], sub, match$2[0]), Curry._2(sub[/* typ */33], sub, match$2[1]));
    case 4 : 
        return Curry._3(Ast_helper_021[/* initializer_ */6], /* Some */[loc], /* Some */[attrs], Curry._2(sub[/* expr */14], sub, desc[0]));
    case 5 : 
        return Curry._2(Ast_helper_021[/* attribute */8], /* Some */[loc], Curry._2(sub[/* attribute */0], sub, desc[0]));
    case 6 : 
        return Curry._3(Ast_helper_021[/* extension */7], /* Some */[loc], /* Some */[attrs], Curry._2(sub[/* extension */15], sub, desc[0]));
    
  }
}

function map_structure(sub, param) {
  return /* record */[
          /* pcstr_self */Curry._2(sub[/* pat */27], sub, param[/* pcstr_self */0]),
          /* pcstr_fields */List.map(Curry._1(sub[/* class_field */7], sub), param[/* pcstr_fields */1])
        ];
}

function class_infos(sub, f, param) {
  var partial_arg = Curry._1(sub[/* typ */33], sub);
  return mk$18(/* Some */[Curry._2(sub[/* location */20], sub, param[/* pci_loc */4])], /* Some */[Curry._2(sub[/* attributes */1], sub, param[/* pci_attributes */5])], /* None */0, /* None */0, /* Some */[param[/* pci_virt */0]], /* Some */[List.map((function (param) {
                      return map_fst(partial_arg, param);
                    }), param[/* pci_params */1])], map_loc(sub, param[/* pci_name */2]), Curry._1(f, param[/* pci_expr */3]));
}

function default_mapper_000($$this, param) {
  return /* tuple */[
          map_loc($$this, param[0]),
          Curry._2($$this[/* payload */28], $$this, param[1])
        ];
}

function default_mapper_001($$this, l) {
  return List.map(Curry._1($$this[/* attribute */0], $$this), l);
}

function default_mapper_002($$this, param) {
  return /* record */[
          /* pc_lhs */Curry._2($$this[/* pat */27], $$this, param[/* pc_lhs */0]),
          /* pc_guard */map_opt(Curry._1($$this[/* expr */14], $$this), param[/* pc_guard */1]),
          /* pc_rhs */Curry._2($$this[/* expr */14], $$this, param[/* pc_rhs */2])
        ];
}

function default_mapper_003($$this, l) {
  return List.map(Curry._1($$this[/* case */2], $$this), l);
}

function default_mapper_004($$this) {
  var partial_arg = Curry._1($$this[/* class_expr */6], $$this);
  return (function (param) {
      return class_infos($$this, partial_arg, param);
    });
}

function default_mapper_005($$this) {
  var partial_arg = Curry._1($$this[/* class_type */10], $$this);
  return (function (param) {
      return class_infos($$this, partial_arg, param);
    });
}

function default_mapper_011($$this) {
  var partial_arg = Curry._1($$this[/* class_type */10], $$this);
  return (function (param) {
      return class_infos($$this, partial_arg, param);
    });
}

function default_mapper_013($$this, param) {
  return constructor(/* Some */[Curry._2($$this[/* location */20], $$this, param[/* pcd_loc */3])], /* Some */[Curry._2($$this[/* attributes */1], $$this, param[/* pcd_attributes */4])], /* None */0, /* Some */[List.map(Curry._1($$this[/* typ */33], $$this), param[/* pcd_args */1])], map_opt(Curry._1($$this[/* typ */33], $$this), param[/* pcd_res */2]), map_loc($$this, param[/* pcd_name */0]));
}

function default_mapper_015($$this, param) {
  return /* tuple */[
          map_loc($$this, param[0]),
          Curry._2($$this[/* payload */28], $$this, param[1])
        ];
}

function default_mapper_017($$this, param) {
  return mk$16(/* Some */[Curry._2($$this[/* location */20], $$this, param[/* pincl_loc */1])], /* Some */[Curry._2($$this[/* attributes */1], $$this, param[/* pincl_attributes */2])], /* None */0, Curry._2($$this[/* module_expr */23], $$this, param[/* pincl_mod */0]));
}

function default_mapper_018($$this, param) {
  return mk$16(/* Some */[Curry._2($$this[/* location */20], $$this, param[/* pincl_loc */1])], /* Some */[Curry._2($$this[/* attributes */1], $$this, param[/* pincl_attributes */2])], /* None */0, Curry._2($$this[/* module_type */24], $$this, param[/* pincl_mod */0]));
}

function default_mapper_019($$this, param) {
  return field$1(/* Some */[Curry._2($$this[/* location */20], $$this, param[/* pld_loc */3])], /* Some */[Curry._2($$this[/* attributes */1], $$this, param[/* pld_attributes */4])], /* None */0, /* Some */[param[/* pld_mutable */1]], map_loc($$this, param[/* pld_name */0]), Curry._2($$this[/* typ */33], $$this, param[/* pld_type */2]));
}

function default_mapper_020(_, l) {
  return l;
}

function default_mapper_021($$this, param) {
  return mk$14(/* Some */[Curry._2($$this[/* location */20], $$this, param[/* pmb_loc */3])], /* Some */[Curry._2($$this[/* attributes */1], $$this, param[/* pmb_attributes */2])], /* None */0, /* None */0, map_loc($$this, param[/* pmb_name */0]), Curry._2($$this[/* module_expr */23], $$this, param[/* pmb_expr */1]));
}

function default_mapper_022($$this, param) {
  return mk$12(/* Some */[Curry._2($$this[/* location */20], $$this, param[/* pmd_loc */3])], /* Some */[Curry._2($$this[/* attributes */1], $$this, param[/* pmd_attributes */2])], /* None */0, /* None */0, map_loc($$this, param[/* pmd_name */0]), Curry._2($$this[/* module_type */24], $$this, param[/* pmd_type */1]));
}

function default_mapper_025($$this, param) {
  return mk$13(/* Some */[Curry._2($$this[/* location */20], $$this, param[/* pmtd_loc */3])], /* Some */[Curry._2($$this[/* attributes */1], $$this, param[/* pmtd_attributes */2])], /* None */0, /* None */0, map_opt(Curry._1($$this[/* module_type */24], $$this), param[/* pmtd_type */1]), map_loc($$this, param[/* pmtd_name */0]));
}

function default_mapper_026($$this, param) {
  return mk$15(/* Some */[Curry._2($$this[/* location */20], $$this, param[/* popen_loc */2])], /* Some */[Curry._2($$this[/* attributes */1], $$this, param[/* popen_attributes */3])], /* None */0, /* Some */[param[/* popen_override */1]], map_loc($$this, param[/* popen_lid */0]));
}

function default_mapper_028($$this, param) {
  switch (param.tag | 0) {
    case 0 : 
        return /* PStr */Block.__(0, [Curry._2($$this[/* structure */31], $$this, param[0])]);
    case 1 : 
        return /* PTyp */Block.__(1, [Curry._2($$this[/* typ */33], $$this, param[0])]);
    case 2 : 
        return /* PPat */Block.__(2, [
                  Curry._2($$this[/* pat */27], $$this, param[0]),
                  map_opt(Curry._1($$this[/* expr */14], $$this), param[1])
                ]);
    
  }
}

function default_mapper_029($$this, l) {
  return List.map(Curry._1($$this[/* signature_item */30], $$this), l);
}

function default_mapper_031($$this, l) {
  return List.map(Curry._1($$this[/* structure_item */32], $$this), l);
}

function default_mapper_037($$this, param) {
  return mk$17(/* Some */[Curry._2($$this[/* location */20], $$this, param[/* pvb_loc */3])], /* Some */[Curry._2($$this[/* attributes */1], $$this, param[/* pvb_attributes */2])], /* None */0, /* None */0, Curry._2($$this[/* pat */27], $$this, param[/* pvb_pat */0]), Curry._2($$this[/* expr */14], $$this, param[/* pvb_expr */1]));
}

function default_mapper_038($$this, param) {
  return mk$11(/* Some */[Curry._2($$this[/* location */20], $$this, param[/* pval_loc */4])], /* Some */[Curry._2($$this[/* attributes */1], $$this, param[/* pval_attributes */3])], /* None */0, /* Some */[param[/* pval_prim */2]], map_loc($$this, param[/* pval_name */0]), Curry._2($$this[/* typ */33], $$this, param[/* pval_type */1]));
}

var default_mapper = /* record */[
  default_mapper_000,
  default_mapper_001,
  default_mapper_002,
  default_mapper_003,
  default_mapper_004,
  default_mapper_005,
  /* class_expr */map$7,
  /* class_field */map_field$1,
  /* class_signature */map_signature,
  /* class_structure */map_structure,
  /* class_type */map$2,
  default_mapper_011,
  /* class_type_field */map_field,
  default_mapper_013,
  /* expr */map$5,
  default_mapper_015,
  /* extension_constructor */map_extension_constructor,
  default_mapper_017,
  default_mapper_018,
  default_mapper_019,
  default_mapper_020,
  default_mapper_021,
  default_mapper_022,
  /* module_expr */map$4,
  /* module_type */map$3,
  default_mapper_025,
  default_mapper_026,
  /* pat */map$6,
  default_mapper_028,
  default_mapper_029,
  /* signature_item */map_signature_item,
  default_mapper_031,
  /* structure_item */map_structure_item,
  /* typ */map$1,
  /* type_declaration */map_type_declaration,
  /* type_extension */map_type_extension,
  /* type_kind */map_type_kind,
  default_mapper_037,
  default_mapper_038,
  /* with_constraint */map_with_constraint
];

function height$4(param) {
  if (param) {
    return param[4];
  } else {
    return 0;
  }
}

function create$5(l, x, d, r) {
  var hl = height$4(l);
  var hr = height$4(r);
  return /* Node */[
          l,
          x,
          d,
          r,
          hl >= hr ? hl + 1 | 0 : hr + 1 | 0
        ];
}

function bal$4(l, x, d, r) {
  var hl = height$4(l);
  var hr = height$4(r);
  if (hl > (hr + 1 | 0)) {
    if (l) {
      var lr = l[3];
      var ld = l[2];
      var lv = l[1];
      var ll = l[0];
      if (height$4(ll) >= height$4(lr)) {
        return create$5(ll, lv, ld, create$5(lr, x, d, r));
      } else if (lr) {
        return create$5(create$5(ll, lv, ld, lr[0]), lr[1], lr[2], create$5(lr[3], x, d, r));
      } else {
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "tbl.ml",
                35,
                11
              ]
            ];
      }
    } else {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "tbl.ml",
              35,
              11
            ]
          ];
    }
  } else if (hr > (hl + 1 | 0)) {
    if (r) {
      var rl = r[0];
      var rr = r[3];
      if (height$4(rr) >= height$4(rl)) {
        return create$5(create$5(l, x, d, rl), r[1], r[2], rr);
      } else if (rl) {
        return create$5(create$5(l, x, d, rl[0]), rl[1], rl[2], create$5(rl[3], r[1], r[2], r[3]));
      } else {
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "tbl.ml",
                42,
                11
              ]
            ];
      }
    } else {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "tbl.ml",
              42,
              11
            ]
          ];
    }
  } else {
    return create$5(l, x, d, r);
  }
}

function add$5(x, data, param) {
  if (param) {
    var r = param[3];
    var d = param[2];
    var v = param[1];
    var l = param[0];
    var c = Caml_obj.caml_compare(x, v);
    if (c) {
      if (c < 0) {
        return bal$4(add$5(x, data, l), v, d, r);
      } else {
        return bal$4(l, v, d, add$5(x, data, r));
      }
    } else {
      return /* Node */[
              l,
              x,
              data,
              r,
              param[4]
            ];
    }
  } else {
    return /* Node */[
            /* Empty */0,
            x,
            data,
            /* Empty */0,
            1
          ];
  }
}

function find$2(x, _param) {
  while(true) {
    var param = _param;
    if (param) {
      var c = Caml_obj.caml_compare(x, param[1]);
      if (c) {
        _param = c < 0 ? param[0] : param[3];
        continue ;
        
      } else {
        return param[2];
      }
    } else {
      throw Caml_builtin_exceptions.not_found;
    }
  };
}

function mem$4(x, _param) {
  while(true) {
    var param = _param;
    if (param) {
      var c = Caml_obj.caml_compare(x, param[1]);
      if (c) {
        _param = c < 0 ? param[0] : param[3];
        continue ;
        
      } else {
        return /* true */1;
      }
    } else {
      return /* false */0;
    }
  };
}

function iter$2(f, _param) {
  while(true) {
    var param = _param;
    if (param) {
      iter$2(f, param[0]);
      Curry._2(f, param[1], param[2]);
      _param = param[3];
      continue ;
      
    } else {
      return /* () */0;
    }
  };
}

function fold$4(f, _m, _accu) {
  while(true) {
    var accu = _accu;
    var m = _m;
    if (m) {
      _accu = Curry._3(f, m[1], m[2], fold$4(f, m[0], accu));
      _m = m[3];
      continue ;
      
    } else {
      return accu;
    }
  };
}

var identity = /* record */[
  /* types : Empty */0,
  /* modules : Empty */0,
  /* modtypes : Empty */0,
  /* for_saving : false */0
];

function add_type(id, p, s) {
  return /* record */[
          /* types */add$5(id, p, s[/* types */0]),
          /* modules */s[/* modules */1],
          /* modtypes */s[/* modtypes */2],
          /* for_saving */s[/* for_saving */3]
        ];
}

function add_module(id, p, s) {
  return /* record */[
          /* types */s[/* types */0],
          /* modules */add$5(id, p, s[/* modules */1]),
          /* modtypes */s[/* modtypes */2],
          /* for_saving */s[/* for_saving */3]
        ];
}

function add_modtype(id, ty, s) {
  return /* record */[
          /* types */s[/* types */0],
          /* modules */s[/* modules */1],
          /* modtypes */add$5(id, ty, s[/* modtypes */2]),
          /* for_saving */s[/* for_saving */3]
        ];
}

function for_saving(s) {
  return /* record */[
          /* types */s[/* types */0],
          /* modules */s[/* modules */1],
          /* modtypes */s[/* modtypes */2],
          /* for_saving : true */1
        ];
}

function loc(s, x) {
  if (s[/* for_saving */3] && !keep_locs[0]) {
    return none;
  } else {
    return x;
  }
}

var newrecord$2 = default_mapper.slice();

newrecord$2[/* location */20] = (function (_, _$1) {
    return none;
  });

function is_not_doc(param) {
  switch (param[0][/* txt */0]) {
    case "doc" : 
    case "ocaml.doc" : 
    case "ocaml.text" : 
    case "text" : 
        return /* false */0;
    default:
      return /* true */1;
  }
}

function attrs(s, x) {
  var x$1 = s[/* for_saving */3] && !keep_docs[0] ? List.filter(is_not_doc)(x) : x;
  if (s[/* for_saving */3] && !keep_locs[0]) {
    return Curry._2(newrecord$2[/* attributes */1], newrecord$2, x$1);
  } else {
    return x$1;
  }
}

function module_path(s, p) {
  switch (p.tag | 0) {
    case 0 : 
        try {
          return find$2(p[0], s[/* modules */1]);
        }
        catch (exn){
          if (exn === Caml_builtin_exceptions.not_found) {
            return p;
          } else {
            throw exn;
          }
        }
        break;
    case 1 : 
        return /* Pdot */Block.__(1, [
                  module_path(s, p[0]),
                  p[1],
                  p[2]
                ]);
    case 2 : 
        return /* Papply */Block.__(2, [
                  module_path(s, p[0]),
                  module_path(s, p[1])
                ]);
    
  }
}

function modtype_path(s, p) {
  switch (p.tag | 0) {
    case 0 : 
        try {
          var match = find$2(p[0], s[/* modtypes */2]);
          if (match.tag) {
            return fatal_error("Subst.modtype_path");
          } else {
            return match[0];
          }
        }
        catch (exn){
          if (exn === Caml_builtin_exceptions.not_found) {
            return p;
          } else {
            throw exn;
          }
        }
        break;
    case 1 : 
        return /* Pdot */Block.__(1, [
                  module_path(s, p[0]),
                  p[1],
                  p[2]
                ]);
    case 2 : 
        return fatal_error("Subst.modtype_path");
    
  }
}

function type_path(s, p) {
  switch (p.tag | 0) {
    case 0 : 
        try {
          return find$2(p[0], s[/* types */0]);
        }
        catch (exn){
          if (exn === Caml_builtin_exceptions.not_found) {
            return p;
          } else {
            throw exn;
          }
        }
        break;
    case 1 : 
        return /* Pdot */Block.__(1, [
                  module_path(s, p[0]),
                  p[1],
                  p[2]
                ]);
    case 2 : 
        return fatal_error("Subst.type_path");
    
  }
}

var new_id$1 = [-1];

function newpersty(desc) {
  new_id$1[0] = new_id$1[0] - 1 | 0;
  return /* record */[
          /* desc */desc,
          /* level */100000000,
          /* id */new_id$1[0]
        ];
}

function norm(d) {
  if (typeof d === "number") {
    return d;
  } else {
    switch (d.tag | 0) {
      case 0 : 
          if (d[0]) {
            return d;
          } else {
            return /* Tvar */Block.__(0, [/* None */0]);
          }
      case 9 : 
          if (d[0]) {
            return d;
          } else {
            return /* Tunivar */Block.__(9, [/* None */0]);
          }
      default:
        return d;
    }
  }
}

function typexp(s, ty) {
  var ty$1 = repr(ty);
  var desc = ty$1[/* desc */0];
  var exit = 0;
  if (typeof desc === "number") {
    exit = 1;
  } else {
    switch (desc.tag | 0) {
      case 7 : 
          return desc[0];
      case 0 : 
      case 9 : 
          exit = 2;
          break;
      default:
        exit = 1;
    }
  }
  switch (exit) {
    case 1 : 
        var desc$1 = ty$1[/* desc */0];
        save_desc(ty$1, desc$1);
        var ty$prime = s[/* for_saving */3] ? newpersty(/* Tvar */Block.__(0, [/* None */0])) : newty2(100000000, /* Tvar */Block.__(0, [/* None */0]));
        ty$1[/* desc */0] = /* Tsubst */Block.__(7, [ty$prime]);
        var $js;
        var exit$1 = 0;
        if (typeof desc$1 === "number") {
          exit$1 = 3;
        } else {
          switch (desc$1.tag | 0) {
            case 3 : 
                $js = /* Tconstr */Block.__(3, [
                    type_path(s, desc$1[0]),
                    List.map((function (param) {
                            return typexp(s, param);
                          }), desc$1[1]),
                    [/* Mnil */0]
                  ]);
                break;
            case 4 : 
                var match = desc$1[1][0];
                var $js$1;
                if (match) {
                  var match$1 = match[0];
                  $js$1 = /* Some */[/* tuple */[
                      type_path(s, match$1[0]),
                      List.map((function (param) {
                              return typexp(s, param);
                            }), match$1[1])
                    ]];
                } else {
                  $js$1 = /* None */0;
                }
                $js = /* Tobject */Block.__(4, [
                    typexp(s, desc$1[0]),
                    [$js$1]
                  ]);
                break;
            case 5 : 
                var t2 = desc$1[3];
                var k = desc$1[1];
                var m = desc$1[0];
                if (s === identity && ty$1[/* level */1] < 100000000 && m === dummy_method) {
                  $js = /* Tfield */Block.__(5, [
                      m,
                      k,
                      desc$1[2],
                      typexp(s, t2)
                    ]);
                } else if (field_kind_repr(k) === /* Fabsent */1) {
                  $js = /* Tlink */Block.__(6, [typexp(s, t2)]);
                } else {
                  exit$1 = 3;
                }
                break;
            case 8 : 
                var row = row_repr_aux(/* [] */0, desc$1[0]);
                var more = repr(row[/* row_more */1]);
                var match$2 = more[/* desc */0];
                var exit$2 = 0;
                if (typeof match$2 === "number") {
                  exit$2 = 4;
                } else if (match$2.tag === 7) {
                  var match$3 = match$2[0][/* desc */0];
                  if (typeof match$3 === "number") {
                    exit$2 = 4;
                  } else if (match$3.tag === 2) {
                    var match$4 = match$3[0];
                    if (match$4) {
                      var match$5 = match$4[1];
                      if (match$5) {
                        if (match$5[1]) {
                          exit$2 = 4;
                        } else {
                          var ty2 = match$5[0];
                          ty$1[/* desc */0] = /* Tsubst */Block.__(7, [ty2]);
                          $js = /* Tlink */Block.__(6, [ty2]);
                        }
                      } else {
                        exit$2 = 4;
                      }
                    } else {
                      exit$2 = 4;
                    }
                  } else {
                    exit$2 = 4;
                  }
                } else {
                  exit$2 = 4;
                }
                if (exit$2 === 4) {
                  var match$6 = more[/* desc */0];
                  var $js$2;
                  $js$2 = typeof match$6 === "number" || match$6.tag !== 3 ? /* false */0 : /* true */1;
                  var dup = s[/* for_saving */3] || +(more[/* level */1] === 100000000) || static_row(row) || $js$2;
                  var match$7 = more[/* desc */0];
                  var more$prime;
                  var exit$3 = 0;
                  if (typeof match$7 === "number") {
                    if (match$7) {
                      throw [
                            Caml_builtin_exceptions.assert_failure,
                            [
                              "subst.ml",
                              170,
                              23
                            ]
                          ];
                    } else {
                      more$prime = typexp(s, more);
                    }
                  } else {
                    switch (match$7.tag | 0) {
                      case 3 : 
                          more$prime = typexp(s, more);
                          break;
                      case 7 : 
                          more$prime = match$7[0];
                          break;
                      case 0 : 
                      case 9 : 
                          exit$3 = 5;
                          break;
                      default:
                        throw [
                              Caml_builtin_exceptions.assert_failure,
                              [
                                "subst.ml",
                                170,
                                23
                              ]
                            ];
                    }
                  }
                  if (exit$3 === 5) {
                    save_desc(more, more[/* desc */0]);
                    more$prime = s[/* for_saving */3] ? newpersty(norm(more[/* desc */0])) : (
                        dup && is_Tvar(more) ? newty2(100000000, more[/* desc */0]) : more
                      );
                  }
                  more[/* desc */0] = /* Tsubst */Block.__(7, [newty2(100000000, /* Ttuple */Block.__(2, [/* :: */[
                                more$prime,
                                /* :: */[
                                  ty$prime,
                                  /* [] */0
                                ]
                              ]]))]);
                  var row$1 = copy_row((function (param) {
                          return typexp(s, param);
                        }), /* true */1, row, 1 - dup, more$prime);
                  var match$8 = row$1[/* row_name */5];
                  if (match$8) {
                    var match$9 = match$8[0];
                    var newrecord = row$1.slice();
                    $js = /* Tvariant */Block.__(8, [(newrecord[/* row_name */5] = /* Some */[/* tuple */[
                              type_path(s, match$9[0]),
                              match$9[1]
                            ]], newrecord)]);
                  } else {
                    $js = /* Tvariant */Block.__(8, [row$1]);
                  }
                }
                break;
            case 11 : 
                $js = /* Tpackage */Block.__(11, [
                    modtype_path(s, desc$1[0]),
                    desc$1[1],
                    List.map((function (param) {
                            return typexp(s, param);
                          }), desc$1[2])
                  ]);
                break;
            default:
              exit$1 = 3;
          }
        }
        if (exit$1 === 3) {
          $js = copy_type_desc(/* None */0, (function (param) {
                  return typexp(s, param);
                }), desc$1);
        }
        ty$prime[/* desc */0] = $js;
        return ty$prime;
    case 2 : 
        if (s[/* for_saving */3] || ty$1[/* id */2] < 0) {
          var ty$prime$1 = s[/* for_saving */3] ? newpersty(norm(desc)) : newty2(ty$1[/* level */1], desc);
          save_desc(ty$1, desc);
          ty$1[/* desc */0] = /* Tsubst */Block.__(7, [ty$prime$1]);
          return ty$prime$1;
        } else {
          return ty$1;
        }
        break;
    
  }
}

function type_expr(s, ty) {
  var ty$prime = typexp(s, ty);
  cleanup_types(/* () */0);
  return ty$prime;
}

function type_declaration(s, decl) {
  var match = decl[/* type_kind */2];
  var $js;
  $js = typeof match === "number" ? (
      match ? /* Type_open */1 : /* Type_abstract */0
    ) : (
      match.tag ? /* Type_variant */Block.__(1, [List.map((function (c) {
                    return /* record */[
                            /* cd_id */c[/* cd_id */0],
                            /* cd_args */List.map((function (param) {
                                    return typexp(s, param);
                                  }), c[/* cd_args */1]),
                            /* cd_res */may_map((function (param) {
                                    return typexp(s, param);
                                  }), c[/* cd_res */2]),
                            /* cd_loc */loc(s, c[/* cd_loc */3]),
                            /* cd_attributes */attrs(s, c[/* cd_attributes */4])
                          ];
                  }), match[0])]) : /* Type_record */Block.__(0, [
            List.map((function (l) {
                    return /* record */[
                            /* ld_id */l[/* ld_id */0],
                            /* ld_mutable */l[/* ld_mutable */1],
                            /* ld_type */typexp(s, l[/* ld_type */2]),
                            /* ld_loc */loc(s, l[/* ld_loc */3]),
                            /* ld_attributes */attrs(s, l[/* ld_attributes */4])
                          ];
                  }), match[0]),
            match[1]
          ])
    );
  var match$1 = decl[/* type_manifest */4];
  var decl_000 = /* type_params */List.map((function (param) {
          return typexp(s, param);
        }), decl[/* type_params */0]);
  var decl_001 = /* type_arity */decl[/* type_arity */1];
  var decl_003 = /* type_private */decl[/* type_private */3];
  var decl_004 = /* type_manifest */match$1 ? /* Some */[typexp(s, match$1[0])] : /* None */0;
  var decl_005 = /* type_variance */decl[/* type_variance */5];
  var decl_007 = /* type_loc */loc(s, decl[/* type_loc */7]);
  var decl_008 = /* type_attributes */attrs(s, decl[/* type_attributes */8]);
  var decl$1 = /* record */[
    decl_000,
    decl_001,
    /* type_kind */$js,
    decl_003,
    decl_004,
    decl_005,
    /* type_newtype_level : None */0,
    decl_007,
    decl_008
  ];
  cleanup_types(/* () */0);
  return decl$1;
}

function class_signature(s, sign) {
  return /* record */[
          /* csig_self */typexp(s, sign[/* csig_self */0]),
          /* csig_vars */map((function (param) {
                  return /* tuple */[
                          param[0],
                          param[1],
                          typexp(s, param[2])
                        ];
                }), sign[/* csig_vars */1]),
          /* csig_concr */sign[/* csig_concr */2],
          /* csig_inher */List.map((function (param) {
                  return /* tuple */[
                          type_path(s, param[0]),
                          List.map((function (param) {
                                  return typexp(s, param);
                                }), param[1])
                        ];
                }), sign[/* csig_inher */3])
        ];
}

function class_type(s, param) {
  switch (param.tag | 0) {
    case 0 : 
        return /* Cty_constr */Block.__(0, [
                  type_path(s, param[0]),
                  List.map((function (param) {
                          return typexp(s, param);
                        }), param[1]),
                  class_type(s, param[2])
                ]);
    case 1 : 
        return /* Cty_signature */Block.__(1, [class_signature(s, param[0])]);
    case 2 : 
        return /* Cty_arrow */Block.__(2, [
                  param[0],
                  typexp(s, param[1]),
                  class_type(s, param[2])
                ]);
    
  }
}

function class_declaration(s, decl) {
  var match = decl[/* cty_new */3];
  var decl$1 = /* record */[
    /* cty_params */List.map((function (param) {
            return typexp(s, param);
          }), decl[/* cty_params */0]),
    /* cty_type */class_type(s, decl[/* cty_type */1]),
    /* cty_path */type_path(s, decl[/* cty_path */2]),
    /* cty_new */match ? /* Some */[typexp(s, match[0])] : /* None */0,
    /* cty_variance */decl[/* cty_variance */4],
    /* cty_loc */loc(s, decl[/* cty_loc */5]),
    /* cty_attributes */attrs(s, decl[/* cty_attributes */6])
  ];
  if (!s[/* for_saving */3]) {
    cleanup_types(/* () */0);
  }
  return decl$1;
}

function cltype_declaration(s, decl) {
  var decl_000 = /* clty_params */List.map((function (param) {
          return typexp(s, param);
        }), decl[/* clty_params */0]);
  var decl_001 = /* clty_type */class_type(s, decl[/* clty_type */1]);
  var decl_002 = /* clty_path */type_path(s, decl[/* clty_path */2]);
  var decl_003 = /* clty_variance */decl[/* clty_variance */3];
  var decl_004 = /* clty_loc */loc(s, decl[/* clty_loc */4]);
  var decl_005 = /* clty_attributes */attrs(s, decl[/* clty_attributes */5]);
  var decl$1 = /* record */[
    decl_000,
    decl_001,
    decl_002,
    decl_003,
    decl_004,
    decl_005
  ];
  cleanup_types(/* () */0);
  return decl$1;
}

function value_description(s, descr) {
  return /* record */[
          /* val_type */type_expr(s, descr[/* val_type */0]),
          /* val_kind */descr[/* val_kind */1],
          /* val_loc */loc(s, descr[/* val_loc */2]),
          /* val_attributes */attrs(s, descr[/* val_attributes */3])
        ];
}

function extension_constructor(s, ext) {
  var ext_000 = /* ext_type_path */type_path(s, ext[/* ext_type_path */0]);
  var ext_001 = /* ext_type_params */List.map((function (param) {
          return typexp(s, param);
        }), ext[/* ext_type_params */1]);
  var ext_002 = /* ext_args */List.map((function (param) {
          return typexp(s, param);
        }), ext[/* ext_args */2]);
  var ext_003 = /* ext_ret_type */may_map((function (param) {
          return typexp(s, param);
        }), ext[/* ext_ret_type */3]);
  var ext_004 = /* ext_private */ext[/* ext_private */4];
  var ext_005 = /* ext_loc */s[/* for_saving */3] ? none : ext[/* ext_loc */5];
  var ext_006 = /* ext_attributes */attrs(s, ext[/* ext_attributes */6]);
  var ext$1 = /* record */[
    ext_000,
    ext_001,
    ext_002,
    ext_003,
    ext_004,
    ext_005,
    ext_006
  ];
  cleanup_types(/* () */0);
  return ext$1;
}

function rename_bound_idents(_s, _idents, _param) {
  while(true) {
    var param = _param;
    var idents = _idents;
    var s = _s;
    if (param) {
      var match = param[0];
      switch (match.tag | 0) {
        case 1 : 
            var id = match[0];
            var id$prime = rename(id);
            _param = param[1];
            _idents = /* :: */[
              id$prime,
              idents
            ];
            _s = add_type(id, /* Pident */Block.__(0, [id$prime]), s);
            continue ;
            case 3 : 
            var id$1 = match[0];
            var id$prime$1 = rename(id$1);
            _param = param[1];
            _idents = /* :: */[
              id$prime$1,
              idents
            ];
            _s = add_module(id$1, /* Pident */Block.__(0, [id$prime$1]), s);
            continue ;
            case 4 : 
            var id$2 = match[0];
            var id$prime$2 = rename(id$2);
            _param = param[1];
            _idents = /* :: */[
              id$prime$2,
              idents
            ];
            _s = add_modtype(id$2, /* Mty_ident */Block.__(0, [/* Pident */Block.__(0, [id$prime$2])]), s);
            continue ;
            default:
          var id$prime$3 = rename(match[0]);
          _param = param[1];
          _idents = /* :: */[
            id$prime$3,
            idents
          ];
          continue ;
          
      }
    } else {
      return /* tuple */[
              List.rev(idents),
              s
            ];
    }
  };
}

function modtype(s, mty) {
  switch (mty.tag | 0) {
    case 0 : 
        var p = mty[0];
        switch (p.tag | 0) {
          case 0 : 
              try {
                return find$2(p[0], s[/* modtypes */2]);
              }
              catch (exn){
                if (exn === Caml_builtin_exceptions.not_found) {
                  return mty;
                } else {
                  throw exn;
                }
              }
              break;
          case 1 : 
              return /* Mty_ident */Block.__(0, [/* Pdot */Block.__(1, [
                            module_path(s, p[0]),
                            p[1],
                            p[2]
                          ])]);
          case 2 : 
              return fatal_error("Subst.modtype");
          
        }
        break;
    case 1 : 
        return /* Mty_signature */Block.__(1, [signature$2(s, mty[0])]);
    case 2 : 
        var id = mty[0];
        var id$prime = rename(id);
        return /* Mty_functor */Block.__(2, [
                  id$prime,
                  may_map((function (param) {
                          return modtype(s, param);
                        }), mty[1]),
                  modtype(add_module(id, /* Pident */Block.__(0, [id$prime]), s), mty[2])
                ]);
    case 3 : 
        return /* Mty_alias */Block.__(3, [module_path(s, mty[0])]);
    
  }
}

function signature$2(s, sg) {
  var match = rename_bound_idents(s, /* [] */0, sg);
  var s$prime = match[1];
  return List.map2((function (param, param$1) {
                var s = s$prime;
                var comp = param;
                var newid = param$1;
                switch (comp.tag | 0) {
                  case 0 : 
                      return /* Sig_value */Block.__(0, [
                                newid,
                                value_description(s, comp[1])
                              ]);
                  case 1 : 
                      return /* Sig_type */Block.__(1, [
                                newid,
                                type_declaration(s, comp[1]),
                                comp[2]
                              ]);
                  case 2 : 
                      return /* Sig_typext */Block.__(2, [
                                newid,
                                extension_constructor(s, comp[1]),
                                comp[2]
                              ]);
                  case 3 : 
                      return /* Sig_module */Block.__(3, [
                                newid,
                                module_declaration(s, comp[1]),
                                comp[2]
                              ]);
                  case 4 : 
                      return /* Sig_modtype */Block.__(4, [
                                newid,
                                modtype_declaration(s, comp[1])
                              ]);
                  case 5 : 
                      return /* Sig_class */Block.__(5, [
                                newid,
                                class_declaration(s, comp[1]),
                                comp[2]
                              ]);
                  case 6 : 
                      return /* Sig_class_type */Block.__(6, [
                                newid,
                                cltype_declaration(s, comp[1]),
                                comp[2]
                              ]);
                  
                }
              }), sg, match[0]);
}

function module_declaration(s, decl) {
  return /* record */[
          /* md_type */modtype(s, decl[/* md_type */0]),
          /* md_attributes */attrs(s, decl[/* md_attributes */1]),
          /* md_loc */loc(s, decl[/* md_loc */2])
        ];
}

function modtype_declaration(s, decl) {
  return /* record */[
          /* mtd_type */may_map((function (param) {
                  return modtype(s, param);
                }), decl[/* mtd_type */0]),
          /* mtd_attributes */attrs(s, decl[/* mtd_attributes */1]),
          /* mtd_loc */loc(s, decl[/* mtd_loc */2])
        ];
}

var add_delayed_check_forward = [(function () {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "env.ml",
              24,
              46
            ]
          ];
    })];

var value_declarations = Hashtbl.create(/* None */0, 16);

var type_declarations = Hashtbl.create(/* None */0, 16);

function add_constructor_usage(cu, param) {
  switch (param) {
    case 0 : 
        cu[/* cu_positive */0] = /* true */1;
        return /* () */0;
    case 1 : 
        cu[/* cu_pattern */1] = /* true */1;
        return /* () */0;
    case 2 : 
        cu[/* cu_privatize */2] = /* true */1;
        return /* () */0;
    
  }
}

var used_constructors = Hashtbl.create(/* None */0, 16);

var prefixed_sg = Hashtbl.create(/* None */0, 113);

var $$Error$2 = Caml_exceptions.create("Ocaml_typedtree_test.Env.Error");

function force(f, x) {
  var match = x[0];
  switch (match.tag | 0) {
    case 0 : 
        return match[0];
    case 1 : 
        throw match[0];
    case 2 : 
        try {
          var y = Curry._1(f, match[0]);
          x[0] = /* Done */Block.__(0, [y]);
          return y;
        }
        catch (raw_e){
          var e = Js_exn.internalToOCamlException(raw_e);
          x[0] = /* Raise */Block.__(1, [e]);
          throw e;
        }
        break;
    
  }
}

function get_arg(x) {
  var match = x[0];
  switch (match.tag | 0) {
    case 0 : 
    case 1 : 
        return /* None */0;
    case 2 : 
        return /* Some */[match[0]];
    
  }
}

function nothing() {
  return /* () */0;
}

function already_defined(s, tbl) {
  try {
    find_name(s, tbl);
    return /* true */1;
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return /* false */0;
    } else {
      throw exn;
    }
  }
}

function add$6(kind, slot, id, x, tbl, ref_tbl) {
  var slot$1;
  if (slot) {
    var f = slot[0];
    slot$1 = (function () {
        var s = id[/* name */1];
        return Curry._3(f, kind, s, already_defined(s, ref_tbl));
      });
  } else {
    slot$1 = nothing;
  }
  return add(id, /* tuple */[
              x,
              slot$1
            ], tbl);
}

function find_same$1(id, tbl) {
  var match = find_same(id, tbl);
  Curry._1(match[1], /* () */0);
  return match[0];
}

function find_name$1(s, tbl) {
  var match = find_name(s, tbl);
  Curry._1(match[1], /* () */0);
  return match[0];
}

function fold_name(f) {
  return (function (param, param$1) {
      var f$1 = function (k, param) {
        return Curry._2(f, k, param[0]);
      };
      var tbl = param;
      var accu = param$1;
      var f$2 = function (k) {
        return Curry._2(f$1, k[/* ident */0], k[/* data */1]);
      };
      var _stack = /* [] */0;
      var _accu = accu;
      var _param = tbl;
      while(true) {
        var param$2 = _param;
        var accu$1 = _accu;
        var stack = _stack;
        if (param$2) {
          _param = param$2[2];
          _accu = Curry._2(f$2, param$2[1], accu$1);
          _stack = /* :: */[
            param$2[0],
            stack
          ];
          continue ;
          
        } else if (stack) {
          _param = stack[0];
          _stack = stack[1];
          continue ;
          
        } else {
          return accu$1;
        }
      };
    });
}

function subst_modtype_maker(param) {
  return modtype(param[0], param[1]);
}

var empty = /* record */[
  /* values : Empty */0,
  /* constrs : Empty */0,
  /* labels : Empty */0,
  /* types : Empty */0,
  /* modules : Empty */0,
  /* modtypes : Empty */0,
  /* components : Empty */0,
  /* classes : Empty */0,
  /* cltypes : Empty */0,
  /* functor_args : Empty */0,
  /* summary : Env_empty */0,
  /* local_constraints : false */0,
  /* gadt_instances : [] */0,
  /* flags */0
];

function in_signature(env) {
  var newrecord = env.slice();
  newrecord[/* flags */13] = env[/* flags */13] | 1;
  return newrecord;
}

function implicit_coercion(env) {
  var newrecord = env.slice();
  newrecord[/* flags */13] = env[/* flags */13] | 2;
  return newrecord;
}

function is_in_signature(env) {
  return +((env[/* flags */13] & 1) !== 0);
}

function is_implicit_coercion(env) {
  return +((env[/* flags */13] & 2) !== 0);
}

var components_of_module$prime = [(function (_, _$1, _$2, _$3) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "env.ml",
              272,
              32
            ]
          ];
    })];

var components_of_module_maker$prime = [(function () {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "env.ml",
              275,
              37
            ]
          ];
    })];

var components_of_functor_appl$prime = [(function (_, _$1, _$2) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "env.ml",
              278,
              23
            ]
          ];
    })];

var check_modtype_inclusion = [(function (_, _$1, _$2, _$3) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "env.ml",
              282,
              35
            ]
          ];
    })];

var strengthen = [(function (_, _$1, _$2) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "env.ml",
              286,
              28
            ]
          ];
    })];

function md(md_type) {
  return /* record */[
          /* md_type */md_type,
          /* md_attributes : [] */0,
          /* md_loc */none
        ];
}

var current_unit = [""];

var persistent_structures = Hashtbl.create(/* None */0, 17);

var crc_units = Hashtbl.create(/* None */0, 13);

function height$5(param) {
  if (param) {
    return param[3];
  } else {
    return 0;
  }
}

function create$6(l, v, r) {
  var hl = l ? l[3] : 0;
  var hr = r ? r[3] : 0;
  return /* Node */[
          l,
          v,
          r,
          hl >= hr ? hl + 1 | 0 : hr + 1 | 0
        ];
}

function bal$5(l, v, r) {
  var hl = l ? l[3] : 0;
  var hr = r ? r[3] : 0;
  if (hl > (hr + 2 | 0)) {
    if (l) {
      var lr = l[2];
      var lv = l[1];
      var ll = l[0];
      if (height$5(ll) >= height$5(lr)) {
        return create$6(ll, lv, create$6(lr, v, r));
      } else if (lr) {
        return create$6(create$6(ll, lv, lr[0]), lr[1], create$6(lr[2], v, r));
      } else {
        throw [
              Caml_builtin_exceptions.invalid_argument,
              "Set.bal"
            ];
      }
    } else {
      throw [
            Caml_builtin_exceptions.invalid_argument,
            "Set.bal"
          ];
    }
  } else if (hr > (hl + 2 | 0)) {
    if (r) {
      var rr = r[2];
      var rv = r[1];
      var rl = r[0];
      if (height$5(rr) >= height$5(rl)) {
        return create$6(create$6(l, v, rl), rv, rr);
      } else if (rl) {
        return create$6(create$6(l, v, rl[0]), rl[1], create$6(rl[2], rv, rr));
      } else {
        throw [
              Caml_builtin_exceptions.invalid_argument,
              "Set.bal"
            ];
      }
    } else {
      throw [
            Caml_builtin_exceptions.invalid_argument,
            "Set.bal"
          ];
    }
  } else {
    return /* Node */[
            l,
            v,
            r,
            hl >= hr ? hl + 1 | 0 : hr + 1 | 0
          ];
  }
}

function add$7(x, t) {
  if (t) {
    var r = t[2];
    var v = t[1];
    var l = t[0];
    var c = Caml_string.caml_string_compare(x, v);
    if (c) {
      if (c < 0) {
        return bal$5(add$7(x, l), v, r);
      } else {
        return bal$5(l, v, add$7(x, r));
      }
    } else {
      return t;
    }
  } else {
    return /* Node */[
            /* Empty */0,
            x,
            /* Empty */0,
            1
          ];
  }
}

function elements_aux$2(_accu, _param) {
  while(true) {
    var param = _param;
    var accu = _accu;
    if (param) {
      _param = param[0];
      _accu = /* :: */[
        param[1],
        elements_aux$2(accu, param[2])
      ];
      continue ;
      
    } else {
      return accu;
    }
  };
}

var imported_units = [/* Empty */0];

function add_import(s) {
  imported_units[0] = add$7(s, imported_units[0]);
  return /* () */0;
}

function check_consistency(ps) {
  if (ps[/* ps_crcs_checked */4]) {
    return 0;
  } else {
    try {
      List.iter((function (param) {
              var crco = param[1];
              if (crco) {
                var name = param[0];
                add_import(name);
                var tbl = crc_units;
                var name$1 = name;
                var crc = crco[0];
                var source = ps[/* ps_filename */5];
                try {
                  var match = Hashtbl.find(tbl, name$1);
                  if (Caml_obj.caml_notequal(crc, match[0])) {
                    throw [
                          Inconsistency,
                          name$1,
                          source,
                          match[1]
                        ];
                  } else {
                    return 0;
                  }
                }
                catch (exn){
                  if (exn === Caml_builtin_exceptions.not_found) {
                    return Hashtbl.add(tbl, name$1, /* tuple */[
                                crc,
                                source
                              ]);
                  } else {
                    throw exn;
                  }
                }
              } else {
                return /* () */0;
              }
            }), ps[/* ps_crcs */3]);
      ps[/* ps_crcs_checked */4] = /* true */1;
      return /* () */0;
    }
    catch (raw_exn){
      var exn = Js_exn.internalToOCamlException(raw_exn);
      if (exn[0] === Inconsistency) {
        throw [
              $$Error$2,
              /* Inconsistent_import */Block.__(1, [
                  exn[1],
                  exn[3],
                  exn[2]
                ])
            ];
      } else {
        throw exn;
      }
    }
  }
}

function save_pers_struct(crc, ps) {
  var modname = ps[/* ps_name */0];
  Hashtbl.add(persistent_structures, modname, /* Some */[ps]);
  set$1(crc_units, modname, crc, ps[/* ps_filename */5]);
  return add_import(modname);
}

function read_pers_struct(modname, filename) {
  var cmi = read_cmi(filename);
  var name = cmi[/* cmi_name */0];
  var sign = cmi[/* cmi_sign */1];
  var crcs = cmi[/* cmi_crcs */2];
  var flags = cmi[/* cmi_flags */3];
  var comps = Curry._4(components_of_module$prime[0], empty, identity, /* Pident */Block.__(0, [/* record */[
            /* stamp */0,
            /* name */name,
            /* flags */1
          ]]), /* Mty_signature */Block.__(1, [sign]));
  var ps = /* record */[
    /* ps_name */name,
    /* ps_sig */sign,
    /* ps_comps */comps,
    /* ps_crcs */crcs,
    /* ps_crcs_checked : false */0,
    /* ps_filename */filename,
    /* ps_flags */flags
  ];
  if (ps[/* ps_name */0] !== modname) {
    throw [
          $$Error$2,
          /* Illegal_renaming */Block.__(0, [
              modname,
              ps[/* ps_name */0],
              filename
            ])
        ];
  }
  add_import(name);
  List.iter((function () {
          if (recursive_types[0]) {
            return 0;
          } else {
            throw [
                  $$Error$2,
                  /* Need_recursive_types */Block.__(2, [
                      ps[/* ps_name */0],
                      current_unit[0]
                    ])
                ];
          }
        }), ps[/* ps_flags */6]);
  Hashtbl.add(persistent_structures, modname, /* Some */[ps]);
  return ps;
}

function find_pers_struct($staropt$star, name) {
  var check = $staropt$star ? $staropt$star[0] : /* true */1;
  if (name === "*predef*") {
    throw Caml_builtin_exceptions.not_found;
  }
  var r;
  try {
    r = /* Some */[Hashtbl.find(persistent_structures, name)];
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      r = /* None */0;
    } else {
      throw exn;
    }
  }
  var ps;
  if (r) {
    var match = r[0];
    if (match) {
      ps = match[0];
    } else {
      throw Caml_builtin_exceptions.not_found;
    }
  } else {
    add_import(name);
    var filename;
    try {
      filename = find_in_path_uncap(load_path[0], name + ".cmi");
    }
    catch (exn$1){
      if (exn$1 === Caml_builtin_exceptions.not_found) {
        Hashtbl.add(persistent_structures, name, /* None */0);
        throw Caml_builtin_exceptions.not_found;
      } else {
        throw exn$1;
      }
    }
    ps = read_pers_struct(name, filename);
  }
  if (check) {
    check_consistency(ps);
  }
  return ps;
}

function find_module_descr(path, env) {
  switch (path.tag | 0) {
    case 0 : 
        var id = path[0];
        try {
          return find_same$1(id, env[/* components */6])[1];
        }
        catch (exn){
          if (exn === Caml_builtin_exceptions.not_found) {
            if (id[/* stamp */0] === 0 && id[/* name */1] !== current_unit[0]) {
              return find_pers_struct(/* None */0, id[/* name */1])[/* ps_comps */2];
            } else {
              throw Caml_builtin_exceptions.not_found;
            }
          } else {
            throw exn;
          }
        }
        break;
    case 1 : 
        var match = force(components_of_module_maker$prime[0], find_module_descr(path[0], env));
        if (match.tag) {
          throw Caml_builtin_exceptions.not_found;
        } else {
          return find$2(path[1], match[0][/* comp_components */6])[0];
        }
        break;
    case 2 : 
        var p1 = path[0];
        var match$1 = force(components_of_module_maker$prime[0], find_module_descr(p1, env));
        if (match$1.tag) {
          return Curry._3(components_of_functor_appl$prime[0], match$1[0], p1, path[1]);
        } else {
          throw Caml_builtin_exceptions.not_found;
        }
        break;
    
  }
}

function find$3(proj1, proj2, path, env) {
  switch (path.tag | 0) {
    case 0 : 
        return find_same$1(path[0], Curry._1(proj1, env))[1];
    case 1 : 
        var match = force(components_of_module_maker$prime[0], find_module_descr(path[0], env));
        if (match.tag) {
          throw Caml_builtin_exceptions.not_found;
        } else {
          return find$2(path[1], Curry._1(proj2, match[0]))[0];
        }
        break;
    case 2 : 
        throw Caml_builtin_exceptions.not_found;
    
  }
}

function find_value(param, param$1) {
  return find$3((function (env) {
                return env[/* values */0];
              }), (function (sc) {
                return sc[/* comp_values */0];
              }), param, param$1);
}

function find_type_full(param, param$1) {
  return find$3((function (env) {
                return env[/* types */3];
              }), (function (sc) {
                return sc[/* comp_types */3];
              }), param, param$1);
}

function find_modtype(param, param$1) {
  return find$3((function (env) {
                return env[/* modtypes */5];
              }), (function (sc) {
                return sc[/* comp_modtypes */5];
              }), param, param$1);
}

function find_class(param, param$1) {
  return find$3((function (env) {
                return env[/* classes */7];
              }), (function (sc) {
                return sc[/* comp_classes */7];
              }), param, param$1);
}

function find_module(alias, path, env) {
  switch (path.tag | 0) {
    case 0 : 
        var id = path[0];
        try {
          return find_same$1(id, env[/* modules */4])[1];
        }
        catch (exn){
          if (exn === Caml_builtin_exceptions.not_found) {
            if (id[/* stamp */0] === 0 && id[/* name */1] !== current_unit[0]) {
              var ps = find_pers_struct(/* None */0, id[/* name */1]);
              return md(/* Mty_signature */Block.__(1, [ps[/* ps_sig */1]]));
            } else {
              throw Caml_builtin_exceptions.not_found;
            }
          } else {
            throw exn;
          }
        }
        break;
    case 1 : 
        var match = force(components_of_module_maker$prime[0], find_module_descr(path[0], env));
        if (match.tag) {
          throw Caml_builtin_exceptions.not_found;
        } else {
          var match$1 = find$2(path[1], match[0][/* comp_modules */4]);
          return md(force(subst_modtype_maker, match$1[0]));
        }
        break;
    case 2 : 
        var p2 = path[1];
        var desc1 = find_module_descr(path[0], env);
        var match$2 = force(components_of_module_maker$prime[0], desc1);
        if (match$2.tag) {
          var f = match$2[0];
          var mty = f[/* fcomp_res */2];
          var $js;
          if (mty.tag === 3) {
            $js = /* Mty_alias */Block.__(3, [module_path(f[/* fcomp_subst */4], mty[0])]);
          } else if (alias) {
            $js = mty;
          } else {
            try {
              $js = Hashtbl.find(f[/* fcomp_subst_cache */6], p2);
            }
            catch (exn$1){
              if (exn$1 === Caml_builtin_exceptions.not_found) {
                var mty$1 = modtype(add_module(f[/* fcomp_param */0], p2, f[/* fcomp_subst */4]), f[/* fcomp_res */2]);
                Hashtbl.add(f[/* fcomp_subst_cache */6], p2, mty$1);
                $js = mty$1;
              } else {
                throw exn$1;
              }
            }
          }
          return md($js);
        } else {
          throw Caml_builtin_exceptions.not_found;
        }
        break;
    
  }
}

var required_globals = [/* [] */0];

function add_required_global(id) {
  if ($$global(id) && !transparent_modules[0] && !List.exists((function (param) {
            return Caml_obj.caml_equal(id, param);
          }), required_globals[0])) {
    required_globals[0] = /* :: */[
      id,
      required_globals[0]
    ];
    return /* () */0;
  } else {
    return 0;
  }
}

function normalize_path(lax, env, path) {
  var path$1;
  switch (path.tag | 0) {
    case 0 : 
        path$1 = path;
        break;
    case 1 : 
        path$1 = /* Pdot */Block.__(1, [
            normalize_path(lax, env, path[0]),
            path[1],
            path[2]
          ]);
        break;
    case 2 : 
        path$1 = /* Papply */Block.__(2, [
            normalize_path(lax, env, path[0]),
            normalize_path(/* true */1, env, path[1])
          ]);
        break;
    
  }
  try {
    var match = find_module(/* true */1, path$1, env);
    var match$1 = match[/* md_type */0];
    if (match$1.tag === 3) {
      var path$prime = normalize_path(lax, env, match$1[0]);
      if (lax || transparent_modules[0]) {
        return path$prime;
      } else {
        var id = head(path$1);
        if ($$global(id) && !Caml_obj.caml_equal(id, head(path$prime))) {
          add_required_global(id);
        }
        return path$prime;
      }
    } else {
      return path$1;
    }
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      var $js;
      switch (path$1.tag | 0) {
        case 0 : 
            $js = +(path$1[0][/* stamp */0] !== 0);
            break;
        case 1 : 
        case 2 : 
            $js = /* true */1;
            break;
        
      }
      if (lax || $js) {
        return path$1;
      } else {
        throw exn;
      }
    } else {
      throw exn;
    }
  }
}

function normalize_path$1(oloc, env, path) {
  try {
    return normalize_path(+(oloc === /* None */0), env, path);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      if (oloc) {
        throw [
              $$Error$2,
              /* Missing_module */Block.__(3, [
                  oloc[0],
                  path,
                  normalize_path(/* true */1, env, path)
                ])
            ];
      } else {
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "env.ml",
                579,
                28
              ]
            ];
      }
    } else {
      throw exn;
    }
  }
}

function find_type_expansion(path, env) {
  var decl = find_type_full(path, env)[0];
  var match = decl[/* type_manifest */4];
  var exit = 0;
  if (match) {
    var body = match[0];
    if (decl[/* type_private */3] === /* Public */1 || decl[/* type_kind */2] !== /* Type_abstract */0 || has_constr_row(body)) {
      return /* tuple */[
              decl[/* type_params */0],
              body,
              may_map((function (prim) {
                      return prim[1];
                    }), decl[/* type_newtype_level */6])
            ];
    } else {
      exit = 1;
    }
  } else {
    exit = 1;
  }
  if (exit === 1) {
    var path$prime = normalize_path$1(/* None */0, env, path);
    if (same(path, path$prime)) {
      throw Caml_builtin_exceptions.not_found;
    } else {
      return /* tuple */[
              decl[/* type_params */0],
              newty2(100000000, /* Tconstr */Block.__(3, [
                      path$prime,
                      decl[/* type_params */0],
                      [/* Mnil */0]
                    ])),
              may_map((function (prim) {
                      return prim[1];
                    }), decl[/* type_newtype_level */6])
            ];
    }
  }
  
}

function find_type_expansion_opt(path, env) {
  var decl = find_type_full(path, env)[0];
  var match = decl[/* type_manifest */4];
  if (match) {
    return /* tuple */[
            decl[/* type_params */0],
            match[0],
            may_map((function (prim) {
                    return prim[1];
                  }), decl[/* type_newtype_level */6])
          ];
  } else {
    var path$prime = normalize_path$1(/* None */0, env, path);
    if (same(path, path$prime)) {
      throw Caml_builtin_exceptions.not_found;
    } else {
      return /* tuple */[
              decl[/* type_params */0],
              newty2(100000000, /* Tconstr */Block.__(3, [
                      path$prime,
                      decl[/* type_params */0],
                      [/* Mnil */0]
                    ])),
              may_map((function (prim) {
                      return prim[1];
                    }), decl[/* type_newtype_level */6])
            ];
    }
  }
}

function find_modtype_expansion(path, env) {
  var match = find_modtype(path, env)[/* mtd_type */0];
  if (match) {
    return match[0];
  } else {
    throw Caml_builtin_exceptions.not_found;
  }
}

function is_functor_arg(_path, env) {
  while(true) {
    var path = _path;
    switch (path.tag | 0) {
      case 0 : 
          try {
            find_same(path[0], env[/* functor_args */9]);
            return /* true */1;
          }
          catch (exn){
            if (exn === Caml_builtin_exceptions.not_found) {
              return /* false */0;
            } else {
              throw exn;
            }
          }
          break;
      case 1 : 
          _path = path[0];
          continue ;
          case 2 : 
          return /* true */1;
      
    }
  };
}

var Recmodule = Caml_exceptions.create("Ocaml_typedtree_test.Env.Recmodule");

function lookup_module_descr(lid, env) {
  switch (lid.tag | 0) {
    case 0 : 
        var s = lid[0];
        try {
          return find_name$1(s, env[/* components */6]);
        }
        catch (exn){
          if (exn === Caml_builtin_exceptions.not_found) {
            if (s === current_unit[0]) {
              throw Caml_builtin_exceptions.not_found;
            }
            var ps = find_pers_struct(/* None */0, s);
            return /* tuple */[
                    /* Pident */Block.__(0, [/* record */[
                          /* stamp */0,
                          /* name */s,
                          /* flags */1
                        ]]),
                    ps[/* ps_comps */2]
                  ];
          } else {
            throw exn;
          }
        }
        break;
    case 1 : 
        var s$1 = lid[1];
        var match = lookup_module_descr(lid[0], env);
        var match$1 = force(components_of_module_maker$prime[0], match[1]);
        if (match$1.tag) {
          throw Caml_builtin_exceptions.not_found;
        } else {
          var match$2 = find$2(s$1, match$1[0][/* comp_components */6]);
          return /* tuple */[
                  /* Pdot */Block.__(1, [
                      match[0],
                      s$1,
                      match$2[1]
                    ]),
                  match$2[0]
                ];
        }
        break;
    case 2 : 
        var match$3 = lookup_module_descr(lid[0], env);
        var p1 = match$3[0];
        var p2 = lookup_module(/* true */1, lid[1], env);
        var match$4 = find_module(/* false */0, p2, env);
        var match$5 = force(components_of_module_maker$prime[0], match$3[1]);
        if (match$5.tag) {
          var f = match$5[0];
          may(Curry._3(check_modtype_inclusion[0], env, match$4[/* md_type */0], p2), f[/* fcomp_arg */1]);
          return /* tuple */[
                  /* Papply */Block.__(2, [
                      p1,
                      p2
                    ]),
                  Curry._3(components_of_functor_appl$prime[0], f, p1, p2)
                ];
        } else {
          throw Caml_builtin_exceptions.not_found;
        }
        break;
    
  }
}

function lookup_module(load, lid, env) {
  switch (lid.tag | 0) {
    case 0 : 
        var s = lid[0];
        try {
          var r = find_name$1(s, env[/* modules */4]);
          var md_type = r[1][/* md_type */0];
          if (!md_type.tag) {
            var match = md_type[0];
            switch (match.tag | 0) {
              case 0 : 
                  if (match[0][/* name */1] === "#recmod#") {
                    throw Recmodule;
                  }
                  break;
              case 1 : 
              case 2 : 
                  break;
              
            }
          }
          return r[0];
        }
        catch (exn){
          if (exn === Caml_builtin_exceptions.not_found) {
            if (s === current_unit[0]) {
              throw Caml_builtin_exceptions.not_found;
            }
            if (transparent_modules[0] && !load) {
              try {
                find_pers_struct(/* Some */[/* false */0], s);
              }
              catch (exn$1){
                if (exn$1 === Caml_builtin_exceptions.not_found) {
                  prerr_warning(none, /* No_cmi_file */Block.__(32, [s]));
                } else {
                  throw exn$1;
                }
              }
            } else {
              find_pers_struct(/* None */0, s);
            }
            return /* Pident */Block.__(0, [/* record */[
                        /* stamp */0,
                        /* name */s,
                        /* flags */1
                      ]]);
          } else {
            throw exn;
          }
        }
        break;
    case 1 : 
        var s$1 = lid[1];
        var match$1 = lookup_module_descr(lid[0], env);
        var match$2 = force(components_of_module_maker$prime[0], match$1[1]);
        if (match$2.tag) {
          throw Caml_builtin_exceptions.not_found;
        } else {
          var match$3 = find$2(s$1, match$2[0][/* comp_modules */4]);
          return /* Pdot */Block.__(1, [
                    match$1[0],
                    s$1,
                    match$3[1]
                  ]);
        }
        break;
    case 2 : 
        var match$4 = lookup_module_descr(lid[0], env);
        var p2 = lookup_module(/* true */1, lid[1], env);
        var match$5 = find_module(/* false */0, p2, env);
        var p_000 = match$4[0];
        var p = /* Papply */Block.__(2, [
            p_000,
            p2
          ]);
        var match$6 = force(components_of_module_maker$prime[0], match$4[1]);
        if (match$6.tag) {
          may(Curry._3(check_modtype_inclusion[0], env, match$5[/* md_type */0], p2), match$6[0][/* fcomp_arg */1]);
          return p;
        } else {
          throw Caml_builtin_exceptions.not_found;
        }
        break;
    
  }
}

function lookup(proj1, proj2, lid, env) {
  switch (lid.tag | 0) {
    case 0 : 
        return find_name$1(lid[0], Curry._1(proj1, env));
    case 1 : 
        var s = lid[1];
        var match = lookup_module_descr(lid[0], env);
        var match$1 = force(components_of_module_maker$prime[0], match[1]);
        if (match$1.tag) {
          throw Caml_builtin_exceptions.not_found;
        } else {
          var match$2 = find$2(s, Curry._1(proj2, match$1[0]));
          return /* tuple */[
                  /* Pdot */Block.__(1, [
                      match[0],
                      s,
                      match$2[1]
                    ]),
                  match$2[0]
                ];
        }
        break;
    case 2 : 
        throw Caml_builtin_exceptions.not_found;
    
  }
}

function lookup_all_simple(proj1, proj2, shadow, lid, env) {
  switch (lid.tag | 0) {
    case 0 : 
        var tbl = Curry._1(proj1, env);
        var xl = find_all(lid[0], tbl);
        var do_shadow = function (param) {
          if (param) {
            var match = param[0];
            var x = match[0];
            return /* :: */[
                    /* tuple */[
                      x,
                      match[1]
                    ],
                    do_shadow(List.filter((function (param) {
                                  return 1 - Curry._2(shadow, x, param[0]);
                                }))(param[1]))
                  ];
          } else {
            return /* [] */0;
          }
        };
        return do_shadow(xl);
    case 1 : 
        var match = lookup_module_descr(lid[0], env);
        var match$1 = force(components_of_module_maker$prime[0], match[1]);
        if (match$1.tag) {
          throw Caml_builtin_exceptions.not_found;
        } else {
          var comps;
          try {
            comps = find$2(lid[1], Curry._1(proj2, match$1[0]));
          }
          catch (exn){
            if (exn === Caml_builtin_exceptions.not_found) {
              comps = /* [] */0;
            } else {
              throw exn;
            }
          }
          return List.map((function (param) {
                        return /* tuple */[
                                param[0],
                                (function () {
                                    return /* () */0;
                                  })
                              ];
                      }), comps);
        }
        break;
    case 2 : 
        throw Caml_builtin_exceptions.not_found;
    
  }
}

function cstr_shadow(cstr1, cstr2) {
  var match = cstr1[/* cstr_tag */5];
  var match$1 = cstr2[/* cstr_tag */5];
  switch (match.tag | 0) {
    case 0 : 
    case 1 : 
        return /* false */0;
    case 2 : 
        switch (match$1.tag | 0) {
          case 0 : 
          case 1 : 
              return /* false */0;
          case 2 : 
              return /* true */1;
          
        }
        break;
    
  }
}

function lbl_shadow(_, _$1) {
  return /* false */0;
}

function lookup_value(param, param$1) {
  return lookup((function (env) {
                return env[/* values */0];
              }), (function (sc) {
                return sc[/* comp_values */0];
              }), param, param$1);
}

function lookup_all_constructors(param, param$1) {
  return lookup_all_simple((function (env) {
                return env[/* constrs */1];
              }), (function (sc) {
                return sc[/* comp_constrs */1];
              }), cstr_shadow, param, param$1);
}

function lookup_all_labels(param, param$1) {
  return lookup_all_simple((function (env) {
                return env[/* labels */2];
              }), (function (sc) {
                return sc[/* comp_labels */2];
              }), lbl_shadow, param, param$1);
}

function lookup_type(param, param$1) {
  return lookup((function (env) {
                return env[/* types */3];
              }), (function (sc) {
                return sc[/* comp_types */3];
              }), param, param$1);
}

function lookup_modtype(param, param$1) {
  return lookup((function (env) {
                return env[/* modtypes */5];
              }), (function (sc) {
                return sc[/* comp_modtypes */5];
              }), param, param$1);
}

function lookup_class(param, param$1) {
  return lookup((function (env) {
                return env[/* classes */7];
              }), (function (sc) {
                return sc[/* comp_classes */7];
              }), param, param$1);
}

function lookup_cltype(param, param$1) {
  return lookup((function (env) {
                return env[/* cltypes */8];
              }), (function (sc) {
                return sc[/* comp_cltypes */8];
              }), param, param$1);
}

function mark_value_used(env, name, vd) {
  if (is_implicit_coercion(env)) {
    return 0;
  } else {
    try {
      return Curry._1(Hashtbl.find(value_declarations, /* tuple */[
                      name,
                      vd[/* val_loc */2]
                    ]), /* () */0);
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        return /* () */0;
      } else {
        throw exn;
      }
    }
  }
}

function mark_type_used(env, name, vd) {
  if (is_implicit_coercion(env)) {
    return 0;
  } else {
    try {
      return Curry._1(Hashtbl.find(type_declarations, /* tuple */[
                      name,
                      vd[/* type_loc */7]
                    ]), /* () */0);
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        return /* () */0;
      } else {
        throw exn;
      }
    }
  }
}

function mark_constructor_used(usage, env, name, vd, constr) {
  if (is_implicit_coercion(env)) {
    return 0;
  } else {
    try {
      return Curry._1(Hashtbl.find(used_constructors, /* tuple */[
                      name,
                      vd[/* type_loc */7],
                      constr
                    ]), usage);
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        return /* () */0;
      } else {
        throw exn;
      }
    }
  }
}

function mark_extension_used(usage, env, ext, name) {
  if (is_implicit_coercion(env)) {
    return 0;
  } else {
    var ty_name = last(ext[/* ext_type_path */0]);
    try {
      return Curry._1(Hashtbl.find(used_constructors, /* tuple */[
                      ty_name,
                      ext[/* ext_loc */5],
                      name
                    ]), usage);
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        return /* () */0;
      } else {
        throw exn;
      }
    }
  }
}

function set_type_used_callback(name, td, callback) {
  var loc = td[/* type_loc */7];
  if (loc[/* loc_ghost */2]) {
    return /* () */0;
  } else {
    var key = /* tuple */[
      name,
      loc
    ];
    var old;
    try {
      old = Hashtbl.find(type_declarations, key);
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "env.ml",
                841,
                22
              ]
            ];
      } else {
        throw exn;
      }
    }
    return Hashtbl.replace(type_declarations, key, (function () {
                  return Curry._1(callback, old);
                }));
  }
}

function lookup_value$1(lid, env) {
  var r = lookup_value(lid, env);
  mark_value_used(env, last$1(lid), r[1]);
  return r;
}

function lookup_type$1(lid, env) {
  var match = lookup_type(lid, env);
  var decl = match[1][0];
  mark_type_used(env, last$1(lid), decl);
  return /* tuple */[
          match[0],
          decl
        ];
}

function mark_type_path(env, path) {
  try {
    var decl = find_type_full(path, env)[0];
    return mark_type_used(env, last(path), decl);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return /* () */0;
    } else {
      throw exn;
    }
  }
}

function ty_path(t) {
  var match = repr(t);
  var match$1 = match[/* desc */0];
  if (typeof match$1 === "number") {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "env.ml",
            871,
            9
          ]
        ];
  } else if (match$1.tag === 3) {
    return match$1[0];
  } else {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "env.ml",
            871,
            9
          ]
        ];
  }
}

function lookup_constructor(lid, env) {
  var match = lookup_all_constructors(lid, env);
  if (match) {
    var match$1 = match[0];
    var desc = match$1[0];
    mark_type_path(env, ty_path(desc[/* cstr_res */1]));
    Curry._1(match$1[1], /* () */0);
    return desc;
  } else {
    throw Caml_builtin_exceptions.not_found;
  }
}

function is_lident(param) {
  switch (param.tag | 0) {
    case 0 : 
        return /* true */1;
    case 1 : 
    case 2 : 
        return /* false */0;
    
  }
}

function lookup_all_constructors$1(lid, env) {
  try {
    var cstrs = lookup_all_constructors(lid, env);
    return List.map((function (param) {
                  var use = param[1];
                  var cstr = param[0];
                  return /* tuple */[
                          cstr,
                          (function (param) {
                              var desc = cstr;
                              var use$1 = use;
                              mark_type_path(env, ty_path(desc[/* cstr_res */1]));
                              return Curry._1(use$1, /* () */0);
                            })
                        ];
                }), cstrs);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      if (is_lident(lid)) {
        return /* [] */0;
      } else {
        throw exn;
      }
    } else {
      throw exn;
    }
  }
}

function mark_constructor(usage, env, name, desc) {
  if (is_implicit_coercion(env)) {
    return 0;
  } else {
    var match = desc[/* cstr_tag */5];
    var exit = 0;
    switch (match.tag | 0) {
      case 0 : 
      case 1 : 
          exit = 1;
          break;
      case 2 : 
          var ty_path$1 = ty_path(desc[/* cstr_res */1]);
          var ty_name = last(ty_path$1);
          try {
            return Curry._1(Hashtbl.find(used_constructors, /* tuple */[
                            ty_name,
                            desc[/* cstr_loc */11],
                            name
                          ]), usage);
          }
          catch (exn){
            if (exn === Caml_builtin_exceptions.not_found) {
              return /* () */0;
            } else {
              throw exn;
            }
          }
          break;
      
    }
    if (exit === 1) {
      var ty_path$2 = ty_path(desc[/* cstr_res */1]);
      var ty_decl;
      try {
        ty_decl = find_type_full(ty_path$2, env)[0];
      }
      catch (exn$1){
        if (exn$1 === Caml_builtin_exceptions.not_found) {
          throw [
                Caml_builtin_exceptions.assert_failure,
                [
                  "env.ml",
                  908,
                  64
                ]
              ];
        } else {
          throw exn$1;
        }
      }
      var ty_name$1 = last(ty_path$2);
      return mark_constructor_used(usage, env, ty_name$1, ty_decl, name);
    }
    
  }
}

function lookup_all_labels$1(lid, env) {
  try {
    var lbls = lookup_all_labels(lid, env);
    return List.map((function (param) {
                  var use = param[1];
                  var lbl = param[0];
                  return /* tuple */[
                          lbl,
                          (function (param) {
                              var desc = lbl;
                              var use$1 = use;
                              mark_type_path(env, ty_path(desc[/* lbl_res */1]));
                              return Curry._1(use$1, /* () */0);
                            })
                        ];
                }), lbls);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      if (is_lident(lid)) {
        return /* [] */0;
      } else {
        throw exn;
      }
    } else {
      throw exn;
    }
  }
}

function lookup_class$1(lid, env) {
  var r = lookup_class(lid, env);
  var desc = r[1];
  if (name(/* None */0, desc[/* cty_path */2]) === "") {
    lookup_type$1(lid, env);
  } else {
    mark_type_path(env, desc[/* cty_path */2]);
  }
  return r;
}

function lookup_cltype$1(lid, env) {
  var r = lookup_cltype(lid, env);
  var desc = r[1];
  if (name(/* None */0, desc[/* clty_path */2]) === "") {
    lookup_type$1(lid, env);
  } else {
    mark_type_path(env, desc[/* clty_path */2]);
  }
  mark_type_path(env, desc[/* clty_path */2]);
  return r;
}

var iter_env_cont = [/* [] */0];

function scrape_alias_safe(env, _mty) {
  while(true) {
    var mty = _mty;
    if (mty.tag === 3) {
      var path = mty[0];
      var exit = 0;
      switch (path.tag | 0) {
        case 0 : 
            if (path[0][/* stamp */0]) {
              exit = 1;
            } else {
              return /* false */0;
            }
            break;
        case 1 : 
        case 2 : 
            exit = 1;
            break;
        
      }
      if (exit === 1) {
        _mty = find_module(/* false */0, path, env)[/* md_type */0];
        continue ;
        
      }
      
    } else {
      return /* true */1;
    }
  };
}

function run_iter_cont(l) {
  iter_env_cont[0] = /* [] */0;
  List.iter((function (c) {
          return Curry._1(c, /* () */0);
        }), l);
  var cont = List.rev(iter_env_cont[0]);
  iter_env_cont[0] = /* [] */0;
  return cont;
}

function iter_types(f) {
  return (function (param, param$1) {
      var proj1 = function (env) {
        return env[/* types */3];
      };
      var proj2 = function (sc) {
        return sc[/* comp_types */3];
      };
      var f$1 = f;
      var env = param;
      iter((function (id, param) {
              return Curry._2(f$1, /* Pident */Block.__(0, [id]), param[0]);
            }), Curry._1(proj1, env));
      var iter_components = function (path, path$prime, mcomps) {
        var cont = function () {
          var match = get_arg(mcomps);
          var safe;
          if (match) {
            var match$1 = match[0];
            try {
              safe = scrape_alias_safe(match$1[0], match$1[3]);
            }
            catch (exn){
              if (exn === Caml_builtin_exceptions.not_found) {
                safe = /* false */0;
              } else {
                throw exn;
              }
            }
          } else {
            safe = /* true */1;
          }
          if (safe) {
            var match$2 = force(components_of_module_maker$prime[0], mcomps);
            if (match$2.tag) {
              return /* () */0;
            } else {
              var comps = match$2[0];
              iter$2((function (s, param) {
                      var n = param[1];
                      return Curry._2(f$1, /* Pdot */Block.__(1, [
                                    path,
                                    s,
                                    n
                                  ]), /* tuple */[
                                  /* Pdot */Block.__(1, [
                                      path$prime,
                                      s,
                                      n
                                    ]),
                                  param[0]
                                ]);
                    }), Curry._1(proj2, comps));
              return iter$2((function (s, param) {
                            var n = param[1];
                            return iter_components(/* Pdot */Block.__(1, [
                                          path,
                                          s,
                                          n
                                        ]), /* Pdot */Block.__(1, [
                                          path$prime,
                                          s,
                                          n
                                        ]), param[0]);
                          }), comps[/* comp_components */6]);
            }
          } else {
            return /* () */0;
          }
        };
        iter_env_cont[0] = /* :: */[
          /* tuple */[
            path,
            cont
          ],
          iter_env_cont[0]
        ];
        return /* () */0;
      };
      Hashtbl.iter((function (s, pso) {
              if (pso) {
                var id = /* Pident */Block.__(0, [/* record */[
                      /* stamp */0,
                      /* name */s,
                      /* flags */1
                    ]]);
                return iter_components(id, id, pso[0][/* ps_comps */2]);
              } else {
                return /* () */0;
              }
            }), persistent_structures);
      return iter((function (id, param) {
                    var match = param[0];
                    return iter_components(/* Pident */Block.__(0, [id]), match[0], match[1]);
                  }), env[/* components */6]);
    });
}

function same_types(env1, env2) {
  if (env1[/* types */3] === env2[/* types */3]) {
    return +(env1[/* components */6] === env2[/* components */6]);
  } else {
    return /* false */0;
  }
}

function used_persistent() {
  var r = [/* Empty */0];
  Hashtbl.iter((function (s, pso) {
          if (pso !== /* None */0) {
            r[0] = add$2(s, r[0]);
            return /* () */0;
          } else {
            return 0;
          }
        }), persistent_structures);
  return r[0];
}

function find_all_comps(proj, s, param) {
  var match = force(components_of_module_maker$prime[0], param[1]);
  if (match.tag) {
    return /* [] */0;
  } else {
    try {
      var match$1 = find$2(s, Curry._1(proj, match[0]));
      return /* :: */[
              /* tuple */[
                /* Pdot */Block.__(1, [
                    param[0],
                    s,
                    match$1[1]
                  ]),
                match$1[0]
              ],
              /* [] */0
            ];
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        return /* [] */0;
      } else {
        throw exn;
      }
    }
  }
}

function find_shadowed_comps(path, env) {
  switch (path.tag | 0) {
    case 0 : 
        return List.map((function (prim) {
                      return prim[0];
                    }), find_all(path[0][/* name */1], env[/* components */6]));
    case 1 : 
        var s = path[1];
        var l = find_shadowed_comps(path[0], env);
        return List.flatten(List.map((function (param) {
                          return find_all_comps((function (comps) {
                                        return comps[/* comp_components */6];
                                      }), s, param);
                        }), l));
    case 2 : 
        return /* [] */0;
    
  }
}

function find_shadowed(proj1, proj2, path, env) {
  switch (path.tag | 0) {
    case 0 : 
        return List.map((function (prim) {
                      return prim[0];
                    }), find_all(path[0][/* name */1], Curry._1(proj1, env)));
    case 1 : 
        var s = path[1];
        var l = find_shadowed_comps(path[0], env);
        return List.flatten(List.map((function (param) {
                          return find_all_comps(proj2, s, param);
                        }), l));
    case 2 : 
        return /* [] */0;
    
  }
}

function find_shadowed_types(path, env) {
  var l = find_shadowed((function (env) {
          return env[/* types */3];
        }), (function (comps) {
          return comps[/* comp_types */3];
        }), path, env);
  return List.map((function (prim) {
                return prim[0];
              }), l);
}

function add_gadt_instance_level(lv, env) {
  var newrecord = env.slice();
  newrecord[/* gadt_instances */12] = /* :: */[
    /* tuple */[
      lv,
      [/* Empty */0]
    ],
    env[/* gadt_instances */12]
  ];
  return newrecord;
}

function is_Tlink(param) {
  var match = param[/* desc */0];
  if (typeof match === "number" || match.tag !== 6) {
    return /* false */0;
  } else {
    return /* true */1;
  }
}

function gadt_instance_level(env, t) {
  var _param = env[/* gadt_instances */12];
  while(true) {
    var param = _param;
    if (param) {
      var match = param[0];
      var r = match[1];
      if (exists(is_Tlink, r[0])) {
        r[0] = fold$2((function (ty) {
                var partial_arg = repr(ty);
                return (function (param) {
                    return add$3(partial_arg, param);
                  });
              }), r[0], /* Empty */0);
      }
      if (mem$3(t, r[0])) {
        return /* Some */[match[0]];
      } else {
        _param = param[1];
        continue ;
        
      }
    } else {
      return /* None */0;
    }
  };
}

function add_gadt_instances(env, lv, tl) {
  var r;
  try {
    r = List.assoc(lv, env[/* gadt_instances */12]);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "env.ml",
              1066,
              59
            ]
          ];
    } else {
      throw exn;
    }
  }
  return set_typeset(r, List.fold_right(add$3, tl, r[0]));
}

function add_gadt_instance_chain(env, lv, t) {
  var r;
  try {
    r = List.assoc(lv, env[/* gadt_instances */12]);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "env.ml",
              1075,
              59
            ]
          ];
    } else {
      throw exn;
    }
  }
  var add_instance = function (t) {
    var t$1 = repr(t);
    if (mem$3(t$1, r[0])) {
      return 0;
    } else {
      set_typeset(r, add$3(t$1, r[0]));
      var match = t$1[/* desc */0];
      if (typeof match === "number" || match.tag !== 3) {
        return /* () */0;
      } else {
        return may(add_instance, find_expans(/* Private */0, match[0], match[2][0]));
      }
    }
  };
  return add_instance(t);
}

function scrape_alias(env, path, mty) {
  var exit = 0;
  switch (mty.tag | 0) {
    case 0 : 
        try {
          return scrape_alias(env, path, find_modtype_expansion(mty[0], env));
        }
        catch (exn){
          if (exn === Caml_builtin_exceptions.not_found) {
            return mty;
          } else {
            throw exn;
          }
        }
        break;
    case 1 : 
    case 2 : 
        exit = 1;
        break;
    case 3 : 
        var path$1 = mty[0];
        try {
          return scrape_alias(env, /* Some */[path$1], find_module(/* false */0, path$1, env)[/* md_type */0]);
        }
        catch (exn$1){
          if (exn$1 === Caml_builtin_exceptions.not_found) {
            return mty;
          } else {
            throw exn$1;
          }
        }
        break;
    
  }
  if (exit === 1) {
    if (path) {
      return Curry._3(strengthen[0], env, mty, path[0]);
    } else {
      return mty;
    }
  }
  
}

function constructors_of_type(ty_path, decl) {
  var match = decl[/* type_kind */2];
  if (typeof match === "number" || match.tag !== 1) {
    return /* [] */0;
  } else {
    var cstrs = match[0];
    var ty_res = newty2(100000000, /* Tconstr */Block.__(3, [
            ty_path,
            decl[/* type_params */0],
            [/* Mnil */0]
          ]));
    var cstrs$1 = cstrs;
    var priv = decl[/* type_private */3];
    var num_consts = [0];
    var num_nonconsts = [0];
    var num_normal = [0];
    List.iter((function (param) {
            if (param[/* cd_args */1]) {
              num_nonconsts[0] = num_nonconsts[0] + 1 | 0;
            } else {
              num_consts[0] = num_consts[0] + 1 | 0;
            }
            if (param[/* cd_res */2]) {
              return 0;
            } else {
              num_normal[0] = num_normal[0] + 1 | 0;
              return /* () */0;
            }
          }), cstrs$1);
    var describe_constructors = function (idx_const, idx_nonconst, param) {
      if (param) {
        var rem = param[1];
        var match = param[0];
        var cd_res = match[/* cd_res */2];
        var cd_args = match[/* cd_args */1];
        var cd_id = match[/* cd_id */0];
        var ty_res$1 = cd_res ? cd_res[0] : ty_res;
        var match$1 = cd_args ? /* tuple */[
            /* Cstr_block */Block.__(1, [idx_nonconst]),
            describe_constructors(idx_const, idx_nonconst + 1 | 0, rem)
          ] : /* tuple */[
            /* Cstr_constant */Block.__(0, [idx_const]),
            describe_constructors(idx_const + 1 | 0, idx_nonconst, rem)
          ];
        var existentials;
        if (cd_res) {
          var res_vars = free_vars(cd_res[0]);
          var arg_vars = free_vars(newty2(100000000, /* Ttuple */Block.__(2, [cd_args])));
          existentials = elements_aux$1(/* [] */0, diff$1(arg_vars, res_vars));
        } else {
          existentials = /* [] */0;
        }
        var cstr_000 = /* cstr_name */cd_id[/* name */1];
        var cstr_004 = /* cstr_arity */List.length(cd_args);
        var cstr_005 = /* cstr_tag */match$1[0];
        var cstr_006 = /* cstr_consts */num_consts[0];
        var cstr_007 = /* cstr_nonconsts */num_nonconsts[0];
        var cstr_008 = /* cstr_normal */num_normal[0];
        var cstr_009 = /* cstr_generalized */+(cd_res !== /* None */0);
        var cstr_011 = /* cstr_loc */match[/* cd_loc */3];
        var cstr_012 = /* cstr_attributes */match[/* cd_attributes */4];
        var cstr = /* record */[
          cstr_000,
          /* cstr_res */ty_res$1,
          /* cstr_existentials */existentials,
          /* cstr_args */cd_args,
          cstr_004,
          cstr_005,
          cstr_006,
          cstr_007,
          cstr_008,
          cstr_009,
          /* cstr_private */priv,
          cstr_011,
          cstr_012
        ];
        return /* :: */[
                /* tuple */[
                  cd_id,
                  cstr
                ],
                match$1[1]
              ];
      } else {
        return /* [] */0;
      }
    };
    return describe_constructors(0, 0, cstrs$1);
  }
}

function labels_of_type(ty_path, decl) {
  var match = decl[/* type_kind */2];
  if (typeof match === "number" || match.tag) {
    return /* [] */0;
  } else {
    var ty_res = newty2(100000000, /* Tconstr */Block.__(3, [
            ty_path,
            decl[/* type_params */0],
            [/* Mnil */0]
          ]));
    var lbls = match[0];
    var repres = match[1];
    var priv = decl[/* type_private */3];
    var all_labels = Caml_array.caml_make_vect(List.length(lbls), dummy_label);
    var describe_labels = function (num, param) {
      if (param) {
        var l = param[0];
        var lbl_000 = /* lbl_name */l[/* ld_id */0][/* name */1];
        var lbl_002 = /* lbl_arg */l[/* ld_type */2];
        var lbl_003 = /* lbl_mut */l[/* ld_mutable */1];
        var lbl_008 = /* lbl_loc */l[/* ld_loc */3];
        var lbl_009 = /* lbl_attributes */l[/* ld_attributes */4];
        var lbl = /* record */[
          lbl_000,
          /* lbl_res */ty_res,
          lbl_002,
          lbl_003,
          /* lbl_pos */num,
          /* lbl_all */all_labels,
          /* lbl_repres */repres,
          /* lbl_private */priv,
          lbl_008,
          lbl_009
        ];
        Caml_array.caml_array_set(all_labels, num, lbl);
        return /* :: */[
                /* tuple */[
                  l[/* ld_id */0],
                  lbl
                ],
                describe_labels(num + 1 | 0, param[1])
              ];
      } else {
        return /* [] */0;
      }
    };
    return describe_labels(0, lbls);
  }
}

function prefix_idents(root, pos, sub, param) {
  if (param) {
    var match = param[0];
    switch (match.tag | 0) {
      case 0 : 
          var p_001 = match[0][/* name */1];
          var p = /* Pdot */Block.__(1, [
              root,
              p_001,
              pos
            ]);
          var match$1 = match[1][/* val_kind */1];
          var nextpos;
          nextpos = typeof match$1 === "number" || match$1.tag ? pos + 1 | 0 : pos;
          var match$2 = prefix_idents(root, nextpos, sub, param[1]);
          return /* tuple */[
                  /* :: */[
                    p,
                    match$2[0]
                  ],
                  match$2[1]
                ];
      case 1 : 
          var id = match[0];
          var p_001$1 = id[/* name */1];
          var p$1 = /* Pdot */Block.__(1, [
              root,
              p_001$1,
              -1
            ]);
          var match$3 = prefix_idents(root, pos, add_type(id, p$1, sub), param[1]);
          return /* tuple */[
                  /* :: */[
                    p$1,
                    match$3[0]
                  ],
                  match$3[1]
                ];
      case 2 : 
          var p_001$2 = match[0][/* name */1];
          var p$2 = /* Pdot */Block.__(1, [
              root,
              p_001$2,
              pos
            ]);
          var match$4 = prefix_idents(root, pos + 1 | 0, sub, param[1]);
          return /* tuple */[
                  /* :: */[
                    p$2,
                    match$4[0]
                  ],
                  match$4[1]
                ];
      case 3 : 
          var id$1 = match[0];
          var p_001$3 = id$1[/* name */1];
          var p$3 = /* Pdot */Block.__(1, [
              root,
              p_001$3,
              pos
            ]);
          var match$5 = prefix_idents(root, pos + 1 | 0, add_module(id$1, p$3, sub), param[1]);
          return /* tuple */[
                  /* :: */[
                    p$3,
                    match$5[0]
                  ],
                  match$5[1]
                ];
      case 4 : 
          var id$2 = match[0];
          var p_001$4 = id$2[/* name */1];
          var p$4 = /* Pdot */Block.__(1, [
              root,
              p_001$4,
              -1
            ]);
          var match$6 = prefix_idents(root, pos, add_modtype(id$2, /* Mty_ident */Block.__(0, [p$4]), sub), param[1]);
          return /* tuple */[
                  /* :: */[
                    p$4,
                    match$6[0]
                  ],
                  match$6[1]
                ];
      case 5 : 
          var p_001$5 = match[0][/* name */1];
          var p$5 = /* Pdot */Block.__(1, [
              root,
              p_001$5,
              pos
            ]);
          var match$7 = prefix_idents(root, pos + 1 | 0, sub, param[1]);
          return /* tuple */[
                  /* :: */[
                    p$5,
                    match$7[0]
                  ],
                  match$7[1]
                ];
      case 6 : 
          var p_001$6 = match[0][/* name */1];
          var p$6 = /* Pdot */Block.__(1, [
              root,
              p_001$6,
              -1
            ]);
          var match$8 = prefix_idents(root, pos, sub, param[1]);
          return /* tuple */[
                  /* :: */[
                    p$6,
                    match$8[0]
                  ],
                  match$8[1]
                ];
      
    }
  } else {
    return /* tuple */[
            /* [] */0,
            sub
          ];
  }
}

function prefix_idents_and_subst(root, sub, sg) {
  var match = prefix_idents(root, 0, sub, sg);
  var sub$1 = match[1];
  return /* tuple */[
          match[0],
          sub$1,
          Block.__(246, [(function () {
                  var sub$2 = sub$1;
                  var sg$1 = sg;
                  return List.map((function (item) {
                                switch (item.tag | 0) {
                                  case 0 : 
                                      return /* Sig_value */Block.__(0, [
                                                item[0],
                                                value_description(sub$2, item[1])
                                              ]);
                                  case 1 : 
                                      return /* Sig_type */Block.__(1, [
                                                item[0],
                                                type_declaration(sub$2, item[1]),
                                                item[2]
                                              ]);
                                  case 2 : 
                                      return /* Sig_typext */Block.__(2, [
                                                item[0],
                                                extension_constructor(sub$2, item[1]),
                                                item[2]
                                              ]);
                                  case 3 : 
                                      return /* Sig_module */Block.__(3, [
                                                item[0],
                                                module_declaration(sub$2, item[1]),
                                                item[2]
                                              ]);
                                  case 4 : 
                                      return /* Sig_modtype */Block.__(4, [
                                                item[0],
                                                modtype_declaration(sub$2, item[1])
                                              ]);
                                  case 5 : 
                                      return /* Sig_class */Block.__(5, [
                                                item[0],
                                                class_declaration(sub$2, item[1]),
                                                item[2]
                                              ]);
                                  case 6 : 
                                      return /* Sig_class_type */Block.__(6, [
                                                item[0],
                                                cltype_declaration(sub$2, item[1]),
                                                item[2]
                                              ]);
                                  
                                }
                              }), sg$1);
                })])
        ];
}

function prefix_idents_and_subst$1(root, sub, sg) {
  if (Caml_obj.caml_equal(sub, identity)) {
    var sgs;
    try {
      sgs = Hashtbl.find(prefixed_sg, root);
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        var sgs$1 = [/* [] */0];
        Hashtbl.add(prefixed_sg, root, sgs$1);
        sgs = sgs$1;
      } else {
        throw exn;
      }
    }
    try {
      return List.assq(sg, sgs[0]);
    }
    catch (exn$1){
      if (exn$1 === Caml_builtin_exceptions.not_found) {
        var r = prefix_idents_and_subst(root, sub, sg);
        sgs[0] = /* :: */[
          /* tuple */[
            sg,
            r
          ],
          sgs[0]
        ];
        return r;
      } else {
        throw exn$1;
      }
    }
  } else {
    return prefix_idents_and_subst(root, sub, sg);
  }
}

function add_to_tbl(id, decl, tbl) {
  var decls;
  try {
    decls = find$2(id, tbl);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      decls = /* [] */0;
    } else {
      throw exn;
    }
  }
  return add$5(id, /* :: */[
              decl,
              decls
            ], tbl);
}

function components_of_module(env, sub, path, mty) {
  return [/* Thunk */Block.__(2, [/* tuple */[
                env,
                sub,
                path,
                mty
              ]])];
}

function store_modtype(slot, id, path, info, env, renv) {
  var newrecord = env.slice();
  newrecord[/* modtypes */5] = add$6("module type", slot, id, /* tuple */[
        path,
        info
      ], env[/* modtypes */5], renv[/* modtypes */5]);
  newrecord[/* summary */10] = /* Env_modtype */Block.__(4, [
      env[/* summary */10],
      id,
      info
    ]);
  return newrecord;
}

function store_module(slot, id, path, md, env, renv) {
  var newrecord = env.slice();
  newrecord[/* modules */4] = add$6("module", slot, id, /* tuple */[
        path,
        md
      ], env[/* modules */4], renv[/* modules */4]);
  newrecord[/* components */6] = add$6("module", slot, id, /* tuple */[
        path,
        components_of_module(env, identity, path, md[/* md_type */0])
      ], env[/* components */6], renv[/* components */6]);
  newrecord[/* summary */10] = /* Env_module */Block.__(3, [
      env[/* summary */10],
      id,
      md
    ]);
  return newrecord;
}

function store_type_infos(slot, id, path, info, env, renv) {
  var newrecord = env.slice();
  newrecord[/* types */3] = add$6("type", slot, id, /* tuple */[
        path,
        /* tuple */[
          info,
          /* tuple */[
            /* [] */0,
            /* [] */0
          ]
        ]
      ], env[/* types */3], renv[/* types */3]);
  newrecord[/* summary */10] = /* Env_type */Block.__(1, [
      env[/* summary */10],
      id,
      info
    ]);
  return newrecord;
}

function check_usage(loc, id, warn, tbl) {
  if (!loc[/* loc_ghost */2] && is_active(Curry._1(warn, ""))) {
    var name = id[/* name */1];
    var key = /* tuple */[
      name,
      loc
    ];
    if (Hashtbl.mem(tbl, key)) {
      return /* () */0;
    } else {
      var used = [/* false */0];
      Hashtbl.add(tbl, key, (function () {
              used[0] = /* true */1;
              return /* () */0;
            }));
      if (name === "" || Caml_string.get(name, 0) === /* "_" */95 || Caml_string.get(name, 0) === /* "#" */35) {
        return 0;
      } else {
        return Curry._1(add_delayed_check_forward[0], (function () {
                      if (used[0]) {
                        return 0;
                      } else {
                        return prerr_warning(loc, Curry._1(warn, name));
                      }
                    }));
      }
    }
  } else {
    return 0;
  }
}

function check_value_name(name, loc) {
  if (name.length > 0 && Caml_string.get(name, 0) === /* "#" */35) {
    for(var i = 1 ,i_finish = name.length - 1 | 0; i <= i_finish; ++i){
      if (Caml_string.get(name, i) === /* "#" */35) {
        throw [
              $$Error$2,
              /* Illegal_value_name */Block.__(4, [
                  loc,
                  name
                ])
            ];
      }
      
    }
    return /* () */0;
  } else {
    return 0;
  }
}

function components_of_module_maker(param) {
  var sub = param[1];
  var env = param[0];
  var match = scrape_alias(env, /* None */0, param[3]);
  var exit = 0;
  switch (match.tag | 0) {
    case 1 : 
        var sg = match[0];
        var c = /* record */[
          /* comp_values : Empty */0,
          /* comp_constrs : Empty */0,
          /* comp_labels : Empty */0,
          /* comp_types : Empty */0,
          /* comp_modules : Empty */0,
          /* comp_modtypes : Empty */0,
          /* comp_components : Empty */0,
          /* comp_classes : Empty */0,
          /* comp_cltypes : Empty */0
        ];
        var match$1 = prefix_idents_and_subst$1(param[2], sub, sg);
        var sub$1 = match$1[1];
        var env$1 = [env];
        var pos = [0];
        List.iter2((function (item, path) {
                switch (item.tag | 0) {
                  case 0 : 
                      var decl = item[1];
                      var decl$prime = value_description(sub$1, decl);
                      c[/* comp_values */0] = add$5(item[0][/* name */1], /* tuple */[
                            decl$prime,
                            pos[0]
                          ], c[/* comp_values */0]);
                      var match = decl[/* val_kind */1];
                      if (typeof match === "number") {
                        pos[0] = pos[0] + 1 | 0;
                        return /* () */0;
                      } else if (match.tag) {
                        pos[0] = pos[0] + 1 | 0;
                        return /* () */0;
                      } else {
                        return /* () */0;
                      }
                      break;
                  case 1 : 
                      var decl$1 = item[1];
                      var id = item[0];
                      var decl$prime$1 = type_declaration(sub$1, decl$1);
                      var constructors = List.map((function (prim) {
                              return prim[1];
                            }), constructors_of_type(path, decl$prime$1));
                      var labels = List.map((function (prim) {
                              return prim[1];
                            }), labels_of_type(path, decl$prime$1));
                      c[/* comp_types */3] = add$5(id[/* name */1], /* tuple */[
                            /* tuple */[
                              decl$prime$1,
                              /* tuple */[
                                constructors,
                                labels
                              ]
                            ],
                            -1
                          ], c[/* comp_types */3]);
                      List.iter((function (descr) {
                              c[/* comp_constrs */1] = add_to_tbl(descr[/* cstr_name */0], /* tuple */[
                                    descr,
                                    -1
                                  ], c[/* comp_constrs */1]);
                              return /* () */0;
                            }), constructors);
                      List.iter((function (descr) {
                              c[/* comp_labels */2] = add_to_tbl(descr[/* lbl_name */0], /* tuple */[
                                    descr,
                                    -1
                                  ], c[/* comp_labels */2]);
                              return /* () */0;
                            }), labels);
                      env$1[0] = store_type_infos(/* None */0, id, /* Pident */Block.__(0, [id]), decl$1, env$1[0], env$1[0]);
                      return /* () */0;
                  case 2 : 
                      var ext$prime = extension_constructor(sub$1, item[1]);
                      var descr = extension_descr(path, ext$prime);
                      c[/* comp_constrs */1] = add_to_tbl(item[0][/* name */1], /* tuple */[
                            descr,
                            pos[0]
                          ], c[/* comp_constrs */1]);
                      pos[0] = pos[0] + 1 | 0;
                      return /* () */0;
                  case 3 : 
                      var md = item[1];
                      var id$1 = item[0];
                      var mty = md[/* md_type */0];
                      var mty$prime = [/* Thunk */Block.__(2, [/* tuple */[
                              sub$1,
                              mty
                            ]])];
                      c[/* comp_modules */4] = add$5(id$1[/* name */1], /* tuple */[
                            mty$prime,
                            pos[0]
                          ], c[/* comp_modules */4]);
                      var comps = components_of_module(env$1[0], sub$1, path, mty);
                      c[/* comp_components */6] = add$5(id$1[/* name */1], /* tuple */[
                            comps,
                            pos[0]
                          ], c[/* comp_components */6]);
                      env$1[0] = store_module(/* None */0, id$1, /* Pident */Block.__(0, [id$1]), md, env$1[0], env$1[0]);
                      pos[0] = pos[0] + 1 | 0;
                      return /* () */0;
                  case 4 : 
                      var decl$2 = item[1];
                      var id$2 = item[0];
                      var decl$prime$2 = modtype_declaration(sub$1, decl$2);
                      c[/* comp_modtypes */5] = add$5(id$2[/* name */1], /* tuple */[
                            decl$prime$2,
                            -1
                          ], c[/* comp_modtypes */5]);
                      env$1[0] = store_modtype(/* None */0, id$2, /* Pident */Block.__(0, [id$2]), decl$2, env$1[0], env$1[0]);
                      return /* () */0;
                  case 5 : 
                      var decl$prime$3 = class_declaration(sub$1, item[1]);
                      c[/* comp_classes */7] = add$5(item[0][/* name */1], /* tuple */[
                            decl$prime$3,
                            pos[0]
                          ], c[/* comp_classes */7]);
                      pos[0] = pos[0] + 1 | 0;
                      return /* () */0;
                  case 6 : 
                      var decl$prime$4 = cltype_declaration(sub$1, item[1]);
                      c[/* comp_cltypes */8] = add$5(item[0][/* name */1], /* tuple */[
                            decl$prime$4,
                            pos[0]
                          ], c[/* comp_cltypes */8]);
                      return /* () */0;
                  
                }
              }), sg, match$1[0]);
        return /* Structure_comps */Block.__(0, [c]);
    case 2 : 
        return /* Functor_comps */Block.__(1, [/* record */[
                    /* fcomp_param */match[0],
                    /* fcomp_arg */may_map((function (param) {
                            return modtype(sub, param);
                          }), match[1]),
                    /* fcomp_res */match[2],
                    /* fcomp_env */env,
                    /* fcomp_subst */sub,
                    /* fcomp_cache */Hashtbl.create(/* None */0, 17),
                    /* fcomp_subst_cache */Hashtbl.create(/* None */0, 17)
                  ]]);
    case 0 : 
    case 3 : 
        exit = 1;
        break;
    
  }
  if (exit === 1) {
    return /* Structure_comps */Block.__(0, [/* record */[
                /* comp_values : Empty */0,
                /* comp_constrs : Empty */0,
                /* comp_labels : Empty */0,
                /* comp_types : Empty */0,
                /* comp_modules : Empty */0,
                /* comp_modtypes : Empty */0,
                /* comp_components : Empty */0,
                /* comp_classes : Empty */0,
                /* comp_cltypes : Empty */0
              ]]);
  }
  
}

function store_value(check, slot, id, path, decl, env, renv) {
  check_value_name(id[/* name */1], decl[/* val_loc */2]);
  may((function (f) {
          return check_usage(decl[/* val_loc */2], id, f, value_declarations);
        }), check);
  var newrecord = env.slice();
  newrecord[/* values */0] = add$6("value", slot, id, /* tuple */[
        path,
        decl
      ], env[/* values */0], renv[/* values */0]);
  newrecord[/* summary */10] = /* Env_value */Block.__(0, [
      env[/* summary */10],
      id,
      decl
    ]);
  return newrecord;
}

function store_type(check, slot, id, path, info, env, renv) {
  var loc = info[/* type_loc */7];
  if (check) {
    check_usage(loc, id, (function (s) {
            return /* Unused_type_declaration */Block.__(18, [s]);
          }), type_declarations);
  }
  var constructors = constructors_of_type(path, info);
  var labels = labels_of_type(path, info);
  var descrs_000 = List.map((function (prim) {
          return prim[1];
        }), constructors);
  var descrs_001 = List.map((function (prim) {
          return prim[1];
        }), labels);
  var descrs = /* tuple */[
    descrs_000,
    descrs_001
  ];
  if (check && !loc[/* loc_ghost */2] && is_active(/* Unused_constructor */Block.__(21, [
            "",
            /* false */0,
            /* false */0
          ]))) {
    var ty = id[/* name */1];
    List.iter((function (param) {
            var c = param[1][/* cstr_name */0];
            var k = /* tuple */[
              ty,
              loc,
              c
            ];
            if (Hashtbl.mem(used_constructors, k)) {
              return 0;
            } else {
              var used = /* record */[
                /* cu_positive : false */0,
                /* cu_pattern : false */0,
                /* cu_privatize : false */0
              ];
              Hashtbl.add(used_constructors, k, (function (param) {
                      return add_constructor_usage(used, param);
                    }));
              if (ty === "" || Caml_string.get(ty, 0) === /* "_" */95) {
                return 0;
              } else {
                return Curry._1(add_delayed_check_forward[0], (function () {
                              if (!is_in_signature(env) && !used[/* cu_positive */0]) {
                                return prerr_warning(loc, /* Unused_constructor */Block.__(21, [
                                              c,
                                              used[/* cu_pattern */1],
                                              used[/* cu_privatize */2]
                                            ]));
                              } else {
                                return 0;
                              }
                            }));
              }
            }
          }), constructors);
  }
  var newrecord = env.slice();
  newrecord[/* constrs */1] = List.fold_right((function (param, constrs) {
          return add$6("constructor", slot, param[0], param[1], constrs, renv[/* constrs */1]);
        }), constructors, env[/* constrs */1]);
  newrecord[/* labels */2] = List.fold_right((function (param, labels) {
          return add$6("label", slot, param[0], param[1], labels, renv[/* labels */2]);
        }), labels, env[/* labels */2]);
  newrecord[/* types */3] = add$6("type", slot, id, /* tuple */[
        path,
        /* tuple */[
          info,
          descrs
        ]
      ], env[/* types */3], renv[/* types */3]);
  newrecord[/* summary */10] = /* Env_type */Block.__(1, [
      env[/* summary */10],
      id,
      info
    ]);
  return newrecord;
}

function store_extension(check, slot, id, path, ext, env, renv) {
  var loc = ext[/* ext_loc */5];
  if (check && !loc[/* loc_ghost */2] && is_active(/* Unused_extension */Block.__(22, [
            "",
            /* false */0,
            /* false */0
          ]))) {
    var ty = last(ext[/* ext_type_path */0]);
    var n = id[/* name */1];
    var k = /* tuple */[
      ty,
      loc,
      n
    ];
    if (!Hashtbl.mem(used_constructors, k)) {
      var used = /* record */[
        /* cu_positive : false */0,
        /* cu_pattern : false */0,
        /* cu_privatize : false */0
      ];
      Hashtbl.add(used_constructors, k, (function (param) {
              return add_constructor_usage(used, param);
            }));
      Curry._1(add_delayed_check_forward[0], (function () {
              if (!is_in_signature(env) && !used[/* cu_positive */0]) {
                return prerr_warning(loc, /* Unused_extension */Block.__(22, [
                              n,
                              used[/* cu_pattern */1],
                              used[/* cu_privatize */2]
                            ]));
              } else {
                return 0;
              }
            }));
    }
    
  }
  var newrecord = env.slice();
  newrecord[/* constrs */1] = add$6("constructor", slot, id, extension_descr(path, ext), env[/* constrs */1], renv[/* constrs */1]);
  newrecord[/* summary */10] = /* Env_extension */Block.__(2, [
      env[/* summary */10],
      id,
      ext
    ]);
  return newrecord;
}

function store_class(slot, id, path, desc, env, renv) {
  var newrecord = env.slice();
  newrecord[/* classes */7] = add$6("class", slot, id, /* tuple */[
        path,
        desc
      ], env[/* classes */7], renv[/* classes */7]);
  newrecord[/* summary */10] = /* Env_class */Block.__(5, [
      env[/* summary */10],
      id,
      desc
    ]);
  return newrecord;
}

function store_cltype(slot, id, path, desc, env, renv) {
  var newrecord = env.slice();
  newrecord[/* cltypes */8] = add$6("class type", slot, id, /* tuple */[
        path,
        desc
      ], env[/* cltypes */8], renv[/* cltypes */8]);
  newrecord[/* summary */10] = /* Env_cltype */Block.__(6, [
      env[/* summary */10],
      id,
      desc
    ]);
  return newrecord;
}

function components_of_functor_appl(f, p1, p2) {
  try {
    return Hashtbl.find(f[/* fcomp_cache */5], p2);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      var p = /* Papply */Block.__(2, [
          p1,
          p2
        ]);
      var mty = modtype(add_module(f[/* fcomp_param */0], p2, identity), f[/* fcomp_res */2]);
      var comps = components_of_module(f[/* fcomp_env */3], f[/* fcomp_subst */4], p, mty);
      Hashtbl.add(f[/* fcomp_cache */5], p2, comps);
      return comps;
    } else {
      throw exn;
    }
  }
}

components_of_module$prime[0] = components_of_module;

components_of_functor_appl$prime[0] = components_of_functor_appl;

components_of_module_maker$prime[0] = components_of_module_maker;

function add_value(check, id, desc, env) {
  return store_value(check, /* None */0, id, /* Pident */Block.__(0, [id]), desc, env, env);
}

function add_type$1(check, id, info, env) {
  return store_type(check, /* None */0, id, /* Pident */Block.__(0, [id]), info, env, env);
}

function add_extension(check, id, ext, env) {
  return store_extension(check, /* None */0, id, /* Pident */Block.__(0, [id]), ext, env, env);
}

function add_module_declaration(arg, id, md, env) {
  var path = /* Pident */Block.__(0, [id]);
  var env$1 = store_module(/* None */0, id, path, md, env, env);
  var $staropt$star = arg;
  var id$1 = id;
  var env$2 = env$1;
  var arg$1 = $staropt$star ? $staropt$star[0] : /* false */0;
  if (arg$1) {
    var newrecord = env$2.slice();
    newrecord[/* functor_args */9] = add(id$1, /* () */0, env$2[/* functor_args */9]);
    newrecord[/* summary */10] = /* Env_functor_arg */Block.__(8, [
        env$2[/* summary */10],
        id$1
      ]);
    return newrecord;
  } else {
    return env$2;
  }
}

function add_modtype$1(id, info, env) {
  return store_modtype(/* None */0, id, /* Pident */Block.__(0, [id]), info, env, env);
}

function add_class(id, ty, env) {
  return store_class(/* None */0, id, /* Pident */Block.__(0, [id]), ty, env, env);
}

function add_cltype(id, ty, env) {
  return store_cltype(/* None */0, id, /* Pident */Block.__(0, [id]), ty, env, env);
}

function add_module$1(arg, id, mty, env) {
  return add_module_declaration(arg, id, md(mty), env);
}

function add_local_constraint(id, info, elv, env) {
  if (info[/* type_manifest */4]) {
    var match = info[/* type_newtype_level */6];
    if (match) {
      var newrecord = info.slice();
      var env$1 = add_type$1(/* false */0, id, (newrecord[/* type_newtype_level */6] = /* Some */[/* tuple */[
                match[0][0],
                elv
              ]], newrecord), env);
      var newrecord$1 = env$1.slice();
      newrecord$1[/* local_constraints */11] = /* true */1;
      return newrecord$1;
    } else {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "env.ml",
              1538,
              9
            ]
          ];
    }
  } else {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "env.ml",
            1538,
            9
          ]
        ];
  }
}

function enter(store_fun, name, data, env) {
  var id = create(name);
  return /* tuple */[
          id,
          Curry._6(store_fun, /* None */0, id, /* Pident */Block.__(0, [id]), data, env, env)
        ];
}

function enter_type(param, param$1, param$2) {
  return enter((function (param, param$1, param$2, param$3, param$4, param$5) {
                return store_type(/* true */1, param, param$1, param$2, param$3, param$4, param$5);
              }), param, param$1, param$2);
}

function enter_module_declaration(arg, name, md, env) {
  var id = create(name);
  return /* tuple */[
          id,
          add_module_declaration(arg, id, md, env)
        ];
}

function enter_modtype(param, param$1, param$2) {
  return enter(store_modtype, param, param$1, param$2);
}

function enter_module(arg, s, mty, env) {
  return enter_module_declaration(arg, s, md(mty), env);
}

function add_item(comp, env) {
  switch (comp.tag | 0) {
    case 0 : 
        return add_value(/* None */0, comp[0], comp[1], env);
    case 1 : 
        return add_type$1(/* false */0, comp[0], comp[1], env);
    case 2 : 
        return add_extension(/* false */0, comp[0], comp[1], env);
    case 3 : 
        return add_module_declaration(/* None */0, comp[0], comp[1], env);
    case 4 : 
        return add_modtype$1(comp[0], comp[1], env);
    case 5 : 
        return add_class(comp[0], comp[1], env);
    case 6 : 
        return add_cltype(comp[0], comp[1], env);
    
  }
}

function add_signature(_sg, _env) {
  while(true) {
    var env = _env;
    var sg = _sg;
    if (sg) {
      _env = add_item(sg[0], env);
      _sg = sg[1];
      continue ;
      
    } else {
      return env;
    }
  };
}

function open_signature(slot, root, sg, env0) {
  var match = prefix_idents_and_subst$1(root, identity, sg);
  var sg$1 = match[2];
  var tag = sg$1.tag | 0;
  var sg$2 = tag === 250 ? sg$1[0] : (
      tag === 246 ? CamlinternalLazy.force_lazy_block(sg$1) : sg$1
    );
  var newenv = List.fold_left2((function (env, item, p) {
          switch (item.tag | 0) {
            case 0 : 
                return store_value(/* None */0, slot, hide(item[0]), p, item[1], env, env0);
            case 1 : 
                return store_type(/* false */0, slot, hide(item[0]), p, item[1], env, env0);
            case 2 : 
                return store_extension(/* false */0, slot, hide(item[0]), p, item[1], env, env0);
            case 3 : 
                return store_module(slot, hide(item[0]), p, item[1], env, env0);
            case 4 : 
                return store_modtype(slot, hide(item[0]), p, item[1], env, env0);
            case 5 : 
                return store_class(slot, hide(item[0]), p, item[1], env, env0);
            case 6 : 
                return store_cltype(slot, hide(item[0]), p, item[1], env, env0);
            
          }
        }), env0, sg$2, match[0]);
  var newrecord = newenv.slice();
  newrecord[/* summary */10] = /* Env_open */Block.__(7, [
      env0[/* summary */10],
      root
    ]);
  return newrecord;
}

function open_signature$1($staropt$star, $staropt$star$1, ovf, root, sg, env) {
  var loc = $staropt$star ? $staropt$star[0] : none;
  var toplevel = $staropt$star$1 ? $staropt$star$1[0] : /* false */0;
  if (!toplevel && ovf === /* Fresh */1 && !loc[/* loc_ghost */2] && (is_active(/* Unused_open */Block.__(17, [""])) || is_active(/* Open_shadow_identifier */Block.__(27, [
              "",
              ""
            ])) || is_active(/* Open_shadow_label_constructor */Block.__(28, [
              "",
              ""
            ])))) {
    var used = [/* false */0];
    Curry._1(add_delayed_check_forward[0], (function () {
            if (used[0]) {
              return 0;
            } else {
              return prerr_warning(loc, /* Unused_open */Block.__(17, [name(/* None */0, root)]));
            }
          }));
    var shadowed = [/* [] */0];
    var slot = function (kind, s, b) {
      if (b && !List.mem(/* tuple */[
              kind,
              s
            ], shadowed[0])) {
        shadowed[0] = /* :: */[
          /* tuple */[
            kind,
            s
          ],
          shadowed[0]
        ];
        var w;
        switch (kind) {
          case "constructor" : 
          case "label" : 
              w = /* Open_shadow_label_constructor */Block.__(28, [
                  kind,
                  s
                ]);
              break;
          default:
            w = /* Open_shadow_identifier */Block.__(27, [
                kind,
                s
              ]);
        }
        prerr_warning(loc, w);
      }
      used[0] = /* true */1;
      return /* () */0;
    };
    return open_signature(/* Some */[slot], root, sg, env);
  } else {
    return open_signature(/* None */0, root, sg, env);
  }
}

function read_signature(modname, filename) {
  var ps = read_pers_struct(modname, filename);
  check_consistency(ps);
  return ps[/* ps_sig */1];
}

function imports() {
  var l = elements_aux$2(/* [] */0, imported_units[0]);
  var tbl = crc_units;
  var l$1 = List.sort_uniq($$String.compare, l);
  return List.fold_left((function (assc, name) {
                try {
                  var match = Hashtbl.find(tbl, name);
                  return /* :: */[
                          /* tuple */[
                            name,
                            /* Some */[match[0]]
                          ],
                          assc
                        ];
                }
                catch (exn){
                  if (exn === Caml_builtin_exceptions.not_found) {
                    return /* :: */[
                            /* tuple */[
                              name,
                              /* None */0
                            ],
                            assc
                          ];
                  } else {
                    throw exn;
                  }
                }
              }), /* [] */0, l$1);
}

function save_signature(sg, modname, filename) {
  var sg$1 = sg;
  var modname$1 = modname;
  var filename$1 = filename;
  var imports$1 = imports(/* () */0);
  cleanup_abbrev(/* () */0);
  new_id$1[0] = -1;
  var sg$2 = signature$2(for_saving(identity), sg$1);
  var oc = Pervasives.open_out_bin(filename$1);
  try {
    var cmi_003 = /* cmi_flags */recursive_types[0] ? /* :: */[
        /* Rectypes */0,
        /* [] */0
      ] : /* [] */0;
    var cmi = /* record */[
      /* cmi_name */modname$1,
      /* cmi_sign */sg$2,
      /* cmi_crcs */imports$1,
      cmi_003
    ];
    var crc = output_cmi(filename$1, oc, cmi);
    Caml_io.caml_ml_flush(oc);
    Caml_missing_polyfill.not_implemented("caml_ml_close_channel not implemented by bucklescript yet\n");
    var comps = components_of_module(empty, identity, /* Pident */Block.__(0, [/* record */[
              /* stamp */0,
              /* name */modname$1,
              /* flags */1
            ]]), /* Mty_signature */Block.__(1, [sg$2]));
    var ps = /* record */[
      /* ps_name */modname$1,
      /* ps_sig */sg$2,
      /* ps_comps */comps,
      /* ps_crcs : :: */[
        /* tuple */[
          modname$1,
          /* Some */[crc]
        ],
        imports$1
      ],
      /* ps_crcs_checked : false */0,
      /* ps_filename */filename$1,
      cmi_003
    ];
    save_pers_struct(crc, ps);
    return sg$2;
  }
  catch (exn){
    Caml_io.caml_ml_flush(oc);
    Caml_missing_polyfill.not_implemented("caml_ml_close_channel not implemented by bucklescript yet\n");
    remove_file(filename$1);
    throw exn;
  }
}

function find_all$1(proj1, proj2, f, lid, env, acc) {
  if (lid) {
    var match = lookup_module_descr(lid[0], env);
    var p = match[0];
    var match$1 = force(components_of_module_maker, match[1]);
    if (match$1.tag) {
      return acc;
    } else {
      return fold$4((function (s, param, acc) {
                    return Curry._4(f, s, /* Pdot */Block.__(1, [
                                  p,
                                  s,
                                  param[1]
                                ]), param[0], acc);
                  }), Curry._1(proj2, match$1[0]), acc);
    }
  } else {
    return fold_name((function (id, param, acc) {
                    return Curry._4(f, id[/* name */1], param[0], param[1], acc);
                  }))(Curry._1(proj1, env), acc);
  }
}

function find_all_simple_list(proj1, proj2, f, lid, env, acc) {
  if (lid) {
    var match = lookup_module_descr(lid[0], env);
    var match$1 = force(components_of_module_maker, match[1]);
    if (match$1.tag) {
      return acc;
    } else {
      return fold$4((function (_, comps, acc) {
                    if (comps) {
                      return Curry._2(f, comps[0][0], acc);
                    } else {
                      return acc;
                    }
                  }), Curry._1(proj2, match$1[0]), acc);
    }
  } else {
    return fold_name((function (_, data, acc) {
                    return Curry._2(f, data, acc);
                  }))(Curry._1(proj1, env), acc);
  }
}

function fold_modules(f, lid, env, acc) {
  if (lid) {
    var match = lookup_module_descr(lid[0], env);
    var p = match[0];
    var match$1 = force(components_of_module_maker, match[1]);
    if (match$1.tag) {
      return acc;
    } else {
      return fold$4((function (s, param, acc) {
                    return Curry._4(f, s, /* Pdot */Block.__(1, [
                                  p,
                                  s,
                                  param[1]
                                ]), md(force(subst_modtype_maker, param[0])), acc);
                  }), match$1[0][/* comp_modules */4], acc);
    }
  } else {
    var acc$1 = fold_name((function (id, param, acc) {
              return Curry._4(f, id[/* name */1], param[0], param[1], acc);
            }))(env[/* modules */4], acc);
    return Hashtbl.fold((function (name, ps, acc) {
                  if (ps) {
                    return Curry._4(f, name, /* Pident */Block.__(0, [/* record */[
                                    /* stamp */0,
                                    /* name */name,
                                    /* flags */1
                                  ]]), md(/* Mty_signature */Block.__(1, [ps[0][/* ps_sig */1]])), acc);
                  } else {
                    return acc;
                  }
                }), persistent_structures, acc$1);
  }
}

function fold_values(f) {
  return (function (param, param$1, param$2) {
      return find_all$1((function (env) {
                    return env[/* values */0];
                  }), (function (sc) {
                    return sc[/* comp_values */0];
                  }), f, param, param$1, param$2);
    });
}

function fold_constructors(f) {
  return (function (param, param$1, param$2) {
      return find_all_simple_list((function (env) {
                    return env[/* constrs */1];
                  }), (function (sc) {
                    return sc[/* comp_constrs */1];
                  }), f, param, param$1, param$2);
    });
}

function fold_labels(f) {
  return (function (param, param$1, param$2) {
      return find_all_simple_list((function (env) {
                    return env[/* labels */2];
                  }), (function (sc) {
                    return sc[/* comp_labels */2];
                  }), f, param, param$1, param$2);
    });
}

function fold_types(f) {
  return (function (param, param$1, param$2) {
      return find_all$1((function (env) {
                    return env[/* types */3];
                  }), (function (sc) {
                    return sc[/* comp_types */3];
                  }), f, param, param$1, param$2);
    });
}

function fold_modtypes(f) {
  return (function (param, param$1, param$2) {
      return find_all$1((function (env) {
                    return env[/* modtypes */5];
                  }), (function (sc) {
                    return sc[/* comp_modtypes */5];
                  }), f, param, param$1, param$2);
    });
}

function fold_classs(f) {
  return (function (param, param$1, param$2) {
      return find_all$1((function (env) {
                    return env[/* classes */7];
                  }), (function (sc) {
                    return sc[/* comp_classes */7];
                  }), f, param, param$1, param$2);
    });
}

function fold_cltypes(f) {
  return (function (param, param$1, param$2) {
      return find_all$1((function (env) {
                    return env[/* cltypes */8];
                  }), (function (sc) {
                    return sc[/* comp_cltypes */8];
                  }), f, param, param$1, param$2);
    });
}

var match = build_initial_env((function (param, param$1, param$2) {
        return add_type$1(/* false */0, param, param$1, param$2);
      }), (function (param, param$1, param$2) {
        return add_extension(/* false */0, param, param$1, param$2);
      }), empty);

var initial_safe_string = match[0];

var last_env = [empty];

var last_reduced_env = [empty];

function keep_only_summary(env) {
  if (last_env[0] === env) {
    return last_reduced_env[0];
  } else {
    var newrecord = empty.slice();
    newrecord[/* summary */10] = env[/* summary */10];
    newrecord[/* local_constraints */11] = env[/* local_constraints */11];
    newrecord[/* flags */13] = env[/* flags */13];
    last_env[0] = env;
    last_reduced_env[0] = newrecord;
    return newrecord;
  }
}

function report_error$1(ppf, param) {
  switch (param.tag | 0) {
    case 0 : 
        return Curry._4(Format.fprintf(ppf, /* Format */[
                        /* String_literal */Block.__(11, [
                            "Wrong file naming: ",
                            /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                    /* Break */Block.__(0, [
                                        "@ ",
                                        1,
                                        0
                                      ]),
                                    /* String_literal */Block.__(11, [
                                        "contains the compiled interface for ",
                                        /* Formatting_lit */Block.__(17, [
                                            /* Break */Block.__(0, [
                                                "@ ",
                                                1,
                                                0
                                              ]),
                                            /* String */Block.__(2, [
                                                /* No_padding */0,
                                                /* String_literal */Block.__(11, [
                                                    " when ",
                                                    /* String */Block.__(2, [
                                                        /* No_padding */0,
                                                        /* String_literal */Block.__(11, [
                                                            " was expected",
                                                            /* End_of_format */0
                                                          ])
                                                      ])
                                                  ])
                                              ])
                                          ])
                                      ])
                                  ])])
                          ]),
                        "Wrong file naming: %a@ contains the compiled interface for @ %s when %s was expected"
                      ]), print_filename, param[2], param[0], param[1]);
    case 1 : 
        return Curry._5(Format.fprintf(ppf, /* Format */[
                        /* Formatting_gen */Block.__(18, [
                            /* Open_box */Block.__(1, [/* Format */[
                                  /* String_literal */Block.__(11, [
                                      "<hov>",
                                      /* End_of_format */0
                                    ]),
                                  "<hov>"
                                ]]),
                            /* String_literal */Block.__(11, [
                                "The files ",
                                /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                        /* Break */Block.__(0, [
                                            "@ ",
                                            1,
                                            0
                                          ]),
                                        /* String_literal */Block.__(11, [
                                            "and ",
                                            /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                    /* Break */Block.__(0, [
                                                        "@ ",
                                                        1,
                                                        0
                                                      ]),
                                                    /* String_literal */Block.__(11, [
                                                        "make inconsistent assumptions",
                                                        /* Formatting_lit */Block.__(17, [
                                                            /* Break */Block.__(0, [
                                                                "@ ",
                                                                1,
                                                                0
                                                              ]),
                                                            /* String_literal */Block.__(11, [
                                                                "over interface ",
                                                                /* String */Block.__(2, [
                                                                    /* No_padding */0,
                                                                    /* Formatting_lit */Block.__(17, [
                                                                        /* Close_box */0,
                                                                        /* End_of_format */0
                                                                      ])
                                                                  ])
                                                              ])
                                                          ])
                                                      ])
                                                  ])])
                                          ])
                                      ])])
                              ])
                          ]),
                        "@[<hov>The files %a@ and %a@ make inconsistent assumptions@ over interface %s@]"
                      ]), print_filename, param[1], print_filename, param[2], param[0]);
    case 2 : 
        return Curry._3(Format.fprintf(ppf, /* Format */[
                        /* Formatting_gen */Block.__(18, [
                            /* Open_box */Block.__(1, [/* Format */[
                                  /* String_literal */Block.__(11, [
                                      "<hov>",
                                      /* End_of_format */0
                                    ]),
                                  "<hov>"
                                ]]),
                            /* String_literal */Block.__(11, [
                                "Unit ",
                                /* String */Block.__(2, [
                                    /* No_padding */0,
                                    /* String_literal */Block.__(11, [
                                        " imports from ",
                                        /* String */Block.__(2, [
                                            /* No_padding */0,
                                            /* String_literal */Block.__(11, [
                                                ", which uses recursive types.",
                                                /* Formatting_lit */Block.__(17, [
                                                    /* Break */Block.__(0, [
                                                        "@ ",
                                                        1,
                                                        0
                                                      ]),
                                                    /* String */Block.__(2, [
                                                        /* No_padding */0,
                                                        /* Formatting_lit */Block.__(17, [
                                                            /* Close_box */0,
                                                            /* End_of_format */0
                                                          ])
                                                      ])
                                                  ])
                                              ])
                                          ])
                                      ])
                                  ])
                              ])
                          ]),
                        "@[<hov>Unit %s imports from %s, which uses recursive types.@ %s@]"
                      ]), param[1], param[0], "The compilation flag -rectypes is required");
    case 3 : 
        var path2 = param[2];
        var path1 = param[1];
        Format.fprintf(ppf, /* Format */[
              /* Formatting_gen */Block.__(18, [
                  /* Open_box */Block.__(1, [/* Format */[
                        /* End_of_format */0,
                        ""
                      ]]),
                  /* Formatting_gen */Block.__(18, [
                      /* Open_box */Block.__(1, [/* Format */[
                            /* String_literal */Block.__(11, [
                                "<hov>",
                                /* End_of_format */0
                              ]),
                            "<hov>"
                          ]]),
                      /* End_of_format */0
                    ])
                ]),
              "@[@[<hov>"
            ]);
        if (same(path1, path2)) {
          Curry._1(Format.fprintf(ppf, /* Format */[
                    /* String_literal */Block.__(11, [
                        "Internal path",
                        /* Formatting_lit */Block.__(17, [
                            /* Break */Block.__(0, [
                                "@ ",
                                1,
                                0
                              ]),
                            /* String */Block.__(2, [
                                /* No_padding */0,
                                /* Formatting_lit */Block.__(17, [
                                    /* Break */Block.__(0, [
                                        "@ ",
                                        1,
                                        0
                                      ]),
                                    /* String_literal */Block.__(11, [
                                        "is dangling.",
                                        /* End_of_format */0
                                      ])
                                  ])
                              ])
                          ])
                      ]),
                    "Internal path@ %s@ is dangling."
                  ]), name(/* None */0, path1));
        } else {
          Curry._2(Format.fprintf(ppf, /* Format */[
                    /* String_literal */Block.__(11, [
                        "Internal path",
                        /* Formatting_lit */Block.__(17, [
                            /* Break */Block.__(0, [
                                "@ ",
                                1,
                                0
                              ]),
                            /* String */Block.__(2, [
                                /* No_padding */0,
                                /* Formatting_lit */Block.__(17, [
                                    /* Break */Block.__(0, [
                                        "@ ",
                                        1,
                                        0
                                      ]),
                                    /* String_literal */Block.__(11, [
                                        "expands to",
                                        /* Formatting_lit */Block.__(17, [
                                            /* Break */Block.__(0, [
                                                "@ ",
                                                1,
                                                0
                                              ]),
                                            /* String */Block.__(2, [
                                                /* No_padding */0,
                                                /* Formatting_lit */Block.__(17, [
                                                    /* Break */Block.__(0, [
                                                        "@ ",
                                                        1,
                                                        0
                                                      ]),
                                                    /* String_literal */Block.__(11, [
                                                        "which is dangling.",
                                                        /* End_of_format */0
                                                      ])
                                                  ])
                                              ])
                                          ])
                                      ])
                                  ])
                              ])
                          ])
                      ]),
                    "Internal path@ %s@ expands to@ %s@ which is dangling."
                  ]), name(/* None */0, path1), name(/* None */0, path2));
        }
        return Curry._3(Format.fprintf(ppf, /* Format */[
                        /* Formatting_lit */Block.__(17, [
                            /* Close_box */0,
                            /* Formatting_lit */Block.__(17, [
                                /* Break */Block.__(0, [
                                    "@ ",
                                    1,
                                    0
                                  ]),
                                /* Formatting_gen */Block.__(18, [
                                    /* Open_box */Block.__(1, [/* Format */[
                                          /* End_of_format */0,
                                          ""
                                        ]]),
                                    /* String */Block.__(2, [
                                        /* No_padding */0,
                                        /* Formatting_lit */Block.__(17, [
                                            /* Break */Block.__(0, [
                                                "@ ",
                                                1,
                                                0
                                              ]),
                                            /* String */Block.__(2, [
                                                /* No_padding */0,
                                                /* Formatting_lit */Block.__(17, [
                                                    /* Break */Block.__(0, [
                                                        "@ ",
                                                        1,
                                                        0
                                                      ]),
                                                    /* String */Block.__(2, [
                                                        /* No_padding */0,
                                                        /* Char_literal */Block.__(12, [
                                                            /* "." */46,
                                                            /* Formatting_lit */Block.__(17, [
                                                                /* Close_box */0,
                                                                /* Formatting_lit */Block.__(17, [
                                                                    /* Close_box */0,
                                                                    /* End_of_format */0
                                                                  ])
                                                              ])
                                                          ])
                                                      ])
                                                  ])
                                              ])
                                          ])
                                      ])
                                  ])
                              ])
                          ]),
                        "@]@ @[%s@ %s@ %s.@]@]"
                      ]), "The compiled interface for module", head(path2)[/* name */1], "was not found");
    case 4 : 
        return Curry._1(Format.fprintf(ppf, /* Format */[
                        /* Char_literal */Block.__(12, [
                            /* "'" */39,
                            /* String */Block.__(2, [
                                /* No_padding */0,
                                /* String_literal */Block.__(11, [
                                    "' is not a valid value identifier.",
                                    /* End_of_format */0
                                  ])
                              ])
                          ]),
                        "'%s' is not a valid value identifier."
                      ]), param[1]);
    
  }
}

register_error_of_exn((function (param) {
        if (param[0] === $$Error$2) {
          var err = param[1];
          var exit = 0;
          switch (err.tag | 0) {
            case 3 : 
            case 4 : 
                exit = 1;
                break;
            default:
              return /* Some */[error_of_printer_file(report_error$1, err)];
          }
          if (exit === 1) {
            var loc = err[0];
            if (Caml_obj.caml_notequal(loc, none)) {
              return /* Some */[error_of_printer(loc, report_error$1, err)];
            } else {
              return /* Some */[error_of_printer_file(report_error$1, err)];
            }
          }
          
        } else {
          return /* None */0;
        }
      }));

function assert_fail(msg) {
  Assert.fail(/* () */0, /* () */0, msg, "");
  return /* () */0;
}

function is_mocha() {
  var match = $$Array.to_list(Process.argv);
  if (match) {
    var match$1 = match[1];
    if (match$1) {
      var exec = Path.basename(match$1[0]);
      if (exec === "mocha") {
        return /* true */1;
      } else {
        return +(exec === "_mocha");
      }
    } else {
      return /* false */0;
    }
  } else {
    return /* false */0;
  }
}

function close_enough($staropt$star, a, b) {
  var threshold = $staropt$star ? $staropt$star[0] : 0.0000001;
  return +(Math.abs(a - b) < threshold);
}

function from_pair_suites(name, suites) {
  var match = $$Array.to_list(Process.argv);
  if (match) {
    if (is_mocha(/* () */0)) {
      describe(name, (function () {
              return List.iter((function (param) {
                            var code = param[1];
                            it(param[0], (function () {
                                    var match = Curry._1(code, /* () */0);
                                    switch (match.tag | 0) {
                                      case 0 : 
                                          Assert.deepEqual(match[0], match[1]);
                                          return /* () */0;
                                      case 1 : 
                                          Assert.notDeepEqual(match[0], match[1]);
                                          return /* () */0;
                                      case 2 : 
                                          Assert.strictEqual(match[0], match[1]);
                                          return /* () */0;
                                      case 3 : 
                                          Assert.notStrictEqual(match[0], match[1]);
                                          return /* () */0;
                                      case 4 : 
                                          var b = match[0];
                                          Assert.ok(b ? true : false);
                                          return /* () */0;
                                      case 5 : 
                                          var b$1 = match[1];
                                          var a = match[0];
                                          if (close_enough(/* None */0, a, b$1)) {
                                            return 0;
                                          } else {
                                            Assert.deepEqual(a, b$1);
                                            return /* () */0;
                                          }
                                      case 6 : 
                                          var b$2 = match[2];
                                          var a$1 = match[1];
                                          if (close_enough(/* Some */[match[0]], a$1, b$2)) {
                                            return 0;
                                          } else {
                                            Assert.deepEqual(a$1, b$2);
                                            return /* () */0;
                                          }
                                      case 7 : 
                                          Assert.throws(match[0]);
                                          return /* () */0;
                                      case 8 : 
                                          return assert_fail("failed");
                                      case 9 : 
                                          return assert_fail(match[0]);
                                      
                                    }
                                  }));
                            return /* () */0;
                          }), suites);
            }));
      return /* () */0;
    } else {
      var name$1 = name;
      var suites$1 = suites;
      console.log(/* tuple */[
            name$1,
            "testing"
          ]);
      return List.iter((function (param) {
                    var name = param[0];
                    var match = Curry._1(param[1], /* () */0);
                    switch (match.tag | 0) {
                      case 0 : 
                          console.log(/* tuple */[
                                name,
                                match[0],
                                "eq?",
                                match[1]
                              ]);
                          return /* () */0;
                      case 1 : 
                          console.log(/* tuple */[
                                name,
                                match[0],
                                "neq?",
                                match[1]
                              ]);
                          return /* () */0;
                      case 2 : 
                          console.log(/* tuple */[
                                name,
                                match[0],
                                "strict_eq?",
                                match[1]
                              ]);
                          return /* () */0;
                      case 3 : 
                          console.log(/* tuple */[
                                name,
                                match[0],
                                "strict_neq?",
                                match[1]
                              ]);
                          return /* () */0;
                      case 4 : 
                          console.log(/* tuple */[
                                name,
                                match[0],
                                "ok?"
                              ]);
                          return /* () */0;
                      case 5 : 
                          console.log(/* tuple */[
                                name,
                                match[0],
                                "~",
                                match[1]
                              ]);
                          return /* () */0;
                      case 6 : 
                          console.log(/* tuple */[
                                name,
                                match[1],
                                "~",
                                match[2],
                                " (",
                                match[0],
                                ")"
                              ]);
                          return /* () */0;
                      case 7 : 
                          return /* () */0;
                      case 8 : 
                          console.log("failed");
                          return /* () */0;
                      case 9 : 
                          console.log("failed: " + match[0]);
                          return /* () */0;
                      
                    }
                  }), suites$1);
    }
  } else {
    return /* () */0;
  }
}

var $$Error$3 = Caml_exceptions.create("Ocaml_typedtree_test.Syntaxerr.Error");

var Escape_error = Caml_exceptions.create("Ocaml_typedtree_test.Syntaxerr.Escape_error");

function prepare_error(param) {
  switch (param.tag | 0) {
    case 0 : 
        var closing = param[3];
        var opening = param[1];
        return Curry._1(errorf(/* Some */[param[2]], /* Some */[/* :: */[
                          Curry._1(errorf(/* Some */[param[0]], /* None */0, /* None */0, /* Format */[
                                    /* String_literal */Block.__(11, [
                                        "This '",
                                        /* String */Block.__(2, [
                                            /* No_padding */0,
                                            /* String_literal */Block.__(11, [
                                                "' might be unmatched",
                                                /* End_of_format */0
                                              ])
                                          ])
                                      ]),
                                    "This '%s' might be unmatched"
                                  ]), opening),
                          /* [] */0
                        ]], /* Some */[Curry._2(Printf.sprintf(/* Format */[
                                  /* String_literal */Block.__(11, [
                                      "Syntax error: '",
                                      /* String */Block.__(2, [
                                          /* No_padding */0,
                                          /* String_literal */Block.__(11, [
                                              "' expected, the highlighted '",
                                              /* String */Block.__(2, [
                                                  /* No_padding */0,
                                                  /* String_literal */Block.__(11, [
                                                      "' might be unmatched",
                                                      /* End_of_format */0
                                                    ])
                                                ])
                                            ])
                                        ])
                                    ]),
                                  "Syntax error: '%s' expected, the highlighted '%s' might be unmatched"
                                ]), closing, opening)], /* Format */[
                        /* String_literal */Block.__(11, [
                            "Syntax error: '",
                            /* String */Block.__(2, [
                                /* No_padding */0,
                                /* String_literal */Block.__(11, [
                                    "' expected",
                                    /* End_of_format */0
                                  ])
                              ])
                          ]),
                        "Syntax error: '%s' expected"
                      ]), closing);
    case 1 : 
        return Curry._1(errorf(/* Some */[param[0]], /* None */0, /* None */0, /* Format */[
                        /* String_literal */Block.__(11, [
                            "Syntax error: ",
                            /* String */Block.__(2, [
                                /* No_padding */0,
                                /* String_literal */Block.__(11, [
                                    " expected.",
                                    /* End_of_format */0
                                  ])
                              ])
                          ]),
                        "Syntax error: %s expected."
                      ]), param[1]);
    case 2 : 
        return Curry._1(errorf(/* Some */[param[0]], /* None */0, /* None */0, /* Format */[
                        /* String_literal */Block.__(11, [
                            "Syntax error: ",
                            /* String */Block.__(2, [
                                /* No_padding */0,
                                /* String_literal */Block.__(11, [
                                    " not expected.",
                                    /* End_of_format */0
                                  ])
                              ])
                          ]),
                        "Syntax error: %s not expected."
                      ]), param[1]);
    case 3 : 
        return errorf(/* Some */[param[0]], /* None */0, /* None */0, /* Format */[
                    /* String_literal */Block.__(11, [
                        "Syntax error: applicative paths of the form F(X).t are not supported when the option -no-app-func is set.",
                        /* End_of_format */0
                      ]),
                    "Syntax error: applicative paths of the form F(X).t are not supported when the option -no-app-func is set."
                  ]);
    case 4 : 
        var $$var = param[1];
        return Curry._2(errorf(/* Some */[param[0]], /* None */0, /* None */0, /* Format */[
                        /* String_literal */Block.__(11, [
                            "In this scoped type, variable '",
                            /* String */Block.__(2, [
                                /* No_padding */0,
                                /* String_literal */Block.__(11, [
                                    " is reserved for the local type ",
                                    /* String */Block.__(2, [
                                        /* No_padding */0,
                                        /* Char_literal */Block.__(12, [
                                            /* "." */46,
                                            /* End_of_format */0
                                          ])
                                      ])
                                  ])
                              ])
                          ]),
                        "In this scoped type, variable '%s is reserved for the local type %s."
                      ]), $$var, $$var);
    case 5 : 
        return errorf(/* Some */[param[0]], /* None */0, /* None */0, /* Format */[
                    /* String_literal */Block.__(11, [
                        "Syntax error",
                        /* End_of_format */0
                      ]),
                    "Syntax error"
                  ]);
    case 6 : 
        return Curry._1(errorf(/* Some */[param[0]], /* None */0, /* None */0, /* Format */[
                        /* String_literal */Block.__(11, [
                            "broken invariant in parsetree: ",
                            /* String */Block.__(2, [
                                /* No_padding */0,
                                /* End_of_format */0
                              ])
                          ]),
                        "broken invariant in parsetree: %s"
                      ]), param[1]);
    
  }
}

register_error_of_exn((function (param) {
        if (param[0] === $$Error$3) {
          return /* Some */[prepare_error(param[1])];
        } else {
          return /* None */0;
        }
      }));

function ill_formed_ast(loc, s) {
  throw [
        $$Error$3,
        /* Ill_formed_ast */Block.__(6, [
            loc,
            s
          ])
      ];
}

function mktyp(d) {
  return mk(/* Some */[symbol_rloc(/* () */0)], /* None */0, d);
}

function mkpat(d) {
  return mk$1(/* Some */[symbol_rloc(/* () */0)], /* None */0, d);
}

function mkexp(d) {
  return Curry._3(Ast_helper_004[/* mk */0], /* Some */[symbol_rloc(/* () */0)], /* None */0, d);
}

function mkmty(d) {
  return mk$3(/* Some */[symbol_rloc(/* () */0)], /* None */0, d);
}

function mksig(d) {
  return mk$5(/* Some */[symbol_rloc(/* () */0)], d);
}

function mkmod(d) {
  return mk$4(/* Some */[symbol_rloc(/* () */0)], /* None */0, d);
}

function mkstr(d) {
  return mk$6(/* Some */[symbol_rloc(/* () */0)], d);
}

function mkclass(d) {
  return mk$7(/* Some */[symbol_rloc(/* () */0)], /* None */0, d);
}

function mkcty(d) {
  return mk$8(/* Some */[symbol_rloc(/* () */0)], /* None */0, d);
}

function mkctf(attrs, docs, d) {
  return Curry._4(Ast_helper_019[/* mk */0], /* Some */[symbol_rloc(/* () */0)], attrs, docs, d);
}

function mkcf(attrs, docs, d) {
  return Curry._4(Ast_helper_021[/* mk */0], /* Some */[symbol_rloc(/* () */0)], attrs, docs, d);
}

function mkrhs(rhs, pos) {
  return /* record */[
          /* txt */rhs,
          /* loc */rhs_loc(pos)
        ];
}

function mkoption(d) {
  var init = d[/* ptyp_loc */1];
  var loc_000 = /* loc_start */init[/* loc_start */0];
  var loc_001 = /* loc_end */init[/* loc_end */1];
  var loc = /* record */[
    loc_000,
    loc_001,
    /* loc_ghost : true */1
  ];
  return mk(/* Some */[loc], /* None */0, /* Ptyp_constr */Block.__(3, [
                /* record */[
                  /* txt : Ldot */Block.__(1, [
                      /* Lident */Block.__(0, ["*predef*"]),
                      "option"
                    ]),
                  /* loc */loc
                ],
                /* :: */[
                  d,
                  /* [] */0
                ]
              ]));
}

function reloc_pat(x) {
  return /* record */[
          /* ppat_desc */x[/* ppat_desc */0],
          /* ppat_loc */symbol_rloc(/* () */0),
          /* ppat_attributes */x[/* ppat_attributes */2]
        ];
}

function reloc_exp(x) {
  return /* record */[
          /* pexp_desc */x[/* pexp_desc */0],
          /* pexp_loc */symbol_rloc(/* () */0),
          /* pexp_attributes */x[/* pexp_attributes */2]
        ];
}

function mkoperator(name, pos) {
  var loc = rhs_loc(pos);
  return Curry._3(Ast_helper_004[/* mk */0], /* Some */[loc], /* None */0, /* Pexp_ident */Block.__(0, [/* record */[
                  /* txt : Lident */Block.__(0, [name]),
                  /* loc */loc
                ]]));
}

function mkpatvar(name, pos) {
  return mk$1(/* Some */[rhs_loc(pos)], /* None */0, /* Ppat_var */Block.__(0, [mkrhs(name, pos)]));
}

function ghexp(d) {
  return Curry._3(Ast_helper_004[/* mk */0], /* Some */[symbol_gloc(/* () */0)], /* None */0, d);
}

function ghpat(d) {
  return mk$1(/* Some */[symbol_gloc(/* () */0)], /* None */0, d);
}

function ghtyp(d) {
  return mk(/* Some */[symbol_gloc(/* () */0)], /* None */0, d);
}

function ghloc(d) {
  return /* record */[
          /* txt */d,
          /* loc */symbol_gloc(/* () */0)
        ];
}

function mkinfix(arg1, name, arg2) {
  return mkexp(/* Pexp_apply */Block.__(5, [
                mkoperator(name, 2),
                /* :: */[
                  /* tuple */[
                    "",
                    arg1
                  ],
                  /* :: */[
                    /* tuple */[
                      "",
                      arg2
                    ],
                    /* [] */0
                  ]
                ]
              ]));
}

function neg_float_string(f) {
  if (f.length > 0 && Caml_string.get(f, 0) === /* "-" */45) {
    return $$String.sub(f, 1, f.length - 1 | 0);
  } else {
    return "-" + f;
  }
}

function mkexp_cons(consloc, args, loc) {
  return Curry._3(Ast_helper_004[/* mk */0], /* Some */[loc], /* None */0, /* Pexp_construct */Block.__(9, [
                /* record */[
                  /* txt : Lident */Block.__(0, ["::"]),
                  /* loc */consloc
                ],
                /* Some */[args]
              ]));
}

function mkpat_cons(consloc, args, loc) {
  return mk$1(/* Some */[loc], /* None */0, /* Ppat_construct */Block.__(5, [
                /* record */[
                  /* txt : Lident */Block.__(0, ["::"]),
                  /* loc */consloc
                ],
                /* Some */[args]
              ]));
}

function mktailexp(nilloc, param) {
  if (param) {
    var e1 = param[0];
    var exp_el = mktailexp(nilloc, param[1]);
    var loc_000 = /* loc_start */e1[/* pexp_loc */1][/* loc_start */0];
    var loc_001 = /* loc_end */exp_el[/* pexp_loc */1][/* loc_end */1];
    var loc = /* record */[
      loc_000,
      loc_001,
      /* loc_ghost : true */1
    ];
    var arg = Curry._3(Ast_helper_004[/* mk */0], /* Some */[loc], /* None */0, /* Pexp_tuple */Block.__(8, [/* :: */[
              e1,
              /* :: */[
                exp_el,
                /* [] */0
              ]
            ]]));
    return mkexp_cons(/* record */[
                loc_000,
                loc_001,
                /* loc_ghost : true */1
              ], arg, loc);
  } else {
    var loc_000$1 = /* loc_start */nilloc[/* loc_start */0];
    var loc_001$1 = /* loc_end */nilloc[/* loc_end */1];
    var loc$1 = /* record */[
      loc_000$1,
      loc_001$1,
      /* loc_ghost : true */1
    ];
    var nil_000 = /* txt : Lident */Block.__(0, ["[]"]);
    var nil = /* record */[
      nil_000,
      /* loc */loc$1
    ];
    return Curry._3(Ast_helper_004[/* mk */0], /* Some */[loc$1], /* None */0, /* Pexp_construct */Block.__(9, [
                  nil,
                  /* None */0
                ]));
  }
}

function mktailpat(nilloc, param) {
  if (param) {
    var p1 = param[0];
    var pat_pl = mktailpat(nilloc, param[1]);
    var loc_000 = /* loc_start */p1[/* ppat_loc */1][/* loc_start */0];
    var loc_001 = /* loc_end */pat_pl[/* ppat_loc */1][/* loc_end */1];
    var loc = /* record */[
      loc_000,
      loc_001,
      /* loc_ghost : true */1
    ];
    var arg = mk$1(/* Some */[loc], /* None */0, /* Ppat_tuple */Block.__(4, [/* :: */[
              p1,
              /* :: */[
                pat_pl,
                /* [] */0
              ]
            ]]));
    return mkpat_cons(/* record */[
                loc_000,
                loc_001,
                /* loc_ghost : true */1
              ], arg, loc);
  } else {
    var loc_000$1 = /* loc_start */nilloc[/* loc_start */0];
    var loc_001$1 = /* loc_end */nilloc[/* loc_end */1];
    var loc$1 = /* record */[
      loc_000$1,
      loc_001$1,
      /* loc_ghost : true */1
    ];
    var nil_000 = /* txt : Lident */Block.__(0, ["[]"]);
    var nil = /* record */[
      nil_000,
      /* loc */loc$1
    ];
    return mk$1(/* Some */[loc$1], /* None */0, /* Ppat_construct */Block.__(5, [
                  nil,
                  /* None */0
                ]));
  }
}

function mkstrexp(e, attrs) {
  return /* record */[
          /* pstr_desc : Pstr_eval */Block.__(0, [
              e,
              attrs
            ]),
          /* pstr_loc */e[/* pexp_loc */1]
        ];
}

function mkexp_constraint(e, param) {
  var t2 = param[1];
  var t1 = param[0];
  if (t1) {
    if (t2) {
      return ghexp(/* Pexp_coerce */Block.__(20, [
                    e,
                    t1,
                    t2[0]
                  ]));
    } else {
      return ghexp(/* Pexp_constraint */Block.__(19, [
                    e,
                    t1[0]
                  ]));
    }
  } else if (t2) {
    return ghexp(/* Pexp_coerce */Block.__(20, [
                  e,
                  t1,
                  t2[0]
                ]));
  } else {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "parsing/parser.mly",
            153,
            18
          ]
        ];
  }
}

function array_function(str, name) {
  return ghloc(/* Ldot */Block.__(1, [
                /* Lident */Block.__(0, [str]),
                fast[0] ? "unsafe_" + name : name
              ]));
}

function unclosed(opening_name, opening_num, closing_name, closing_num) {
  throw [
        $$Error$3,
        /* Unclosed */Block.__(0, [
            rhs_loc(opening_num),
            opening_name,
            rhs_loc(closing_num),
            closing_name
          ])
      ];
}

function expecting(pos, nonterm) {
  throw [
        $$Error$3,
        /* Expecting */Block.__(1, [
            rhs_loc(pos),
            nonterm
          ])
      ];
}

function not_expecting(pos, nonterm) {
  throw [
        $$Error$3,
        /* Not_expecting */Block.__(2, [
            rhs_loc(pos),
            nonterm
          ])
      ];
}

function bigarray_function(str, name) {
  return ghloc(/* Ldot */Block.__(1, [
                /* Ldot */Block.__(1, [
                    /* Lident */Block.__(0, ["Bigarray"]),
                    str
                  ]),
                name
              ]));
}

function bigarray_untuplify(exp) {
  var match = exp[/* pexp_desc */0];
  if (match.tag === 8) {
    return match[0];
  } else {
    return /* :: */[
            exp,
            /* [] */0
          ];
  }
}

function exp_of_label(lbl, pos) {
  return mkexp(/* Pexp_ident */Block.__(0, [mkrhs(/* Lident */Block.__(0, [last$1(lbl)]), pos)]));
}

function pat_of_label(lbl, pos) {
  return mkpat(/* Ppat_var */Block.__(0, [mkrhs(last$1(lbl), pos)]));
}

function check_variable(vl, loc, v) {
  if (List.mem(v, vl)) {
    throw [
          $$Error$3,
          /* Variable_in_scope */Block.__(4, [
              loc,
              v
            ])
        ];
  } else {
    return 0;
  }
}

function varify_constructors(var_names, t) {
  var loop = function (t) {
    var match = t[/* ptyp_desc */0];
    var desc;
    if (typeof match === "number") {
      desc = /* Ptyp_any */0;
    } else {
      switch (match.tag | 0) {
        case 0 : 
            var x = match[0];
            check_variable(var_names, t[/* ptyp_loc */1], x);
            desc = /* Ptyp_var */Block.__(0, [x]);
            break;
        case 1 : 
            desc = /* Ptyp_arrow */Block.__(1, [
                match[0],
                loop(match[1]),
                loop(match[2])
              ]);
            break;
        case 2 : 
            desc = /* Ptyp_tuple */Block.__(2, [List.map(loop, match[0])]);
            break;
        case 3 : 
            var longident = match[0];
            var match$1 = longident[/* txt */0];
            var exit = 0;
            switch (match$1.tag | 0) {
              case 0 : 
                  if (match[1]) {
                    exit = 1;
                  } else {
                    var s = match$1[0];
                    if (List.mem(s, var_names)) {
                      desc = /* Ptyp_var */Block.__(0, [s]);
                    } else {
                      exit = 1;
                    }
                  }
                  break;
              case 1 : 
              case 2 : 
                  exit = 1;
                  break;
              
            }
            if (exit === 1) {
              desc = /* Ptyp_constr */Block.__(3, [
                  longident,
                  List.map(loop, match[1])
                ]);
            }
            break;
        case 4 : 
            desc = /* Ptyp_object */Block.__(4, [
                List.map((function (param) {
                        return /* tuple */[
                                param[0],
                                param[1],
                                loop(param[2])
                              ];
                      }), match[0]),
                match[1]
              ]);
            break;
        case 5 : 
            desc = /* Ptyp_class */Block.__(5, [
                match[0],
                List.map(loop, match[1])
              ]);
            break;
        case 6 : 
            var string = match[1];
            check_variable(var_names, t[/* ptyp_loc */1], string);
            desc = /* Ptyp_alias */Block.__(6, [
                loop(match[0]),
                string
              ]);
            break;
        case 7 : 
            desc = /* Ptyp_variant */Block.__(7, [
                List.map(loop_row_field, match[0]),
                match[1],
                match[2]
              ]);
            break;
        case 8 : 
            var string_lst = match[0];
            var partial_arg = t[/* ptyp_loc */1];
            List.iter((function (param) {
                    return check_variable(var_names, partial_arg, param);
                  }), string_lst);
            desc = /* Ptyp_poly */Block.__(8, [
                string_lst,
                loop(match[1])
              ]);
            break;
        case 9 : 
            var match$2 = match[0];
            desc = /* Ptyp_package */Block.__(9, [/* tuple */[
                  match$2[0],
                  List.map((function (param) {
                          return /* tuple */[
                                  param[0],
                                  loop(param[1])
                                ];
                        }), match$2[1])
                ]]);
            break;
        case 10 : 
            var match$3 = match[0];
            desc = /* Ptyp_extension */Block.__(10, [/* tuple */[
                  match$3[0],
                  match$3[1]
                ]]);
            break;
        
      }
    }
    return /* record */[
            /* ptyp_desc */desc,
            /* ptyp_loc */t[/* ptyp_loc */1],
            /* ptyp_attributes */t[/* ptyp_attributes */2]
          ];
  };
  var loop_row_field = function (param) {
    if (param.tag) {
      return /* Rinherit */Block.__(1, [loop(param[0])]);
    } else {
      return /* Rtag */Block.__(0, [
                param[0],
                param[1],
                param[2],
                List.map(loop, param[3])
              ]);
    }
  };
  return loop(t);
}

function wrap_type_annotation(newtypes, core_type, body) {
  var exp = mkexp(/* Pexp_constraint */Block.__(19, [
          body,
          core_type
        ]));
  var exp$1 = List.fold_right((function (newtype, exp) {
          return mkexp(/* Pexp_newtype */Block.__(30, [
                        newtype,
                        exp
                      ]));
        }), newtypes, exp);
  return /* tuple */[
          exp$1,
          ghtyp(/* Ptyp_poly */Block.__(8, [
                  newtypes,
                  varify_constructors(newtypes, core_type)
                ]))
        ];
}

function wrap_exp_attrs(body, param) {
  var ext = param[0];
  var body_000 = /* pexp_desc */body[/* pexp_desc */0];
  var body_001 = /* pexp_loc */body[/* pexp_loc */1];
  var body_002 = /* pexp_attributes */Pervasives.$at(param[1], body[/* pexp_attributes */2]);
  var body$1 = /* record */[
    body_000,
    body_001,
    body_002
  ];
  if (ext) {
    return ghexp(/* Pexp_extension */Block.__(33, [/* tuple */[
                    ext[0],
                    /* PStr */Block.__(0, [/* :: */[
                          mkstrexp(body$1, /* [] */0),
                          /* [] */0
                        ]])
                  ]]));
  } else {
    return body$1;
  }
}

function text_str(pos) {
  return text$1(get_text(Parsing.rhs_start_pos(pos)));
}

function text_sig(pos) {
  return text(get_text(Parsing.rhs_start_pos(pos)));
}

function text_cstr(pos) {
  return Curry._1(Ast_helper_021[/* text */9], get_text(Parsing.rhs_start_pos(pos)));
}

function text_csig(pos) {
  return Curry._1(Ast_helper_019[/* text */8], get_text(Parsing.rhs_start_pos(pos)));
}

function text_def(pos) {
  return /* :: */[
          /* Ptop_def */Block.__(0, [text$1(get_text(Parsing.rhs_start_pos(pos)))]),
          /* [] */0
        ];
}

function extra_text(text, pos, items) {
  var pre_extras = get_pre_extra_text(Parsing.rhs_start_pos(pos));
  var post_extras = get_post_extra_text(Parsing.rhs_end_pos(pos));
  return Pervasives.$at(Curry._1(text, pre_extras), Pervasives.$at(items, Curry._1(text, post_extras)));
}

function extra_str(pos, items) {
  return extra_text(text$1, pos, items);
}

function extra_sig(pos, items) {
  return extra_text(text, pos, items);
}

function extra_cstr(pos, items) {
  return extra_text(Ast_helper_021[/* text */9], pos, items);
}

function extra_csig(pos, items) {
  return extra_text(Ast_helper_019[/* text */8], pos, items);
}

function add_nonrec(rf, attrs, pos) {
  if (rf !== 0) {
    return attrs;
  } else {
    var name_001 = /* loc */rhs_loc(pos);
    var name = /* record */[
      /* txt */"nonrec",
      name_001
    ];
    return /* :: */[
            /* tuple */[
              name,
              /* PStr */Block.__(0, [/* [] */0])
            ],
            attrs
          ];
  }
}

function mklb(param, attrs) {
  return /* record */[
          /* lb_pattern */param[0],
          /* lb_expression */param[1],
          /* lb_attributes */attrs,
          /* lb_docs */symbol_docs_lazy(/* () */0),
          /* lb_text */symbol_text_lazy(/* () */0),
          /* lb_loc */symbol_rloc(/* () */0)
        ];
}

var yytransl_const = /* array */[
  257,
  258,
  259,
  260,
  261,
  262,
  263,
  264,
  265,
  266,
  267,
  269,
  270,
  271,
  272,
  273,
  274,
  275,
  276,
  277,
  278,
  279,
  280,
  281,
  282,
  0,
  283,
  284,
  285,
  286,
  288,
  289,
  290,
  291,
  292,
  293,
  294,
  295,
  296,
  297,
  303,
  304,
  309,
  310,
  311,
  312,
  313,
  314,
  315,
  316,
  317,
  318,
  319,
  320,
  322,
  323,
  324,
  325,
  326,
  327,
  328,
  329,
  330,
  331,
  332,
  334,
  335,
  336,
  337,
  338,
  340,
  341,
  342,
  343,
  344,
  346,
  347,
  348,
  349,
  350,
  351,
  352,
  353,
  354,
  355,
  357,
  358,
  360,
  361,
  362,
  363,
  364,
  365,
  366,
  368,
  369,
  370,
  371,
  372,
  373,
  376,
  0
];

var yytransl_block = /* array */[
  268,
  287,
  298,
  299,
  300,
  301,
  302,
  305,
  306,
  307,
  308,
  321,
  333,
  339,
  345,
  356,
  359,
  367,
  374,
  375,
  0
];

var yyact = /* array */[
  (function () {
      throw [
            Caml_builtin_exceptions.failure,
            "parser"
          ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      return extra_str(1, _1);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      return extra_sig(1, _1);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      return /* Ptop_def */Block.__(0, [extra_str(1, _1)]);
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 1);
    }),
  (function () {
      throw Caml_builtin_exceptions.end_of_file;
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return Pervasives.$at(text_str(1), /* :: */[
                  mkstrexp(_1, _2),
                  /* [] */0
                ]);
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function () {
      return /* [] */0;
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return Pervasives.$at(text_str(1), /* :: */[
                  _1,
                  _2
                ]);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      var pos = 1;
      var items = _1;
      return extra_text((function (txt) {
                    return /* :: */[
                            /* Ptop_def */Block.__(0, [text$1(txt)]),
                            /* [] */0
                          ];
                  }), pos, items);
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _2 = Parsing.peek_val(__caml_parser_env, 1);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return Pervasives.$at(text_def(1), /* :: */[
                  /* Ptop_def */Block.__(0, [/* :: */[
                        mkstrexp(_1, _2),
                        /* [] */0
                      ]]),
                  _3
                ]);
    }),
  (function () {
      return /* [] */0;
    }),
  (function () {
      return text_def(1);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 1);
      var _4 = Parsing.peek_val(__caml_parser_env, 0);
      mark_rhs_docs(2, 3);
      return Pervasives.$at(text_def(1), Pervasives.$at(text_def(2), /* :: */[
                      /* Ptop_def */Block.__(0, [/* :: */[
                            mkstrexp(_2, _3),
                            /* [] */0
                          ]]),
                      _4
                    ]));
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 1);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return Pervasives.$at(text_def(1), Pervasives.$at(text_def(2), /* :: */[
                      /* Ptop_def */Block.__(0, [/* :: */[
                            _2,
                            /* [] */0
                          ]]),
                      _3
                    ]));
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 1);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      mark_rhs_docs(2, 3);
      return Pervasives.$at(text_def(1), Pervasives.$at(text_def(2), /* :: */[
                      _2,
                      _3
                    ]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return Pervasives.$at(text_def(1), /* :: */[
                  /* Ptop_def */Block.__(0, [/* :: */[
                        _1,
                        /* [] */0
                      ]]),
                  _2
                ]);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      mark_rhs_docs(1, 1);
      return Pervasives.$at(text_def(1), /* :: */[
                  _1,
                  _2
                ]);
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 1);
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 1);
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 1);
    }),
  (function () {
      return /* tuple */[
              mkrhs("*", 2),
              /* None */0
            ];
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 3);
      var _4 = Parsing.peek_val(__caml_parser_env, 1);
      return /* tuple */[
              mkrhs(_2, 2),
              /* Some */[_4]
            ];
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function () {
      return "_";
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _2,
              _1
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _1,
              /* [] */0
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkmod(/* Pmod_ident */Block.__(0, [mkrhs(_1, 1)]));
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 1);
      return mkmod(/* Pmod_structure */Block.__(1, [extra_str(2, _2)]));
    }),
  (function (__caml_parser_env) {
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("struct", 1, "end", 3);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 2);
      var _4 = Parsing.peek_val(__caml_parser_env, 0);
      return List.fold_left((function (acc, param) {
                    return mkmod(/* Pmod_functor */Block.__(2, [
                                  param[0],
                                  param[1],
                                  acc
                                ]));
                  }), _4, _2);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 3);
      var _3 = Parsing.peek_val(__caml_parser_env, 1);
      return mkmod(/* Pmod_apply */Block.__(3, [
                    _1,
                    _3
                  ]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      return mkmod(/* Pmod_apply */Block.__(3, [
                    _1,
                    mkmod(/* Pmod_structure */Block.__(1, [/* [] */0]))
                  ]));
    }),
  (function (__caml_parser_env) {
      Parsing.peek_val(__caml_parser_env, 3);
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("(", 2, ")", 4);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 3);
      var _4 = Parsing.peek_val(__caml_parser_env, 1);
      return mkmod(/* Pmod_constraint */Block.__(4, [
                    _2,
                    _4
                  ]));
    }),
  (function (__caml_parser_env) {
      Parsing.peek_val(__caml_parser_env, 3);
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("(", 1, ")", 5);
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 1);
    }),
  (function (__caml_parser_env) {
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("(", 1, ")", 3);
    }),
  (function (__caml_parser_env) {
      var _3 = Parsing.peek_val(__caml_parser_env, 1);
      return mkmod(/* Pmod_unpack */Block.__(5, [_3]));
    }),
  (function (__caml_parser_env) {
      var _3 = Parsing.peek_val(__caml_parser_env, 3);
      var _5 = Parsing.peek_val(__caml_parser_env, 1);
      return mkmod(/* Pmod_unpack */Block.__(5, [ghexp(/* Pexp_constraint */Block.__(19, [
                            _3,
                            ghtyp(/* Ptyp_package */Block.__(9, [_5]))
                          ]))]));
    }),
  (function (__caml_parser_env) {
      var _3 = Parsing.peek_val(__caml_parser_env, 5);
      var _5 = Parsing.peek_val(__caml_parser_env, 3);
      var _7 = Parsing.peek_val(__caml_parser_env, 1);
      return mkmod(/* Pmod_unpack */Block.__(5, [ghexp(/* Pexp_coerce */Block.__(20, [
                            _3,
                            /* Some */[ghtyp(/* Ptyp_package */Block.__(9, [_5]))],
                            ghtyp(/* Ptyp_package */Block.__(9, [_7]))
                          ]))]));
    }),
  (function (__caml_parser_env) {
      var _3 = Parsing.peek_val(__caml_parser_env, 3);
      var _5 = Parsing.peek_val(__caml_parser_env, 1);
      return mkmod(/* Pmod_unpack */Block.__(5, [ghexp(/* Pexp_coerce */Block.__(20, [
                            _3,
                            /* None */0,
                            ghtyp(/* Ptyp_package */Block.__(9, [_5]))
                          ]))]));
    }),
  (function (__caml_parser_env) {
      Parsing.peek_val(__caml_parser_env, 2);
      return unclosed("(", 1, ")", 5);
    }),
  (function (__caml_parser_env) {
      Parsing.peek_val(__caml_parser_env, 2);
      return unclosed("(", 1, ")", 5);
    }),
  (function (__caml_parser_env) {
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("(", 1, ")", 4);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return attr$4(_1, _2);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkmod(/* Pmod_extension */Block.__(6, [_1]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _2 = Parsing.peek_val(__caml_parser_env, 1);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      mark_rhs_docs(1, 2);
      return Pervasives.$at(text_str(1), /* :: */[
                  mkstrexp(_1, _2),
                  _3
                ]);
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function () {
      return /* [] */0;
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return Pervasives.$at(text_str(1), _2);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return Pervasives.$at(text_str(1), /* :: */[
                  _1,
                  _2
                ]);
    }),
  (function (__caml_parser_env) {
      var lbs = Parsing.peek_val(__caml_parser_env, 0);
      var bindings = lbs[/* lbs_bindings */0];
      var str;
      var exit = 0;
      if (bindings) {
        var lb = bindings[0];
        if (typeof lb[/* lb_pattern */0][/* ppat_desc */0] === "number") {
          if (bindings[1]) {
            exit = 1;
          } else {
            var exp = wrap_exp_attrs(lb[/* lb_expression */1], /* tuple */[
                  /* None */0,
                  lbs[/* lbs_attributes */3]
                ]);
            str = mkstr(/* Pstr_eval */Block.__(0, [
                    exp,
                    lb[/* lb_attributes */2]
                  ]));
          }
        } else {
          exit = 1;
        }
      } else {
        exit = 1;
      }
      if (exit === 1) {
        if (lbs[/* lbs_attributes */3] !== /* [] */0) {
          throw [
                $$Error$3,
                /* Not_expecting */Block.__(2, [
                    lbs[/* lbs_loc */4],
                    "attributes"
                  ])
              ];
        }
        var bindings$1 = List.map((function (lb) {
                var lzarg = lb[/* lb_docs */3];
                var tag = lzarg.tag | 0;
                var lzarg$1 = lb[/* lb_text */4];
                var tag$1 = lzarg$1.tag | 0;
                return mk$17(/* Some */[lb[/* lb_loc */5]], /* Some */[lb[/* lb_attributes */2]], /* Some */[tag === 250 ? lzarg[0] : (
                                tag === 246 ? CamlinternalLazy.force_lazy_block(lzarg) : lzarg
                              )], /* Some */[tag$1 === 250 ? lzarg$1[0] : (
                                tag$1 === 246 ? CamlinternalLazy.force_lazy_block(lzarg$1) : lzarg$1
                              )], lb[/* lb_pattern */0], lb[/* lb_expression */1]);
              }), bindings);
        str = mkstr(/* Pstr_value */Block.__(1, [
                lbs[/* lbs_rec */1],
                List.rev(bindings$1)
              ]));
      }
      var match = lbs[/* lbs_extension */2];
      if (match) {
        var d = /* Pstr_extension */Block.__(14, [
            /* tuple */[
              match[0],
              /* PStr */Block.__(0, [/* :: */[
                    str,
                    /* [] */0
                  ]])
            ],
            /* [] */0
          ]);
        return mk$6(/* Some */[symbol_gloc(/* () */0)], d);
      } else {
        return str;
      }
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkstr(/* Pstr_primitive */Block.__(2, [_1]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkstr(/* Pstr_type */Block.__(3, [List.rev(_1)]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkstr(/* Pstr_typext */Block.__(4, [_1]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkstr(/* Pstr_exception */Block.__(5, [_1]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkstr(/* Pstr_module */Block.__(6, [_1]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkstr(/* Pstr_recmodule */Block.__(7, [List.rev(_1)]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkstr(/* Pstr_modtype */Block.__(8, [_1]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkstr(/* Pstr_open */Block.__(9, [_1]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkstr(/* Pstr_class */Block.__(10, [List.rev(_1)]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkstr(/* Pstr_class_type */Block.__(11, [List.rev(_1)]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkstr(/* Pstr_include */Block.__(12, [_1]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return mkstr(/* Pstr_extension */Block.__(14, [
                    _1,
                    add_docs_attrs(symbol_docs(/* () */0), _2)
                  ]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      mark_symbol_docs(/* () */0);
      return mkstr(/* Pstr_attribute */Block.__(13, [_1]));
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 1);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mk$16(/* Some */[symbol_rloc(/* () */0)], /* Some */[_3], /* Some */[symbol_docs(/* () */0)], _2);
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 2);
      var _4 = Parsing.peek_val(__caml_parser_env, 0);
      return mkmod(/* Pmod_constraint */Block.__(4, [
                    _4,
                    _2
                  ]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return mkmod(/* Pmod_functor */Block.__(2, [
                    _1[0],
                    _1[1],
                    _2
                  ]));
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 1);
      var _4 = Parsing.peek_val(__caml_parser_env, 0);
      return mk$14(/* Some */[symbol_rloc(/* () */0)], /* Some */[_4], /* Some */[symbol_docs(/* () */0)], /* None */0, mkrhs(_2, 2), _3);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _1,
              /* [] */0
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _2,
              _1
            ];
    }),
  (function (__caml_parser_env) {
      var _3 = Parsing.peek_val(__caml_parser_env, 2);
      var _4 = Parsing.peek_val(__caml_parser_env, 1);
      var _5 = Parsing.peek_val(__caml_parser_env, 0);
      return mk$14(/* Some */[symbol_rloc(/* () */0)], /* Some */[_5], /* Some */[symbol_docs(/* () */0)], /* None */0, mkrhs(_3, 3), _4);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 1);
      var _4 = Parsing.peek_val(__caml_parser_env, 0);
      return mk$14(/* Some */[symbol_rloc(/* () */0)], /* Some */[_4], /* Some */[symbol_docs(/* () */0)], /* Some */[get_text(Parsing.symbol_start_pos(/* () */0))], mkrhs(_2, 2), _3);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkmty(/* Pmty_ident */Block.__(0, [mkrhs(_1, 1)]));
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 1);
      return mkmty(/* Pmty_signature */Block.__(1, [extra_sig(2, _2)]));
    }),
  (function (__caml_parser_env) {
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("sig", 1, "end", 3);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 2);
      var _4 = Parsing.peek_val(__caml_parser_env, 0);
      return List.fold_left((function (acc, param) {
                    return mkmty(/* Pmty_functor */Block.__(2, [
                                  param[0],
                                  param[1],
                                  acc
                                ]));
                  }), _4, _2);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkmty(/* Pmty_with */Block.__(3, [
                    _1,
                    List.rev(_3)
                  ]));
    }),
  (function (__caml_parser_env) {
      var _4 = Parsing.peek_val(__caml_parser_env, 0);
      return mkmty(/* Pmty_typeof */Block.__(4, [_4]));
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 1);
    }),
  (function (__caml_parser_env) {
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("(", 1, ")", 3);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkmty(/* Pmty_extension */Block.__(5, [_1]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return attr$3(_1, _2);
    }),
  (function () {
      return /* [] */0;
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return Pervasives.$at(text_sig(1), _2);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return Pervasives.$at(text_sig(1), /* :: */[
                  _1,
                  _2
                ]);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mksig(/* Psig_value */Block.__(0, [_1]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mksig(/* Psig_value */Block.__(0, [_1]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mksig(/* Psig_type */Block.__(1, [List.rev(_1)]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mksig(/* Psig_typext */Block.__(2, [_1]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mksig(/* Psig_exception */Block.__(3, [_1]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mksig(/* Psig_module */Block.__(4, [_1]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mksig(/* Psig_module */Block.__(4, [_1]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mksig(/* Psig_recmodule */Block.__(5, [List.rev(_1)]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mksig(/* Psig_modtype */Block.__(6, [_1]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mksig(/* Psig_open */Block.__(7, [_1]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mksig(/* Psig_include */Block.__(8, [_1]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mksig(/* Psig_class */Block.__(9, [List.rev(_1)]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mksig(/* Psig_class_type */Block.__(10, [List.rev(_1)]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return mksig(/* Psig_extension */Block.__(12, [
                    _1,
                    add_docs_attrs(symbol_docs(/* () */0), _2)
                  ]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      mark_symbol_docs(/* () */0);
      return mksig(/* Psig_attribute */Block.__(11, [_1]));
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 1);
      var _4 = Parsing.peek_val(__caml_parser_env, 0);
      return mk$15(/* Some */[symbol_rloc(/* () */0)], /* Some */[_4], /* Some */[symbol_docs(/* () */0)], /* Some */[_2], mkrhs(_3, 3));
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 1);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mk$16(/* Some */[symbol_rloc(/* () */0)], /* Some */[_3], /* Some */[symbol_docs(/* () */0)], _2);
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 4);
      var _4 = Parsing.peek_val(__caml_parser_env, 2);
      var _6 = Parsing.peek_val(__caml_parser_env, 0);
      return mkmty(/* Pmty_functor */Block.__(2, [
                    mkrhs(_2, 2),
                    /* Some */[_4],
                    _6
                  ]));
    }),
  (function (__caml_parser_env) {
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkmty(/* Pmty_functor */Block.__(2, [
                    mkrhs("*", 1),
                    /* None */0,
                    _3
                  ]));
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 1);
      var _4 = Parsing.peek_val(__caml_parser_env, 0);
      return mk$12(/* Some */[symbol_rloc(/* () */0)], /* Some */[_4], /* Some */[symbol_docs(/* () */0)], /* None */0, mkrhs(_2, 2), _3);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 3);
      var _4 = Parsing.peek_val(__caml_parser_env, 1);
      var _5 = Parsing.peek_val(__caml_parser_env, 0);
      return mk$12(/* Some */[symbol_rloc(/* () */0)], /* Some */[_5], /* Some */[symbol_docs(/* () */0)], /* None */0, mkrhs(_2, 2), alias$2(/* Some */[rhs_loc(4)], /* None */0, mkrhs(_4, 4)));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _1,
              /* [] */0
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _2,
              _1
            ];
    }),
  (function (__caml_parser_env) {
      var _3 = Parsing.peek_val(__caml_parser_env, 3);
      var _5 = Parsing.peek_val(__caml_parser_env, 1);
      var _6 = Parsing.peek_val(__caml_parser_env, 0);
      return mk$12(/* Some */[symbol_rloc(/* () */0)], /* Some */[_6], /* Some */[symbol_docs(/* () */0)], /* None */0, mkrhs(_3, 3), _5);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 3);
      var _4 = Parsing.peek_val(__caml_parser_env, 1);
      var _5 = Parsing.peek_val(__caml_parser_env, 0);
      return mk$12(/* Some */[symbol_rloc(/* () */0)], /* Some */[_5], /* Some */[symbol_docs(/* () */0)], /* Some */[get_text(Parsing.symbol_start_pos(/* () */0))], mkrhs(_2, 2), _4);
    }),
  (function () {
      return /* None */0;
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* Some */[_2];
    }),
  (function (__caml_parser_env) {
      var _3 = Parsing.peek_val(__caml_parser_env, 2);
      var _4 = Parsing.peek_val(__caml_parser_env, 1);
      var _5 = Parsing.peek_val(__caml_parser_env, 0);
      return mk$13(/* Some */[symbol_rloc(/* () */0)], /* Some */[_5], /* Some */[symbol_docs(/* () */0)], /* None */0, _4, mkrhs(_3, 3));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _1,
              /* [] */0
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _2,
              _1
            ];
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 4);
      var _3 = Parsing.peek_val(__caml_parser_env, 3);
      var _4 = Parsing.peek_val(__caml_parser_env, 2);
      var _5 = Parsing.peek_val(__caml_parser_env, 1);
      var _6 = Parsing.peek_val(__caml_parser_env, 0);
      return mk$18(/* Some */[symbol_rloc(/* () */0)], /* Some */[_6], /* Some */[symbol_docs(/* () */0)], /* None */0, /* Some */[_2], /* Some */[_3], mkrhs(_4, 4), _5);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 4);
      var _3 = Parsing.peek_val(__caml_parser_env, 3);
      var _4 = Parsing.peek_val(__caml_parser_env, 2);
      var _5 = Parsing.peek_val(__caml_parser_env, 1);
      var _6 = Parsing.peek_val(__caml_parser_env, 0);
      return mk$18(/* Some */[symbol_rloc(/* () */0)], /* Some */[_6], /* Some */[symbol_docs(/* () */0)], /* Some */[get_text(Parsing.symbol_start_pos(/* () */0))], /* Some */[_2], /* Some */[_3], mkrhs(_4, 4), _5);
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 2);
      var _4 = Parsing.peek_val(__caml_parser_env, 0);
      return mkclass(/* Pcl_constraint */Block.__(5, [
                    _4,
                    _2
                  ]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return mkclass(/* Pcl_fun */Block.__(2, [
                    _1[0],
                    _1[1],
                    _1[2],
                    _2
                  ]));
    }),
  (function () {
      return /* [] */0;
    }),
  (function (__caml_parser_env) {
      return List.rev(Parsing.peek_val(__caml_parser_env, 1));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkclass(/* Pcl_fun */Block.__(2, [
                    _1[0],
                    _1[1],
                    _1[2],
                    _3
                  ]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return mkclass(/* Pcl_fun */Block.__(2, [
                    _1[0],
                    _1[1],
                    _1[2],
                    _2
                  ]));
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return mkclass(/* Pcl_apply */Block.__(3, [
                    _1,
                    List.rev(_2)
                  ]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      var lbs = _1;
      var body = _3;
      var bindings = List.map((function (lb) {
              if (lb[/* lb_attributes */2] !== /* [] */0) {
                throw [
                      $$Error$3,
                      /* Not_expecting */Block.__(2, [
                          lb[/* lb_loc */5],
                          "item attribute"
                        ])
                    ];
              }
              return mk$17(/* Some */[lb[/* lb_loc */5]], /* None */0, /* None */0, /* None */0, lb[/* lb_pattern */0], lb[/* lb_expression */1]);
            }), lbs[/* lbs_bindings */0]);
      if (lbs[/* lbs_extension */2] !== /* None */0) {
        throw [
              $$Error$3,
              /* Not_expecting */Block.__(2, [
                  lbs[/* lbs_loc */4],
                  "extension"
                ])
            ];
      }
      if (lbs[/* lbs_attributes */3] !== /* [] */0) {
        throw [
              $$Error$3,
              /* Not_expecting */Block.__(2, [
                  lbs[/* lbs_loc */4],
                  "attributes"
                ])
            ];
      }
      return mkclass(/* Pcl_let */Block.__(4, [
                    lbs[/* lbs_rec */1],
                    List.rev(bindings),
                    body
                  ]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return attr$5(_1, _2);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkclass(/* Pcl_extension */Block.__(6, [_1]));
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 2);
      var _4 = Parsing.peek_val(__caml_parser_env, 0);
      return mkclass(/* Pcl_constr */Block.__(0, [
                    /* record */[
                      /* txt */_4,
                      /* loc */rhs_loc(4)
                    ],
                    List.rev(_2)
                  ]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkclass(/* Pcl_constr */Block.__(0, [
                    mkrhs(_1, 1),
                    /* [] */0
                  ]));
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 1);
      return mkclass(/* Pcl_structure */Block.__(1, [_2]));
    }),
  (function (__caml_parser_env) {
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("object", 1, "end", 3);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 3);
      var _4 = Parsing.peek_val(__caml_parser_env, 1);
      return mkclass(/* Pcl_constraint */Block.__(5, [
                    _2,
                    _4
                  ]));
    }),
  (function (__caml_parser_env) {
      Parsing.peek_val(__caml_parser_env, 3);
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("(", 1, ")", 5);
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 1);
    }),
  (function (__caml_parser_env) {
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("(", 1, ")", 3);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* record */[
              /* pcstr_self */_1,
              /* pcstr_fields */extra_cstr(2, List.rev(_2))
            ];
    }),
  (function (__caml_parser_env) {
      return reloc_pat(Parsing.peek_val(__caml_parser_env, 1));
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 3);
      var _4 = Parsing.peek_val(__caml_parser_env, 1);
      return mkpat(/* Ppat_constraint */Block.__(10, [
                    _2,
                    _4
                  ]));
    }),
  (function () {
      return ghpat(/* Ppat_any */0);
    }),
  (function () {
      return /* [] */0;
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return Pervasives.$at(/* :: */[
                  _2,
                  text_cstr(2)
                ], _1);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 3);
      var _3 = Parsing.peek_val(__caml_parser_env, 2);
      var _4 = Parsing.peek_val(__caml_parser_env, 1);
      var _5 = Parsing.peek_val(__caml_parser_env, 0);
      return mkcf(/* Some */[_5], /* Some */[symbol_docs(/* () */0)], /* Pcf_inherit */Block.__(0, [
                    _2,
                    _3,
                    _4
                  ]));
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 1);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkcf(/* Some */[_3], /* Some */[symbol_docs(/* () */0)], /* Pcf_val */Block.__(1, [_2]));
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 1);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkcf(/* Some */[_3], /* Some */[symbol_docs(/* () */0)], /* Pcf_method */Block.__(2, [_2]));
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 1);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkcf(/* Some */[_3], /* Some */[symbol_docs(/* () */0)], /* Pcf_constraint */Block.__(3, [_2]));
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 1);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkcf(/* Some */[_3], /* Some */[symbol_docs(/* () */0)], /* Pcf_initializer */Block.__(4, [_2]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return mkcf(/* Some */[_2], /* Some */[symbol_docs(/* () */0)], /* Pcf_extension */Block.__(6, [_1]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      mark_symbol_docs(/* () */0);
      return mkcf(/* None */0, /* None */0, /* Pcf_attribute */Block.__(5, [_1]));
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* Some */[_2];
    }),
  (function () {
      return /* None */0;
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 5);
      var _4 = Parsing.peek_val(__caml_parser_env, 2);
      var _6 = Parsing.peek_val(__caml_parser_env, 0);
      if (!_1) {
        throw Escape_error;
      }
      return /* tuple */[
              /* record */[
                /* txt */_4,
                /* loc */rhs_loc(4)
              ],
              /* Mutable */1,
              /* Cfk_virtual */Block.__(0, [_6])
            ];
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 3);
      var _3 = Parsing.peek_val(__caml_parser_env, 2);
      var _5 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              mkrhs(_3, 3),
              _2,
              /* Cfk_virtual */Block.__(0, [_5])
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 4);
      var _2 = Parsing.peek_val(__caml_parser_env, 3);
      var _3 = Parsing.peek_val(__caml_parser_env, 2);
      var _5 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              mkrhs(_3, 3),
              _2,
              /* Cfk_concrete */Block.__(1, [
                  _1,
                  _5
                ])
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 5);
      var _2 = Parsing.peek_val(__caml_parser_env, 4);
      var _3 = Parsing.peek_val(__caml_parser_env, 3);
      var _4 = Parsing.peek_val(__caml_parser_env, 2);
      var _6 = Parsing.peek_val(__caml_parser_env, 0);
      var e = mkexp_constraint(_6, _4);
      return /* tuple */[
              mkrhs(_3, 3),
              _2,
              /* Cfk_concrete */Block.__(1, [
                  _1,
                  e
                ])
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 5);
      var _4 = Parsing.peek_val(__caml_parser_env, 2);
      var _6 = Parsing.peek_val(__caml_parser_env, 0);
      if (!_1) {
        throw Escape_error;
      }
      return /* tuple */[
              /* record */[
                /* txt */_4,
                /* loc */rhs_loc(4)
              ],
              /* Private */0,
              /* Cfk_virtual */Block.__(0, [_6])
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 5);
      var _3 = Parsing.peek_val(__caml_parser_env, 3);
      var _4 = Parsing.peek_val(__caml_parser_env, 2);
      var _6 = Parsing.peek_val(__caml_parser_env, 0);
      if (!_1) {
        throw Escape_error;
      }
      return /* tuple */[
              /* record */[
                /* txt */_4,
                /* loc */rhs_loc(4)
              ],
              _3,
              /* Cfk_virtual */Block.__(0, [_6])
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 3);
      var _2 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 1);
      var _4 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              /* record */[
                /* txt */_3,
                /* loc */rhs_loc(3)
              ],
              _2,
              /* Cfk_concrete */Block.__(1, [
                  _1,
                  ghexp(/* Pexp_poly */Block.__(28, [
                          _4,
                          /* None */0
                        ]))
                ])
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 6);
      var _2 = Parsing.peek_val(__caml_parser_env, 5);
      var _3 = Parsing.peek_val(__caml_parser_env, 4);
      var _5 = Parsing.peek_val(__caml_parser_env, 2);
      var _7 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              /* record */[
                /* txt */_3,
                /* loc */rhs_loc(3)
              ],
              _2,
              /* Cfk_concrete */Block.__(1, [
                  _1,
                  ghexp(/* Pexp_poly */Block.__(28, [
                          _7,
                          /* Some */[_5]
                        ]))
                ])
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 9);
      var _2 = Parsing.peek_val(__caml_parser_env, 8);
      var _3 = Parsing.peek_val(__caml_parser_env, 7);
      var _6 = Parsing.peek_val(__caml_parser_env, 4);
      var _8 = Parsing.peek_val(__caml_parser_env, 2);
      var _10 = Parsing.peek_val(__caml_parser_env, 0);
      var match = wrap_type_annotation(_6, _8, _10);
      return /* tuple */[
              /* record */[
                /* txt */_3,
                /* loc */rhs_loc(3)
              ],
              _2,
              /* Cfk_concrete */Block.__(1, [
                  _1,
                  ghexp(/* Pexp_poly */Block.__(28, [
                          match[0],
                          /* Some */[match[1]]
                        ]))
                ])
            ];
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 4);
      var _4 = Parsing.peek_val(__caml_parser_env, 2);
      var _6 = Parsing.peek_val(__caml_parser_env, 0);
      return mkcty(/* Pcty_arrow */Block.__(2, [
                    "?" + _2,
                    mkoption(_4),
                    _6
                  ]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 3);
      var _2 = Parsing.peek_val(__caml_parser_env, 2);
      var _4 = Parsing.peek_val(__caml_parser_env, 0);
      return mkcty(/* Pcty_arrow */Block.__(2, [
                    "?" + _1,
                    mkoption(_2),
                    _4
                  ]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 4);
      var _3 = Parsing.peek_val(__caml_parser_env, 2);
      var _5 = Parsing.peek_val(__caml_parser_env, 0);
      return mkcty(/* Pcty_arrow */Block.__(2, [
                    _1,
                    _3,
                    _5
                  ]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkcty(/* Pcty_arrow */Block.__(2, [
                    "",
                    _1,
                    _3
                  ]));
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 2);
      var _4 = Parsing.peek_val(__caml_parser_env, 0);
      return mkcty(/* Pcty_constr */Block.__(0, [
                    /* record */[
                      /* txt */_4,
                      /* loc */rhs_loc(4)
                    ],
                    List.rev(_2)
                  ]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkcty(/* Pcty_constr */Block.__(0, [
                    mkrhs(_1, 1),
                    /* [] */0
                  ]));
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 1);
      return mkcty(/* Pcty_signature */Block.__(1, [_2]));
    }),
  (function (__caml_parser_env) {
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("object", 1, "end", 3);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return attr$6(_1, _2);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkcty(/* Pcty_extension */Block.__(3, [_1]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* record */[
              /* pcsig_self */_1,
              /* pcsig_fields */extra_csig(2, List.rev(_2))
            ];
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 1);
    }),
  (function () {
      return mktyp(/* Ptyp_any */0);
    }),
  (function () {
      return /* [] */0;
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return Pervasives.$at(/* :: */[
                  _2,
                  text_csig(2)
                ], _1);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 1);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkctf(/* Some */[_3], /* Some */[symbol_docs(/* () */0)], /* Pctf_inherit */Block.__(0, [_2]));
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 1);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkctf(/* Some */[_3], /* Some */[symbol_docs(/* () */0)], /* Pctf_val */Block.__(1, [_2]));
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 4);
      var _3 = Parsing.peek_val(__caml_parser_env, 3);
      var _5 = Parsing.peek_val(__caml_parser_env, 1);
      var _6 = Parsing.peek_val(__caml_parser_env, 0);
      return mkctf(/* Some */[_6], /* Some */[symbol_docs(/* () */0)], /* Pctf_method */Block.__(2, [/* tuple */[
                      _3,
                      _2[0],
                      _2[1],
                      _5
                    ]]));
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 1);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkctf(/* Some */[_3], /* Some */[symbol_docs(/* () */0)], /* Pctf_constraint */Block.__(3, [_2]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return mkctf(/* Some */[_2], /* Some */[symbol_docs(/* () */0)], /* Pctf_extension */Block.__(5, [_1]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      mark_symbol_docs(/* () */0);
      return mkctf(/* None */0, /* None */0, /* Pctf_attribute */Block.__(4, [_1]));
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 3);
      var _3 = Parsing.peek_val(__caml_parser_env, 2);
      var _5 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              _3,
              _2,
              /* Virtual */0,
              _5
            ];
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 3);
      var _3 = Parsing.peek_val(__caml_parser_env, 2);
      var _5 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              _3,
              /* Mutable */1,
              _2,
              _5
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              _1,
              /* Immutable */0,
              /* Concrete */1,
              _3
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              _1,
              _3,
              symbol_rloc(/* () */0)
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              _1,
              _3
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _1,
              /* [] */0
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _2,
              _1
            ];
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 5);
      var _3 = Parsing.peek_val(__caml_parser_env, 4);
      var _4 = Parsing.peek_val(__caml_parser_env, 3);
      var _6 = Parsing.peek_val(__caml_parser_env, 1);
      var _7 = Parsing.peek_val(__caml_parser_env, 0);
      return mk$18(/* Some */[symbol_rloc(/* () */0)], /* Some */[_7], /* Some */[symbol_docs(/* () */0)], /* None */0, /* Some */[_2], /* Some */[_3], mkrhs(_4, 4), _6);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 5);
      var _3 = Parsing.peek_val(__caml_parser_env, 4);
      var _4 = Parsing.peek_val(__caml_parser_env, 3);
      var _6 = Parsing.peek_val(__caml_parser_env, 1);
      var _7 = Parsing.peek_val(__caml_parser_env, 0);
      return mk$18(/* Some */[symbol_rloc(/* () */0)], /* Some */[_7], /* Some */[symbol_docs(/* () */0)], /* Some */[get_text(Parsing.symbol_start_pos(/* () */0))], /* Some */[_2], /* Some */[_3], mkrhs(_4, 4), _6);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _1,
              /* [] */0
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _2,
              _1
            ];
    }),
  (function (__caml_parser_env) {
      var _3 = Parsing.peek_val(__caml_parser_env, 5);
      var _4 = Parsing.peek_val(__caml_parser_env, 4);
      var _5 = Parsing.peek_val(__caml_parser_env, 3);
      var _7 = Parsing.peek_val(__caml_parser_env, 1);
      var _8 = Parsing.peek_val(__caml_parser_env, 0);
      return mk$18(/* Some */[symbol_rloc(/* () */0)], /* Some */[_8], /* Some */[symbol_docs(/* () */0)], /* None */0, /* Some */[_3], /* Some */[_4], mkrhs(_5, 5), _7);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 5);
      var _3 = Parsing.peek_val(__caml_parser_env, 4);
      var _4 = Parsing.peek_val(__caml_parser_env, 3);
      var _6 = Parsing.peek_val(__caml_parser_env, 1);
      var _7 = Parsing.peek_val(__caml_parser_env, 0);
      return mk$18(/* Some */[symbol_rloc(/* () */0)], /* Some */[_7], /* Some */[symbol_docs(/* () */0)], /* Some */[get_text(Parsing.symbol_start_pos(/* () */0))], /* Some */[_2], /* Some */[_3], mkrhs(_4, 4), _6);
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      return reloc_exp(Parsing.peek_val(__caml_parser_env, 1));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkexp(/* Pexp_sequence */Block.__(16, [
                    _1,
                    _3
                  ]));
    }),
  (function (__caml_parser_env) {
      var _3 = Parsing.peek_val(__caml_parser_env, 2);
      var _4 = Parsing.peek_val(__caml_parser_env, 1);
      return /* tuple */[
              "?" + _3[0],
              _4,
              _3[1]
            ];
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              "?" + _2[0],
              /* None */0,
              _2[1]
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 4);
      var _3 = Parsing.peek_val(__caml_parser_env, 2);
      var _4 = Parsing.peek_val(__caml_parser_env, 1);
      return /* tuple */[
              "?" + _1,
              _4,
              _3
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              "?" + _1,
              /* None */0,
              _2
            ];
    }),
  (function (__caml_parser_env) {
      var _3 = Parsing.peek_val(__caml_parser_env, 1);
      return /* tuple */[
              _3[0],
              /* None */0,
              _3[1]
            ];
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              _2[0],
              /* None */0,
              _2[1]
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              _1,
              /* None */0,
              _2
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              "",
              /* None */0,
              _1
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkpat(/* Ppat_var */Block.__(0, [mkrhs(_1, 1)]));
    }),
  (function () {
      return mkpat(/* Ppat_any */0);
    }),
  (function () {
      return /* None */0;
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* Some */[_2];
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              _1[0],
              mkpat(/* Ppat_constraint */Block.__(10, [
                      _1[1],
                      _3
                    ]))
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              _1,
              mkpat(/* Ppat_var */Block.__(0, [mkrhs(_1, 1)]))
            ];
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkpat(/* Ppat_constraint */Block.__(10, [
                    _1,
                    _3
                  ]));
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return mkexp(/* Pexp_apply */Block.__(5, [
                    _1,
                    List.rev(_2)
                  ]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      var lbs = _1;
      var body = _3;
      var bindings = List.map((function (lb) {
              if (lb[/* lb_attributes */2] !== /* [] */0) {
                throw [
                      $$Error$3,
                      /* Not_expecting */Block.__(2, [
                          lb[/* lb_loc */5],
                          "item attribute"
                        ])
                    ];
              }
              return mk$17(/* Some */[lb[/* lb_loc */5]], /* None */0, /* None */0, /* None */0, lb[/* lb_pattern */0], lb[/* lb_expression */1]);
            }), lbs[/* lbs_bindings */0]);
      var d_000 = lbs[/* lbs_rec */1];
      var d_001 = List.rev(bindings);
      var d = /* Pexp_let */Block.__(2, [
          d_000,
          d_001,
          body
        ]);
      return wrap_exp_attrs(mkexp(d), /* tuple */[
                  lbs[/* lbs_extension */2],
                  lbs[/* lbs_attributes */3]
                ]);
    }),
  (function (__caml_parser_env) {
      var _3 = Parsing.peek_val(__caml_parser_env, 4);
      var _4 = Parsing.peek_val(__caml_parser_env, 3);
      var _5 = Parsing.peek_val(__caml_parser_env, 2);
      var _7 = Parsing.peek_val(__caml_parser_env, 0);
      var d_000 = mkrhs(_4, 4);
      var d = /* Pexp_letmodule */Block.__(25, [
          d_000,
          _5,
          _7
        ]);
      return wrap_exp_attrs(mkexp(d), _3);
    }),
  (function (__caml_parser_env) {
      var _3 = Parsing.peek_val(__caml_parser_env, 4);
      var _4 = Parsing.peek_val(__caml_parser_env, 3);
      var _5 = Parsing.peek_val(__caml_parser_env, 2);
      var _7 = Parsing.peek_val(__caml_parser_env, 0);
      var d_001 = mkrhs(_5, 5);
      var d = /* Pexp_open */Block.__(32, [
          _3,
          d_001,
          _7
        ]);
      return wrap_exp_attrs(mkexp(d), _4);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 2);
      Parsing.peek_val(__caml_parser_env, 1);
      var _4 = Parsing.peek_val(__caml_parser_env, 0);
      var d = /* Pexp_function */Block.__(3, [List.rev(_4)]);
      return wrap_exp_attrs(mkexp(d), _2);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 1);
      var _4 = Parsing.peek_val(__caml_parser_env, 0);
      return wrap_exp_attrs(mkexp(/* Pexp_fun */Block.__(4, [
                        _3[0],
                        _3[1],
                        _3[2],
                        _4
                      ])), _2);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 5);
      var _5 = Parsing.peek_val(__caml_parser_env, 2);
      var _7 = Parsing.peek_val(__caml_parser_env, 0);
      return wrap_exp_attrs(mkexp(/* Pexp_newtype */Block.__(30, [
                        _5,
                        _7
                      ])), _2);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 4);
      var _3 = Parsing.peek_val(__caml_parser_env, 3);
      Parsing.peek_val(__caml_parser_env, 1);
      var _6 = Parsing.peek_val(__caml_parser_env, 0);
      var d_001 = List.rev(_6);
      var d = /* Pexp_match */Block.__(6, [
          _3,
          d_001
        ]);
      return wrap_exp_attrs(mkexp(d), _2);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 4);
      var _3 = Parsing.peek_val(__caml_parser_env, 3);
      Parsing.peek_val(__caml_parser_env, 1);
      var _6 = Parsing.peek_val(__caml_parser_env, 0);
      var d_001 = List.rev(_6);
      var d = /* Pexp_try */Block.__(7, [
          _3,
          d_001
        ]);
      return wrap_exp_attrs(mkexp(d), _2);
    }),
  (function (__caml_parser_env) {
      Parsing.peek_val(__caml_parser_env, 3);
      Parsing.peek_val(__caml_parser_env, 2);
      throw Escape_error;
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkexp(/* Pexp_tuple */Block.__(8, [List.rev(_1)]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return mkexp(/* Pexp_construct */Block.__(9, [
                    mkrhs(_1, 1),
                    /* Some */[_2]
                  ]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return mkexp(/* Pexp_variant */Block.__(10, [
                    _1,
                    /* Some */[_2]
                  ]));
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 5);
      var _3 = Parsing.peek_val(__caml_parser_env, 4);
      var _5 = Parsing.peek_val(__caml_parser_env, 2);
      var _7 = Parsing.peek_val(__caml_parser_env, 0);
      return wrap_exp_attrs(mkexp(/* Pexp_ifthenelse */Block.__(15, [
                        _3,
                        _5,
                        /* Some */[_7]
                      ])), _2);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 3);
      var _3 = Parsing.peek_val(__caml_parser_env, 2);
      var _5 = Parsing.peek_val(__caml_parser_env, 0);
      return wrap_exp_attrs(mkexp(/* Pexp_ifthenelse */Block.__(15, [
                        _3,
                        _5,
                        /* None */0
                      ])), _2);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 4);
      var _3 = Parsing.peek_val(__caml_parser_env, 3);
      var _5 = Parsing.peek_val(__caml_parser_env, 1);
      return wrap_exp_attrs(mkexp(/* Pexp_while */Block.__(17, [
                        _3,
                        _5
                      ])), _2);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 8);
      var _3 = Parsing.peek_val(__caml_parser_env, 7);
      var _5 = Parsing.peek_val(__caml_parser_env, 5);
      var _6 = Parsing.peek_val(__caml_parser_env, 4);
      var _7 = Parsing.peek_val(__caml_parser_env, 3);
      var _9 = Parsing.peek_val(__caml_parser_env, 1);
      return wrap_exp_attrs(mkexp(/* Pexp_for */Block.__(18, [
                        _3,
                        _5,
                        _7,
                        _6,
                        _9
                      ])), _2);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkexp_cons(rhs_loc(2), ghexp(/* Pexp_tuple */Block.__(8, [/* :: */[
                          _1,
                          /* :: */[
                            _3,
                            /* [] */0
                          ]
                        ]])), symbol_rloc(/* () */0));
    }),
  (function (__caml_parser_env) {
      var _5 = Parsing.peek_val(__caml_parser_env, 3);
      var _7 = Parsing.peek_val(__caml_parser_env, 1);
      return mkexp_cons(rhs_loc(2), ghexp(/* Pexp_tuple */Block.__(8, [/* :: */[
                          _5,
                          /* :: */[
                            _7,
                            /* [] */0
                          ]
                        ]])), symbol_rloc(/* () */0));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _2 = Parsing.peek_val(__caml_parser_env, 1);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, _2, _3);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _2 = Parsing.peek_val(__caml_parser_env, 1);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, _2, _3);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _2 = Parsing.peek_val(__caml_parser_env, 1);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, _2, _3);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _2 = Parsing.peek_val(__caml_parser_env, 1);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, _2, _3);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _2 = Parsing.peek_val(__caml_parser_env, 1);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, _2, _3);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, "+", _3);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, "+.", _3);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, "+=", _3);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, "-", _3);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, "-.", _3);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, "*", _3);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, "%", _3);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, "=", _3);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, "<", _3);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, ">", _3);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, "or", _3);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, "||", _3);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, "&", _3);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, "&&", _3);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, ":=", _3);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      var name = _1;
      var arg = _2;
      var match = arg[/* pexp_desc */0];
      var exit = 0;
      var exit$1 = 0;
      switch (name) {
        case "-" : 
            if (match.tag === 1) {
              var match$1 = match[0];
              switch (match$1.tag | 0) {
                case 0 : 
                    return mkexp(/* Pexp_constant */Block.__(1, [/* Const_int */Block.__(0, [-match$1[0] | 0])]));
                case 4 : 
                    return mkexp(/* Pexp_constant */Block.__(1, [/* Const_int32 */Block.__(4, [-match$1[0] | 0])]));
                case 5 : 
                    return mkexp(/* Pexp_constant */Block.__(1, [/* Const_int64 */Block.__(5, [Caml_int64.neg(match$1[0])])]));
                case 6 : 
                    return mkexp(/* Pexp_constant */Block.__(1, [/* Const_nativeint */Block.__(6, [-match$1[0]])]));
                default:
                  exit$1 = 2;
              }
            } else {
              exit$1 = 2;
            }
            break;
        case "-." : 
            exit$1 = 2;
            break;
        default:
          exit = 1;
      }
      if (exit$1 === 2) {
        if (match.tag === 1) {
          var match$2 = match[0];
          if (match$2.tag === 3) {
            return mkexp(/* Pexp_constant */Block.__(1, [/* Const_float */Block.__(3, [neg_float_string(match$2[0])])]));
          } else {
            exit = 1;
          }
        } else {
          exit = 1;
        }
      }
      if (exit === 1) {
        return mkexp(/* Pexp_apply */Block.__(5, [
                      mkoperator("~" + name, 1),
                      /* :: */[
                        /* tuple */[
                          "",
                          arg
                        ],
                        /* [] */0
                      ]
                    ]));
      }
      
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      var name = _1;
      var arg = _2;
      var desc = arg[/* pexp_desc */0];
      var exit = 0;
      var exit$1 = 0;
      switch (name) {
        case "+" : 
            if (desc.tag === 1) {
              switch (desc[0].tag | 0) {
                case 1 : 
                case 2 : 
                case 3 : 
                    exit$1 = 2;
                    break;
                default:
                  return mkexp(desc);
              }
            } else {
              exit$1 = 2;
            }
            break;
        case "+." : 
            exit$1 = 2;
            break;
        default:
          exit = 1;
      }
      if (exit$1 === 2) {
        if (desc.tag === 1) {
          if (desc[0].tag === 3) {
            return mkexp(desc);
          } else {
            exit = 1;
          }
        } else {
          exit = 1;
        }
      }
      if (exit === 1) {
        return mkexp(/* Pexp_apply */Block.__(5, [
                      mkoperator("~" + name, 1),
                      /* :: */[
                        /* tuple */[
                          "",
                          arg
                        ],
                        /* [] */0
                      ]
                    ]));
      }
      
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 4);
      var _3 = Parsing.peek_val(__caml_parser_env, 2);
      var _5 = Parsing.peek_val(__caml_parser_env, 0);
      return mkexp(/* Pexp_setfield */Block.__(13, [
                    _1,
                    mkrhs(_3, 3),
                    _5
                  ]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 6);
      var _4 = Parsing.peek_val(__caml_parser_env, 3);
      var _7 = Parsing.peek_val(__caml_parser_env, 0);
      return mkexp(/* Pexp_apply */Block.__(5, [
                    ghexp(/* Pexp_ident */Block.__(0, [array_function("Array", "set")])),
                    /* :: */[
                      /* tuple */[
                        "",
                        _1
                      ],
                      /* :: */[
                        /* tuple */[
                          "",
                          _4
                        ],
                        /* :: */[
                          /* tuple */[
                            "",
                            _7
                          ],
                          /* [] */0
                        ]
                      ]
                    ]
                  ]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 6);
      var _4 = Parsing.peek_val(__caml_parser_env, 3);
      var _7 = Parsing.peek_val(__caml_parser_env, 0);
      return mkexp(/* Pexp_apply */Block.__(5, [
                    ghexp(/* Pexp_ident */Block.__(0, [array_function("String", "set")])),
                    /* :: */[
                      /* tuple */[
                        "",
                        _1
                      ],
                      /* :: */[
                        /* tuple */[
                          "",
                          _4
                        ],
                        /* :: */[
                          /* tuple */[
                            "",
                            _7
                          ],
                          /* [] */0
                        ]
                      ]
                    ]
                  ]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 6);
      var _4 = Parsing.peek_val(__caml_parser_env, 3);
      var _7 = Parsing.peek_val(__caml_parser_env, 0);
      var arr = _1;
      var arg = _4;
      var newval = _7;
      var set = fast[0] ? "unsafe_set" : "set";
      var coords = bigarray_untuplify(arg);
      var exit = 0;
      if (coords) {
        var match = coords[1];
        var c1 = coords[0];
        if (match) {
          var match$1 = match[1];
          var c2 = match[0];
          if (match$1) {
            if (match$1[1]) {
              exit = 1;
            } else {
              return mkexp(/* Pexp_apply */Block.__(5, [
                            ghexp(/* Pexp_ident */Block.__(0, [bigarray_function("Array3", set)])),
                            /* :: */[
                              /* tuple */[
                                "",
                                arr
                              ],
                              /* :: */[
                                /* tuple */[
                                  "",
                                  c1
                                ],
                                /* :: */[
                                  /* tuple */[
                                    "",
                                    c2
                                  ],
                                  /* :: */[
                                    /* tuple */[
                                      "",
                                      match$1[0]
                                    ],
                                    /* :: */[
                                      /* tuple */[
                                        "",
                                        newval
                                      ],
                                      /* [] */0
                                    ]
                                  ]
                                ]
                              ]
                            ]
                          ]));
            }
          } else {
            return mkexp(/* Pexp_apply */Block.__(5, [
                          ghexp(/* Pexp_ident */Block.__(0, [bigarray_function("Array2", set)])),
                          /* :: */[
                            /* tuple */[
                              "",
                              arr
                            ],
                            /* :: */[
                              /* tuple */[
                                "",
                                c1
                              ],
                              /* :: */[
                                /* tuple */[
                                  "",
                                  c2
                                ],
                                /* :: */[
                                  /* tuple */[
                                    "",
                                    newval
                                  ],
                                  /* [] */0
                                ]
                              ]
                            ]
                          ]
                        ]));
          }
        } else {
          return mkexp(/* Pexp_apply */Block.__(5, [
                        ghexp(/* Pexp_ident */Block.__(0, [bigarray_function("Array1", set)])),
                        /* :: */[
                          /* tuple */[
                            "",
                            arr
                          ],
                          /* :: */[
                            /* tuple */[
                              "",
                              c1
                            ],
                            /* :: */[
                              /* tuple */[
                                "",
                                newval
                              ],
                              /* [] */0
                            ]
                          ]
                        ]
                      ]));
        }
      } else {
        exit = 1;
      }
      if (exit === 1) {
        return mkexp(/* Pexp_apply */Block.__(5, [
                      ghexp(/* Pexp_ident */Block.__(0, [bigarray_function("Genarray", "set")])),
                      /* :: */[
                        /* tuple */[
                          "",
                          arr
                        ],
                        /* :: */[
                          /* tuple */[
                            "",
                            ghexp(/* Pexp_array */Block.__(14, [coords]))
                          ],
                          /* :: */[
                            /* tuple */[
                              "",
                              newval
                            ],
                            /* [] */0
                          ]
                        ]
                      ]
                    ]));
      }
      
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkexp(/* Pexp_setinstvar */Block.__(23, [
                    mkrhs(_1, 1),
                    _3
                  ]));
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 1);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return wrap_exp_attrs(mkexp(/* Pexp_assert */Block.__(26, [_3])), _2);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 1);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return wrap_exp_attrs(mkexp(/* Pexp_lazy */Block.__(27, [_3])), _2);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 1);
      return wrap_exp_attrs(mkexp(/* Pexp_object */Block.__(29, [_3])), _2);
    }),
  (function (__caml_parser_env) {
      Parsing.peek_val(__caml_parser_env, 2);
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("object", 1, "end", 4);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return Curry._2(Ast_helper_004[/* attr */1], _1, _2);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkexp(/* Pexp_ident */Block.__(0, [mkrhs(_1, 1)]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkexp(/* Pexp_constant */Block.__(1, [_1]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkexp(/* Pexp_construct */Block.__(9, [
                    mkrhs(_1, 1),
                    /* None */0
                  ]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkexp(/* Pexp_variant */Block.__(10, [
                    _1,
                    /* None */0
                  ]));
    }),
  (function (__caml_parser_env) {
      return reloc_exp(Parsing.peek_val(__caml_parser_env, 1));
    }),
  (function (__caml_parser_env) {
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("(", 1, ")", 3);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 1);
      return wrap_exp_attrs(reloc_exp(_3), _2);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 1);
      var d_000 = /* record */[
        /* txt : Lident */Block.__(0, ["()"]),
        /* loc */symbol_rloc(/* () */0)
      ];
      var d = /* Pexp_construct */Block.__(9, [
          d_000,
          /* None */0
        ]);
      return wrap_exp_attrs(mkexp(d), _2);
    }),
  (function (__caml_parser_env) {
      Parsing.peek_val(__caml_parser_env, 2);
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("begin", 1, "end", 3);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 1);
      return mkexp_constraint(_2, _3);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkexp(/* Pexp_field */Block.__(12, [
                    _1,
                    mkrhs(_3, 3)
                  ]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 4);
      var _4 = Parsing.peek_val(__caml_parser_env, 1);
      return mkexp(/* Pexp_open */Block.__(32, [
                    /* Fresh */1,
                    mkrhs(_1, 1),
                    _4
                  ]));
    }),
  (function (__caml_parser_env) {
      Parsing.peek_val(__caml_parser_env, 4);
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("(", 3, ")", 5);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 4);
      var _4 = Parsing.peek_val(__caml_parser_env, 1);
      return mkexp(/* Pexp_apply */Block.__(5, [
                    ghexp(/* Pexp_ident */Block.__(0, [array_function("Array", "get")])),
                    /* :: */[
                      /* tuple */[
                        "",
                        _1
                      ],
                      /* :: */[
                        /* tuple */[
                          "",
                          _4
                        ],
                        /* [] */0
                      ]
                    ]
                  ]));
    }),
  (function (__caml_parser_env) {
      Parsing.peek_val(__caml_parser_env, 4);
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("(", 3, ")", 5);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 4);
      var _4 = Parsing.peek_val(__caml_parser_env, 1);
      return mkexp(/* Pexp_apply */Block.__(5, [
                    ghexp(/* Pexp_ident */Block.__(0, [array_function("String", "get")])),
                    /* :: */[
                      /* tuple */[
                        "",
                        _1
                      ],
                      /* :: */[
                        /* tuple */[
                          "",
                          _4
                        ],
                        /* [] */0
                      ]
                    ]
                  ]));
    }),
  (function (__caml_parser_env) {
      Parsing.peek_val(__caml_parser_env, 4);
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("[", 3, "]", 5);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 4);
      var _4 = Parsing.peek_val(__caml_parser_env, 1);
      var arr = _1;
      var arg = _4;
      var get = fast[0] ? "unsafe_get" : "get";
      var coords = bigarray_untuplify(arg);
      var exit = 0;
      if (coords) {
        var match = coords[1];
        var c1 = coords[0];
        if (match) {
          var match$1 = match[1];
          var c2 = match[0];
          if (match$1) {
            if (match$1[1]) {
              exit = 1;
            } else {
              return mkexp(/* Pexp_apply */Block.__(5, [
                            ghexp(/* Pexp_ident */Block.__(0, [bigarray_function("Array3", get)])),
                            /* :: */[
                              /* tuple */[
                                "",
                                arr
                              ],
                              /* :: */[
                                /* tuple */[
                                  "",
                                  c1
                                ],
                                /* :: */[
                                  /* tuple */[
                                    "",
                                    c2
                                  ],
                                  /* :: */[
                                    /* tuple */[
                                      "",
                                      match$1[0]
                                    ],
                                    /* [] */0
                                  ]
                                ]
                              ]
                            ]
                          ]));
            }
          } else {
            return mkexp(/* Pexp_apply */Block.__(5, [
                          ghexp(/* Pexp_ident */Block.__(0, [bigarray_function("Array2", get)])),
                          /* :: */[
                            /* tuple */[
                              "",
                              arr
                            ],
                            /* :: */[
                              /* tuple */[
                                "",
                                c1
                              ],
                              /* :: */[
                                /* tuple */[
                                  "",
                                  c2
                                ],
                                /* [] */0
                              ]
                            ]
                          ]
                        ]));
          }
        } else {
          return mkexp(/* Pexp_apply */Block.__(5, [
                        ghexp(/* Pexp_ident */Block.__(0, [bigarray_function("Array1", get)])),
                        /* :: */[
                          /* tuple */[
                            "",
                            arr
                          ],
                          /* :: */[
                            /* tuple */[
                              "",
                              c1
                            ],
                            /* [] */0
                          ]
                        ]
                      ]));
        }
      } else {
        exit = 1;
      }
      if (exit === 1) {
        return mkexp(/* Pexp_apply */Block.__(5, [
                      ghexp(/* Pexp_ident */Block.__(0, [bigarray_function("Genarray", "get")])),
                      /* :: */[
                        /* tuple */[
                          "",
                          arr
                        ],
                        /* :: */[
                          /* tuple */[
                            "",
                            ghexp(/* Pexp_array */Block.__(14, [coords]))
                          ],
                          /* [] */0
                        ]
                      ]
                    ]));
      }
      
    }),
  (function (__caml_parser_env) {
      Parsing.peek_val(__caml_parser_env, 4);
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("{", 3, "}", 5);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 1);
      return mkexp(/* Pexp_record */Block.__(11, [
                    _2[1],
                    _2[0]
                  ]));
    }),
  (function (__caml_parser_env) {
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("{", 1, "}", 3);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 4);
      var _4 = Parsing.peek_val(__caml_parser_env, 1);
      var rec_exp = mkexp(/* Pexp_record */Block.__(11, [
              _4[1],
              _4[0]
            ]));
      return mkexp(/* Pexp_open */Block.__(32, [
                    /* Fresh */1,
                    mkrhs(_1, 1),
                    rec_exp
                  ]));
    }),
  (function (__caml_parser_env) {
      Parsing.peek_val(__caml_parser_env, 4);
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("{", 3, "}", 5);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 2);
      Parsing.peek_val(__caml_parser_env, 1);
      return mkexp(/* Pexp_array */Block.__(14, [List.rev(_2)]));
    }),
  (function (__caml_parser_env) {
      Parsing.peek_val(__caml_parser_env, 2);
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("[|", 1, "|]", 4);
    }),
  (function () {
      return mkexp(/* Pexp_array */Block.__(14, [/* [] */0]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 5);
      var _4 = Parsing.peek_val(__caml_parser_env, 2);
      Parsing.peek_val(__caml_parser_env, 1);
      return mkexp(/* Pexp_open */Block.__(32, [
                    /* Fresh */1,
                    mkrhs(_1, 1),
                    mkexp(/* Pexp_array */Block.__(14, [List.rev(_4)]))
                  ]));
    }),
  (function (__caml_parser_env) {
      Parsing.peek_val(__caml_parser_env, 5);
      Parsing.peek_val(__caml_parser_env, 2);
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("[|", 3, "|]", 6);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 2);
      Parsing.peek_val(__caml_parser_env, 1);
      return reloc_exp(mktailexp(rhs_loc(4), List.rev(_2)));
    }),
  (function (__caml_parser_env) {
      Parsing.peek_val(__caml_parser_env, 2);
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("[", 1, "]", 4);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 5);
      var _4 = Parsing.peek_val(__caml_parser_env, 2);
      Parsing.peek_val(__caml_parser_env, 1);
      var list_exp = reloc_exp(mktailexp(rhs_loc(6), List.rev(_4)));
      return mkexp(/* Pexp_open */Block.__(32, [
                    /* Fresh */1,
                    mkrhs(_1, 1),
                    list_exp
                  ]));
    }),
  (function (__caml_parser_env) {
      Parsing.peek_val(__caml_parser_env, 5);
      Parsing.peek_val(__caml_parser_env, 2);
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("[", 3, "]", 6);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return mkexp(/* Pexp_apply */Block.__(5, [
                    mkoperator(_1, 1),
                    /* :: */[
                      /* tuple */[
                        "",
                        _2
                      ],
                      /* [] */0
                    ]
                  ]));
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return mkexp(/* Pexp_apply */Block.__(5, [
                    mkoperator("!", 1),
                    /* :: */[
                      /* tuple */[
                        "",
                        _2
                      ],
                      /* [] */0
                    ]
                  ]));
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 1);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      var d = /* Pexp_new */Block.__(22, [mkrhs(_3, 3)]);
      return wrap_exp_attrs(mkexp(d), _2);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 2);
      Parsing.peek_val(__caml_parser_env, 1);
      return mkexp(/* Pexp_override */Block.__(24, [List.rev(_2)]));
    }),
  (function (__caml_parser_env) {
      Parsing.peek_val(__caml_parser_env, 2);
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("{<", 1, ">}", 4);
    }),
  (function () {
      return mkexp(/* Pexp_override */Block.__(24, [/* [] */0]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 5);
      var _4 = Parsing.peek_val(__caml_parser_env, 2);
      Parsing.peek_val(__caml_parser_env, 1);
      return mkexp(/* Pexp_open */Block.__(32, [
                    /* Fresh */1,
                    mkrhs(_1, 1),
                    mkexp(/* Pexp_override */Block.__(24, [List.rev(_4)]))
                  ]));
    }),
  (function (__caml_parser_env) {
      Parsing.peek_val(__caml_parser_env, 5);
      Parsing.peek_val(__caml_parser_env, 2);
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("{<", 3, ">}", 6);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkexp(/* Pexp_send */Block.__(21, [
                    _1,
                    _3
                  ]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _2 = Parsing.peek_val(__caml_parser_env, 1);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, _2, _3);
    }),
  (function (__caml_parser_env) {
      var _3 = Parsing.peek_val(__caml_parser_env, 1);
      return mkexp(/* Pexp_pack */Block.__(31, [_3]));
    }),
  (function (__caml_parser_env) {
      var _3 = Parsing.peek_val(__caml_parser_env, 3);
      var _5 = Parsing.peek_val(__caml_parser_env, 1);
      return mkexp(/* Pexp_constraint */Block.__(19, [
                    ghexp(/* Pexp_pack */Block.__(31, [_3])),
                    ghtyp(/* Ptyp_package */Block.__(9, [_5]))
                  ]));
    }),
  (function (__caml_parser_env) {
      Parsing.peek_val(__caml_parser_env, 2);
      return unclosed("(", 1, ")", 5);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 7);
      var _5 = Parsing.peek_val(__caml_parser_env, 3);
      var _7 = Parsing.peek_val(__caml_parser_env, 1);
      return mkexp(/* Pexp_open */Block.__(32, [
                    /* Fresh */1,
                    mkrhs(_1, 1),
                    mkexp(/* Pexp_constraint */Block.__(19, [
                            ghexp(/* Pexp_pack */Block.__(31, [_5])),
                            ghtyp(/* Ptyp_package */Block.__(9, [_7]))
                          ]))
                  ]));
    }),
  (function (__caml_parser_env) {
      Parsing.peek_val(__caml_parser_env, 6);
      Parsing.peek_val(__caml_parser_env, 2);
      return unclosed("(", 3, ")", 7);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkexp(/* Pexp_extension */Block.__(33, [_1]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _1,
              /* [] */0
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _2,
              _1
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              "",
              _1
            ];
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              _1,
              _2
            ];
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              "?" + _2[0],
              _2[1]
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              "?" + _1,
              _2
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              _1,
              mkexp(/* Pexp_ident */Block.__(0, [mkrhs(/* Lident */Block.__(0, [_1]), 1)]))
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _1,
              /* [] */0
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _1,
              _2
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              mkpatvar(_1, 1),
              _2
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 6);
      var _3 = Parsing.peek_val(__caml_parser_env, 4);
      var _5 = Parsing.peek_val(__caml_parser_env, 2);
      var _7 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              ghpat(/* Ppat_constraint */Block.__(10, [
                      mkpatvar(_1, 1),
                      ghtyp(/* Ptyp_poly */Block.__(8, [
                              List.rev(_3),
                              _5
                            ]))
                    ])),
              _7
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 7);
      var _4 = Parsing.peek_val(__caml_parser_env, 4);
      var _6 = Parsing.peek_val(__caml_parser_env, 2);
      var _8 = Parsing.peek_val(__caml_parser_env, 0);
      var match = wrap_type_annotation(_4, _6, _8);
      return /* tuple */[
              ghpat(/* Ppat_constraint */Block.__(10, [
                      mkpatvar(_1, 1),
                      match[1]
                    ])),
              match[0]
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              _1,
              _3
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 4);
      var _3 = Parsing.peek_val(__caml_parser_env, 2);
      var _5 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              ghpat(/* Ppat_constraint */Block.__(10, [
                      _1,
                      _3
                    ])),
              _5
            ];
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      var lbs = _1;
      var lb = _2;
      return /* record */[
              /* lbs_bindings : :: */[
                lb,
                lbs[/* lbs_bindings */0]
              ],
              /* lbs_rec */lbs[/* lbs_rec */1],
              /* lbs_extension */lbs[/* lbs_extension */2],
              /* lbs_attributes */lbs[/* lbs_attributes */3],
              /* lbs_loc */lbs[/* lbs_loc */4]
            ];
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 3);
      var _3 = Parsing.peek_val(__caml_parser_env, 2);
      var _4 = Parsing.peek_val(__caml_parser_env, 1);
      var _5 = Parsing.peek_val(__caml_parser_env, 0);
      var param = _2;
      var rf = _3;
      var lb = mklb(_4, _5);
      return /* record */[
              /* lbs_bindings : :: */[
                lb,
                /* [] */0
              ],
              /* lbs_rec */rf,
              /* lbs_extension */param[0],
              /* lbs_attributes */param[1],
              /* lbs_loc */symbol_rloc(/* () */0)
            ];
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 1);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mklb(_2, _3);
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkexp_constraint(_3, _1);
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return ghexp(/* Pexp_fun */Block.__(4, [
                    _1[0],
                    _1[1],
                    _1[2],
                    _2
                  ]));
    }),
  (function (__caml_parser_env) {
      var _3 = Parsing.peek_val(__caml_parser_env, 2);
      var _5 = Parsing.peek_val(__caml_parser_env, 0);
      return mkexp(/* Pexp_newtype */Block.__(30, [
                    _3,
                    _5
                  ]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _1,
              /* [] */0
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _3,
              _1
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return Curry._3(Ast_helper_004[/* case */36], _1, /* None */0, _3);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 4);
      var _3 = Parsing.peek_val(__caml_parser_env, 2);
      var _5 = Parsing.peek_val(__caml_parser_env, 0);
      return Curry._3(Ast_helper_004[/* case */36], _1, /* Some */[_3], _5);
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return ghexp(/* Pexp_fun */Block.__(4, [
                    _1[0],
                    _1[1],
                    _1[2],
                    _2
                  ]));
    }),
  (function (__caml_parser_env) {
      var _3 = Parsing.peek_val(__caml_parser_env, 2);
      var _5 = Parsing.peek_val(__caml_parser_env, 0);
      return mkexp(/* Pexp_newtype */Block.__(30, [
                    _3,
                    _5
                  ]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _3,
              _1
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _3,
              /* :: */[
                _1,
                /* [] */0
              ]
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              /* Some */[_1],
              _3
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              /* None */0,
              _1
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _1,
              /* [] */0
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _1,
              _3
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      return /* :: */[
              _1,
              /* [] */0
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              mkrhs(_1, 1),
              _3
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              mkrhs(_1, 1),
              exp_of_label(_1, 1)
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              /* tuple */[
                mkrhs(_1, 1),
                _3
              ],
              /* [] */0
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 4);
      var _3 = Parsing.peek_val(__caml_parser_env, 2);
      var _5 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              /* tuple */[
                mkrhs(_3, 3),
                _5
              ],
              _1
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _1,
              /* [] */0
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _3,
              _1
            ];
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              /* Some */[_2],
              /* None */0
            ];
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 2);
      var _4 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              /* Some */[_2],
              /* Some */[_4]
            ];
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              /* None */0,
              /* Some */[_2]
            ];
    }),
  (function () {
      throw Escape_error;
    }),
  (function () {
      throw Escape_error;
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkpat(/* Ppat_alias */Block.__(1, [
                    _1,
                    mkrhs(_3, 3)
                  ]));
    }),
  (function (__caml_parser_env) {
      Parsing.peek_val(__caml_parser_env, 2);
      return expecting(3, "identifier");
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkpat(/* Ppat_tuple */Block.__(4, [List.rev(_1)]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return mkpat(/* Ppat_construct */Block.__(5, [
                    mkrhs(_1, 1),
                    /* Some */[_2]
                  ]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return mkpat(/* Ppat_variant */Block.__(6, [
                    _1,
                    /* Some */[_2]
                  ]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkpat_cons(rhs_loc(2), ghpat(/* Ppat_tuple */Block.__(4, [/* :: */[
                          _1,
                          /* :: */[
                            _3,
                            /* [] */0
                          ]
                        ]])), symbol_rloc(/* () */0));
    }),
  (function (__caml_parser_env) {
      Parsing.peek_val(__caml_parser_env, 2);
      return expecting(3, "pattern");
    }),
  (function (__caml_parser_env) {
      var _5 = Parsing.peek_val(__caml_parser_env, 3);
      var _7 = Parsing.peek_val(__caml_parser_env, 1);
      return mkpat_cons(rhs_loc(2), ghpat(/* Ppat_tuple */Block.__(4, [/* :: */[
                          _5,
                          /* :: */[
                            _7,
                            /* [] */0
                          ]
                        ]])), symbol_rloc(/* () */0));
    }),
  (function (__caml_parser_env) {
      Parsing.peek_val(__caml_parser_env, 3);
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("(", 4, ")", 8);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkpat(/* Ppat_or */Block.__(9, [
                    _1,
                    _3
                  ]));
    }),
  (function (__caml_parser_env) {
      Parsing.peek_val(__caml_parser_env, 2);
      return expecting(3, "pattern");
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return mkpat(/* Ppat_lazy */Block.__(12, [_2]));
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return mkpat(/* Ppat_exception */Block.__(14, [_2]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return attr$1(_1, _2);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkpat(/* Ppat_var */Block.__(0, [mkrhs(_1, 1)]));
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function () {
      return mkpat(/* Ppat_any */0);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkpat(/* Ppat_constant */Block.__(2, [_1]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkpat(/* Ppat_interval */Block.__(3, [
                    _1,
                    _3
                  ]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkpat(/* Ppat_construct */Block.__(5, [
                    mkrhs(_1, 1),
                    /* None */0
                  ]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkpat(/* Ppat_variant */Block.__(6, [
                    _1,
                    /* None */0
                  ]));
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return mkpat(/* Ppat_type */Block.__(11, [mkrhs(_2, 2)]));
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 1);
      return mkpat(/* Ppat_record */Block.__(7, [
                    _2[0],
                    _2[1]
                  ]));
    }),
  (function (__caml_parser_env) {
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("{", 1, "}", 3);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 2);
      Parsing.peek_val(__caml_parser_env, 1);
      return reloc_pat(mktailpat(rhs_loc(4), List.rev(_2)));
    }),
  (function (__caml_parser_env) {
      Parsing.peek_val(__caml_parser_env, 2);
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("[", 1, "]", 4);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 2);
      Parsing.peek_val(__caml_parser_env, 1);
      return mkpat(/* Ppat_array */Block.__(8, [List.rev(_2)]));
    }),
  (function () {
      return mkpat(/* Ppat_array */Block.__(8, [/* [] */0]));
    }),
  (function (__caml_parser_env) {
      Parsing.peek_val(__caml_parser_env, 2);
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("[|", 1, "|]", 4);
    }),
  (function (__caml_parser_env) {
      return reloc_pat(Parsing.peek_val(__caml_parser_env, 1));
    }),
  (function (__caml_parser_env) {
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("(", 1, ")", 3);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 3);
      var _4 = Parsing.peek_val(__caml_parser_env, 1);
      return mkpat(/* Ppat_constraint */Block.__(10, [
                    _2,
                    _4
                  ]));
    }),
  (function (__caml_parser_env) {
      Parsing.peek_val(__caml_parser_env, 3);
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("(", 1, ")", 5);
    }),
  (function (__caml_parser_env) {
      Parsing.peek_val(__caml_parser_env, 2);
      return expecting(4, "type");
    }),
  (function (__caml_parser_env) {
      var _3 = Parsing.peek_val(__caml_parser_env, 1);
      return mkpat(/* Ppat_unpack */Block.__(13, [mkrhs(_3, 3)]));
    }),
  (function (__caml_parser_env) {
      var _3 = Parsing.peek_val(__caml_parser_env, 3);
      var _5 = Parsing.peek_val(__caml_parser_env, 1);
      return mkpat(/* Ppat_constraint */Block.__(10, [
                    mkpat(/* Ppat_unpack */Block.__(13, [mkrhs(_3, 3)])),
                    ghtyp(/* Ptyp_package */Block.__(9, [_5]))
                  ]));
    }),
  (function (__caml_parser_env) {
      Parsing.peek_val(__caml_parser_env, 3);
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("(", 1, ")", 6);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkpat(/* Ppat_extension */Block.__(15, [_1]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _3,
              _1
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _3,
              /* :: */[
                _1,
                /* [] */0
              ]
            ];
    }),
  (function (__caml_parser_env) {
      Parsing.peek_val(__caml_parser_env, 2);
      return expecting(3, "pattern");
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _1,
              /* [] */0
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _3,
              _1
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              /* :: */[
                _1,
                /* [] */0
              ],
              /* Closed */0
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      return /* tuple */[
              /* :: */[
                _1,
                /* [] */0
              ],
              /* Closed */0
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 3);
      Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              /* :: */[
                _1,
                /* [] */0
              ],
              /* Open */1
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              /* :: */[
                _1,
                _3[0]
              ],
              _3[1]
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              mkrhs(_1, 1),
              _3
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              mkrhs(_1, 1),
              pat_of_label(_1, 1)
            ];
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 3);
      var _4 = Parsing.peek_val(__caml_parser_env, 1);
      var _5 = Parsing.peek_val(__caml_parser_env, 0);
      return mk$11(/* Some */[symbol_rloc(/* () */0)], /* Some */[_5], /* Some */[symbol_docs(/* () */0)], /* None */0, mkrhs(_2, 2), _4);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _1[0],
              /* [] */0
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _1[0],
              _2
            ];
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 5);
      var _4 = Parsing.peek_val(__caml_parser_env, 3);
      var _6 = Parsing.peek_val(__caml_parser_env, 1);
      var _7 = Parsing.peek_val(__caml_parser_env, 0);
      return mk$11(/* Some */[symbol_rloc(/* () */0)], /* Some */[_7], /* Some */[symbol_docs(/* () */0)], /* Some */[_6], mkrhs(_2, 2), _4);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _1,
              /* [] */0
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _2,
              _1
            ];
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 5);
      var _3 = Parsing.peek_val(__caml_parser_env, 4);
      var _4 = Parsing.peek_val(__caml_parser_env, 3);
      var _5 = Parsing.peek_val(__caml_parser_env, 2);
      var _6 = Parsing.peek_val(__caml_parser_env, 1);
      var _7 = Parsing.peek_val(__caml_parser_env, 0);
      return mk$19(/* Some */[symbol_rloc(/* () */0)], /* Some */[add_nonrec(_2, _7, 2)], /* Some */[symbol_docs(/* () */0)], /* None */0, /* Some */[_3], /* Some */[List.rev(_6)], /* Some */[_5[0]], /* Some */[_5[1]], _5[2], mkrhs(_4, 4));
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 4);
      var _3 = Parsing.peek_val(__caml_parser_env, 3);
      var _4 = Parsing.peek_val(__caml_parser_env, 2);
      var _5 = Parsing.peek_val(__caml_parser_env, 1);
      var _6 = Parsing.peek_val(__caml_parser_env, 0);
      return mk$19(/* Some */[symbol_rloc(/* () */0)], /* Some */[_6], /* Some */[symbol_docs(/* () */0)], /* Some */[get_text(Parsing.symbol_start_pos(/* () */0))], /* Some */[_2], /* Some */[List.rev(_5)], /* Some */[_4[0]], /* Some */[_4[1]], _4[2], mkrhs(_3, 3));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _3,
              _1
            ];
    }),
  (function () {
      return /* [] */0;
    }),
  (function () {
      return /* tuple */[
              /* Ptype_abstract */0,
              /* Public */1,
              /* None */0
            ];
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              /* Ptype_abstract */0,
              /* Public */1,
              /* Some */[_2]
            ];
    }),
  (function (__caml_parser_env) {
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              /* Ptype_abstract */0,
              /* Private */0,
              /* Some */[_3]
            ];
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              /* Ptype_variant */Block.__(0, [List.rev(_2)]),
              /* Public */1,
              /* None */0
            ];
    }),
  (function (__caml_parser_env) {
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              /* Ptype_variant */Block.__(0, [List.rev(_3)]),
              /* Private */0,
              /* None */0
            ];
    }),
  (function () {
      return /* tuple */[
              /* Ptype_open */1,
              /* Public */1,
              /* None */0
            ];
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 3);
      var _4 = Parsing.peek_val(__caml_parser_env, 1);
      return /* tuple */[
              /* Ptype_record */Block.__(1, [_4]),
              _2,
              /* None */0
            ];
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 3);
      var _4 = Parsing.peek_val(__caml_parser_env, 1);
      var _5 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              /* Ptype_variant */Block.__(0, [List.rev(_5)]),
              _4,
              /* Some */[_2]
            ];
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 2);
      return /* tuple */[
              /* Ptype_open */1,
              /* Public */1,
              /* Some */[_2]
            ];
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 5);
      var _4 = Parsing.peek_val(__caml_parser_env, 3);
      var _6 = Parsing.peek_val(__caml_parser_env, 1);
      return /* tuple */[
              /* Ptype_record */Block.__(1, [_6]),
              _4,
              /* Some */[_2]
            ];
    }),
  (function () {
      return /* [] */0;
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _1,
              /* [] */0
            ];
    }),
  (function (__caml_parser_env) {
      return List.rev(Parsing.peek_val(__caml_parser_env, 1));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              _2,
              _1
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _1,
              /* [] */0
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _3,
              _1
            ];
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return mktyp(/* Ptyp_var */Block.__(0, [_2]));
    }),
  (function () {
      return mktyp(/* Ptyp_any */0);
    }),
  (function () {
      return /* [] */0;
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _1,
              /* [] */0
            ];
    }),
  (function (__caml_parser_env) {
      return List.rev(Parsing.peek_val(__caml_parser_env, 1));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              _2,
              _1
            ];
    }),
  (function () {
      return /* Invariant */2;
    }),
  (function () {
      return /* Covariant */0;
    }),
  (function () {
      return /* Contravariant */1;
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return mktyp(/* Ptyp_var */Block.__(0, [_2]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _1,
              /* [] */0
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _3,
              _1
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _1,
              /* [] */0
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _1,
              /* [] */0
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _2,
              _1
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _2 = Parsing.peek_val(__caml_parser_env, 1);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return constructor(/* Some */[symbol_rloc(/* () */0)], /* Some */[_3], /* Some */[get_info(Parsing.symbol_end_pos(/* () */0))], /* Some */[_2[0]], _2[1], mkrhs(_1, 1));
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 1);
      var _4 = Parsing.peek_val(__caml_parser_env, 0);
      return constructor(/* Some */[symbol_rloc(/* () */0)], /* Some */[_4], /* Some */[get_info(Parsing.symbol_end_pos(/* () */0))], /* Some */[_3[0]], _3[1], mkrhs(_2, 2));
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 4);
      var _4 = Parsing.peek_val(__caml_parser_env, 2);
      var _5 = Parsing.peek_val(__caml_parser_env, 1);
      var _6 = Parsing.peek_val(__caml_parser_env, 0);
      return rebind(/* Some */[symbol_rloc(/* () */0)], /* Some */[Pervasives.$at(_5, _6)], /* Some */[symbol_docs(/* () */0)], /* None */0, mkrhs(_2, 2), mkrhs(_4, 4));
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 3);
      var _3 = Parsing.peek_val(__caml_parser_env, 2);
      var _4 = Parsing.peek_val(__caml_parser_env, 1);
      var _5 = Parsing.peek_val(__caml_parser_env, 0);
      return decl(/* Some */[symbol_rloc(/* () */0)], /* Some */[Pervasives.$at(_4, _5)], /* Some */[symbol_docs(/* () */0)], /* None */0, /* Some */[_3[0]], _3[1], mkrhs(_2, 2));
    }),
  (function () {
      return /* tuple */[
              /* [] */0,
              /* None */0
            ];
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              List.rev(_2),
              /* None */0
            ];
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 2);
      var _4 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              List.rev(_2),
              /* Some */[_4]
            ];
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              /* [] */0,
              /* Some */[_2]
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _1,
              /* [] */0
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _1,
              /* [] */0
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _1,
              _2
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 4);
      var _2 = Parsing.peek_val(__caml_parser_env, 3);
      var _4 = Parsing.peek_val(__caml_parser_env, 1);
      var _5 = Parsing.peek_val(__caml_parser_env, 0);
      return field$1(/* Some */[symbol_rloc(/* () */0)], /* Some */[_5], /* Some */[get_info(Parsing.symbol_end_pos(/* () */0))], /* Some */[_1], mkrhs(_2, 2), _4);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 6);
      var _2 = Parsing.peek_val(__caml_parser_env, 5);
      var _4 = Parsing.peek_val(__caml_parser_env, 3);
      var _5 = Parsing.peek_val(__caml_parser_env, 2);
      var _7 = Parsing.peek_val(__caml_parser_env, 0);
      var info_before_semi = get_info(Parsing.rhs_end_pos(5));
      var info = info_before_semi ? info_before_semi : get_info(Parsing.symbol_end_pos(/* () */0));
      return field$1(/* Some */[symbol_rloc(/* () */0)], /* Some */[Pervasives.$at(_5, _7)], /* Some */[info], /* Some */[_1], mkrhs(_2, 2), _4);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 6);
      var _3 = Parsing.peek_val(__caml_parser_env, 5);
      var _4 = Parsing.peek_val(__caml_parser_env, 4);
      var _6 = Parsing.peek_val(__caml_parser_env, 2);
      var _7 = Parsing.peek_val(__caml_parser_env, 1);
      var _8 = Parsing.peek_val(__caml_parser_env, 0);
      if (_2 !== /* Recursive */1) {
        not_expecting(2, "nonrec flag");
      }
      return mk$20(/* Some */[_8], /* Some */[symbol_docs(/* () */0)], /* Some */[_3], /* Some */[_6], mkrhs(_4, 4), List.rev(_7));
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 6);
      var _3 = Parsing.peek_val(__caml_parser_env, 5);
      var _4 = Parsing.peek_val(__caml_parser_env, 4);
      var _6 = Parsing.peek_val(__caml_parser_env, 2);
      var _7 = Parsing.peek_val(__caml_parser_env, 1);
      var _8 = Parsing.peek_val(__caml_parser_env, 0);
      if (_2 !== /* Recursive */1) {
        not_expecting(2, "nonrec flag");
      }
      return mk$20(/* Some */[_8], /* Some */[symbol_docs(/* () */0)], /* Some */[_3], /* Some */[_6], mkrhs(_4, 4), List.rev(_7));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _1,
              /* [] */0
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _1,
              /* [] */0
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _1,
              /* [] */0
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _1,
              /* [] */0
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _2,
              _1
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _2,
              _1
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _1,
              /* [] */0
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _1,
              /* [] */0
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _2,
              _1
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _2 = Parsing.peek_val(__caml_parser_env, 1);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return decl(/* Some */[symbol_rloc(/* () */0)], /* Some */[_3], /* None */0, /* Some */[get_info(Parsing.symbol_end_pos(/* () */0))], /* Some */[_2[0]], _2[1], mkrhs(_1, 1));
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 1);
      var _4 = Parsing.peek_val(__caml_parser_env, 0);
      return decl(/* Some */[symbol_rloc(/* () */0)], /* Some */[_4], /* None */0, /* Some */[get_info(Parsing.symbol_end_pos(/* () */0))], /* Some */[_3[0]], _3[1], mkrhs(_2, 2));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 3);
      var _3 = Parsing.peek_val(__caml_parser_env, 1);
      var _4 = Parsing.peek_val(__caml_parser_env, 0);
      return rebind(/* Some */[symbol_rloc(/* () */0)], /* Some */[_4], /* None */0, /* Some */[get_info(Parsing.symbol_end_pos(/* () */0))], mkrhs(_1, 1), mkrhs(_3, 3));
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 3);
      var _4 = Parsing.peek_val(__caml_parser_env, 1);
      var _5 = Parsing.peek_val(__caml_parser_env, 0);
      return rebind(/* Some */[symbol_rloc(/* () */0)], /* Some */[_5], /* None */0, /* Some */[get_info(Parsing.symbol_end_pos(/* () */0))], mkrhs(_2, 2), mkrhs(_4, 4));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _1,
              /* [] */0
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _3,
              _1
            ];
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 4);
      var _3 = Parsing.peek_val(__caml_parser_env, 3);
      var _4 = Parsing.peek_val(__caml_parser_env, 2);
      var _5 = Parsing.peek_val(__caml_parser_env, 1);
      var _6 = Parsing.peek_val(__caml_parser_env, 0);
      return /* Pwith_type */Block.__(0, [
                mkrhs(_3, 3),
                mk$19(/* Some */[symbol_rloc(/* () */0)], /* None */0, /* None */0, /* None */0, /* Some */[_2], /* Some */[List.rev(_6)], /* None */0, /* Some */[_4], /* Some */[_5], mkrhs(last$1(_3), 3))
              ]);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 3);
      var _3 = Parsing.peek_val(__caml_parser_env, 2);
      var _5 = Parsing.peek_val(__caml_parser_env, 0);
      return /* Pwith_typesubst */Block.__(2, [mk$19(/* Some */[symbol_rloc(/* () */0)], /* None */0, /* None */0, /* None */0, /* Some */[_2], /* None */0, /* None */0, /* None */0, /* Some */[_5], mkrhs(_3, 3))]);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 2);
      var _4 = Parsing.peek_val(__caml_parser_env, 0);
      return /* Pwith_module */Block.__(1, [
                mkrhs(_2, 2),
                mkrhs(_4, 4)
              ]);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 2);
      var _4 = Parsing.peek_val(__caml_parser_env, 0);
      return /* Pwith_modsubst */Block.__(3, [
                mkrhs(_2, 2),
                mkrhs(_4, 4)
              ]);
    }),
  (function () {
      return /* Public */1;
    }),
  (function () {
      return /* Private */0;
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _2,
              /* [] */0
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _3,
              _1
            ];
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mktyp(/* Ptyp_poly */Block.__(8, [
                    List.rev(_1),
                    _3
                  ]));
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mktyp(/* Ptyp_poly */Block.__(8, [
                    List.rev(_1),
                    _3
                  ]));
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return attr(_1, _2);
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 3);
      var _4 = Parsing.peek_val(__caml_parser_env, 0);
      return mktyp(/* Ptyp_alias */Block.__(6, [
                    _1,
                    _4
                  ]));
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 4);
      var _4 = Parsing.peek_val(__caml_parser_env, 2);
      var _6 = Parsing.peek_val(__caml_parser_env, 0);
      return mktyp(/* Ptyp_arrow */Block.__(1, [
                    "?" + _2,
                    mkoption(_4),
                    _6
                  ]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 3);
      var _2 = Parsing.peek_val(__caml_parser_env, 2);
      var _4 = Parsing.peek_val(__caml_parser_env, 0);
      return mktyp(/* Ptyp_arrow */Block.__(1, [
                    "?" + _1,
                    mkoption(_2),
                    _4
                  ]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 4);
      var _3 = Parsing.peek_val(__caml_parser_env, 2);
      var _5 = Parsing.peek_val(__caml_parser_env, 0);
      return mktyp(/* Ptyp_arrow */Block.__(1, [
                    _1,
                    _3,
                    _5
                  ]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mktyp(/* Ptyp_arrow */Block.__(1, [
                    "",
                    _1,
                    _3
                  ]));
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 1);
      if (_2) {
        if (_2[1]) {
          throw Parsing.Parse_error;
        } else {
          return _2[0];
        }
      } else {
        throw Parsing.Parse_error;
      }
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 1);
      if (_2) {
        if (_2[1]) {
          throw Parsing.Parse_error;
        } else {
          return _2[0];
        }
      } else {
        throw Parsing.Parse_error;
      }
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return mktyp(/* Ptyp_var */Block.__(0, [_2]));
    }),
  (function () {
      return mktyp(/* Ptyp_any */0);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mktyp(/* Ptyp_constr */Block.__(3, [
                    mkrhs(_1, 1),
                    /* [] */0
                  ]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return mktyp(/* Ptyp_constr */Block.__(3, [
                    mkrhs(_2, 2),
                    /* :: */[
                      _1,
                      /* [] */0
                    ]
                  ]));
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 2);
      var _4 = Parsing.peek_val(__caml_parser_env, 0);
      return mktyp(/* Ptyp_constr */Block.__(3, [
                    mkrhs(_4, 4),
                    List.rev(_2)
                  ]));
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 1);
      return mktyp(/* Ptyp_object */Block.__(4, [
                    _2[0],
                    _2[1]
                  ]));
    }),
  (function () {
      return mktyp(/* Ptyp_object */Block.__(4, [
                    /* [] */0,
                    /* Closed */0
                  ]));
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return mktyp(/* Ptyp_class */Block.__(5, [
                    mkrhs(_2, 2),
                    /* [] */0
                  ]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mktyp(/* Ptyp_class */Block.__(5, [
                    mkrhs(_3, 3),
                    /* :: */[
                      _1,
                      /* [] */0
                    ]
                  ]));
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 3);
      var _5 = Parsing.peek_val(__caml_parser_env, 0);
      return mktyp(/* Ptyp_class */Block.__(5, [
                    mkrhs(_5, 5),
                    List.rev(_2)
                  ]));
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 1);
      return mktyp(/* Ptyp_variant */Block.__(7, [
                    /* :: */[
                      _2,
                      /* [] */0
                    ],
                    /* Closed */0,
                    /* None */0
                  ]));
    }),
  (function (__caml_parser_env) {
      var _3 = Parsing.peek_val(__caml_parser_env, 1);
      return mktyp(/* Ptyp_variant */Block.__(7, [
                    List.rev(_3),
                    /* Closed */0,
                    /* None */0
                  ]));
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 3);
      var _4 = Parsing.peek_val(__caml_parser_env, 1);
      return mktyp(/* Ptyp_variant */Block.__(7, [
                    /* :: */[
                      _2,
                      List.rev(_4)
                    ],
                    /* Closed */0,
                    /* None */0
                  ]));
    }),
  (function (__caml_parser_env) {
      Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 1);
      return mktyp(/* Ptyp_variant */Block.__(7, [
                    List.rev(_3),
                    /* Open */1,
                    /* None */0
                  ]));
    }),
  (function () {
      return mktyp(/* Ptyp_variant */Block.__(7, [
                    /* [] */0,
                    /* Open */1,
                    /* None */0
                  ]));
    }),
  (function (__caml_parser_env) {
      Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 1);
      return mktyp(/* Ptyp_variant */Block.__(7, [
                    List.rev(_3),
                    /* Closed */0,
                    /* Some */[/* [] */0]
                  ]));
    }),
  (function (__caml_parser_env) {
      Parsing.peek_val(__caml_parser_env, 4);
      var _3 = Parsing.peek_val(__caml_parser_env, 3);
      var _5 = Parsing.peek_val(__caml_parser_env, 1);
      return mktyp(/* Ptyp_variant */Block.__(7, [
                    List.rev(_3),
                    /* Closed */0,
                    /* Some */[List.rev(_5)]
                  ]));
    }),
  (function (__caml_parser_env) {
      var _3 = Parsing.peek_val(__caml_parser_env, 1);
      return mktyp(/* Ptyp_package */Block.__(9, [_3]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mktyp(/* Ptyp_extension */Block.__(10, [_1]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              mkrhs(_1, 1),
              /* [] */0
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              mkrhs(_1, 1),
              _3
            ];
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 2);
      var _4 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              mkrhs(_2, 2),
              _4
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _1,
              /* [] */0
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _1,
              _3
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _1,
              /* [] */0
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _3,
              _1
            ];
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* Rinherit */Block.__(1, [_1]);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 4);
      var _3 = Parsing.peek_val(__caml_parser_env, 2);
      var _4 = Parsing.peek_val(__caml_parser_env, 1);
      var _5 = Parsing.peek_val(__caml_parser_env, 0);
      return /* Rtag */Block.__(0, [
                _1,
                _5,
                _3,
                List.rev(_4)
              ]);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* Rtag */Block.__(0, [
                _1,
                _2,
                /* true */1,
                /* [] */0
              ]);
    }),
  (function () {
      return /* true */1;
    }),
  (function () {
      return /* false */0;
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _1,
              /* [] */0
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _3,
              _1
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _1,
              /* [] */0
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _2,
              _1
            ];
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mktyp(/* Ptyp_tuple */Block.__(2, [/* :: */[
                      _1,
                      List.rev(_3)
                    ]]));
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mktyp(/* Ptyp_tuple */Block.__(2, [/* :: */[
                      _1,
                      List.rev(_3)
                    ]]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _1,
              /* [] */0
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _3,
              _1
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _1,
              /* [] */0
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _3,
              _1
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _1,
              /* [] */0
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _3,
              _1
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              /* :: */[
                _1,
                _3[0]
              ],
              _3[1]
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              /* :: */[
                _1,
                /* [] */0
              ],
              /* Closed */0
            ];
    }),
  (function () {
      return /* tuple */[
              /* [] */0,
              /* Open */1
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 3);
      var _3 = Parsing.peek_val(__caml_parser_env, 1);
      var _4 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              _1,
              _4,
              _3
            ];
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* Const_int */Block.__(0, [_1]);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* Const_char */Block.__(1, [_1]);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* Const_string */Block.__(2, [
                _1[0],
                _1[1]
              ]);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* Const_float */Block.__(3, [_1]);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* Const_int32 */Block.__(4, [_1]);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* Const_int64 */Block.__(5, [_1]);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* Const_nativeint */Block.__(6, [_1]);
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* Const_int */Block.__(0, [-_2 | 0]);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* Const_float */Block.__(3, ["-" + _2]);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* Const_int32 */Block.__(4, [-_2 | 0]);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* Const_int64 */Block.__(5, [Caml_int64.neg(_2)]);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* Const_nativeint */Block.__(6, [-_2]);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* Const_int */Block.__(0, [_2]);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* Const_float */Block.__(3, [_2]);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* Const_int32 */Block.__(4, [_2]);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* Const_int64 */Block.__(5, [_2]);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* Const_nativeint */Block.__(6, [_2]);
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 1);
    }),
  (function (__caml_parser_env) {
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("(", 1, ")", 3);
    }),
  (function () {
      return expecting(2, "operator");
    }),
  (function () {
      return expecting(3, "module-expr");
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function () {
      return "!";
    }),
  (function () {
      return "+";
    }),
  (function () {
      return "+.";
    }),
  (function () {
      return "-";
    }),
  (function () {
      return "-.";
    }),
  (function () {
      return "*";
    }),
  (function () {
      return "=";
    }),
  (function () {
      return "<";
    }),
  (function () {
      return ">";
    }),
  (function () {
      return "or";
    }),
  (function () {
      return "||";
    }),
  (function () {
      return "&";
    }),
  (function () {
      return "&&";
    }),
  (function () {
      return ":=";
    }),
  (function () {
      return "+=";
    }),
  (function () {
      return "%";
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function () {
      return "()";
    }),
  (function () {
      return "::";
    }),
  (function () {
      return "false";
    }),
  (function () {
      return "true";
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* Lident */Block.__(0, [_1]);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return /* Ldot */Block.__(1, [
                _1,
                _3
              ]);
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function () {
      return /* Lident */Block.__(0, ["[]"]);
    }),
  (function () {
      return /* Lident */Block.__(0, ["()"]);
    }),
  (function () {
      return /* Lident */Block.__(0, ["false"]);
    }),
  (function () {
      return /* Lident */Block.__(0, ["true"]);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* Lident */Block.__(0, [_1]);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return /* Ldot */Block.__(1, [
                _1,
                _3
              ]);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* Lident */Block.__(0, [_1]);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return /* Ldot */Block.__(1, [
                _1,
                _3
              ]);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* Lident */Block.__(0, [_1]);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return /* Ldot */Block.__(1, [
                _1,
                _3
              ]);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* Lident */Block.__(0, [_1]);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return /* Ldot */Block.__(1, [
                _1,
                _3
              ]);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 3);
      var _3 = Parsing.peek_val(__caml_parser_env, 1);
      var p1 = _1;
      var p2 = _3;
      if (applicative_functors[0]) {
        return /* Lapply */Block.__(2, [
                  p1,
                  p2
                ]);
      } else {
        throw [
              $$Error$3,
              /* Applicative_path */Block.__(3, [symbol_rloc(/* () */0)])
            ];
      }
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* Lident */Block.__(0, [_1]);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return /* Ldot */Block.__(1, [
                _1,
                _3
              ]);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* Lident */Block.__(0, [_1]);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return /* Ldot */Block.__(1, [
                _1,
                _3
              ]);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* Lident */Block.__(0, [_1]);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return /* Ldot */Block.__(1, [
                _1,
                _3
              ]);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* Ptop_dir */Block.__(1, [
                _2,
                /* Pdir_none */0
              ]);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 1);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return /* Ptop_dir */Block.__(1, [
                _2,
                /* Pdir_string */Block.__(0, [_3[0]])
              ]);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 1);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return /* Ptop_dir */Block.__(1, [
                _2,
                /* Pdir_int */Block.__(1, [_3])
              ]);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 1);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return /* Ptop_dir */Block.__(1, [
                _2,
                /* Pdir_ident */Block.__(2, [_3])
              ]);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 1);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return /* Ptop_dir */Block.__(1, [
                _2,
                /* Pdir_ident */Block.__(2, [_3])
              ]);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 1);
      return /* Ptop_dir */Block.__(1, [
                _2,
                /* Pdir_bool */Block.__(3, [/* false */0])
              ]);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 1);
      return /* Ptop_dir */Block.__(1, [
                _2,
                /* Pdir_bool */Block.__(3, [/* true */1])
              ]);
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function () {
      return /* Nonrecursive */0;
    }),
  (function () {
      return /* Recursive */1;
    }),
  (function () {
      return /* Recursive */1;
    }),
  (function () {
      return /* Nonrecursive */0;
    }),
  (function () {
      return /* Upto */0;
    }),
  (function () {
      return /* Downto */1;
    }),
  (function () {
      return /* Public */1;
    }),
  (function () {
      return /* Private */0;
    }),
  (function () {
      return /* Immutable */0;
    }),
  (function () {
      return /* Mutable */1;
    }),
  (function () {
      return /* Concrete */1;
    }),
  (function () {
      return /* Virtual */0;
    }),
  (function () {
      return /* tuple */[
              /* Public */1,
              /* Concrete */1
            ];
    }),
  (function () {
      return /* tuple */[
              /* Private */0,
              /* Concrete */1
            ];
    }),
  (function () {
      return /* tuple */[
              /* Public */1,
              /* Virtual */0
            ];
    }),
  (function () {
      return /* tuple */[
              /* Private */0,
              /* Virtual */0
            ];
    }),
  (function () {
      return /* tuple */[
              /* Private */0,
              /* Virtual */0
            ];
    }),
  (function () {
      return /* Fresh */1;
    }),
  (function () {
      return /* Override */0;
    }),
  (function () {
      return /* () */0;
    }),
  (function () {
      return /* () */0;
    }),
  (function () {
      return /* () */0;
    }),
  (function () {
      return /* () */0;
    }),
  (function () {
      return "-";
    }),
  (function () {
      return "-.";
    }),
  (function () {
      return "+";
    }),
  (function () {
      return "+.";
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function () {
      return "and";
    }),
  (function () {
      return "as";
    }),
  (function () {
      return "assert";
    }),
  (function () {
      return "begin";
    }),
  (function () {
      return "class";
    }),
  (function () {
      return "constraint";
    }),
  (function () {
      return "do";
    }),
  (function () {
      return "done";
    }),
  (function () {
      return "downto";
    }),
  (function () {
      return "else";
    }),
  (function () {
      return "end";
    }),
  (function () {
      return "exception";
    }),
  (function () {
      return "external";
    }),
  (function () {
      return "false";
    }),
  (function () {
      return "for";
    }),
  (function () {
      return "fun";
    }),
  (function () {
      return "function";
    }),
  (function () {
      return "functor";
    }),
  (function () {
      return "if";
    }),
  (function () {
      return "in";
    }),
  (function () {
      return "include";
    }),
  (function () {
      return "inherit";
    }),
  (function () {
      return "initializer";
    }),
  (function () {
      return "lazy";
    }),
  (function () {
      return "let";
    }),
  (function () {
      return "match";
    }),
  (function () {
      return "method";
    }),
  (function () {
      return "module";
    }),
  (function () {
      return "mutable";
    }),
  (function () {
      return "new";
    }),
  (function () {
      return "object";
    }),
  (function () {
      return "of";
    }),
  (function () {
      return "open";
    }),
  (function () {
      return "or";
    }),
  (function () {
      return "private";
    }),
  (function () {
      return "rec";
    }),
  (function () {
      return "sig";
    }),
  (function () {
      return "struct";
    }),
  (function () {
      return "then";
    }),
  (function () {
      return "to";
    }),
  (function () {
      return "true";
    }),
  (function () {
      return "try";
    }),
  (function () {
      return "type";
    }),
  (function () {
      return "val";
    }),
  (function () {
      return "virtual";
    }),
  (function () {
      return "when";
    }),
  (function () {
      return "while";
    }),
  (function () {
      return "with";
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* record */[
              /* txt */_1,
              /* loc */symbol_rloc(/* () */0)
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return /* record */[
              /* txt */_1 + ("." + _3[/* txt */0]),
              /* loc */symbol_rloc(/* () */0)
            ];
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 1);
      return /* tuple */[
              _2,
              _3
            ];
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 1);
      return /* tuple */[
              _2,
              _3
            ];
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 1);
      return /* tuple */[
              _2,
              _3
            ];
    }),
  (function () {
      return /* [] */0;
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _1,
              _2
            ];
    }),
  (function () {
      return /* [] */0;
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _1,
              _2
            ];
    }),
  (function () {
      return /* tuple */[
              /* None */0,
              /* [] */0
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              /* None */0,
              /* :: */[
                _1,
                _2
              ]
            ];
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 1);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              /* Some */[_2],
              _3
            ];
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 1);
      return /* tuple */[
              _2,
              _3
            ];
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 1);
      return /* tuple */[
              _2,
              _3
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* PStr */Block.__(0, [_1]);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* PTyp */Block.__(1, [_2]);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* PPat */Block.__(2, [
                _2,
                /* None */0
              ]);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 2);
      var _4 = Parsing.peek_val(__caml_parser_env, 0);
      return /* PPat */Block.__(2, [
                _2,
                /* Some */[_4]
              ]);
    }),
  (function (__caml_parser_env) {
      throw [
            Parsing.YYexit,
            Parsing.peek_val(__caml_parser_env, 0)
          ];
    }),
  (function (__caml_parser_env) {
      throw [
            Parsing.YYexit,
            Parsing.peek_val(__caml_parser_env, 0)
          ];
    }),
  (function (__caml_parser_env) {
      throw [
            Parsing.YYexit,
            Parsing.peek_val(__caml_parser_env, 0)
          ];
    }),
  (function (__caml_parser_env) {
      throw [
            Parsing.YYexit,
            Parsing.peek_val(__caml_parser_env, 0)
          ];
    }),
  (function (__caml_parser_env) {
      throw [
            Parsing.YYexit,
            Parsing.peek_val(__caml_parser_env, 0)
          ];
    }),
  (function (__caml_parser_env) {
      throw [
            Parsing.YYexit,
            Parsing.peek_val(__caml_parser_env, 0)
          ];
    }),
  (function (__caml_parser_env) {
      throw [
            Parsing.YYexit,
            Parsing.peek_val(__caml_parser_env, 0)
          ];
    })
];

var yytables = /* record */[
  /* actions */yyact,
  /* transl_const */yytransl_const,
  /* transl_block */yytransl_block,
  /* lhs */"\xff\xff\x01\0\x02\0\x03\0\x03\0\x03\0\n\0\n\0\x0e\0\x0e\0\x04\0\x10\0\x10\0\x11\0\x11\0\x11\0\x11\0\x11\0\x11\0\x11\0\x05\0\x06\0\x07\0\x14\0\x14\0\x15\0\x15\0\x17\0\x17\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\b\0\b\0\x1e\0\x1e\0\x1e\0\x0f\0\x0f\0\x0f\0\x0f\0\x0f\0\x0f\0\x0f\0\x0f\0\x0f\0\x0f\0\x0f\0\x0f\0\x0f\0\x0f\0*\0-\0-\0-\0$\0%\0%\0.\0/\0\x16\0\x16\0\x16\0\x16\0\x16\0\x16\0\x16\0\x16\0\x16\0\x16\0\t\0\t\0\t\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\0'\x009\0<\0<\0<\x006\x007\x008\x008\0=\0>\0?\0?\0&\0(\0(\0A\0B\0E\0E\0E\0D\0D\0J\0J\0F\0F\0F\0F\0F\0F\0K\0K\0K\0K\0K\0K\0K\0K\0O\0P\0P\0P\0Q\0Q\0R\0R\0R\0R\0R\0R\0R\0S\0S\0T\0T\0T\0T\0U\0U\0U\0U\0U\0G\0G\0G\0G\0G\0^\0^\0^\0^\0^\0^\0a\0b\0b\0c\0c\0d\0d\0d\0d\0d\0d\0e\0e\0e\0g\0V\0:\0:\0h\0i\0)\0)\0j\0k\0\f\0\f\0\f\0H\0H\0H\0H\0H\0H\0H\0H\0p\0p\0m\0m\0l\0l\0n\0o\0o\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0L\0L\0\x84\0\x84\0\x85\0\x85\0\x85\0\x85\0\x86\0]\0]\0\x87\0\x87\0\x87\0\x87\0\x87\0\x1f\0\x1f\0\x8c\0\x8d\0\x89\0\x89\0\\\0\\\0\\\0u\0u\0\x8f\0\x8f\0v\0v\0v\0w\0w\0\x80\0\x80\0\x90\0\x90\0\x90\0\x91\0\x91\0\x83\0\x83\0\x81\0\x81\0Y\0Y\0Y\0Y\0Y\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0q\0q\0\x8b\0\x8b\0\x8b\0\x8b\0\x8b\0\x8b\0\x8b\0\x8b\0\x8b\0\x8b\0\x8b\0\x8b\0\x8b\0\x8b\0\x8b\0\x8b\0\x8b\0\x8b\0\x8b\0\x8b\0\x8b\0\x8b\0\x92\0\x92\0\x92\0\x96\0\x96\0\x95\0\x95\0\x95\0\x95\0\x97\0\x97\x003\0\x98\0\x98\0 \0!\0!\0\x99\0\x9a\0\x9e\0\x9e\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9c\0\x9c\0\x9c\0\xa1\0\xa2\0\xa2\0\xa4\0\xa4\0\xa5\0\xa5\0\xa5\0\xa6\0\xa3\0\xa3\0\xa3\0\xa7\0I\0I\0\x9f\0\x9f\0\x9f\0\xa8\0\xa9\0#\0#\x005\0\xab\0\xab\0\xab\0\xab\0\xa0\0\xa0\0\xa0\0\xaf\0\xb0\0\"\x004\0\xb2\0\xb2\0\xb2\0\xb2\0\xb2\0\xb2\0\xb3\0\xb3\0\xb3\0\xb4\0\xb5\0\xb6\0\xb7\x001\x001\0\xb8\0\xb8\0\xb8\0\xb8\0\xb9\0\xb9\0\x8a\0\x8a\0Z\0Z\0\xb1\0\xb1\0\x12\0\x12\0\xba\0\xba\0\xbc\0\xbc\0\xbc\0\xbc\0\xbc\0\xbe\0\xbe\0\xae\0\xae\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\x1b\0\x1b\0\xc6\0\xc5\0\xc5\0\xc2\0\xc2\0\xc3\0\xc3\0\xc1\0\xc1\0\xc7\0\xc7\0\xc8\0\xc8\0\xc4\0\xc4\0\xbd\0\xbd\0_\0_\0M\0M\0\xc9\0\xc9\0\xad\0\xad\0\xc0\0\xc0\0\xc0\0\xca\0W\0\x7f\0\x7f\0\x7f\0\x7f\0\x7f\0\x7f\0\x7f\0\x93\0\x93\0\x93\0\x93\0\x93\0\x93\0\x93\0\x93\0\x93\0\x93\0\x93\0@\0@\0\x88\0\x88\0\x88\0\x88\0\x88\0\xcb\0\xcb\0\xcb\0\xcb\0\xcb\0\xcb\0\xcb\0\xcb\0\xcb\0\xcb\0\xcb\0\xcb\0\xcb\0\xcb\0\xcb\0\xcb\0\xcb\0\xcb\0\xcb\0\xcb\0\xcb\0\xcb\0\xcb\0\xaa\0\xaa\0\xaa\0\xaa\0\xaa\0~\0~\0x\0x\0x\0x\0x\0}\0}\0\x94\0\x94\0\x19\0\x19\0\xbb\0\xbb\0\xbb\x000\x000\0`\0`\0N\0N\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0y\0\x8e\0\x8e\0\x9b\0\x9b\0z\0z\0[\0[\0X\0X\0C\0C\0f\0f\0f\0f\0f\0;\0;\0t\0t\0\x82\0\x82\0{\0{\0|\0|\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcd\0\xcd\0\x1c\0\xcf\0,\0\r\0\r\0\xac\0\xac\0s\0s\0s\0\x1d\0+\0\xce\0\xce\0\xce\0\xce\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
  /* len */"\x02\0\x02\0\x02\0\x02\0\x02\0\x01\0\x02\0\x01\0\0\0\x02\0\x01\0\x01\0\x03\0\x01\0\x02\0\x04\0\x03\0\x03\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x05\0\x01\0\x01\0\x02\0\x01\0\x01\0\x03\0\x03\0\x04\0\x04\0\x03\0\x04\0\x05\0\x05\0\x03\0\x03\0\x04\0\x06\0\b\0\x06\0\x05\0\x05\0\x04\0\x02\0\x01\0\x03\0\x01\0\0\0\x02\0\x02\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x02\0\x01\0\x03\0\x02\0\x04\0\x02\0\x04\0\x01\0\x02\0\x05\0\x04\0\x01\0\x03\0\x03\0\x04\0\x03\0\x04\0\x03\0\x03\0\x01\0\x02\0\0\0\x02\0\x02\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x02\0\x01\0\x04\0\x03\0\x02\0\x06\0\x03\0\x04\0\x05\0\x01\0\x02\0\x06\0\x05\0\0\0\x02\0\x05\0\x01\0\x02\0\x06\0\x06\0\x02\0\x04\0\x02\0\0\0\x03\0\x03\0\x02\0\x01\0\x02\0\x02\0\x03\0\x02\0\x01\0\x04\0\x01\0\x03\0\x03\0\x05\0\x05\0\x03\0\x03\0\x02\0\x03\0\x05\0\0\0\0\0\x02\0\x05\0\x03\0\x03\0\x03\0\x03\0\x02\0\x01\0\x02\0\0\0\x06\0\x05\0\x05\0\x06\0\x06\0\x06\0\x04\0\x07\0\n\0\x01\0\x06\0\x04\0\x05\0\x03\0\x04\0\x01\0\x03\0\x03\0\x02\0\x01\0\x02\0\x03\0\0\0\0\0\x02\0\x03\0\x03\0\x06\0\x03\0\x02\0\x01\0\x05\0\x05\0\x03\0\x03\0\x03\0\x01\0\x02\0\x07\0\x07\0\x01\0\x02\0\b\0\x07\0\x01\0\x02\0\x03\0\x05\0\x02\0\x05\0\x02\0\x04\0\x02\0\x02\0\x01\0\x01\0\x01\0\0\0\x02\0\x01\0\x03\0\x01\0\x01\0\x03\0\x01\0\x02\0\x03\0\x07\0\x07\0\x04\0\x04\0\x07\0\x06\0\x06\0\x05\0\x01\0\x02\0\x02\0\x07\0\x05\0\x06\0\n\0\x03\0\b\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x02\0\x02\0\x05\0\x07\0\x07\0\x07\0\x03\0\x03\0\x03\0\x04\0\x04\0\x02\0\x01\0\x01\0\x01\0\x01\0\x03\0\x03\0\x04\0\x03\0\x04\0\x04\0\x03\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x03\0\x03\0\x05\0\x05\0\x04\0\x04\0\x02\0\x06\0\x06\0\x04\0\x04\0\x06\0\x06\0\x02\0\x02\0\x03\0\x04\0\x04\0\x02\0\x06\0\x06\0\x03\0\x03\0\x04\0\x06\0\x05\0\b\0\x07\0\x01\0\x01\0\x02\0\x01\0\x01\0\x02\0\x02\0\x02\0\x02\0\x01\0\x01\0\x02\0\x02\0\x07\0\b\0\x03\0\x05\0\x01\0\x02\0\x05\0\x03\0\x01\0\x03\0\x02\0\x02\0\x05\0\x01\0\x03\0\x03\0\x05\0\x02\0\x02\0\x05\0\x03\0\x03\0\x03\0\x01\0\x01\0\x03\0\x02\0\x03\0\x01\0\x03\0\x05\0\x01\0\x03\0\x02\0\x04\0\x02\0\x02\0\x02\0\x01\0\x03\0\x03\0\x01\0\x02\0\x02\0\x03\0\x03\0\b\0\b\0\x03\0\x03\0\x02\0\x02\0\x02\0\x01\0\x01\0\x01\0\x01\0\x03\0\x01\0\x01\0\x02\0\x03\0\x03\0\x04\0\x04\0\x04\0\x02\0\x04\0\x03\0\x03\0\x05\0\x05\0\x04\0\x04\0\x06\0\x06\0\x01\0\x03\0\x03\0\x03\0\x01\0\x03\0\x01\0\x02\0\x04\0\x03\0\x03\0\x01\0\x05\0\x01\0\x02\0\x07\0\x01\0\x02\0\x07\0\x06\0\x03\0\0\0\0\0\x02\0\x03\0\x02\0\x03\0\x02\0\x05\0\x05\0\x04\0\x07\0\0\0\x01\0\x03\0\x02\0\x01\0\x03\0\x02\0\x01\0\0\0\x01\0\x03\0\x02\0\0\0\x01\0\x01\0\x02\0\x01\0\x03\0\x01\0\x01\0\x02\0\x03\0\x04\0\x01\0\x06\0\x05\0\0\0\x02\0\x04\0\x02\0\x01\0\x01\0\x02\0\x05\0\x07\0\b\0\b\0\x01\0\x01\0\x01\0\x01\0\x02\0\x02\0\x01\0\x01\0\x02\0\x03\0\x04\0\x04\0\x05\0\x01\0\x03\0\x06\0\x05\0\x04\0\x04\0\x01\0\x02\0\x02\0\x03\0\x01\0\x03\0\x01\0\x03\0\x01\0\x02\0\x01\0\x04\0\x01\0\x06\0\x04\0\x05\0\x03\0\x01\0\x03\0\x01\0\x03\0\x02\0\x01\0\x01\0\x02\0\x04\0\x03\0\x02\0\x02\0\x03\0\x05\0\x03\0\x04\0\x05\0\x04\0\x02\0\x04\0\x06\0\x04\0\x01\0\x01\0\x03\0\x04\0\x01\0\x03\0\x01\0\x03\0\x01\0\x01\0\x05\0\x02\0\x01\0\0\0\x01\0\x03\0\x01\0\x02\0\x01\0\x03\0\x01\0\x03\0\x01\0\x03\0\x01\0\x03\0\x01\0\x03\0\x03\0\x02\0\x01\0\x04\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x01\0\x01\0\x01\0\x03\0\x03\0\x02\0\x03\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x02\0\x01\0\x01\0\x01\0\x01\0\x03\0\x01\0\x02\0\x02\0\x01\0\x01\0\x01\0\x03\0\x01\0\x03\0\x01\0\x03\0\x01\0\x03\0\x04\0\x01\0\x03\0\x01\0\x03\0\x01\0\x03\0\x02\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x02\0\0\0\x01\0\0\0\x01\0\x01\0\x01\0\0\0\x01\0\0\0\x01\0\0\0\x01\0\0\0\x01\0\x01\0\x02\0\x02\0\0\0\x01\0\0\0\x01\0\0\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x03\0\x04\0\x04\0\x04\0\0\0\x02\0\0\0\x02\0\0\0\x02\0\x03\0\x04\0\x04\0\x01\0\x02\0\x02\0\x04\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0",
  /* defred */"\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0<\x02\0\0\0\0\0\0u\x02>\x02\0\0\0\0\0\0\0\0\0\0;\x02?\x02@\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xa5\x02\xa6\x02\0\0A\x02\0\0\0\0\0\0\xa7\x02\xa8\x02\0\0\0\0=\x02v\x02\0\0\0\0{\x02\0\0\xed\x02\0\0\0\0\0\0\0\0\0\0B\x012\0\0\x007\0\0\x009\0:\0;\0\0\0=\0>\0\0\0\0\0A\0\0\0C\0I\0\xd2\x01w\0\0\0\xc7\0\0\0\0\0\0\0\0\0\0\0\0\0\x13\x01\x14\x01p\x02S\x01\xab\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xee\x02\0\0[\0\0\0b\0c\0\0\0\0\0h\0\0\0Z\0]\0^\0_\0`\0\0\0d\0\0\0p\0\xc3\0\x05\0\0\0\xef\x02\0\0\0\0\0\0\x07\0\0\0\r\0\0\0\xf0\x02\0\0\0\0\0\0\n\0\x0b\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0}\x02\t\x02\xf1\x02\0\0\x1a\x02\n\x02\xfb\x01\0\0\0\0\xff\x01\0\0\0\0\xf2\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0O\x02\0\0\0\0\0\0\0\0\x86\x01\xf3\x02\0\0\0\0\x9b\x01u\x01\0\0\0\0B\x02\x84\x01\x85\x01\0\0\0\0\0\0\0\0\0\0\0\0N\x02M\x02\x8d\x02\0\x004\x01\x15\x01\x16\x01\0\0\0\0\x99\x02\0\0m\x02n\x02\0\0o\x02k\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x000\0\0\0\0\0\0\0\0\0\0\0\0\0f\x01\0\x008\x01:\x02\0\0\0\0s\x02\0\0\0\0,\x01\0\0\xab\x02\xac\x02\xad\x02\xae\x02\xaf\x02\xb0\x02\xb1\x02\xb2\x02\xb3\x02\xb4\x02\xb5\x02\xb6\x02\xb7\x02\xb8\x02\xb9\x02\xba\x02\xbb\x02\xbc\x02\xbd\x02\xbe\x02\xbf\x02\xc0\x02\xc1\x02\xc2\x02\xc3\x02\xa9\x02\xc4\x02\xc5\x02\xc6\x02\xc7\x02\xc8\x02\xc9\x02\xca\x02\xcb\x02\xcc\x02\xcd\x02\xce\x02\xcf\x02\xd0\x02\xd1\x02\xd2\x02\xd3\x02\xd4\x02\xd5\x02\xaa\x02\xd6\x02\xd7\x02\xd8\x02\xd9\x02\xda\x02\0\0\0\0\0\0\0\0\0\0\0\0R\x02g\x02f\x02\0\0e\x02\0\0h\x02a\x02c\x02U\x02V\x02W\x02X\x02Y\x02b\x02\0\0\0\0\0\0d\x02j\x02\0\0\0\0i\x02\0\0t\x02Z\x02`\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xa0\x02\0\x003\x014\0\0\0\x91\x02\0\0\0\0\x01\0\0\0\0\0\0\0\0\x005\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x12\x01\0\0\0\0T\x01\0\0\xac\x01\0\0J\0\0\0x\0\0\0\xc8\0B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0C\x01F\x01\0\0\0\0\0\0\x07\x01\b\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0U\0M\0\x80\x02\0\0\0\0\0\0X\0\0\0\0\0\x02\0g\0Y\0\0\0q\0\0\0\xc4\0\0\0\x03\0\x04\0\x06\0\t\0\x0e\0\0\0\0\0\0\0\x13\0\0\0\x12\0\0\0y\x02\0\0#\x02\0\0\0\0\xa2\x02\0\0\x16\x02\0\x008\x02\x0e\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\b\x02\x84\x02\0\0\x0f\x02\x14\0\xfc\x01\0\0\0\0\0\0\0\0\0\0\0\0\x0b\x02\x15\0\x82\x01\0\0\x81\x01\x89\x01\x8a\x01w\x02\0\0\0\0\0\0\0\0\0\0\0\0\x91\x01\0\0[\x02\0\0\0\0_\x02\0\0\0\0]\x02T\x02\0\0D\x02C\x02E\x02F\x02G\x02I\x02H\x02J\x02K\x02L\x02\x8b\x01\0\0\0\0\0\0\0\0\x16\0\x83\x01\0\0y\x01z\x01\0\0\0\0\0\0\0\0\0\0\xe5\x02\0\0\0\0\x1a\x01\0\0\0\0\0\0\0\0l\x02\0\0\0\0\0\0\0\0^\x02\0\0\\\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xd5\0\0\0\0\0\0\0\x1c\0\0\0\0\0\0\0\0\0\0\0D\0/\0\0\0\0\0\0\0\0\0'\x01&\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe9\x02\0\0\0\0\0\0\0\0\x8f\x02\0\0\0\0S\x02\0\0\x18\x01\0\0\0\0\x17\x01\0\0Q\x02P\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x005\x01\0\0\0\0\x94\0\0\0\0\0\0\0\xc9\x01\xc8\x01\0\0\xbc\x01\0\0\0\0\0\x001\0\xe1\x02\0\0\0\0\0\0\0\0\0\0|\x02q\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xcd\0\0\0\0\0\0\0\0\0\0\0\xe1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0K\x01I\x01;\x01\0\0H\x01D\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0j\0V\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x8b\x02\x88\x02\x87\x02\x8c\x02\0\0\x89\x02\x11\0\0\0\x10\0\f\0\"\x02\0\0 \x02\0\0%\x02\x12\x02\0\0\0\0\0\0\0\0\r\x02\0\x007\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0z\x02~\x02\0\0\0\0\0\x002\x02\0\0\x10\x02\0\0\0\0\x8d\x01\x8c\x01\0\0\0\0\0\0\0\0\0\0\0\0\x94\x01\0\0\x93\x01w\x01v\x01\x80\x01\0\0|\x01\0\0\x9e\x01\0\0\0\0\x88\x01\0\0\xe6\x02\xe3\x02\0\0\0\0\0\0\x1d\x01\x1b\x01\x19\x01\0\0\0\0\0\0\xcb\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xd6\x014\x02\0\0\0\0\0\0\xd4\0\0\0\xd6\0\0\0\xd7\0\xd1\0\xdc\0\0\0\xcf\0\0\0\xd3\0\0\0\0\0\0\0\xe5\0\0\0\0\0\\\x01\0\0\x17\0\x19\0\x1a\0\0\0\0\0\x1b\0\0\0'\0\0\0&\0\x1f\0\x1e\0\"\0\0\0\0\0e\x01\0\0h\x01\0\0\0\x007\x016\x01\0\x000\x01/\x01+\x01*\x01\xdc\x02\0\0\0\0\xe7\x02\xe8\x02\0\0\0\0\0\0\0\0\0\0=\x01s\x01\0\0t\x01\0\0\x1c\x01\xdf\x02\0\0\0\0\0\0\0\0\0\0\0\0G\0H\0\0\0\x11\x01\x10\x01\0\0i\0\0\0\xbf\x01\0\0\0\0\0\0\0\0\xc2\x01\xbe\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0V\x01\0\0\0\0\0\0\0\0\0\0W\x01N\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0T\0S\0\0\0O\0N\0\0\0\0\0\0\0\xed\x01\0\0\x81\x02\0\0\0\0\0\0\0\0\0\0n\0\0\0\0\0\0\0\0\0\0\0\x0f\0\0\0\x13\x02&\x02\0\0\0\0\0\0\x17\x02\x15\x02\0\0\0\0\0\0\xf9\x016\x02\0\0\x19\x02\0\0\0\0\0\0\f\x02\0\0\0\0\x85\x02\0\0\x7f\x02\xfe\x01\0\0x\x02\0\0\0\0\xa4\x01\0\0\x8f\x01\x8e\x01\x92\x01\x90\x01\0\0\0\0\x98\x01\x97\x01\0\0\xdd\x02\0\0\0\0\0\0\0\0\0\0\x7f\0\0\0\xc6\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xd4\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01a\x01\0\0\0\0\0\0\0\0\0\0\0\0.\0\0\0\0\0(\0\0\0#\0!\0\0\0\0\0\0\0\0\0U\x01\0\0?\x01\0\0\0\0\0\0K\0\0\0v\0\0\0\0\0\x91\0\0\0\0\0\0\0\0\0\0\0\0\0\x9c\0\x95\0\xe9\0\0\0\0\0\xbd\x01\0\0\xb0\x01\0\0\xc1\x01\0\0\xde\x02)\x01(\x01\0\0\0\0\0\0\0\0\x1f\x01\x1e\x01Q\x01\0\0\0\0Y\x01\0\0Z\x01\0\0\0\0\xb0\x01L\0\0\0\0\0\0\0%\x01#\x01\0\0!\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xc4\x01\0\0\0\0o\0m\0\0\0\0\0\xa7\x01\0\0\0\0!\x02(\x02\0\0\x14\x02*\x02\0\0\0\0\0\0\0\x009\x02\0\0\0\0\x1c\x02\0\0\x11\x02\0\x003\x02\xa4\x02\xa3\x01\0\0\0\0\x96\x01\x95\x01$\x01\"\x01 \x01\0\0\xcc\x01\xca\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xae\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x87\0\0\0\0\0\0\0\x89\0y\0}\0\0\0\xd7\x015\x02\xd3\x01\0\0\0\0\x93\x02\x92\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xd2\0\0\0^\x01\0\0]\x01\0\0\0\0,\0\0\0-\0\0\0%\0$\0\0\0\xec\x02\0\0\0\0\0\0>\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x9b\0\0\0\xc0\x01\0\0\xb6\x01\0\0\0\0\0\0\0\0\0\0\0\0\xcd\x01\xce\x01\0\0\0\0\x95\x02\0\0\xef\0:\x019\x012\x011\x01.\x01-\x01\0\0\0\0\0\0\0\0\0\0X\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xee\x01r\0\0\0\0\0s\0\0\0\0\0$\x02\x18\x02+\x02\xfa\x01\xf6\x01\0\0\0\0\0\0\0\0\x9a\x01\x99\x01\0\0\x82\x02\xb2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xb6\0\0\0\0\0\0\0\xb1\0\0\0\0\0\0\0\0\0\x83\0\0\0\0\0\0\0\0\0\x86\0\0\0\xa9\x01\xaa\x01\0\0\xe6\0\0\0\xd9\0\xd0\0\xce\0\0\0\0\0\0\0\0\0\x18\0\0\0)\0+\0\xe2\0\xe3\0\0\0\x92\0\0\0\x99\0\0\0\x9a\0\0\0\0\0\0\0\x98\0\x97\x02\0\0\0\0\0\0\x97\0\0\0\0\0\0\0\0\0\0\0\xcf\x01\0\0\0\0\xad\x01\0\0\0\0\0\0\xe0\x01\xe1\x01\xe2\x01\xe3\x01A\x01\0\0M\x01\0\0\0\0\0\0R\x01\xae\x01z\0\0\0\0\0\0\0\0\0\xc5\0\0\0\0\0\xc5\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe6\x01\xe7\x01\0\0)\x02\0\0\x1f\x02\0\0\xc9\0\0\0\0\0\0\0\0\0\0\0\xb0\0\xaf\0\0\0\0\0\0\0\0\0\xac\0/\x02\0\0\0\0\x81\0\0\0\x8f\0\0\0\x8e\0\x8b\0\x8a\0\0\0\0\0b\x01_\x01\0\0\xf2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xb9\x01\0\0\0\0\0\0\xd9\x01\0\0\xd0\x01\0\0\xaf\x01\0\0\0\0\0\0\xde\x01\xe4\x01\xe5\x01@\x01\0\0\0\0[\x01\xca\0\xf0\x01\xf4\x01\xb0\x01l\0\0\0\xdf\x01\xe8\x01\xc6\0\0\0~\x01}\x01\x83\x02\xad\0\0\0\xb4\0\0\0\0\0\0\0\0\0\0\0\xbd\0\xb7\0\xaa\0\0\0\0\0\x88\0\0\0\0\0*\0\x9d\0\x96\0\0\0\0\0\0\0\xa5\0\0\0\0\0\0\0\0\0\xd1\x01\0\0\0\0\0\0\xb7\x01\xdb\x01\0\0\0\0\0\0\0\0\xe9\x01\0\0O\x01\0\0\xab\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xbc\0\0\0\x8d\0\x8c\0\xf0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xa1\0\0\0\0\0\0\0\0\0\0\0\xea\x01\xeb\x01P\x01\xbb\0\xb8\0\x9d\x02\x9e\x02\0\0\0\0\0\0\0\0\xb9\0\xa9\0\xa3\0\xa4\0\0\0\0\0\0\0\0\0\xa2\0\xba\x01\0\0\xec\x01\0\0\0\0\0\0\0\0\0\0\xa6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xba\0\0\0\0\0\0\0\xdd\x01\xa7\0",
  /* dgoto */"\b\x008\0e\0{\0\x83\0\x95\0\x9f\0\xad\x007\x02f\0|\0\x84\0:\0Q\x01\x7f\0;\0\x87\0\x88\0\xc1\x01\xe9\x01N\x02\x16\x03\x93\x01 \x02\xd7\0<\0=\0\xbf\x02n\x01>\0?\0\xa1\0A\0B\0C\0D\0E\0F\0G\0H\0I\0J\0K\0L\0M\0O\x02N\0u\x01\x95\x01x\x03n\0o\0p\0O\0r\0s\0t\0u\0v\0H\x01\xa2\x02w\0\xa1\x01B\x03\x96\x01P\0w\x01\xc7\0\n\x02\xbb\x03Y\x04L\x04\r\x03\xef\x02\xdf\x04Z\x04\x83\x01\xc2\x01[\x04R\x02S\x02J\x03\xf1\x03U\x05\x8c\x04\x89\x04\x85\x04Q\0_\x05b\x03\xb9\x05\x96\x04c\x03\xa7\x04M\x04N\x04O\x04\xd5\x04\xd6\x04>\x05\x86\x05\xaf\x05\xab\x05e\x05x\0\xa3\x01R\0y\x01\xc7\x03j\x04\xc8\x03\xc6\x03\x05\x03\xb1\0S\0\"\x01\xb7\x01\x10\x03\x0e\x03T\0U\0V\0f\x04W\0X\0\xde\0Y\0Z\0\xdf\0\xe8\x000\x02\xe5\0\x85\x01\x86\x01\x8f\x02\x7f\x02[\0d\x03\xba\x05\xb6\0\\\0q\x01=\x02\x11\x03\xe0\0\xe1\0\xb7\0\xb8\0\x98\0\xdb\x01\xde\x01\xdc\x01c\x04]\0s\x01M\x01Y\x02\xf7\x03\x9b\x04\x97\x04`\x05Z\x02N\x03[\x02S\x03\x1d\x04\xf1\x02\xb8\x03\x98\x04\x99\x04\x9a\x04\x0f\x02\x03\x02\xf4\x02P\x04a\x05b\x05\x92\x03\x12\x05.\x05\x13\x05\x14\x05\x15\x05\x16\x05y\x03*\x05\x99\0\x9a\0\x9b\0\x9c\0\x9d\0\x9e\0\xbd\x01\xb1\x02\xb2\x02\xb3\x02-\x044\x045\x04\x8b\x03*\x04\xf7\x02\xbe\x01?\x01\x1d\x01\x1e\x018\x02R\x01",
  /* sindex */"\x14\b\xd9>\x9d\x06p,\x05,k\x0f\x90@\x96D\0\0\x84\x04l\x02WF\x84\x04\0\0\xca\x01e\0\x11\x01\0\0\0\0\x84\x04\x84\x04\x84\x04\x84\x04\x19\x03\0\0\0\0\0\0\x84\x04\x96FR\xff1?\x8b?\xdb:\xdb:\x1d\x05\0\0\xb87\xdb:\x84\x04\0\0\0\0\xe8\x04\0\0\x84\x04\x84\x04\x8e\xff\0\0\0\0WF\xd9>\0\0\0\0\x84\x04\xb9\xff\0\0\x84\x04\0\0(\x01/\0\x9b\x0b\x18\0\xd9G\0\0\0\0\xf6\x02\0\x008\0\0\0\0\0\0\0\xde\x01\0\0\0\0\"\x027\x02\0\0/\0\0\0\0\0\0\0\0\x000\x02\0\0\xd9E\x9b\0WFWF\x90@\x90@\0\0\0\0\0\0\0\0\0\0\xca\x01e\0\x18\x04B\x05\x9d\x06\xb9\xff\x11\x01\0\0\x88\x03\0\x008\0\0\0\0\x007\x02/\0\0\0\x9d\x06\0\0\0\0\0\0\0\0\0\0\x87\x02\0\0\x9e\x02\0\0\0\0\0\0l\x02\0\0<\x02`\x02/\0\0\0\xe3\x02\0\0\xe4,\0\0R\x04/\0R\x04\0\0\0\0\x0b\t\xd5\x02\xac\xff\x87\x04\n\x03\x85Ik\x0f\x8c\x03l\x02\xf3\x02\0\0\0\0\0\0L\0\0\0\0\0\0\0\xd4\x01\x13\0\0\0\x90\x03\xb6\x02\0\0+\x05\xf6\x02\x96D\x96E\x18\x03\x87C\xcdC\0\0\x90;f\x03\xb7\x03\x1c\x03\0\0\0\0J\0$\x04\0\0\0\0\x96D\x96D\0\0\0\0\0\0U\x04\x98\x04\xdb:\xdb:S\x04WF\0\0\0\0\0\0(8\0\0\0\0\0\0\xe2?\xcf\x03\0\0~\x04\0\0\0\0X\x04\0\0\0\0O\x02\x98G\xbd\x04\x96D\xc7B\xd5\x02\x90@\x95\x04o\x02\xd9>[\x05$\x04\0\0WF\0\0\xd9\x04\x0e\x01\xe5\x04\x91\xff\0\0\x93\x04\0\0\0\0\xea\x04\xa1\x04\0\0\x95H\xbe\x04\0\0\xbe\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x10\x05\x80>\x80>\x84\x04\x8e\xff\xd5\x04\0\0\0\0\0\0WF\0\0\xe1\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xb3\0\0\0\0\0\0\0\0\0\0\0WF\0\0\0\0\0\0)\0v\xff\x80>\x90@\xcc\x04l\x02\xc1\x02\xf3\x02\b\x05\0\0\xe2\x04\0\0\0\0\x90@\0\0\xb9\x04\x90@\0\0\xdb:\x9b\x0b/\0\x84\x04\0\0W\x05\t\x06\x90@\x90@\x90@\x90@\x90@\x90@\x90@\x90@\x90@\x90@\x90@\x90@\x90@\x90@\x90@\x90@\x90@\x90@\x90@\x90@\x90@\x90@\x90@\0\0\x96D\x90@\0\0\xb9\x04\0\0\xfa\x04\0\0\xcf\x03\0\0\xcf\x03\0\0\0\0\x90@\x1f\x04WFWF6\x05;\x05WF6\x05\x18Fb\x01\0\0\0\0\x90@b\x01b\x01\0\0\0\0~\x04\x98\x01\x95\x04\x18\x04\x02\x05\x9d\x06\0\0;\x02\0\0\0\0\0\0\xad\x02\x1b\x05J\x03\0\0\xb9\x04\x80\x05\0\0\0\0\0\x003\x05\0\0\xcf\x03\0\0B\x06\0\0\0\0\0\0\0\0\0\0R\x04/\0R\x04\0\0R\x04\0\0I\f\0\0\x19\x04\0\0M\x05\xa5\x05\0\0I\f\0\0I\f\0\0\0\0\xab\x05\x97\x05]\x05k\x0f;\x03S\x04\x1d\x01{\x05\xba\x05\0\0\0\0\xb6\x05\0\0\0\0\0\0=\x03`\x05x\x05k\x0f_\x07\xf3\x02\0\0\0\0\0\0T=\0\0\0\0\0\0\0\0\xbf\x05\xbb\x05@\0z\x05\xf9\x03}\x05\0\0}\x05\0\0\x86\x05f\x03\0\0\x87\xff\xb7\x03\0\0\0\0\x81\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0,\x02\x94=\xd4=\x14>\0\0\0\0\x8b\x05\0\0\0\0\x96D\xc0\x02\x80>S\x04S\x04\0\0b\x01\xd0\x04\0\0\xf5\x02~\x04*\x04\xad\x05\0\0\x03't\x01\x03'S\x04\0\0\xec\x05\0\0k\x0f+\x03\x96E\x01<d\x02D\x05d\x05GB\0\0\x96D\x95\x05\x0e\x05\0\0\x0b\x01\x90@\x8b\x01\xa7\x03\xd6\x03\0\0\0\0b\x01|\x06\x18\x03\x90@\0\0\0\0\x18\x03\x90@;\x05\xc7\x03\x90@\xbb\xffz\xff\xdb:k\x0f\x96D\0\0\xa4\x05\xa6\x05\x94\x05\x84\x04\0\0\x96D\xc3\x05\0\0v\x01\0\0\x98\x0b\xd6\f\0\0\xaa\x05\0\0\0\0\xa8\x05\x96\x05\xc1\x02\xf1\x05\x18\x04\x19\x03\xc1\x02/\0\0\0\x96D5\x04\0\0l\x03\x9c\x05*\x04\0\0\0\0b\x03\0\0\xef\0\xfe\x05\x80>\0\0\0\0\x96F;\x05\x90@\x90@\x988\0\0\0\0\x86I\x86IQI\x1a\x07\x95HQI\x8f\f\x8f\f\x8f\f\x8f\f\xa5\x02\xe5\x05\xe5\x05\x8f\f\xa5\x02\xa5\x02QI\xe5\x05\xa5\x02\xa5\x02\xa5\x02\0\0\xe5\x05\x0f\x05/\0>A\x06\x06\0\0\xd5\x05\xc1\x02~\x04~\x04\x95H\x90@\x90@\x90@\xd9\x05b\x01b\x01\0\0\0\0\0\0\x01\x06\0\0\0\0QI\xdd\x05\x13\x05\x8f\xff\xc9\x05H\x04\xfe\x03\0\0\0\0m\x03\x14\x06\x18\x04\xe2\x04\xd8\x02/\0b\x03k\x0f\x18\x06~\x04\0\0\0\0\0\0\0\0\x11\x06\0\0\0\0R\x04\0\0\0\0\0\0\xda\0\0\0)\x06\0\0\0\0I\f\xbf\0\x19\x01\x1d\x10\0\0\xec\x01\0\0\xe2\x05\xda\x05\xc4\x05k\x0f/\x03k\x0fk\x0fu\x03\0\0\0\0\xbb\x01l\x02\xf2\x05\0\0\xd7\x05\0\0\x81\x03\x96D\0\0\0\0 \x03\x96D \0?\x03\x04\x06\"\x01\0\0\x9c\r\0\0\0\0\0\0\0\0\xaa\x02\0\x004\x06\0\0`\xff`\xff\0\0\xe9\x05\0\0\0\0\x90@\x90@\x90@\0\0\0\0\0\0\x07\x06\xbb\0\xf0\x05\0\0\xc4A\x85I\x03\x06\0\0\xb6\x02\xe8\x05\xf4\x05\xef\x05S\x04\0\0\0\0/\0\xc2\x01\x90@\0\0\x0f\x06\0\0\x96D\0\0\0\0\0\0\x17\x06\0\0\x17\x06\0\0r<\x90@GB\0\0\x1d\0Q\x06\0\0\x90@\0\0\0\0\0\0L\x06\x19\x03\0\0iG\0\0\x18\x04\0\0\0\0\0\0\0\0\xfd\0\0\0\0\0\x95H\0\0\x95HA\x06\0\0\0\0\x95H\0\0\0\0\0\0\0\0\0\0S\x04y\xff\0\0\0\0\xc1\x02\xe2\x04/\0\x90@\x94\xff\0\0\0\0\x10\x02\0\0S\x04\0\0\0\0\xd5\x02/\0\x18\x04/\0+\x01p\x05\0\0\0\x005\x02\0\0\0\0+\x02\0\0\x83\x05\0\x008\x01C\x06\x05\x06l\x02\0\0\0\0\x90@\x0b\x06S\0\xa1\x04\xbe\x04\xbe\x04\xb3\0\xa6\xff\x90@\0\0$\x0b\x90@\xe3<\x81AD\x06\0\0\0\0k\x0fC\x06/\0!\x06$\x06\xf9G\x03\x05E\0\xae\xff\x90@Y\x06\x18\x04\0\0\0\0\x19\x03\0\0\0\0\xfc\x05\xc2\x04i\x06\0\0\0\0\0\0\x18\x04$\x02l\x03v\x02c\x06\0\0\x1a\x06s\x05\x18\x048\x06\xe2\xff\0\0I\f\0\0\0\0k\x0f@\x01t\x06\0\0\0\0l\x02+\0S\x04\0\0\0\0k\x0f\0\0\x0e\x06S\x04\xf3\x02\0\0\xf2\x055\x06\0\0\x13\x06\0\0\0\0_\x07\0\0\xf9\x03&\x06\0\0\xf9\x03\0\0\0\0\0\0\0\0\x96D;\x03\0\0\0\0\xcd\xff\0\x007H\xb6\0\xd9\xffj\x06*\x04\0\0l\x02\0\0a\n\x9c\x04/\0\xc4A^\x01\x8d.\x03'/\0\0\0%\x06\x07\0(\x06\xcb\x03r\x06r\x06\x80\x06/\x06O\x06\0\0\0\0\x90@\x90@\x96DWH\x18\x04p\x05\0\0\x9c\xff\x9d\xff\0\0\xa0\xff\0\0\0\0\x90@\x90@l\x06\x18\x05\0\0\xb5H\0\x001\x06k\x0f\x96D\0\0$\x02\0\0\x19\x03k\x0f\0\0k\x0f\x8e\xff\x90@\x8e\xffu\xff/\0\0\0\0\0\0\0\x96D*\x04\0\0\xe3F\0\0<\x06\0\0\x82\x06\0\0\0\0\0\x003\x04\xeb\0>\x05U\x02\0\0\0\0\0\0Z\x06T\x01\0\0d\x06\0\0\x90@\xa3\x02\0\0\0\0\xc4A\x81\x06g\x06\0\0\0\0h\x06\0\0m\x06\x95Ha\n$\x02p\x05\x98\x06\x90\0*\x04\x96\x03\0\0\xfe\x03;\x02\0\0\0\0\x18\x04<\x06\0\0;\x02\x9f\x06\0\0\0\0.\x02\0\0\0\0A\x01\0\0k\x0fl\x02\0\0\xf2\x05\x18\x03\0\0\xac\x06\0\0k\x0f\0\0\0\0\0\0%\x04Z\0\0\0\0\0\0\0\0\0\0\0\f\x03\0\0\0\0r\x0e\xa8\x06\x85Iv\x06\x8d.z\x06\0\0\xa1\x06S\x04x\x06\0\0]\x06*\x03\xb6\x02\x07Ck\x0f\x9c\x04\b\x05\0\0P\x04S\x04\x18F\0\0\0\0\0\0/\x03\0\0\0\0\0\0%\x06/\0\0\0\0\0\x90@GBk\x0f\x90@`\x06e\x06k\x0f\0\0k\x06\0\0}\x06\0\0\x90@%\xff\0\0O\xff\0\0n\x06\0\0\0\0\x95H\0\0\x90@\x90@\x90@\0\0S\x04Q\x06p\x05;\xff\xff\x02/\0\x9c\x04/\0\0\x03/\0\x85\x06\x87\x06/\0\0\0Q\x06\0\0e\0\0\0\xdb0\"G\0\0o\x03\x8e\x06\xc0\x06\0\0\0\0\x98\x01\x01\x02\0\0%\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xa9\xffZ\x06\xb3\x06k\x0fw\x06\0\0\x90@\x01\x02/\0\f\x03\x90@\x90@\x90@/\0`\x05`\x05\x95\x01\0\0\xbd\x06\xbb\x06\0\0\0\0\xde\x02y\x01\0\0a\nk\x0f\0\0\0\0\0\0\0\0\0\0\xc1\x06\x0e\x06\xf2\x05\x14>\0\0\0\0k\x0f\0\0\0\0s\x05\x99\x03W\x01\x90\x03\x8d.\x9f\x01k\x0f\x89\x04\0\0\x91\x06\xcf\x06\x9c\x04\0\0a\n\x03'\xb3\x03\x87B\0\0a\x01\xdf\xff\x90\x04\x9c\x04\0\0\x18F\0\0\0\0\xca\x06\0\0S\x04\0\0\0\0\0\0S\x04GB\x90@\x95H\0\0;\x03\0\0\0\0\0\0\0\0\x13I\0\0k\x0f\0\0\xc3\x01\0\0q\x06<\x06;\x05\0\0\0\0;\x05{\x06;\x05\0\0\x98\x01S\x04\xc0\x06\xc0\x01\x85\x06\0\0S\x04k\x0f\0\0e\0^\x02 \x02\0\0\0\0\0\0\0\0\0\0\x84\x06\0\0k\x0f\x92\x03\x81A\0\0\0\0\0\0s\x05\x95H\x95H\x95H\0\0\xf0\x03\xf0\x03\0\0k\x0f\x86\x06k\x0fv\x02e\0\x98\x01G\x02\0\0\0\0/\0\0\0k\x0f\0\0\x1f\x01\0\0\xce\x03\xd0\x03\x9c\x06/\x03W\0\0\0\0\0m\x01a\n\x8d.S\x04\0\0\0\0\0\0\x9c\x04\0\0\xf3\x02\0\0a\n\0\0\0\0\0\0S\x04\x90@\0\0\0\0\x8a\x06\0\0S\x04\xab\x06/\0;\x05;\x05\x07B\xe2\x06;\x05\f\x05S\x04\0\0\xcf\0;\x05\x94\x06\0\0\x85\x06\0\0\xdd\x03\0\0\x7f\x02t\x01S\x04\0\0\0\0\0\0\0\0\xe5\x03\x90@\0\0\0\0\0\0\0\0\0\0\0\0\x98\x01\0\0\0\0\0\0S\x04\0\0\0\0\0\0\0\0a\n\0\0k\x0f\f\x03:\x04\xba\x02/\0\0\0\0\0\0\0\xb2\x06S\x04\0\0l\0\xec\x06\0\0\0\0\0\0\xf4\x06\xf5\x06\xbdF\0\0k\x0f\xf8\x06\x90@\xef\x06\0\0\x85\x06\xc0\x06\xf9\x06\0\0\0\0k\x0ft\x01S\x04S\x04\0\0\x90@\0\0\xfa\x06\0\0/\0s\x05\xaa\x06\xb5\x06;\x05\xcf\x03\x85\x06\x0f\x07/\0\0\0a\n\0\0\0\0\0\0\x1d\x10\x1d\x10Z\x06S\x04\x06\x07\xac\x01S\x04k\x0f\0\0\x90@\xc5\x06\x1d\x10S\x04S\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x15\x07;\x05;\x05k\x0f\0\0\0\0\0\0\0\0\x11\x07\x90@k\x0fS\x04\0\0\0\0S\x04\0\0\x1d\x10\x1c\x07\x1e\x07S\x04k\x0f\0\0S\x04\xcd\x06/\0k\x0fk\x0f\x04\x04S\x04\0\0S\x04S\x04\x90@\0\0\0\0",
  /* rindex */"\0\0/\b0\b\xd0\x06\0\0\0\0\0\0\0\0\0\0\xd5F\0\0\0\x009@\0\0s\x03\0\0\0\0\0\0\0\0\xd6DGC\x10D\xe7@\0\0\0\0\0\0\0\0\xd5F\0\0\0\0\0\0\0\0\0\0\0\0PD\xea\x10\0\0\0\0\xe7@\0\0\0\0\0\0\0\0\xf7\x03\xed\x01\xc2\x06\0\0\0\0\0\0G\0\0\0\0\0\xe7@\xd4\x03\0\0\xe7@\0\0\0\0\xe2\tG\0f\x11\x9a&\0\0\0\0@6\0\0g6\0\0\0\0\0\0\x936\0\0\0\0\xc06\xd66\0\0\xdf6\0\0\0\0\0\0\0\0\0\0\0\0\xfb\x16s\x17\x0e\x16\x84\x16\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\x03\0\0\0\0\0\0n\0\xd4\x03\0\0\0\0\0\0\0\0y\x0e\0\0\0\0?1\xb51\0\0n\0\0\0\0\0\0\0\0\0\0\0\xf02\0\0Y3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xd1\x06\0\0\xd0\x06\0\0\0\0\0\0\0\0\x7f\x04\0\0\0\0\0\0\0\0<\r<\r\0\0\n'\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0%\x0f\0\0\xed'R(\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0V-\0\0\0\0\xa4\x02 \x06\0\0\0\0\0\0\x95\x06\xc8-\0\0\0\0\x039\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\x03\0\0\xfc\x06\0\0\0\0\0\0\0\0\0\0\xf84\0\0\0\0\0\0\0\0\x16E\0\0\0\0\0\0\xc5\x04\xdf6\xf3\x05\0\0\0\0`\x01\x9b\x04\0\0\xc9\xff\0\0\0\0[\0\0\0\0\0\0\0\x82\x04\0\0^\0\xfe\0\0\0\\\x05\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0C7\xd7\x06\xd7\x06\xc7\x06\"\x04VE\0\0\0\0\0\0\x97\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0u9\xcd9\0\0\0\0\0\0%:}:\0\0\x99\0\0\0\0\0\0\0\0\0\0\0\xd7\x06\0\0\0\0\0\0\0\0\0\0[\x06\0\0\0\0\0\0\0\0\0\0\0\0\xf8\x02\0\0\0\0\0\0G\0\xf7/PD\0\0@6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xca\x1f\0\0\0\0\0\0\0\0\0\x002\x03\0\0\0\0\0\0s\x03\0\0s\x03\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe0\x11\xa9\x14\0\0\0\0\0\0\xe9\x17_\x18\0\0\0\0\xfc\x06\x8a\n\0\0\0\0\0\0\xd6\x04\xca\x07\xb51\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xf8\x02\0\0\0\0\0\0\0\0\0\0\0\0s\x03\0\0o\x07\0\0\0\0\0\0\0\0\0\0\0\0\x7f\x04\0\0\0\0\0\0\0\0\0\0\0\0G\x01\0\x000\x07\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x1b\x07\0\0\0\0\x90\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xca\xff\0\0\x96\0\xa8\0\xfe\0\0\0\\\x05\0\0\0\0\xc9\0\0\0\0\0\xca\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xd7\x06\x039\x95+\0\0\xd7\x18\0\0\0\0\0\0\xfc\x06\xe4\x06\0\0\0\0\0\0\0\0\0\0\xac\x0b\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0M\x19\0\0\0\0\0\0\0\0\0\0\x0f\x01\0\0\xa9\x04\0\0\xa1\xff\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xc7\x06\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x13'\0\0\0\0\0\0\xdf6\0\0\0\0\0\0\0\0z4\0\0/\x04\0\0\0\0\0\0\0\0\0\0\0\0\xd7\x06\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x85\"\xf4\"P\t\x7f\x05\xcf\x0f^#@ \xb7 .!\xa4!\x02\x1d\xc3\x19:\x1a\x1b\"x\x1d\xef\x1d\xc8#\xb0\x1af\x1e\xdc\x1eS\x1f\0\0'\x1b\0\0F5\xaf\x04i\x05\0\0\0\0\0\0\xfc\x06\xfc\x06Z\x10\0\0\0\0\0\0W\x12!\x15\x98\x15\0\0\0\0\0\0\xce\x12\0\0\0\x002$\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xb51\0\0\0\0\0\0\xfc\x06\0\0\0\0\0\0\0\0\x11\f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x036\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x1d\x07\0\0\0\0\0\0\x99\xff\0\0\xb7(\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x83)\0\0\x1e)\0\0\0\0\0\0\0\0\0\0\x1c\x01\xa1\xff\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x13\x04\0\0\t\n\0\0\xc6\x03+\b\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0.0z0\0\0\0\0\0\0\xcb5\0\0\0\0z4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x9e\x1b\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0o\x01\0\0\xdb\xff\0\0\xa9\0\0\0\0\0\0\0\xaa\0\0\0\0\0\0\0\0\0\0\0\xe0\x06\xe5\x06\0\0\0\0\0\0\0\0F5\0\0\0\0\0\0\0\x005\x01\0\0\xb9\x01\0\0\0\0\x16E\x0e6\0\0z4\0\0\x904\0\0\0\0\0\0\0\0\0\0\xdb\x04\0\0\x16E\0\0\0\0\xcd1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x04\xfe\0\\\x05\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0v2\x0e6\0\0\0\0\0\0\xf3H\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xa1\x02\x80\x03\0\0\xf3\n\0\0\0\0D\r\xb51\0\0\0\0\0\0\0\0\xb51\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x1b\x02\0\0\0\0\0\0\0\0\0\0\x99\x01\0\0\0\0\xe8)\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x05\0,\x01\0\0\xf6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe4\x06\0\0\0\0\0\0\0\0\0\0\x0e6\0\0\0\0\0\0\0\0\xdf6\0\0\0\0\0\0\0\0\xc7\x01\xea\x06\xea\x06\xd7\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0}'\0\0\xf7\x06\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe03\0\0\0\0\0\0\0\0\0\0\xf5\x04\0\0,\xff\xe7\x04:\b\0\0\0\0\0\0\0\0/\x04\0\0\x18\x07\0\0\b\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0D\x13\0\0\0\0\xbc\x13\0\x003\x14\x97$\0\0\xff1!+r\x04\0\0\xe4\x06\0\0\0\0\0\0\xe9\r\0\0\0\0\0\0\b\x02\0\0\xe9\r\0\0\0\0\0\0G\x01\0\0\0\0\0\0A;\0\0\0\0\0\0O*\0\0\0\0\xac\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0E/\0\0\xd8\x05\0\0\0\0\x80/\0\0\xc0\b\0\0\0\0\x01\x07\0\0\x8b0\0\0\0\0\0\0[\x06\0\0\0\0\\5\x14.\0\0\0\0\0\0\xe70\0\0\0\0\0\0\x124z4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xb5\0\0\0\0\0\0\0\0\0\0\0\xdb\x01\x14\x1c\xbd4\0\0\0\0:\b\0\0:\b\x0e\x07:\b\x12\x07\x12\x07:\b\0\0\x8b\x1c\0\0\0\0\0\0\0\0 \x07\x9d.\xb12\0\0\xec2\0\0\0\0\x831M4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0:\x07\0\0\0\0\0\0\0\0\0\0M4\x0e6\0\0\0\0\0\0\0\0\xe9\r\0\0\0\0\0\x004\x05\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xb4*\0\0\0\0\0\0\0\0\0\0\0\0M4\0\0\0\0\r\x03\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0O.\0\0\0\0\0\0\0\0\xf2\x01\0\0\0\0\0\0\t\x02\0\0\0\0\xfc$\0\0\0\0\0\0\0\0\0\0\0\0V\x01\0\0\0\0\0\x006\x02\0\0\x13\x07\x0e\x07\0\0\0\0\0\0\0\0%\x07\0\0\0\0\x831'3j3\xf3\x01\x12\x07\0\0:2\0\0\0\0\0\0\xef4\xdf6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0M4f%\xcb%0&\0\0P\f\xdd\f\0\0\0\0&A\0\0\0\0\0\0D\x07\xb51\0\0\0\0\xe9\r\0\0\0\0\0\0\xfa\x03\0\0\0\0\0\0\0\x0051\0\0\0\0\0\0\xe3\x04\0\0\0\0r5\0\0\0\0\xbb/\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xd8.\0\0\0\0\0\0\0\0\0\0\t\x05\0\0:\b\0\0\0\0\0\0\0\0\0\0\0\0:2\0\0\0\0\0\0\0\0\0\0E\x02\0\0\0\0\0\0\xef4\0\0\xd73\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0D\x07\0\0\0\0\0\0\xbe\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0&\x07\0\0\xe3\t\0\0\0\0\0\0\0\0\x13/\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x12\x07\xa53\0\0\0\0\0\0\0\0\0\0\xd73\xc15\0\0\0\0\0\0,\x0e\0\0\xe3\t\xe3\t-\x072\x07\0\x008\x07\x12\x07\0\0\xe3\t\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x000\x03\0\0\0\0/\x05\0\0\0\0\0\0\0\0\0\0\xef*\xc15\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xb4\x05\0\0\0\0\x9b\x02\0\0\0\0\0\0\0\0\xb8\x05\0\0\0\0i\x04\xff\x06\xe3\t\0\0\0\0\0\0\x9f\x04\0\0\xe1\x06\xd3\b\0\0\0\0\0\0",
  /* gindex */"\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\\\0\xf3\xff\0\0V\0\xfd\xff\xe8\x06\xff\x07>\0\0\0\xcc\xff\x87\0?\0[\xff\0\0\x94\xfe\0\x07G\xff\xd2\x07\xa3\x0e\xf3\xfc\x11\0\x16\x04\x0e\x001\x004\0B\0\0\0\0\0\0\0\0\0K\0X\0\0\0a\0\0\0\x02\0\x04\0^\xfe\0\0\0\0S\xfe\0\0\0\0\0\0\0\0c\0\0\0\0\0\0\0\0\0\0\0\xee\xfe\xa0\xfc\0\0\0\0\0\0\x06\0\0\0\0\0\xa4\xff\xcf\xfe\x88\xfe\x12\xfcr\xfcH\xffg\x04\xa8\x03\0\x000\x048\xfds\xff7\x04\0\0\0\0\0\0\0\0\0\0\0\0\x10\x03\xf7\xff\xcc\xfb\xc9\xfe$\xfe\x81\xfc9\x03\x8b\xfb\x1d\xfc\n\xfcZ\x03\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x8c\x05\xcd\x04\xa8\x04\0\0\0\0g\xff\x1e\0\xe7\0\x8c\xff\x05\x02\t\xfd]\xff\xbe\b1\x0b\0\0\0\0\0\0j\xff\xfb\x06\x8e\f>\x06\x01\0V\xffI\x06\x86\xfe\0\0\"\x07p\x06\xd6\x0b\xbd\xfcX\xfd\xd4\xfe\0\0\0\0\0\0\xdc\x04L\x04\0\0\0\0\xa6\x06w\xff\xdc\x05\n\b\0\0O\x04\0\0\0\0P\bI\x02P\x05-\xfc\xb8\xfb\xf4\xfc\xd2\xfd\0\0\x0f\xfe\0\0\0\0\xea\xff\0\0\0\0\xeb\xfb\xf9\xff\xf0\xfbi\xfe\xfe\xfd\"\xfe\0\0\0\0\xf7\x02\0\0\0\0\xfc\x03\xa0\xfb\0\0\xaa\x03\x9a\x04\0\0s\xfd\x03\f~\xff\0\0\t\0C\xfe\n\x06\x88\xff\xd7\xfe\x82\xff\0\0\xfd\x03\0\0\0\0\0\0\xee\x06\0\0\0\0\0\0\x1a\x005\xff\0\0",
  /* tablesize */19189,
  /* table */"~\0\x85\0\x8c\x01\xa0\0l\0\xc8\x01m\0E\x02\xcd\0\x93\x02\xd5\x01\xb5\x01\xfb\x02\xc3\x01\xda\x01;\x02\xbf\0\xb4\x01\x91\x03\xc0\x02\xe4\0\xd1\x01\xcc\x03\xb9\x01\xf0\x02\x1a\x02\xbb\0\xb5\x02\"\x02\xbb\0\t\x04\"\x04\xea\0>\x01\xf4\x01\x97\x02\xbb\0\xbb\0\xbb\0\xbb\0M\x03\xc1\0\xe1\x03\xbd\x03\xbb\0\x93\x03\xf5\x02\x1f\x02\xfc\x02\x19\x05@\0\xbb\0@\0@\0g\0\xbb\0\x1b\x02\xac\x04\xdd\0\x1f\x01\xbb\0\xbb\x002\x02@\x013\x02\x80\0\x86\0\x81\x02h\0\xbb\0\xae\x003\0\xbb\0T\x01\xf9\x01\t\x05\xc9\x01i\0I\x01\xf6\x02\xad\x01\xf6\x02\xaf\x01\xd7\x049\x02\x9a\x01\x03\x05\x05\x05\x8d\x01}\0j\0\x95\x020\x059\0\x1c\x02\xce\x04\xf3\x04\x9f\x01@\0k\0l\0q\0m\0\xe1\x04\xb9\0\b\x02\xe6\x02\xe7\x02U\x01\x9f\x02W\0\xf7\x01l\0\x84\x01m\0\x88\x01\x89\x01H\x02F\x02\xe2\0\xfd\x02\x9d\x04,\x03@\x02G\x01\xf5\x01\xb9\0\xab\x01\xa4\x01\xf6\x01\f\x05\xbc\x01-\x03\xf2\x04\x9f\x02?\x02\xf7\x01\xb2\x04\r\x05\xf8\x01\x96\0J\x01\xb8\x02q\x03\xb9\x02+\x02\xb3\x01\xe3\0\xe0\x03G\x01g\0\xc5\x01\xfc\x04\x1b\x02\x9a\x02\xf9\x04t\x04v\x04\x9f\x02<\x04x\x04\xa4\x02g\0\xb9\0h\0\xbc\x04\x02\x04\xca\x01@\x03\x17\x05\x1b\x02\xa4\x02E\x03i\0\x14\x04\xf4\x04h\0U\x01j\x05@\0\xb6\x01U\x01\x06\x04U\x01P\x02i\0j\0*\x03\xb9\0>\x01\x80\0\xfa\x01\xac\x01\x07\x02\x86\0k\0\x86\0q\0j\0u\x04w\x04k\x01\xa6\x01 \x05\x02\x02=\x04w\x05k\0\x1d\x02q\0\xb9\0\0\x02\x01\x02\xbd\0G\x02\xee\x02\xaa\x01\x14\x04\x04\x02j\x019\x05\xbd\0\xbd\0H\x05C\x03\xd3\x01g\x03\xb9\0\xdd\x01\xdd\x01\x8b\x02\x8a\x04&\x02\x1f\x02\xbd\0A\x05\xdb\x03I\x05,\x02r\x03\xbc\0\xfc\x01\xfd\x01\xc4\0\f\x05M\x05\xd7\x02\\\x05'\x02\x1b\x02\xd0\0\xd1\0\xd2\0\xd3\0)\x04\xa4\x02y\x04h\x05\xda\0\x92\x01\x9a\x02\xa5\x01\x03\x04@\0L\x01\0\x05\xb8\x01\x92\x01\x92\x01A\x01\x15\x04\x14\x02\xb9\0\x81\x02E\x01F\x01\xbd\x02\x9a\x02\x9a\x05\xcd\x01\x92\x01+\x03\x85\x02K\x01\x86\x02h\x05N\x01d\x04\xa7\x03\xf5\x01\xb9\0\xa7\0\xce\0\xf6\x01k\x01\xa6\x01O\x01A\x02k\x01\xa6\x01\xf7\x01>\x04V\x01\xf8\x011\x05\xbb\0#\x02}\x03\xd4\x02\xe5\x02\xd5\x02B\x02j\x01A\x04C\x02r\x01j\x01\xbe\x02I\x02J\x05\xd0\x02/\x04\xd2\x05\xcd\x02\xc1\0\x12\x04\xa6\x023\0U\x02K\x02\x88\x05\\\x02\xca\x02B\x05\xf5\x01@\0@\0e\x02\xf6\x01\xfc\x03h\x03i\x03\xa0\x05\x89\x05I\x01\xf7\x01\xc9\x04g\x01\xf8\x01\xce\x01n\x01^\x02\xb9\x003\0\xa5\x01\xc0\x03\xbb\0\xa0\x05\xa5\x01\xcd\x03n\x01|\x02]\x02 \x03\xb2\x05\x82\x02W\0\xeb\x02\xe9\x04@\0e\x04P\x01\xc8\0\x85\x03\xad\x02\x90\x02\xaf\x02\xcc\x05\xb0\x02\x18\x03\0\x03\xd0\x04\xa8\x03\xd3\x04W\x05\x1b\x02U\x01\xc9\0\x99\x02\f\x05\xf0\x020\x04W\0D\x02\xc0\x02^\x05\xe0\x04\xb9\0\x8c\x03\xb9\0\xce\x03\xdc\x03U\x03l\0D\x03m\0\xa1\x01[\x02\x18\x05T\x02\xb9\0\x8c\x02\x8d\x02\xd1\x02\xa8\x05\x91\x02\xa5\x05\x84\x01\xc3\x04\x13\x04\x9c\x023\0\xfb\x01\xca\0\x9f\x01l\x01o\x01\xb4\x04\x1e\x02\x87\x01~\x02\xd7\x03\xfd\x03\x87\x05\x9f\x01?\x02o\x01m\x01\x12\x04\x7f\x05g\x01\xb3\x01\xca\x04\x8b\x05n\x01\x1e\x02\x1d\x02n\x01\xb3\x01\x1d\x02\xb3\x01\x02\x02\xf0\x02g\0\x8f\x04\x88\x03a\x03^\x02\\\x02t\x05\xb3\x05\xb5\x03l\x01\x1d\x02P\x03\xcb\0\xca\x01h\0\xcc\0\xe5\x03\xd4\0\x90\x04\xcb\x02o\x05m\x01U\x01i\0U\x01\xc8\0U\x01_\x04`\x04\x88\x03\x8d\x03\xfa\x01k\x03Q\x05\x1b\x02\x86\0j\0\x86\0\xa1\x04\x86\0\xc9\0\xfa\x01 \0\xa6\x05\x18\x03k\0\xa1\x01q\0\xd5\0\xa0\x01[\x02O\x05T\x02\xfa\x011\x04R\x04\xd8\x03\xa3\x02\xc0\x02\xa0\x01R\x04\xf6\x02\xd0\x04\x18\x04\x99\x05\x9f\x01:\x02o\x01\x9f\x01l\x01o\x01\x1e\x02\xfa\x01\xfa\x01i\x01 \x04\xca\0\x02\x02\x02\x02@\x04\xcb\x02m\x01\xcb\x02&\x04\xb6\x03\x82\x03\xd6\0\xa2\x01\x8e\x03\x1d\x02z\x05\x02\x02\x88\x036\0\xcf\x05\x05\x02\xfa\x01&\x03\xc0\x02\xc0\x02^\x02\\\x02\xf0\x02\xa3\x02\x10\x05\xf7\x01\xc1\x02\xac\x03@\x002\x05&\x02\xc8\0\xde\x02\xe0\x02\xe2\x02\x89\x03\x9a\x03\xbc\x03\xcb\0\xda\x01\xe3\x02\xcc\0$\x02\xb9\0\x9b\x03\x9c\x03\xc9\0]\x04k\x03\xe7\x03\n\0\x88\x03\xa2\x04\xf4\x03Q\x03\xbb\0\x1e\x02.\x03\xe2\x02p\x01&\x02\xa7\0\xce\0\xa0\x01\x17\x03\x9d\x05\xa0\x01\xe4\0\x1b\x02R\x04\x0f\x03\xa3\x02\xd9\x03\xd2\x03R\x03w\x02[\x03\xb9\0X\x03Y\x03s\x04d\x01\xca\0d\x01\xc1\x02\xa8\x04\xe2\x02i\x01\xd1\x01\xb9\0x\x02\xc1\x02\x80\x01\x81\x01\xc1\x02\x1b\x020\x03O\x02\x8f\x03\x05\x02\xa2\x01\x87\x03w\x02~\x02\xc2\x02\xdd\0{\x05\x80\x05,\x05\xad\x03)\x027\x03O\x02l\x03m\x03\xc8\0\xa3\x02x\x02\x1a\x03R\x04\xbf\x05@\0\xfa\x01G\x03\xcb\0\x11\0\xc0\x04\xcc\0p\x01\xad\x04\xc9\0\xf5\x03\x1b\x03\xfe\x02q\x05\x81\x05s\x05+\x04\xc1\x04\x9a\x02\x01\x040\x02{\x03\x89\x01\xe2\x02\f\x02\xb5\x03\x9c\x02a\x03!\x001\x02\xf8\x02\xfe\x03\xff\x03\0\x040\x04\xc1\x02%\0\xbc\x01\x82\x058\x05\xf9\x02\xbb\x04$\x02\xb9\0\x19\x04\xca\0/\x03w\x02^\x04G\x05\xb3\x01w\x02\xd4\x05O\x02O\x02\x80\x01\x81\x01T\x05\x1b\x02:\x03<\x03\xe3\x03x\x02$\x02\xb9\0\xa0\x03x\x02\x9e\x03O\x02O\x02r\x01O\x028\x03]\x05\xf3\x03\x86\x04C\x05\x88\x04\x8b\x04\xc2\x03\x83\x05U\x013\0t\x01\xdd\x006\0O\x02\xcb\0\xb2\x03\xb3\x03\xcc\0\x0e\x02\xcb\x01\x1c\x03\x86\0\xe4\x020\x02\xfa\x010\x02\xfa\x01\xda\0\xfa\x01\xfa\x01'\x05q\x011\x02\xc0\x021\x02:\x04\x94\x02\xc3\x03\xcc\x01\xfc\x02:\x05\xe4\x02R\x04\x94\x02\xba\x01\xbc\x03\xb9\0\xb9\0\xe4\x020\x04\xcb\x03(\x04\x02\x026\x04\xde\0\xa3\x03\xca\x01\x94\x02\x94\x02\xa6\x032\x04\x0e\x05R\x04\xcc\x01\x94\x02\x91\x03r\x01\x9c\x04\x9f\x03\xe4\x02\xe4\x02R\x04\xf6\x02\xfa\x01\xe2\x034\x03\x1b\x02\xdb\0v\x01\x94\x02\xdd\0\x10\x05\x94\x02\xe4\x02\x83\x03\xdb\x02\xe3\0\x82\x04\xe4\x02\xbf\x04&\x02\xe4\x02\x93\x03\xe4\x02\x94\x02\x9e\0\xda\0\xc5\0\xf5\x01x\x01q\x01\xc6\0\xf6\x01\xea\x03\xe2\x02\xca\x01\xfa\x01\xc5\x03\xe8\x03\xf7\x01P\x01\xc0\x02\xf8\x01\x98\x03\x9e\0\x94\x02\xca\x01\xef\x03\xca\x01\xf0\x03,\x05\x9e\0\xfa\x03\xde\0\xb9\0\x9c\x02&\x02\xbc\x03\xf9\x03\xfa\x01\x04\x04\xeb\x03\xec\x03\x07\x04\f\x02\xe4\x02\x94\x02\xaf\x03\x1e\x04\x94\x02\xa5\x04P\x01\x9e\0\x9e\0\xb9\0!\0\xdb\0\r\x02\x93\x02\f\x02\xa7\0\xce\0{\x01%\0\xb9\0\xed\x03\x9e\0\x94\x02\x1b\x02c\x05\x94\x02\xb9\0g\x05\x9e\0\x9e\0\xe2\x02\x9e\0\xb9\0P\x01Q\0\xd8\x02R\x04R\x04\x9f\x02\xf5\x01\x96\x02\xb8\x04\x9d\x01\xf6\x01\xa0\x01P\x01R\x04\f\x02\x9c\x02\xd9\x02\xf7\x01\xb3\x01\xd4\0\xf8\x01\xca\x01\xe9\x03.\x04$\x02\xb9\0\x9a\x02\x9f\x05\xde\x04\xee\x03\xc5\x04\xa5\x01C\x04\x0e\x02\xa2\x01\xda\x01\x02\x02\x89\x01\x02\x03\x03\x03\x9e\0\x89\x01\xca\x018\x04 \0\x89\x01\xbd\0\x89\x01\x0e\x02\x9a\x02\xd5\0\x89\x01\x89\x01\xfa\x01\xc7\x04\x89\x01\xfa\x01\xa1\x02\xf7\x01\x1b\x02\x83\x02\xf8\x01D\x04\xab\x04\x89\x01\xca\x01R\x04\xa6\x01\x9d\x02\xb9\0\x98\x05\x9d\x01\xb5\x018\x04\xd1\x01o\x04p\x04\r\0\xb4\x01\x1b\x02L\x02\x0e\x02\xa2\x05b\x01c\x01\x04\x03\x9a\x03\xfa\x01\xd6\0{\x04\xd0\x05\xd1\x05\xbe\0M\x02\xb6\x016\0\x12\0!\x02\xda\x02\xc3\x01&\x02\xa3\x02:\x03\xb9\0\x89\x01\x9c\x02\x87\x04;\x04X\x04\x0b\x04\xb9\0\x89\x01\xcc\x01\x0e\0\x18\0\x19\0\x1a\0R\x04\xec\x02\x9c\x02\xb1\x01\xe2\x02o\x01h\x01\xe3\0\xe2\x02\xc7\x01\xe2\x05\x0f\0\x10\0\x89\x01\x89\x01\x1e\x02\x89\x01\x89\x01\xac\x05\xaa\x04\xa9\0\xc3\x05\xc4\x05m\x01\x17\0*\0\x0f\x03\xed\x02\xc3\x01,\x02&\x02\x7f\x01\xb7\x04#\x02\xaa\0\x89\x01\xbf\x01\xd0\x01\xfa\x04\x97\0\xca\x01\xb0\0p\x01,\x02!\0\xb9\0\x0f\x03S\x01\x97\x05\x93\0\xde\x042\0%\0\x9c\x02&\x02\xd9\x05\xad\x05\xd9\0)\0\xf5\x01\xf7\x01\x9c\x02\x0f\x03\xf6\x01\xc6\x01-\0\xc4\x04\x9c\x02\x7f\x03\xbb\x01\xf7\x01\x02\x02\xd4\0\xf8\x01+\x05\xa9\x03\xdd\x04\xe1\x05\xb9\0\xf7\x01\xcb\x04\x1b\x02\xff\x02\x80\x03 \0\xaa\x03\xf7\x01\xf7\x01\xfa\x01\xcc\x04\xd1\x04\xeb\x05,\x025\0\x81\0\x9a\x02\xc7\x01 \0\x1b\x02,\x02\x9f\x02\xd8\x01\xfe\x04\xd5\0H\x04\xb1\x01\xda\x04\xf7\x01\xf7\x01\xd8\x016\0\xe8\x04a\x03\xa0\x02\xeb\x04\xbb\x01\xc7\x01\x80\x04\xe4\x04,\x02\xcc\x01\xf7\x01\xb9\0\x83\x04\xb1\x01\x84\x04\xff\x04\xbb\x01\xf7\x01\xf7\x01\x94\x01\xf7\x01\x84\x01\xf6\x04\xf7\x04\x93\0\xbd\0\x95\x04\xc6\x02\xe0\x02Q\0\xd6\0\xfb\x01\x1b\x02\x9c\x02\xea\x01X\x046\x006\0\x07\x05\n\x05\x93\0\xa1\x02Q\0\xc7\x016\0\xa4\x03\xca\x01\x99\x03&\x02\xca\x01\xca\x01\x11\x05\xeb\x01\xec\x01\xed\x01Q\0Q\0Q\0Q\0\x93\0\x97\0a\x03\xf7\x01\xc7\x01O\x03\x97\0\x97\0\xca\x01\x1d\x03\x1d\x05Q\0\x92\x01\x98\x02\xc7\x02n\x05\xbd\x007\x05P\x01\x9a\x03\xb9\0\xee\x01\x98\x02-\x05\x9d\x03X\x04\xb0\0\xb0\0\x8a\x05\xb0\0\xb0\0Q\0\xb0\0\x1b\x02Q\0\x1e\x03\xa2\x03Q\0Q\0Q\0\x9d\x01'\x03\xb0\0\xb0\0\x9d\x01Q\0\x9c\x02\xc4\x01\x9d\x01\xf5\x01\x9d\x01\x93\0Q\0\xf6\x01\x9d\x01\xb9\0\xef\x01\xb6\x04\x9d\x01h\x04\xf7\x01\xcc\x01z\x03\xf8\x01Q\0\xda\x04Q\0\x9d\x01Q\0Q\0e\x02\xcb\x02\xb0\0\xb0\0\xf0\x01\xf1\x01\xf2\x01\xd9\0(\x03P\x05Q\0\xea\x04e\x02Q\0\xe4\x04\xee\x04D\x05Q\0\xcf\x01X\x05\x9e\x05\xd4\0Y\x05\xca\x01[\x05\xf5\x01\x9d\x01\xca\x01\xa3\x05\xf6\x01\x9d\x01\x84\x01\xf3\x016\0\x9e\x035\x05\xf7\x01f\x05X\x04\xf8\x01\x9d\x01\xe4\x04\xb9\0|\x05\x9d\x01\xcc\x04 \0\x7f\x01X\x04\x90\x02\x90\x02\x7f\x01\xd5\0\xca\x01\b\x05\x7f\x01\x90\x02\x7f\x01\x02\x02\xea\x05\xb9\0\x7f\x01\xc7\x02\x9d\x01\x9d\x01u\x05\x9d\x01\x9d\x01\xb9\0\xf5\x01\x90\x02\xd2\x01\xca\x01\xf6\x01\x7f\x01\x1b\x05\x90\x02\xda\x04\xcc\x01\x9f\x04\xf7\x01H\x03\x1f\x03\xc8\x04\xe4\x02\x9d\x01\xfb\x01\x8e\x01\xb9\0\xc7\x02\xd6\0\x93\0\x84\x05\xc6\0\x85\x05\x90\x02\x90\x026\0\xfa\x01\xb9\0t\x03v\x03\xd9\0\x8c\x05\xca\x01\x90\x05\x91\x05I\x03\xcb\x05\x95\x05\xe4\x04o\x01 \0\x88\x02\x9b\x05\x89\x02\xa0\x04\xbd\0\x8f\x01;\x05\xb9\0\x7f\x01\xe4\x04\x0e\0\xd8\x01\x8a\x02u\x03\x90\x01\xca\x01\x9f\x02\xe4\x02\xfe\x01\xb9\0\xf8\x01\xb4\x02\xa4\x05w\x03\x02\x02\x0f\0\x10\0\x7f\x01\x7f\x01W\x02\x7f\x01\x7f\x01\xca\x01X\x04\x9f\x02\xe3\x04\x02\x02\xae\x05\x17\0\xf8\x01\x91\x01\xca\x01\xf1\0X\x02S\x05\xa3\x02\xf8\x01\xf8\x01\xb0\0\x7f\x01\x92\x01{\x02<\x05\xca\x01\xc7\x01\xe0\x02{\x026\0!\0K\x05\x9f\x02S\x01\xbd\x05\xa9\x05d\x05\xb9\0%\0\xf8\x01\xf8\x01\xe4\x04\xe0\x02\xe0\x02)\0\xba\x01\xc7\x01\xc5\x05m\x05\xca\x05=\x05-\0\x94\x01\xf8\x01\xa3\x02\xe0\x02\xa4\x02L\x05\xbb\x01\xaa\x05\xf8\x01\xf8\x01\xff\x01\xf8\x01\x02\x02\x02\x02\x84\x01\x82\0z\0\t\x02\x84\x01\x0b\x02\xda\x04y\x05\xd6\x05\xe0\x02S\x04\x84\x01\xe0\x025\0\x84\x01\xdb\x05\xdc\x05\xe0\x023\0\x97\0\xb9\0\xe3\0\xca\x01\xe0\x02\x13\x02\xca\x01\x97\0\xa4\x02\x97\0\xdf\x05\xe0\x02\xca\x01\x02\x02T\x04\x97\0W\0\x1e\x02 \0\xba\0\xf8\x01\x90\0S\x01\xc6\x01U\x043\0\xe2\x02\xe0\x02\xe0\x02\xb3\0\x97\0\x97\0\xca\x01\xec\x05\x81\x04\x02\x02\xb0\0\xe2\x02V\x04\xe0\x02\xca\x01(\x02W\0\xca\x01\x84\x01\x1d\0-\x02\x90\0\xca\x01\x02\x02\x8e\x04\xca\x01\xca\x01V\x02\xe2\x02\xb3\0r\x02r\x02*\x02W\x02/\x02\x11\x04\x1c\x04.\x02\xe8\x02\x84\x04\xe9\x02\xc2\0W\x026\0\xb0\0\xb0\0\xb0\0X\x02r\x02\xd8\x01\xea\x02\xf5\x01\xb0\0\x87\x01\x9f\x02\xf6\x01X\x02\xb8\x05B\x02\xbb\x05\xc2\0C\x02\xf7\x011\x02\x8a\x01\xf8\x01\x97\0\xc2\0\x97\0\xc1\x054\x02\x96\x05\x9f\x02\x97\0\\\x03\xb0\0\xb0\0\x9f\x02\xfb\x01\xa0\0\xb0\0\x9f\x02\xb0\0\x9f\x02<\x02\x9f\x02\x9f\x02\x9f\x02\xc2\0\xc2\0\xd9\0J\x02\xb8\x05\xb8\x05\xa3\x046\0}\x04>\x02\xa0\0\xd5\x05:\x02\x9f\x02\xc2\0B\x01\xa4\x04\xa0\0Q\x02\x97\0\xb0\0\xc2\0\xc2\0w\x02\xc2\x006\0\xb9\0\xb0\0\xdd\x05\x1e\x02C\x01D\x01\x97\0\x97\0o\x01\xe0\x05\xa3\x02p\x03\xa0\0\xa0\0\xb9\0\xb8\x05\x94\x01\xd9\0\x9f\x02\xe5\x05\xa3\x02\xb0\0 \x01\x84\x02\xe8\x05\xe9\x05\xa0\0\x85\x01\x13\x03!\x01\x98\x02\x85\x01\xba\0\xa0\0\xa0\0\"\x03\xa0\0\x8e\x02\x85\x01$\x03\xc2\0\x85\x01\xe3\0\x14\x03\x15\x03\xf1\0\xf1\0\xf1\0\xf1\0\xf2\x03\x85\x01\x06\x03\x07\x03\xf1\0\xf1\0\xf1\0\x9e\x02\xb6\x01\xf1\0\xf1\0\xa4\x02\xf1\0\xf1\0\xf1\0\xf1\0\xf1\0\xf1\0x\x01\xb0\0\xf1\0\xf1\0\xf1\0\xf1\0\xf1\0\xf1\0$\x02\xb9\0P\x01\xa0\0\x98\x01\xa5\x02\xf1\0\xf1\0\x06\x03\t\x03\xf1\0\xf1\0\xf1\0\xf1\0\xb6\x02\x85\x01\xb7\x02\xf1\0\xf1\0C\x01\x99\x01$\x02\xb9\0\x9f\0\x94\x01\xb9\0P\x01\xc0\0\xba\x02\x97\0\xbb\x02\xf1\0\xf1\0\xbc\x02\xf1\0\b\x03\n\x03\xf1\0\xf1\0\xf1\0\xc3\x02\xf1\0\x9f\0\xc4\x02\xf1\0\xf1\0\xc0\0\xc5\x02\x97\0\x9f\0\x93\0\x97\0\xf1\0\xc0\0\xf1\0\xc9\x02\xce\x02\xcf\x02\x97\0\xb5\0\x97\0\x97\0\xd2\x02\xf1\0\xf1\0\xd3\x02\xf1\0\xf1\0\xf1\0\xf1\0\x9f\0\x9f\0\xb0\0\xd6\x02\xc0\0\xf1\0\xb0\0\xf1\0\xb5\0?\x02\xf1\0\xf2\x02\x97\0\xf1\0\x9f\0\xb5\0\x1d\0\xf1\0\xc0\0\x1d\0 \0\x9f\0\x9f\0e\x02\x9f\0\xc0\0\xc0\0\x12\x03\xc0\0\x1d\0\x1d\x001\x033\x032\x036\x03>\x03\xb5\0\xb0\0\x97\0=\x03?\x03A\x03\x1d\0\x1d\0\x1d\0\x1d\0L\x03T\x03c\x01e\x03\xb5\0f\x03\x05\x02n\x03\xb0\0s\x03\x1d\0\x1d\0\xb5\0o\x03\xb5\0\x8a\x01\xb0\0|\x03\xb0\0\x8a\x01\x9f\0\x84\x03\x86\x03\x8a\x01\xc0\0\x8a\x01\x8a\x03\x95\x03\xd9\0\x8a\x01\x8a\x01\x1d\0\x94\x01\x8a\x01\x1d\0z\x01\x1d\0\x1d\0\x1d\0\x1d\0\x97\x03\x96\x03\x8a\x01\xce\x01\xa1\x03\x1d\0`\x02a\x02b\x02c\x02\xf7\x01\xd5\x01\x1d\0\xab\x03\xb0\x03\xb4\x03\xb5\0\xa7\0d\x02\xb7\x03\xbe\x03\xbf\x03;\x01\xc4\x03\x1d\0\xe6\0\x1d\0\x9e\x01\x1d\0\x1d\0\x94\x01\x06\x03\xcf\x03\xd1\x03\x93\0\xda\x03\xf8\x03\xf6\x03\n\x04\xa7\x02\x1d\0\x0e\x04\x8a\x01\x1d\0\x0f\x04\xa7\x01\x17\x04\x1d\0\xfb\x03\x8a\x01\x1a\x04\x1f\x04\xae\x01\x93\0\x86\x02\xd9\0#\x04$\x04\xa8\x02\x97\0\x93\0\xb0\0\xb0\0e\x02'\x04\n\0\x97\x003\x04\x8a\x01\x8a\x017\x04\x8a\x01\x8a\x01\xc7\x02\xa7\0\xce\0B\x04\x94\x019\x04g\x04\xd9\0\x93\0\x93\0b\x04i\x04l\x04m\x04n\x04\x7f\x04\x94\x01\x8a\x01|\x04x\x01\x9c\x04\x9e\x04\x93\0x\x01\x94\x01\xa6\x04\xae\x04x\x01\x97\0x\x01\x93\0\x97\0\x93\0x\x01x\x01\xa9\x04\xaf\x04\xb0\x04\xb3\x04\xa9\x02^\0\x97\0\xb1\x04\xbe\x04\xaa\x02\xc6\x04x\x016\0`\x02a\x02b\x02c\x02\xd2\x04\x97\0\xd4\x04_\0\x10\0\xd8\x04\xd9\x04!\x03d\x02%\x02\xec\x04\xb0\0\xdb\x04\xdc\x04\x0b\x05\xed\x04`\0\xf0\x04\x90\x04\x1a\x05M\x02\xef\x04\x93\0(\x05\xf5\x04K\x04W\x04\x02\x05\xb0\0\x04\x05\x97\0\x97\0)\x05\x1c\x05x\x01\xaf\0!\0?\x053\x05@\x05N\x05x\x01r\x05\xbf\0%\0V\x05l\x05\xb0\0~\x05\x94\x01a\0\xd8\0\x8d\x05e\x02\x8e\x05Z\x05\xdc\0-\0\x94\x05\x9c\x05x\x01x\x01\xbf\0x\x01x\x01 \0\x97\0\xb0\0 \0\xbf\0\xb1\x05\xd9\0\x97\0b\0\x97\0\xb4\x05\xb5\x05\xb6\x05 \0 \0\xbc\x05\xc0\x05x\x01\xb0\0\xbe\x05c\0\x97\0\x0e\x05d\0\xc9\x05\xbf\0 \0 \0 \0 \0\x01\0\x02\0\x03\0\x04\0\x05\0\x06\0\x07\0\xc8\x05\xcd\x05\xbf\0 \0 \0\xd3\x05\xd7\x05\xda\x05\xb0\0\xbf\0\xbf\0\xde\x05\xbf\0Z\x01\xe3\x05\x9c\x01\xe4\x05K\x04\xe6\x053\0W\0\x9f\x02\b\0\xe0\x02 \x003\0\xe4\x02 \0\"\x02\x94\x01_\x02 \0 \0~\0\xea\x02\xa3\x02\xc7\x01\xa4\x02 \0\xeb\x02\xd5\x01\x97\0a\x01b\x01c\x01 \0\xd8\0.\x02\xd5\x01\x97\0\x94\x02\x94\x02L\x01\xd5\x01\xbf\0\x96\x02\x95\x02 \0\x95\x02 \0\xcd\x04 \0 \0\x97\0\xdc\x01\x97\0\xd5\x01\x97\0\xd5\x01\xd5\x01e\x01f\x01\xc7\x01 \0\x97\x02\x9a\x02 \0\xb0\0\x97\0W\x04 \0\xd5\x01\x9b\x02h\x01i\x01j\x01k\x01\x9c\x02\xaf\0\xaf\0\xd9\x01\xaf\0\xaf\0\x98\x02\xaf\0\x9b\x02\x86\x02\xb0\0\x97\0\xa8\x01m\x01\xd5\x01\x97\0\xb5\x04\xaf\0\xaf\0F\x05\xd5\x01\xd5\x01\xd5\x01\xe5\x04\x86\x02\x86\x02\xe2\x04\x96\x02\xd5\x01\xa7\x05\x93\x05}\x05\xae\x02k\x04\xc9\x03\xd5\x01\x89\0\x86\x02\x8a\0\x8b\0 \0W\x04\x8c\0V\x03\xac\x02\xb1\x01\x8e\0\xaf\0\xaf\0\x92\x02\xe4\x02\xd5\x01\xd8\0\x97\0\x97\0W\x03q\x04\x86\x025\x03\xa5\x03\x86\x02\xe0\x01\xe6\x04\xd5\x01\x9b\x01\x86\x02\xd5\x01\f\x04\xd8\x05/\x05\xb9\x04\x86\x02\x91\0k\x05\xcc\x02\x97\0\0\0\xa8\0\x86\x02\x92\x004\x05\xcd\x04\xb2\0\x94\x03\0\0\0\0\xc2\0M\x02\0\0\0\0M\x02\x93\0\x94\0\0\0\x86\x02\x86\x02\0\0K\x04\x97\0\0\0M\x02\0\0\0\0\xc2\0M\x02\0\0\x86\x02\xb0\0\0\0}\x02\x97\0\0\0\0\0M\x02M\x02M\x02M\x02\x97\0\0\0\x97\0\0\0\0\0\0\0\xc2\0W\x04\0\0K\x04\x97\0M\x02\xb0\0\0\0\0\0\0\0\0\0W\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xb0\0\xd8\0M\x02\0\0\0\0M\x02\0\0}\x02M\x02M\x02M\x02\x97\0\xc2\0\0\0\xc2\0\xc2\0M\x02\0\0\xc7\x01\0\0\0\0T\x02\0\0M\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x97\0\0\0\0\0\0\0M\x02\0\0M\x02\x9c\x01M\x02M\x02\0\0\x9c\x01\x97\0\0\0\xb0\0\x9c\x01\0\0\x9c\x01\0\0F\x03M\x02\x9c\x01\xe0\x02M\x02K\x03\x9c\x01\x97\0M\x02\x97\0\xaf\0\0\0\0\0\0\0\0\0\x9c\x01\0\0\0\0\x97\0\0\0\0\0\0\0\xe0\x02\xd9\x01\0\0\x03\x01\0\0\0\0\0\0\xe0\x02K\x04\x97\0\0\0\0\0\0\0\0\0W\x04\0\0\0\0\0\0K\x04\xb2\0\xd6\x01\0\0\xb2\0\xb2\0\0\0\xb2\0]\x03\0\0\xe0\x02\xe0\x02\0\0\0\0\0\0\xb0\0\0\0\xb2\0\xb2\0\0\0\0\0\0\0\x9c\x01\xab\x02\xe0\x02\0\0\0\0\xc2\0\0\0\0\0\0\0\0\0\xe0\x02\0\0\xe0\x02\0\0\0\0\0\0\0\0\0\0\0\0\x9c\x01\x9c\x01\x81\x03\x9c\x01\x9c\x01\0\0\xb2\0\xd6\x01\0\0\0\0\0\0\0\0K\x04\0\0\x97\0\xcd\x04\xc2\0\0\0\0\0\0\0\0\0\0\0\x9c\x01\0\0\0\0\0\0\xc7\x01\0\0\0\0\0\0\xaf\0\0\0\x97\0\0\0\x97\0\xe0\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x97\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xa8\0\0\0\0\0\xa8\0\0\0\0\0\0\0K\x04\xaf\0\xaf\0\xaf\0\x97\0\x97\0\xa8\0\0\0\0\0\xaf\0\0\0\x97\0\xbe\0\0\0\0\0\x97\0\xd9\x01\0\0\0\0\xa8\0\xa8\0\xa8\0\xa8\0\0\0\xaf\0\0\0\0\0\xe0\x02\x97\0\xc2\0\xc1\x03\xbe\0\xaf\0\xaf\0\xa8\0\x97\0\0\0\xaf\0\xbe\0\xaf\0\0\0\x97\0\0\0\0\0\0\0\x97\0\0\0\xd8\0\0\0\xc2\0\x97\0\x97\0\xd9\x01\0\0\xa8\0\0\0\xd9\x01\0\0\0\0\xbe\0\0\0\xa8\0\xa8\0\0\0\0\0\xaf\0{\x01\0\0\xa8\0\0\0\0\0\0\0\xaf\0\xbe\0\n\0\xa8\0\xb0\x01\0\0\0\0\0\0\xbe\0\xbe\0\0\0\xbe\0\0\0\0\0\xde\x03\0\0\xd8\0\xa8\0\0\0\xa8\0\xaf\0\0\0\0\0\0\0\0\0\xe4\x03\0\0\xe6\x03\0\0\0\0\xb2\0\xa8\0\0\0\0\0\xa8\0\xdc\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xc2\0\xc2\0\0\0\0\0\xc2\0\0\0\xc2\0\0\0\x89\0\xbe\0\x8a\0\x8b\0 \0\0\0\x8c\0\0\0\0\0\xb1\x01\x8e\0\0\0\r\x04\x03\x01\0\0\xaf\0\x03\x01\0\0\0\0\0\0\0\0\x03\x01\0\0\x03\x01\0\0\0\0\x03\x01\x03\x01\0\0\x03\x01\x03\x01\x03\x01\x03\x01\x03\x01\x03\x01!\x04\x91\0\x03\x01\x03\x01\x03\x01%\x04\x03\x01\x03\x01\x92\0\0\0\0\0\0\0~\x03\0\0\0\0\x03\x01\0\0\0\0\x03\x01\x03\x01\x93\0\x94\0\0\0\0\0\0\0\x03\x01\x03\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xd5\x01\0\0\0\0\x03\x01\0\0\0\0\x03\x01\0\0\xb2\0\0\0\x03\x01\x03\x01\0\0\x03\x01\0\0\0\0\x03\x01\x03\x01\0\0\0\0\0\0\0\0\0\0\xaf\0\x03\x01\\\x04\xd9\x01\xaf\0\0\0\0\0a\x04\0\0\0\0\0\0\0\0\x03\x01\x03\x01\0\0\x03\x01\x03\x01\x03\x01\x03\x01\xb2\0\xb2\0\xb2\0\0\0\0\0\x03\x01\0\0\x03\x01\xb2\0\0\0\x03\x01\0\0\0\0\x03\x01\0\0\0\0\xaf\0\x03\x01\0\0\0\0\0\0\0\0\0\0\xfa\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xd6\x01\xb2\0\xaf\0\0\0\x8d\x04\xd6\x01\0\0\xb2\0\0\0\0\0\xaf\0\0\0\xaf\0\0\0\0\0\xe0\x02\xe0\x02\0\0\0\0\0\0\0\0\0\0\xd8\0\0\0\0\0\0\0\0\0\0\0\xe0\x02\0\0\0\0\0\0M\x02\xb2\0\0\0\xe0\x02\0\0\0\0\0\0\0\0\xb2\0\xe0\x02\xe0\x02\xe0\x02\xe0\x02\0\0\0\0\0\0\0\0\0\0\0\0\xdd\x03\0\0\xba\x04{\x01\0\0\xe0\x02\0\0{\x01\xbd\x04\xb2\0\0\0{\x01\xe0\x02{\x01\0\0\0\0\0\0{\x01\0\0\0\0\0\0{\x01\0\0\0\0\xc2\0\xe0\x02\xe0\x02\0\0\xe0\x02\0\0{\x01\0\0\0\0\xe0\x02\xe0\x02\0\0\xe0\x02\0\0\xd8\0\xe0\x02\0\0\0\0\0\0\0\0\xaf\0\xaf\0\xe0\x02\0\0\0\0\0\0\xb3\0\0\0\0\0\0\0\xc3\0\0\0\xd6\x01\0\0\xe0\x02\0\0\0\0\0\0\xe0\x02\xd8\0\0\0\0\0\x1b\x04\0\0\0\0\xe7\x04{\x01\xc3\0\0\0\0\0\xe0\x02\0\0\0\0{\x01\xe0\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xc3\0\0\0\0\0\0\0\0\0{\x01{\x01\0\0{\x01{\x01\xc7\x01\0\0\xfb\x04\0\0\xfd\x04\0\0\x01\x05\0\0\0\0\x06\x05\0\0\0\0\0\0\0\0\0\0\0\0\0\0{\x01\xaf\0\0\0\0\0\0\0\0\0\0\0\x0f\x05\xc3\0\0\0\xc3\0\xc3\0\0\0\0\0\xd5\x01\0\0\xc7\x01\xb2\0\xaf\0\0\0\0\0\xb2\0\0\0\0\0\x1e\x05\x1f\x05\0\0\xd5\x01\0\0E\x04$\x05\x8a\0\x8b\0 \0\0\0\x8c\0\0\0\xaf\0F\x04G\x04\xd5\x01\0\0\xd5\x01\xd5\x01\0\0\0\0\0\0\0\0\xe2\x02\0\0\0\0\0\0\xd6\x01H\x04\0\0\xd5\x01I\x04\xaf\x006\x05\0\0\0\0\xd8\0\xb2\x01\0\0J\x04\x91\0\0\0\0\0\0\0\xb2\0\0\0\0\0\x92\0\xaf\0\0\0\xd5\x01\0\0\xb2\0\0\0\xd6\x01\0\0\xd5\x01\xd5\x01\xd5\x01\x93\0\x94\0\0\0\xb3\0\xd7\x01\xd5\x01\xb3\0\xb3\0\0\0\xb3\0\0\0\0\0\xd5\x01\xb5\0\0\0\0\0\xaf\0\0\0\0\0\xb3\0\xb3\0\0\0\xcf\0\0\0\0\0\0\0\0\0\0\0\xd5\x01\xc3\0\0\0\xd9\x01\0\0\0\0\0\0M\x02\0\0\0\0M\x02\0\0\xd5\x01\0\0i\x05\xd5\x01\0\0\0\0\0\0\0\0M\x02\xb3\0\xd7\x01\0\0M\x02\xd9\x01\0\0\0\0p\x05~\x02\0\0\xc3\0\0\0M\x02M\x02M\x02M\x02\x8a\x02\0\0\0\0\0\0\0\0v\x05\0\0\0\0x\x05\0\0\0\0M\x02\0\0\xb2\0\xd6\x01\0\0\0\0\0\0\0\x009\x03\xaf\0\0\0\xc7\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0M\x02\0\0\0\0M\x02\0\0~\x02M\x02M\x02M\x02\xaf\0\x9c\x01\0\0\0\0\x8f\x05M\x02\0\0\0\0\0\0\0\0\0\0\0\0M\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xf2\x01M\x02\0\0M\x02\0\0M\x02M\x02\xc3\0\xc7\x01\0\0\0\0\0\0\x89\0\0\0\x8a\0\x8b\0 \0M\x02\x8c\0\x97\x01M\x02\x8d\0\x8e\0\0\0M\x02\xb2\0\0\0\xc3\0\xb0\x05\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x8f\0\xb5\0\xb5\0\xd6\x01\xb5\0\xb5\0\0\0\xb5\0\x90\0\x90\x03\0\0\0\0\0\0\0\0\0\0\0\0\x92\0\xb5\0\xb5\0\0\0\0\0\0\0\xb2\0\0\0\xc6\x05\xc7\x05\0\0\x05\x04\x93\0\x94\0\xb4\0\0\0\xce\x059\x03\0\0\xaf\0\0\0\0\0\0\0\0\0\0\0\xb3\0\xb2\0\0\0\0\0\0\0\0\0\xb5\0\xb5\0\x0e\0\0\0\0\0\xc7\x01\xe2\x02\0\0\xc3\0\xc3\0\xaf\0\xb2\0\xc3\0\0\0\xc3\0\xc7\x01\0\0\x0f\0\x10\0\xe2\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xaf\0\0\0\0\0\x17\0\0\0\xe2\x02\0\0\xe2\x02\xe2\x02\xe7\x05\0\0\xd6\x01\0\0\0\0\0\0\x89\0\0\0\x8a\0\x8b\0 \0\xe2\x02\x8c\0\0\0!\0\x8d\0\x8e\0S\x01\0\0\xf1\x01\0\0\0\0%\0\xb2\x01\0\0\0\0\0\0\0\0)\0\0\0\xb2\x01\xe2\x02\xb2\x01\x8f\0\xe2\x02-\0\xaf\0\0\0\xe2\x02\xe2\x02\0\0\x90\0\x91\0\0\0\0\0\xe2\x02\0\0\0\0\0\0\x92\0\0\x001\0\xe2\x02\0\0\0\0\0\0\0\0\0\0\0\0\xb3\0\0\0\x93\0\x94\x005\0\xe2\x02\0\0\0\0\0\0\xe2\x02\xe2\x02\0\0\xd6\x01\0\0\0\0\0\0\0\0\0\0\xc7\x01\xc2\0\xc7\x01\xe2\x02\0\0\0\0\xe2\x02\x8a\x02\0\0\0\0\0\0\0\0\0\0\0\0\xd6\x01\0\0\xb3\0\xb3\0\xb3\0\xaf\0\0\0f\x02\x8a\x02\x8a\x02\xb3\0\xb4\0\xb4\0\0\0\xb4\0\xb4\0\0\0\xb4\0\0\0\0\0\xaf\0\x8a\x02\0\0\0\0\0\0\0\0\0\0\xb4\0\xb4\0\0\0\0\0k\0\x80\x02\xd7\x01\xb3\0\0\0\0\0\0\0\xd7\x01\0\0\xb3\0\x8a\x02\n\0\xf2\x01\x8a\x02\0\0\xf2\x01\0\0\0\0\x8a\x02\0\0\0\0\0\0\0\0\0\0\x8a\x02\xf2\x01\xb4\0\xb4\0\0\0\0\0\0\0\x8a\x02\0\0\0\0\0\0\xb3\0\0\0\0\0\xf2\x01\xf2\x01\xf2\x01\xf2\x01\xb3\0\0\0\0\0\xaf\0\0\0\x8a\x02\x8a\x02\0\0\0\0\0\0\0\0\xf2\x01\0\0\0\0\0\0\0\0\0\0\x8a\x02\0\0\x89\0\xb3\0\x8a\0\x8b\0 \0\xb2\0\x8c\0\0\0\0\0\xb1\x01\x8e\0\0\0\xf2\x01\0\0\0\0\xf2\x01\xc3\0\x97\x01\xf2\x01\xf2\x01\xf2\x01\0\0\0\0\0\0\0\0\0\0\xf2\x01\xd6\x01\0\0Z\x01\0\0\0\0\0\0\xf2\x01\xc2\0\0\0\x91\0\0\0\0\0\0\0\0\0\xb5\0\0\0\x92\0\xd6\x01\xf2\x01\0\0\xf2\x01\xd7\x01\xf2\x01\xf2\x01\0\0\0\0\0\0\0\0\x93\0\x94\0`\x01a\x01b\x01c\x01\xf2\x01\0\0\0\0\xf2\x01\0\0\x97\x01\0\0\xf2\x01\0\0\0\0\0\0\0\0\0\0\xdc\x02\xb5\0\xb5\0\xb5\0\xc8\x02\0\0\0\0\xb9\0\0\0\xb5\0\0\0;\x03e\x01f\x01\0\0\xd6\x01\0\0\0\0\xf1\x01\0\0\0\0\xf1\x01\0\0\0\0\0\0h\x01i\x01j\x01k\x01\xb2\x01\xe0\x02\xf1\x01\xb5\0\xb5\0\0\0\0\0\0\0\xb5\0\0\0\xb5\0\0\0\0\0m\x01\0\0\xf1\x01\xf1\x01\xf1\x01\xf1\x01\0\0\0\0\xb4\0f\x02\0\0\xb3\0\0\0\0\0\0\0\xb3\0\0\0\xf1\x01\0\0\0\0\0\0\0\0\0\0\xb5\0\0\0\x89\0\0\0\x8a\0\x8b\0 \0\x80\x02\x8c\0\0\0\xd6\x01\x8d\0\x8e\0\0\0\xf1\x01\0\0\0\0\xf1\x01\0\0\0\0\xf1\x01\xf1\x01\xf1\x01\xd7\x01\0\0\xa1\x05\0\0\xb5\0\xf1\x01\x8f\0\0\0\0\0\xef\x01\0\0\0\0\xf1\x01\0\0\x90\0\x91\0\0\0\xb3\0\0\0\0\0\0\0\0\0\x92\0\0\0\xf1\x01\xb3\0\xf1\x01\xd7\x01\xf1\x01\xf1\x01\0\0\xa1\x02\0\0k\0\x93\0\x94\0\0\0\0\0\0\0\0\0\xf1\x01\0\0\0\0\xf1\x01\x97\x01\0\0k\0\xf1\x01\0\0\0\0\0\0\xb5\0\0\0\0\0\0\0\0\0\0\0\0\0\xc2\x05k\0\0\0k\0k\0\xb4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\xa1\x02\0\0\xa1\x02\xa1\x02\xa1\x02\\\0\xa1\x02\0\0\0\0\xa1\x02\xa1\x02\0\0\0\0k\0\0\0\0\0\xb4\0\xb4\0\xb4\0\0\0k\0k\0\0\0\0\0\xb4\0\xb4\0\0\0k\0\0\0\xb3\0\xd7\x01\0\0\0\0\0\0k\0\0\0\xa1\x02\0\0\0\0\0\0\xae\x03\0\0\0\0\xa1\x02\0\0\0\0\x97\x01\xb4\0\xb4\0\xb5\0k\0\0\0\xb4\0\xb5\0\xb4\0\xa1\x02\xa1\x02\0\0\0\0\0\0\0\0\0\0k\0\0\0\0\0k\0\0\0\0\0\0\0\xb2\x01\0\0\0\0\0\0\0\0,\x04\0\0\0\0\xe7\0\xe7\0\0\0\xb4\0\0\0\0\0\0\0\xb5\0\0\0\0\0\xb4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x89\0\0\0\x8a\0\x8b\0 \0\xb5\0\x8c\0\0\0\xb3\0\x8d\0\x8e\0\xb4\0\0\0\xb5\0\0\0\xb5\0\0\0\0\0\0\0\0\0\0\0\xe0\x02\0\0\0\0\xe0\x02\xd7\x01\0\0\x8f\0\0\0\0\0\0\0\0\0\0\0\0\0\xe0\x02\x90\0\x91\0\0\0\x8a\x01\x8b\x01\0\0\0\0\0\0\x92\0\xb3\0\0\0\0\0\xe0\x02\0\0\xe0\x02\xe0\x02\0\0\0\0\0\0\0\0\x93\0\x94\0\0\0\xb4\0\0\0\0\0\0\0\xe0\x02\0\0\xb3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x97\x01\0\0\0\0\0\0\0\0\0\0\xb3\0\xfd\x01\xe0\x02\0\0\0\0\0\0\0\0\0\0\xef\x01\0\0\xe0\x02\xef\x01\0\0\0\0\0\0\0\0\xe0\x02\0\0\xb5\0\xb5\0\0\0\xef\x01\x97\x01\xe0\x02\0\0\0\0\0\0\xd7\x01\0\0\0\0\0\0\0\0\x97\x01\0\0\xef\x01\xef\x01\xef\x01\xef\x01\0\0\xe0\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xef\x01\0\0\xe0\x02\0\0\0\0\xe0\x02\0\0f\x02\xb4\0\xc2\x04\0\0\0\0\xb4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xef\x01\0\0\0\0\xef\x01\0\0\0\0\xef\x01\xef\x01\xef\x01\0\0\x97\x01\0\0\0\0\xb2\x01\xef\x01\n\0\\\0\xb0\x01\0\0\0\0\0\0\xef\x01\x97\x01\xb4\0\xb5\0\0\0\0\0\xd7\x01\0\0\\\0\x97\x01\0\0\0\0\xef\x01\xc3\0\xef\x01\0\0\xef\x01\xef\x01\0\0\xb4\0\xb5\0\\\0\0\0\\\0\\\0\0\0\xd7\x01\xb4\0\xef\x01\xb4\0\0\0\xef\x01\0\0\0\0\0\0\xef\x01\\\0\0\0\0\0\xb5\0\0\0\0\0\0\0\0\0\x89\0\0\0\x8a\0\x8b\0 \0\x97\x01\x8c\0\0\0\0\0\x8d\0\x8e\0\0\0\\\0\0\0\0\0\xb5\0\0\0\0\0Q\x04\0\0\\\0\0\0\0\0\0\0\0\0\0\0\\\0\x8f\0\0\0\0\0\0\0\xb5\0\0\0\\\0\0\0\x90\0\x91\0\x06\x01\0\0\0\0\0\0\0\0\x97\x01\x92\0\0\0\x97\x01\x97\x01\0\0\0\0\\\0\0\0\0\0\0\0\0\0\0\0\x93\0\x94\0\0\0\xb5\0\0\0\0\0\\\0\0\0\0\0\\\0\0\0\0\0\0\0\xb4\0\xb4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xb3\0g\x02h\x02i\x02j\x02k\x02l\x02m\x02n\x02o\x02p\x02q\x02r\x02s\x02t\x02u\x02v\x02w\x02x\x02y\x02z\x02{\x02\xd7\x01}\x02\0\0\0\0\0\0\0\0\0\0\xc3\0\0\0\0\0\0\0Q\x04\0\0\0\0\0\0\x87\x02\0\0\xd7\x01\0\0\0\0\0\0\0\0\xfd\x01\x97\x01\xfd\x01\xfd\x01\xb5\0\x94\x02\0\0\0\0\xfd\x01\0\0\0\0\0\0\0\0\xfd\x01\0\0\0\0\0\0\xfd\x01\xfd\x01\xfd\x01\xb4\0\0\0\0\0\0\0\xb5\0\0\0\xfd\x01\xfd\x01\xfd\x01\xfd\x01\0\0\0\0\xcf\x04\0\0\0\0\0\0\xfd\x01\xb4\0\0\0\0\0\xd7\x01\xfd\x01\0\0\0\0\0\0\0\0\0\0\xfd\x01\xfd\x01\0\0\0\0\0\0\0\0\r\x01\0\0\0\0\xb4\0\0\0\0\0\0\0\0\0\xfd\x01\0\0\0\0\xfd\x01\0\0\0\0\xfd\x01\xfd\x01\xfd\x01\0\0\xfd\x01\0\0\0\0\0\0\xfd\x01\xb4\0\0\0\0\0\0\0\0\0\0\0\xfd\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xb4\0\xfd\x01\xfd\x01\0\0\xfd\x01\xfd\x01\xfd\x01\xfd\x01\xd7\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xfd\x01\0\0\0\0\xfd\x01\0\0\0\0\0\0\xfd\x01\0\0\xb4\0\0\0\xb5\0\0\0\0\0\0\0\0\0\x89\0\0\0\x8a\0\x8b\0 \0\x97\x01\x8c\0\0\0\0\0\x8d\0\x8e\0\0\0\0\0\0\0\xcf\x04\0\0\0\0\xb5\0\0\0%\x05&\x05\0\0\0\0\0\0\0\0\0\0\0\0\x8f\0\0\0\0\0Q\x04\0\0\0\0\x19\x03\xb5\0\x90\0\x91\0\0\0\0\0\0\0\0\0\0\0#\x03\x92\0\x06\x01\0\0%\x03\x06\x01\0\0)\x03\0\0\0\0\x06\x01\0\0\x06\x01\x93\0\x94\0\x06\x01\x06\x01Q\x04\0\0\x06\x01\xb4\0\x06\x01\x06\x01\x06\x01\0\0\0\0\x06\x01\x06\x01\x06\x01O\x02\x06\x01\x06\x01\0\0\0\0\0\0\0\0\0\0\xb5\0\0\0\x06\x01\xb4\0\x97\x01\x06\x01\x06\x01\0\0\0\0\0\0\0\0\0\0\x06\x01\x06\x01\0\0\0\0\0\0\0\0\0\0\xe7\0\xe7\0\0\0\0\0\0\0\0\0\0\0\x06\x01\0\0\0\0\x06\x01\0\0\0\0\0\0\x06\x01\x06\x01\0\0\x06\x01\0\0\0\0\x06\x01\x06\x01\0\0\0\0\0\0\0\0\0\0\0\0\x06\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0j\x03\x06\x01\x06\x01\xb5\0\x06\x01\x06\x01\x06\x01\x06\x01\0\0\0\0\0\0\0\0\0\0\x06\x01\0\0\x06\x01\xcf\x04\0\0\x06\x01\0\0\0\0\x06\x01\0\0Q\x04\0\0\x06\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0Q\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x89\0\xb4\0\x8a\0\x8b\0 \0\r\x01\x8c\0\0\0\r\x01\x8d\0\x8e\0\0\0\0\0\r\x01\0\0\r\x01\0\0r\x02\r\x01\r\x01\0\0\0\0\r\x01\xb4\0\r\x01\r\x01\r\x01\x8f\0\0\0\r\x01\r\x01\r\x01\0\0\r\x01\r\x01\x90\0\x90\x03\0\0\0\0\0\0\xb4\0\0\0\r\x01\x92\0Q\x04\r\x01\r\x01\xcf\x04\0\0\0\0\0\0\0\0\r\x01\r\x01\xb1\x03\x93\0\x94\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\r\x01\0\0\0\0\r\x01\0\0\0\0\0\0\r\x01\r\x01\0\0\r\x01\0\0\0\0\r\x01\r\x01\0\0\0\0\0\0\0\0\xb4\0\0\0\r\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0Q\x04\xd0\x03\0\0\r\x01\r\x01\0\0\r\x01\r\x01\r\x01\r\x01\0\0\0\0\0\0\0\0\0\0\r\x01\0\0\r\x01\0\0\0\0\r\x01\0\0\0\0\r\x01\0\0\0\0\0\0\r\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xdf\x03\0\0\0\0\0\0\0\0\0\0\0\0\xe0\0\0\0\0\0\0\0\0\0\0\0\xb4\0\0\0\0\0\0\0O\x02O\x02O\x02O\x02\0\0\0\0O\x02O\x02O\x02O\x02O\x02O\x02O\x02O\x02O\x02O\x02O\x02O\x02O\x02O\x02O\x02O\x02O\x02\0\0O\x02O\x02O\x02O\x02O\x02O\x02O\x02O\x02\0\0\0\0\0\0\0\0O\x02O\x02\0\0\x16\x04O\x02O\x02O\x02O\x02O\x02O\x02O\x02O\x02O\x02O\x02O\x02O\x02O\x02\0\0O\x02O\x02O\x02O\x02\0\0\0\0O\x02O\x02O\x02:\x02O\x02O\x02O\x02O\x02O\x02O\x02\0\0O\x02O\x02O\x02O\x02O\x02\0\0O\x02O\x02\0\0\0\0\0\0O\x02O\x02O\x02O\x02O\x02O\x02O\x02O\x02\0\0O\x02\0\0O\x02O\x02\0\0O\x02O\x02O\x02O\x02O\x02\0\0O\x02O\x02\0\0O\x02O\x02O\x02O\x02\x1d\x01O\x02O\x02\0\0O\x02\0\0\0\0\0\0O\x02\0\0\0\0\0\0\0\0\0\0\0\0r\x02r\x02r\x02r\x02r\x02\0\0r\x02r\x02r\x02r\x02r\x02r\x02r\x02r\x02r\x02r\x02r\x02r\x02r\x02r\x02r\x02r\x02\0\0z\x04r\x02r\x02r\x02r\x02r\x02r\x02r\x02r\x02\0\0\0\0\0\0\0\0r\x02r\x02\0\0\0\0r\x02r\x02r\x02r\x02r\x02r\x02r\x02r\x02r\x02r\x02r\x02r\x02r\x02\0\0r\x02r\x02r\x02r\x02\0\0\0\0r\x02r\x02r\x02\0\0r\x02r\x02r\x02r\x02r\x02r\x02\0\0r\x02r\x02r\x02r\x02r\x02\0\0r\x02r\x02\0\0\0\0\0\0r\x02r\x02r\x02r\x02r\x02r\x02r\x02r\x02\0\0r\x02\0\0r\x02r\x02\0\0r\x02r\x02r\x02r\x02r\x02\0\0r\x02r\x02<\x01r\x02r\x02r\x02r\x02\0\0r\x02r\x02\0\0r\x02\0\0\0\0\0\0r\x02\0\0\0\0\0\0\0\0\xe0\0\xe0\0\xe0\0\xe0\0\0\0\0\0\0\0\0\0\xe0\0\xe0\0\xe0\0\0\0\0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\0\0\0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe0\0\xe0\0\0\0\0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\0\0\0\0\0\0\0\0\xf1\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe0\0\xe0\0\0\0\xe0\0\xf8\x04\0\0\xe0\0\xe0\0\xe0\0\0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe0\0\0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\0\0\0\0\0\0\0\0\xe0\0\xe0\0\0\0\xe0\0\xe0\0\xe0\0\xe0\0$\x01\0\0\xe0\0\0\0\0\0\xe0\0\0\0\xe0\0\0\0\0\0\xe0\0\0\0\0\0\xe0\0!\x05\"\x05#\x05\xe0\0\0\0\x1d\x01\x1d\x01\x1d\x01\x1d\x01\0\0\0\0\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\0\0\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\0\0\0\0\0\0\0\0\x1d\x01\x1d\x01\0\0\0\0\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\0\0\x1d\x01\x1d\x01\x1d\x01\x1d\x01\0\0\0\0\x1d\x01\x1d\x01\x1d\x01\0\0\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\0\0\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\0\0\x1d\x01\x1d\x01\0\0\0\0\0\0\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\0\0\x1d\x01\0\0\x1d\x01\x1d\x01\0\0\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\"\x01\x1d\x01\x1d\x01\0\0\x1d\x01\x1d\x01\x1d\x01\x1d\x01\0\0\x1d\x01\x1d\x01\0\0\x1d\x01\0\0\0\0\0\0\x1d\x01\0\0<\x01<\x01<\x01<\x01<\x01\0\0<\x01<\x01<\x01<\x01<\x01<\x01<\x01<\x01<\x01<\x01<\x01<\x01<\x01<\x01<\x01<\x01\0\0\0\0<\x01<\x01<\x01<\x01<\x01<\x01<\x01<\x01\0\0\0\0\0\0\0\0<\x01<\x01\0\0\0\0<\x01<\x01<\x01<\x01<\x01<\x01<\x01<\x01<\x01<\x01<\x01<\x01<\x01\0\0<\x01<\x01<\x01<\x01\0\0\0\0<\x01<\x01<\x01\0\0<\x01<\x01<\x01<\x01<\x01<\x01\0\0<\x01<\x01<\x01<\x01<\x01\0\0<\x01<\x01\0\0\0\0\0\0<\x01<\x01<\x01<\x01<\x01<\x01<\x01<\x01\0\0<\x01\0\0<\x01<\x01\0\0<\x01<\x01<\x01<\x01<\x01 \x01<\x01<\x01\0\0<\x01<\x01<\x01<\x01\0\0<\x01<\x01\0\0<\x01\0\0\0\0\0\0<\x01$\x01$\x01$\x01$\x01\0\0\0\0$\x01$\x01$\x01$\x01$\x01$\x01$\x01$\x01$\x01$\x01$\x01$\x01$\x01$\x01$\x01$\x01$\x01\0\0$\x01$\x01$\x01$\x01$\x01$\x01$\x01$\x01\0\0\0\0\0\0\0\0$\x01$\x01\0\0\0\0$\x01$\x01$\x01$\x01$\x01$\x01$\x01$\x01$\x01$\x01$\x01$\x01$\x01\0\0$\x01$\x01$\x01$\x01\0\0\0\0$\x01$\x01$\x01\0\0$\x01$\x01$\x01$\x01$\x01$\x01\0\0$\x01$\x01$\x01$\x01$\x01\0\0$\x01$\x01\0\0\0\0\0\0$\x01$\x01$\x01$\x01$\x01$\x01$\x01$\x01\0\0$\x01\0\0$\x01$\x01\0\0$\x01$\x01$\x01$\x01$\x01E\x01$\x01$\x01\0\0$\x01$\x01$\x01$\x01\0\0$\x01$\x01\0\0$\x01\0\0\0\0\0\0$\x01\0\0\0\0\"\x01\"\x01\"\x01\"\x01\0\0\0\0\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\0\0\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\0\0\0\0\0\0\0\0\"\x01\"\x01\0\0\0\0\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\0\0\"\x01\"\x01\"\x01\"\x01\0\0\0\0\"\x01\"\x01\"\x01\0\0\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\0\0\"\x01\"\x01\"\x01\"\x01\"\x01\0\0\"\x01\"\x01\0\0\0\0\0\0\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\0\0\"\x01\0\0\"\x01\"\x01\0\0\"\x01\"\x01\"\x01\"\x01\"\x01G\x01\"\x01\"\x01\0\0\"\x01\"\x01\"\x01\"\x01\0\0\"\x01\"\x01\0\0\"\x01\0\0\0\0\0\0\"\x01\0\0 \x01 \x01 \x01 \x01\0\0\0\0 \x01 \x01 \x01 \x01 \x01 \x01 \x01 \x01 \x01 \x01 \x01 \x01 \x01 \x01 \x01 \x01 \x01\0\0 \x01 \x01 \x01 \x01 \x01 \x01 \x01 \x01\0\0\0\0\0\0\0\0 \x01 \x01\0\0\0\0 \x01 \x01 \x01 \x01 \x01 \x01 \x01 \x01 \x01 \x01 \x01 \x01 \x01\0\0 \x01 \x01 \x01 \x01\0\0\0\0 \x01 \x01 \x01\0\0 \x01 \x01 \x01 \x01 \x01 \x01\0\0 \x01 \x01 \x01 \x01 \x01\0\0 \x01 \x01\0\0\0\0\0\0 \x01 \x01 \x01 \x01 \x01 \x01 \x01 \x01\0\0 \x01\0\0 \x01 \x01\0\0 \x01 \x01 \x01 \x01 \x01J\x01 \x01 \x01\0\0 \x01 \x01 \x01 \x01\0\0 \x01 \x01\0\0 \x01\0\0\0\0\0\0 \x01E\x01E\x01E\x01E\x01E\x01\0\0E\x01E\x01E\x01E\x01E\x01E\x01E\x01E\x01E\x01E\x01E\x01E\x01E\x01E\x01E\x01E\x01\0\0\0\0E\x01E\x01E\x01E\x01E\x01E\x01E\x01E\x01\0\0\0\0\0\0\0\0E\x01E\x01\0\0\0\0E\x01E\x01E\x01E\x01E\x01E\x01E\x01E\x01E\x01E\x01E\x01E\x01E\x01\0\0E\x01E\x01E\x01E\x01\0\0\0\0E\x01E\x01E\x01\0\0E\x01E\x01E\x01E\x01E\x01E\x01\0\0E\x01E\x01E\x01E\x01E\x01\0\0E\x01E\x01\0\0\0\0\0\0E\x01E\x01E\x01E\x01E\x01E\x01E\x01E\x01\0\0E\x01\0\0E\x01E\x01\0\0E\x01E\x01E\x01\0\0\0\0\x15\x01E\x01E\x01\0\0E\x01E\x01E\x01E\x01\0\0E\x01E\x01\0\0E\x01\0\0\0\0\0\0E\x01\0\0\0\0G\x01G\x01G\x01G\x01G\x01\0\0G\x01G\x01G\x01G\x01G\x01G\x01G\x01G\x01G\x01G\x01G\x01G\x01G\x01G\x01G\x01G\x01\0\0\0\0G\x01G\x01G\x01G\x01G\x01G\x01G\x01G\x01\0\0\0\0\0\0\0\0G\x01G\x01\0\0\0\0G\x01G\x01G\x01G\x01G\x01G\x01G\x01G\x01G\x01G\x01G\x01G\x01G\x01\0\0G\x01G\x01G\x01G\x01\0\0\0\0G\x01G\x01G\x01\0\0G\x01G\x01G\x01G\x01G\x01G\x01\0\0G\x01G\x01G\x01G\x01G\x01\0\0G\x01G\x01\0\0\0\0\0\0G\x01G\x01G\x01G\x01G\x01G\x01G\x01G\x01\0\0G\x01\0\0G\x01G\x01\0\0G\x01G\x01G\x01\x16\x01\0\0\0\0G\x01G\x01\0\0G\x01G\x01G\x01G\x01\0\0G\x01G\x01\0\0G\x01\0\0\0\0\0\0G\x01\0\0J\x01J\x01J\x01J\x01J\x01\0\0J\x01J\x01J\x01J\x01J\x01J\x01J\x01J\x01J\x01J\x01J\x01J\x01J\x01J\x01J\x01J\x01\0\0\0\0J\x01J\x01J\x01J\x01J\x01J\x01J\x01J\x01\0\0\0\0\0\0\0\0J\x01J\x01\0\0\0\0J\x01J\x01J\x01J\x01J\x01J\x01J\x01J\x01J\x01J\x01J\x01J\x01J\x01\0\0J\x01J\x01J\x01J\x01\0\0\0\0J\x01J\x01J\x01\0\0J\x01J\x01J\x01J\x01J\x01J\x01\0\0J\x01J\x01J\x01J\x01J\x01\0\0J\x01J\x01\0\0\0\0\0\0J\x01J\x01J\x01J\x01J\x01J\x01J\x01J\x01\0\0J\x01\0\0J\x01J\x01\0\0J\x01J\x01J\x01\xdf\0\0\0\0\0J\x01J\x01\0\0J\x01J\x01J\x01J\x01\0\0J\x01J\x01\0\0J\x01\0\0\0\0\0\0J\x01\x15\x01\x15\x01\x15\x01\x15\x01\0\0\0\0\0\0\0\0\x15\x01\x15\x01\x15\x01\0\0\0\0\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\0\0\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\0\0\0\0\0\0\0\0\0\0\0\0\x15\x01\x15\x01\0\0\0\0\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\0\0\0\0\0\0\x15\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x15\x01\x15\x01\0\0\x15\x01\0\0\0\0\x15\x01\x15\x01\x15\x01\0\0\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\0\0\0\0\0\0\0\0\0\0\0\0\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\0\0\0\0\x15\x01\0\0\x15\x01\x15\x01\0\0\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\xea\0\x15\x01\0\0\0\0\x15\x01\x15\x01\x15\x01\0\0\0\0\x15\x01\0\0\0\0\x15\x01\0\0\0\0\0\0\x15\x01\x16\x01\x16\x01\x16\x01\x16\x01\0\0\0\0\0\0\0\0\x16\x01\x16\x01\x16\x01\0\0\0\0\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\0\0\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\0\0\0\0\0\0\0\0\0\0\0\0\x16\x01\x16\x01\0\0\0\0\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\0\0\0\0\0\0\x16\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x01\x16\x01\0\0\x16\x01\0\0\0\0\x16\x01\x16\x01\x16\x01\0\0\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\0\0\0\0\0\0\0\0\0\0\0\0\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\0\0\0\0\x16\x01\0\0\x16\x01\x16\x01\0\0\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\xeb\0\x16\x01\0\0\0\0\x16\x01\x16\x01\x16\x01\0\0\0\0\x16\x01\0\0\0\0\x16\x01\0\0\0\0\0\0\x16\x01\0\0\xdf\0\xdf\0\xdf\0\xdf\0\0\0\0\0\0\0\0\0\xdf\0\xdf\0\xdf\0\0\0\0\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\0\0\0\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\0\0\0\0\0\0\0\0\0\0\0\0\xdf\0\xdf\0\0\0\0\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xdf\0\xdf\0\0\0\xdf\0\0\0\0\0\xdf\0\xdf\0\xdf\0\0\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\0\0\0\0\0\0\0\0\0\0\0\0\xdf\0\0\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\0\0\0\0\0\0\0\0\xdf\0\xdf\0\0\0\xdf\0\xdf\0\xdf\0\0\0\xec\0\0\0\xdf\0\0\0\0\0\xdf\0\0\0\xdf\0\0\0\0\0\xdf\0\0\0\0\0\xdf\0\0\0\0\0\0\0\xdf\0\0\0\0\0\xea\0\xea\0\xea\0\xea\0\0\0\0\0\0\0\0\0\xea\0\xea\0\xea\0\0\0\0\0\xea\0\xea\0\xea\0\xea\0\xea\0\0\0\xea\0\xea\0\xea\0\0\0\0\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\0\0\0\0\0\0\0\0\0\0\0\0\xea\0\xea\0\0\0\0\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xea\0\xea\0\0\0\xea\0\0\0\0\0\xea\0\xea\0\xea\0\0\0\xea\0\xea\0\xea\0\xea\0\xea\0\0\0\0\0\0\0\0\0\0\0\0\0\xea\0\0\0\xea\0\xea\0\xea\0\xea\0\xea\0\0\0\0\0\0\0\0\0\xea\0\xea\0\0\0\xea\0\xea\0\xea\0\xea\0\x0e\x01\0\0\xea\0\0\0\0\0\xea\0\0\0\xea\0\0\0\0\0\xea\0\0\0\0\0\xea\0\0\0\0\0\0\0\xea\0\xeb\0\xeb\0\xeb\0\xeb\0\0\0\0\0\0\0\0\0\xeb\0\xeb\0\xeb\0\0\0\0\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\0\0\0\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\0\0\0\0\0\0\0\0\0\0\0\0\xeb\0\xeb\0\0\0\0\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xeb\0\xeb\0\0\0\xeb\0\0\0\0\0\xeb\0\xeb\0\xeb\0\0\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\0\0\0\0\0\0\0\0\0\0\0\0\xeb\0\0\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\0\0\0\0\0\0\0\0\xeb\0\xeb\0\0\0\xeb\0\xeb\0\xeb\0\0\0\x0f\x01\0\0\xeb\0\0\0\0\0\xeb\0\0\0\xeb\0\0\0\0\0\xeb\0\0\0\0\0\xeb\0\0\0\0\0\0\0\xeb\0\xec\0\xec\0\xec\0\xec\0\0\0\0\0\0\0\0\0\xec\0\xec\0\xec\0\0\0\0\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\0\0\0\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\0\0\0\0\0\0\0\0\0\0\0\0\xec\0\xec\0\0\0\0\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xec\0\xec\0\0\0\xec\0\0\0\0\0\xec\0\xec\0\xec\0\0\0\xec\0\xec\0\xec\0\xec\0\xec\0\0\0\0\0\0\0\0\0\0\0\0\0\xec\0\0\0\xec\0\xec\0\xec\0\xec\0\xec\0\0\0\0\0\0\0\0\0\xec\0\xec\0\0\0\xec\0\xec\0\xec\0\0\0\xf6\0\0\0\xec\0\0\0\0\0\xec\0\0\0\xec\0\0\0\0\0\xec\0\0\0\0\0\xec\0\0\0\0\0\0\0\xec\0\0\0\0\0\x0e\x01\x0e\x01\x0e\x01\x0e\x01\0\0\0\0\0\0\0\0\x0e\x01\x0e\x01\x0e\x01\0\0\0\0\x0e\x01\x0e\x01\x0e\x01\x0e\x01\x0e\x01\x0e\x01\x0e\x01\x0e\x01\x0e\x01\0\0\0\0\x0e\x01\x0e\x01\x0e\x01\x0e\x01\x0e\x01\x0e\x01\0\0\0\0\0\0\0\0\0\0\0\0\x0e\x01\x0e\x01\0\0\0\0\x0e\x01\x0e\x01\x0e\x01\x0e\x01\x0e\x01\x0e\x01\x0e\x01\x0e\x01\x0e\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x0e\x01\x0e\x01\0\0\x0e\x01\0\0\0\0\x0e\x01\x0e\x01\x0e\x01\0\0\x0e\x01\x0e\x01\x0e\x01\x0e\x01\x0e\x01\0\0\0\0\0\0\0\0\0\0\0\0\x0e\x01\0\0\x0e\x01\x0e\x01\x0e\x01\x0e\x01\x0e\x01\0\0\0\0\0\0\0\0\x0e\x01\x0e\x01\0\0\x0e\x01\x0e\x01\x0e\x01\xf7\0\0\0\0\0\x0e\x01\0\0\0\0\x0e\x01\0\0\x0e\x01\0\0\0\0\x0e\x01\0\0\0\0\x0e\x01\0\0\0\0\0\0\x0e\x01\x0f\x01\x0f\x01\x0f\x01\x0f\x01\0\0\0\0\0\0\0\0\x0f\x01\x0f\x01\x0f\x01\0\0\0\0\x0f\x01\x0f\x01\x0f\x01\x0f\x01\x0f\x01\x0f\x01\x0f\x01\x0f\x01\x0f\x01\0\0\0\0\x0f\x01\x0f\x01\x0f\x01\x0f\x01\x0f\x01\x0f\x01\0\0\0\0\0\0\0\0\0\0\0\0\x0f\x01\x0f\x01\0\0\0\0\x0f\x01\x0f\x01\x0f\x01\x0f\x01\x0f\x01\x0f\x01\x0f\x01\x0f\x01\x0f\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x0f\x01\x0f\x01\0\0\x0f\x01\0\0\0\0\x0f\x01\x0f\x01\x0f\x01\0\0\x0f\x01\x0f\x01\x0f\x01\x0f\x01\x0f\x01\0\0\0\0\0\0\0\0\0\0\0\0\x0f\x01\0\0\x0f\x01\x0f\x01\x0f\x01\x0f\x01\x0f\x01\0\0\0\0\0\0\0\0\x0f\x01\x0f\x01\0\0\x0f\x01\x0f\x01\x0f\x01\xfe\0\0\0\0\0\x0f\x01\0\0\0\0\x0f\x01\0\0\x0f\x01\0\0\0\0\x0f\x01\0\0\0\0\x0f\x01\0\0\0\0\0\0\x0f\x01\xf6\0\xf6\0\xf6\0\xf6\0\0\0\0\0\0\0\0\0\xf6\0\xf6\0\xf6\0\0\0\0\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\0\0\0\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\0\0\0\0\0\0\0\0\0\0\0\0\xf6\0\xf6\0\0\0\0\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\0\0\xf6\0\xf6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xf6\0\xf6\0\0\0\xf6\0\0\0\0\0\xf6\0\xf6\0\xf6\0\0\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\0\0\0\0\0\0\0\0\0\0\0\0\xf6\0\0\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\0\0\0\0\0\0\0\0\xf6\0\xf6\0\0\0\xf6\0\xf6\0\xf6\0\xf6\0\xfd\0\0\0\xf6\0\0\0\0\0\xf6\0\0\0\xf6\0\0\0\0\0\xf6\0\0\0\0\0\xf6\0\0\0\0\0\0\0\xf6\0\0\0\xf7\0\xf7\0\xf7\0\xf7\0\0\0\0\0\0\0\0\0\xf7\0\xf7\0\xf7\0\0\0\0\0\xf7\0\xf7\0\xf7\0\xf7\0\xf7\0\xf7\0\xf7\0\xf7\0\xf7\0\0\0\0\0\xf7\0\xf7\0\xf7\0\xf7\0\xf7\0\xf7\0\0\0\0\0\0\0\0\0\0\0\0\0\xf7\0\xf7\0\0\0\0\0\xf7\0\xf7\0\xf7\0\xf7\0\xf7\0\xf7\0\0\0\xf7\0\xf7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xf7\0\xf7\0\0\0\xf7\0\0\0\0\0\xf7\0\xf7\0\xf7\0\0\0\xf7\0\xf7\0\xf7\0\xf7\0\xf7\0\0\0\0\0\0\0\0\0\0\0\0\0\xf7\0\0\0\xf7\0\xf7\0\xf7\0\xf7\0\xf7\0\0\0\0\0\0\0\0\0\xf7\0\xf7\0\0\0\xf7\0\xf7\0\xf7\0\xf7\0\xe4\0\0\0\xf7\0\0\0\0\0\xf7\0\0\0\xf7\0\0\0\0\0\xf7\0\0\0\0\0\xf7\0\0\0\0\0\0\0\xf7\0\xfe\0\xfe\0\xfe\0\xfe\0\0\0\0\0\0\0\0\0\xfe\0\xfe\0\xfe\0\0\0\0\0\xfe\0\xfe\0\xfe\0\xfe\0\xfe\0\xfe\0\xfe\0\xfe\0\xfe\0\0\0\0\0\xfe\0\xfe\0\xfe\0\xfe\0\xfe\0\xfe\0\0\0\0\0\0\0\0\0\0\0\0\0\xfe\0\xfe\0\0\0\0\0\xfe\0\xfe\0\xfe\0\xfe\0\xfe\0\xfe\0\0\0\xfe\0\xfe\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xfe\0\xfe\0\0\0\xfe\0\0\0\0\0\xfe\0\xfe\0\xfe\0\0\0\xfe\0\xfe\0\xfe\0\xfe\0\xfe\0\0\0\0\0\0\0\0\0\0\0\0\0\xfe\0\0\0\xfe\0\xfe\0\xfe\0\xfe\0\xfe\0\0\0\0\0\0\0\0\0\xfe\0\xfe\0\0\0\xfe\0\xfe\0\xfe\0\xfe\0\xe7\0\0\0\xfe\0\0\0\0\0\xfe\0\0\0\xfe\0\0\0\0\0\xfe\0\0\0\0\0\xfe\0\0\0\0\0\0\0\xfe\0\0\0\xfd\0\xfd\0\xfd\0\xfd\0\0\0\0\0\0\0\0\0\xfd\0\xfd\0\xfd\0\0\0\0\0\xfd\0\xfd\0\xfd\0\xfd\0\xfd\0\xfd\0\xfd\0\xfd\0\xfd\0\0\0\0\0\xfd\0\xfd\0\xfd\0\xfd\0\xfd\0\xfd\0\0\0\0\0\0\0\0\0\0\0\0\0\xfd\0\xfd\0\0\0\0\0\xfd\0\xfd\0\xfd\0\xfd\0\xfd\0\xfd\0\0\0\xfd\0\xfd\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xfd\0\xfd\0\0\0\xfd\0\0\0\0\0\xfd\0\xfd\0\xfd\0\0\0\xfd\0\xfd\0\xfd\0\xfd\0\xfd\0\0\0\0\0\0\0\0\0\0\0\0\0\xfd\0\0\0\xfd\0\xfd\0\xfd\0\xfd\0\xfd\0\0\0\0\0\0\0\0\0\xfd\0\xfd\0\0\0\xfd\0\xfd\0\xfd\0\xfd\0\xe8\0\0\0\xfd\0\0\0\0\0\xfd\0\0\0\xfd\0\0\0\0\0\xfd\0\0\0\0\0\xfd\0\0\0\0\0\0\0\xfd\0\0\0\xe4\0\xe4\0\xe4\0\xe4\0\0\0\0\0\0\0\0\0\0\0\xe4\0\xe4\0\0\0\0\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\0\0\0\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\0\0\0\0\0\0\0\0\0\0\0\0\xe4\0\xe4\0\0\0\0\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe4\0\xe4\0\0\0\xe4\0\0\0\0\0\xe4\0\xe4\0\xe4\0\0\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\0\0\0\0\0\0\0\0\0\0\0\0\xe4\0\0\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\0\0\0\0\0\0\0\0\xe4\0\xe4\0\0\0\xe4\0\xe4\0\xe4\0\xe4\0\xf5\0\0\0\xe4\0\0\0\0\0\xe4\0\0\0\xe4\0\0\0\0\0\xe4\0\0\0\0\0\xe4\0\0\0\0\0\0\0\xe4\0\xe7\0\xe7\0\xe7\0\xe7\0\0\0\0\0\0\0\0\0\0\0\xe7\0\xe7\0\0\0\0\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\0\0\0\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\0\0\0\0\0\0\0\0\0\0\0\0\xe7\0\xe7\0\0\0\0\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe7\0\xe7\0\0\0\xe7\0\0\0\0\0\xe7\0\xe7\0\xe7\0\0\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\0\0\0\0\0\0\0\0\0\0\0\0\xe7\0\0\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\0\0\0\0\0\0\0\0\xe7\0\xe7\0\0\0\xe7\0\xe7\0\xe7\0\xe7\0\xfb\0\0\0\xe7\0\0\0\0\0\xe7\0\0\0\xe7\0\0\0\0\0\xe7\0\0\0\0\0\xe7\0\0\0\0\0\0\0\xe7\0\0\0\xe8\0\xe8\0\xe8\0\xe8\0\0\0\0\0\0\0\0\0\0\0\xe8\0\xe8\0\0\0\0\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\0\0\0\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\0\0\0\0\0\0\0\0\0\0\0\0\xe8\0\xe8\0\0\0\0\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe8\0\xe8\0\0\0\xe8\0\0\0\0\0\xe8\0\xe8\0\xe8\0\0\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\0\0\0\0\0\0\0\0\0\0\0\0\xe8\0\0\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\0\0\0\0\0\0\0\0\xe8\0\xe8\0\0\0\xe8\0\xe8\0\xe8\0\xe8\0\xfc\0\0\0\xe8\0\0\0\0\0\xe8\0\0\0\xe8\0\0\0\0\0\xe8\0\0\0\0\0\xe8\0\0\0\0\0\0\0\xe8\0\0\0\xf5\0\xf5\0\xf5\0\xf5\0\0\0\0\0\0\0\0\0\xf5\0\xf5\0\xf5\0\0\0\0\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\0\0\0\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\0\0\0\0\0\0\0\0\0\0\0\0\xf5\0\xf5\0\0\0\0\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\0\0\0\0\xf5\0\xf5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xf5\0\xf5\0\0\0\xf5\0\0\0\0\0\xf5\0\xf5\0\xf5\0\0\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\0\0\0\0\0\0\0\0\0\0\0\0\xf5\0\0\0\xf5\0\0\0\xf5\0\xf5\0\xf5\0\0\0\0\0\0\0\0\0\xf5\0\xf5\0\0\0\xf5\0\xf5\0\xf5\0\xf5\0\xf8\0\0\0\0\0\0\0\0\0\xf5\0\0\0\xf5\0\0\0\0\0\xf5\0\0\0\0\0\xf5\0\0\0\0\0\0\0\xf5\0\xfb\0\xfb\0\xfb\0\xfb\0\0\0\0\0\0\0\0\0\xfb\0\xfb\0\xfb\0\0\0\0\0\xfb\0\xfb\0\xfb\0\xfb\0\xfb\0\xfb\0\xfb\0\xfb\0\xfb\0\0\0\0\0\xfb\0\xfb\0\xfb\0\xfb\0\xfb\0\xfb\0\0\0\0\0\0\0\0\0\0\0\0\0\xfb\0\xfb\0\0\0\0\0\xfb\0\xfb\0\xfb\0\xfb\0\xfb\0\0\0\0\0\xfb\0\xfb\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xfb\0\xfb\0\0\0\xfb\0\0\0\0\0\xfb\0\xfb\0\xfb\0\0\0\xfb\0\xfb\0\xfb\0\xfb\0\xfb\0\0\0\0\0\0\0\0\0\0\0\0\0\xfb\0\0\0\xfb\0\0\0\xfb\0\xfb\0\xfb\0\0\0\0\0\0\0\0\0\xfb\0\xfb\0\0\0\xfb\0\xfb\0\xfb\0\xfb\0\xf9\0\0\0\0\0\0\0\0\0\xfb\0\0\0\xfb\0\0\0\0\0\xfb\0\0\0\0\0\xfb\0\0\0\0\0\0\0\xfb\0\0\0\xfc\0\xfc\0\xfc\0\xfc\0\0\0\0\0\0\0\0\0\xfc\0\xfc\0\xfc\0\0\0\0\0\xfc\0\xfc\0\xfc\0\xfc\0\xfc\0\xfc\0\xfc\0\xfc\0\xfc\0\0\0\0\0\xfc\0\xfc\0\xfc\0\xfc\0\xfc\0\xfc\0\0\0\0\0\0\0\0\0\0\0\0\0\xfc\0\xfc\0\0\0\0\0\xfc\0\xfc\0\xfc\0\xfc\0\xfc\0\0\0\0\0\xfc\0\xfc\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xfc\0\xfc\0\0\0\xfc\0\0\0\0\0\xfc\0\xfc\0\xfc\0\0\0\xfc\0\xfc\0\xfc\0\xfc\0\xfc\0\0\0\0\0\0\0\0\0\0\0\0\0\xfc\0\0\0\xfc\0\0\0\xfc\0\xfc\0\xfc\0\0\0\0\0\0\0\0\0\xfc\0\xfc\0\0\0\xfc\0\xfc\0\xfc\0\xfc\0\xfa\0\0\0\0\0\0\0\0\0\xfc\0\0\0\xfc\0\0\0\0\0\xfc\0\0\0\0\0\xfc\0\0\0\0\0\0\0\xfc\0\0\0\xf8\0\xf8\0\xf8\0\xf8\0\0\0\0\0\0\0\0\0\xf8\0\xf8\0\xf8\0\0\0\0\0\xf8\0\xf8\0\xf8\0\xf8\0\xf8\0\xf8\0\xf8\0\xf8\0\xf8\0\0\0\0\0\xf8\0\xf8\0\xf8\0\xf8\0\xf8\0\xf8\0\0\0\0\0\0\0\0\0\0\0\0\0\xf8\0\xf8\0\0\0\0\0\xf8\0\xf8\0\xf8\0\xf8\0\xf8\0\0\0\0\0\xf8\0\xf8\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xf8\0\xf8\0\0\0\xf8\0\0\0\0\0\xf8\0\xf8\0\xf8\0\0\0\xf8\0\xf8\0\xf8\0\xf8\0\xf8\0\0\0\0\0\0\0\0\0\0\0\0\0\xf8\0\0\0\xf8\0\0\0\xf8\0\xf8\0\xf8\0\0\0\0\0\0\0\0\0\xf8\0\xf8\0\0\0\xf8\0\xf8\0\xf8\0\xf8\0\xcc\0\0\0\0\0\0\0\0\0\xf8\0\0\0\xf8\0\0\0\0\0\xf8\0\0\0\0\0\xf8\0\0\0\0\0\0\0\xf8\0\xf9\0\xf9\0\xf9\0\xf9\0\0\0\0\0\0\0\0\0\xf9\0\xf9\0\xf9\0\0\0\0\0\xf9\0\xf9\0\xf9\0\xf9\0\xf9\0\xf9\0\xf9\0\xf9\0\xf9\0\0\0\0\0\xf9\0\xf9\0\xf9\0\xf9\0\xf9\0\xf9\0\0\0\0\0\0\0\0\0\0\0\0\0\xf9\0\xf9\0\0\0\0\0\xf9\0\xf9\0\xf9\0\xf9\0\xf9\0\0\0\0\0\xf9\0\xf9\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xf9\0\xf9\0\0\0\xf9\0\0\0\0\0\xf9\0\xf9\0\xf9\0\0\0\xf9\0\xf9\0\xf9\0\xf9\0\xf9\0\0\0\0\0\0\0\0\0\0\0\0\0\xf9\0\0\0\xf9\0\0\0\xf9\0\xf9\0\xf9\0\0\0\0\0\0\0\0\0\xf9\0\xf9\0\0\0\xf9\0\xf9\0\xf9\0\xf9\0\xff\0\0\0\0\0\0\0\0\0\xf9\0\0\0\xf9\0\0\0\0\0\xf9\0\0\0\0\0\xf9\0\0\0\0\0\0\0\xf9\0\0\0\xfa\0\xfa\0\xfa\0\xfa\0\0\0\0\0\0\0\0\0\xfa\0\xfa\0\xfa\0\0\0\0\0\xfa\0\xfa\0\xfa\0\xfa\0\xfa\0\xfa\0\xfa\0\xfa\0\xfa\0\0\0\0\0\xfa\0\xfa\0\xfa\0\xfa\0\xfa\0\xfa\0\0\0\0\0\0\0\0\0\0\0\0\0\xfa\0\xfa\0\0\0\0\0\xfa\0\xfa\0\xfa\0\xfa\0\xfa\0\0\0\0\0\xfa\0\xfa\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xfa\0\xfa\0\0\0\xfa\0\0\0\0\0\xfa\0\xfa\0\xfa\0\0\0\xfa\0\xfa\0\xfa\0\xfa\0\xfa\0\0\0\0\0\0\0\0\0\0\0\0\0\xfa\0\0\0\xfa\0\0\0\xfa\0\xfa\0\xfa\0\0\0\0\0\0\0\0\0\xfa\0\xfa\0\0\0\xfa\0\xfa\0\xfa\0\xfa\0\x01\x01\0\0\0\0\0\0\0\0\xfa\0\0\0\xfa\0\0\0\0\0\xfa\0\0\0\0\0\xfa\0\0\0\0\0\0\0\xfa\0\0\0\xcc\0\xcc\0\xcc\0\xcc\0\0\0\0\0\0\0\0\0\xcc\0\xcc\0\xcc\0\0\0\0\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\0\0\0\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\0\0\0\0\0\0\0\0\0\0\0\0\xcc\0\xcc\0\0\0\0\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xcc\0\xcc\0\0\0\0\0\0\0\0\0\xcc\0\xcc\0\xcc\0\0\0\xcc\0\0\0\0\0\xcc\0\xcc\0\0\0\0\0\0\0\0\0\0\0\0\0\xcc\0\0\0\xcc\0\xcc\0\0\0\0\0\xcc\0\0\0\0\0\0\0\0\0\xcc\0\xcc\0\0\0\xcc\0\xcc\0\xcc\0\xcc\0\xf3\0\0\0\xcc\0\0\0\0\0\xcc\0\0\0\xcc\0\0\0\0\0\xcc\0\0\0\0\0\xcc\0\0\0\0\0\0\0\xcc\0\xff\0\xff\0\xff\0\xff\0\0\0\0\0\0\0\0\0\xff\0\xff\0\xff\0\0\0\0\0\xff\0\xff\0\0\0\xff\0\xff\0\xff\0\xff\0\xff\0\xff\0\0\0\0\0\xff\0\xff\0\xff\0\xff\0\xff\0\xff\0\0\0\0\0\0\0\0\0\0\0\0\0\xff\0\xff\0\0\0\0\0\xff\0\xff\0\xff\0\0\0\0\0\0\0\0\0\xff\0\xff\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xff\0\xff\0\0\0\xff\0\0\0\0\0\0\0\xff\0\xff\0\0\0\xff\0\0\0\0\0\xff\0\xff\0\0\0\0\0\0\0\0\0\0\0\0\0\xff\0\0\0\xff\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xff\0\xff\0\0\0\xff\0\xff\0\xff\0\xff\0\xf4\0\0\0\0\0\0\0\0\0\xff\0\0\0\xff\0\0\0\0\0\xff\0\0\0\0\0\xff\0\0\0\0\0\0\0\xff\0\0\0\x01\x01\x01\x01\x01\x01\x01\x01\0\0\0\0\0\0\0\0\x01\x01\x01\x01\x01\x01\0\0\0\0\x01\x01\x01\x01\0\0\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\0\0\0\0\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\0\0\0\0\0\0\0\0\0\0\0\0\x01\x01\x01\x01\0\0\0\0\x01\x01\x01\x01\x01\x01\0\0\0\0\0\0\0\0\x01\x01\x01\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\x01\x01\x01\0\0\x01\x01\0\0\0\0\0\0\x01\x01\x01\x01\0\0\x01\x01\0\0\0\0\x01\x01\x01\x01\0\0\0\0\0\0\0\0\0\0\0\0\x01\x01\0\0\x01\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\x01\x01\x01\0\0\x01\x01\x01\x01\x01\x01\x01\x01\0\x01\0\0\0\0\0\0\0\0\x01\x01\0\0\x01\x01\0\0\0\0\x01\x01\0\0\0\0\x01\x01\0\0\0\0\0\0\x01\x01\0\0\xf3\0\xf3\0\xf3\0\xf3\0\0\0\0\0\0\0\0\0\xf3\0\xf3\0\xf3\0\0\0\0\0\xf3\0\xf3\0\0\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\0\0\0\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\0\0\0\0\0\0\0\0\0\0\0\0\xf3\0\xf3\0\0\0\0\0\xf3\0\xf3\0\xf3\0\0\0\0\0\0\0\0\0\xf3\0\xf3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xf3\0\xf3\0\0\0\xf3\0\0\0\0\0\0\0\xf3\0\xf3\0\0\0\xf3\0\0\0\0\0\xf3\0\xf3\0\0\0\0\0\0\0\0\0\0\0\0\0\xf3\0\0\0\xf3\0\0\0\0\0\x05\x01\0\0\0\0\0\0\0\0\0\0\xf3\0\xf3\0\0\0\xf3\0\xf3\0\xf3\0\xf3\0\0\0\0\0\0\0\0\0\0\0\xf3\0\0\0\xf3\0\0\0\0\0\xf3\0\0\0\0\0\xf3\0\0\0\0\0\0\0\xf3\0\xf4\0\xf4\0\xf4\0\xf4\0\0\0\0\0\0\0\0\0\xf4\0\xf4\0\xf4\0\0\0\0\0\xf4\0\xf4\0\0\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\0\0\0\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\0\0\0\0\0\0\0\0\0\0\0\0\xf4\0\xf4\0\0\0\0\0\xf4\0\xf4\0\xf4\0\0\0\0\0\0\0\0\0\xf4\0\xf4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xf4\0\xf4\0\0\0\xf4\0\0\0\0\0\0\0\xf4\0\xf4\0\0\0\xf4\0\0\0\0\0\xf4\0\xf4\0\0\0\0\0\0\0\0\0\x04\x01\0\0\xf4\0\0\0\xf4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xf4\0\xf4\0\0\0\xf4\0\xf4\0\xf4\0\xf4\0\0\0\0\0\0\0\0\0\0\0\xf4\0\0\0\xf4\0\0\0\0\0\xf4\0\0\0\0\0\xf4\0\0\0\0\0\0\0\xf4\0\0\0\0\x01\0\x01\0\x01\0\x01\0\0\0\0\0\0\0\0\0\x01\0\x01\0\x01\0\0\0\0\0\x01\0\x01\0\0\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\0\0\0\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\x01\0\0\0\0\0\x01\0\x01\0\x01\0\0\0\0\0\0\0\0\0\x01\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\x01\0\0\0\x01\0\0\0\0d\x01\0\x01\0\x01\0\0\0\x01\0\0\0\0\0\x01\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\x01\0\0\0\x01\0\x01\0\x01\0\x01\0\0\0\0\0\0\0\0\0\0\0\x01\x05\x01\0\x01\0\0\x05\x01\0\x01\0\0\0\0\0\x01\x05\x01\x05\x01\x05\x01\0\x01\0\0\x05\x01\x05\x01\0\0\x05\x01\x05\x01\x05\x01\x05\x01\x05\x01\x05\x01\0\0\0\0\x05\x01\x05\x01\x05\x01\0\0\x05\x01\x05\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x05\x01\0\0\0\0\x05\x01\x05\x01\0\0\0\0\0\0\0\0\0\0\x05\x01\x05\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x05\x01\0\0\0\0\x05\x01\0\0\0\0\x02\x01\x05\x01\x05\x01\0\0\x05\x01\0\0\0\0\x05\x01\x05\x01\0\0\0\0\0\0\0\0\0\0\0\0\x05\x01\0\0\x05\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x05\x01\x05\x01\0\0\x05\x01\x05\x01\x05\x01\x05\x01\0\0\0\0\0\0\0\0\0\0\x05\x01\0\0\x05\x01\0\0\0\0\x05\x01\x04\x01\0\0\x05\x01\x04\x01\0\0\0\0\x05\x01\0\0\x04\x01\x04\x01\x04\x01\0\0\0\0\x04\x01\x04\x01\0\0\x04\x01\x04\x01\x04\x01\x04\x01\x04\x01\x04\x01\0\0\0\0\x04\x01\x04\x01\x04\x01\0\0\x04\x01\x04\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\x01\0\0\0\0\x04\x01\x04\x01\0\0\0\0\0\0\0\0\0\0\x04\x01\x04\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\x01c\x01\0\0\x04\x01\0\0\0\0\0\0\x04\x01\x04\x01\0\0\x04\x01\0\0\0\0\x04\x01\x04\x01\0\0\0\0\0\0\0\0\0\0\0\0\x04\x01\0\0\x04\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\x01\x04\x01\0\0\x04\x01\x04\x01\x04\x01\x04\x01\0\0\0\0\0\0\0\0\0\0\x04\x01d\x01\x04\x01\0\0d\x01\x04\x01\0\0\0\0\x04\x01d\x01\0\0d\x01\x04\x01\0\0d\x01d\x01\0\0d\x01d\x01d\x01d\x01d\x01d\x01\0\0\0\0d\x01d\x01d\x01\0\0d\x01d\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\x01\0\0\0\0d\x01d\x01\0\0\0\0\0\0\0\0\0\0d\x01d\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\t\x01\0\0\0\0\0\0d\x01\0\0\0\0d\x01\0\0\0\0\0\0d\x01d\x01\0\0d\x01\0\0\0\0d\x01d\x01\0\0\0\0\0\0\0\0\0\0\0\0d\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\x01d\x01\0\0d\x01d\x01d\x01d\x01\0\0\0\0\0\0\0\0\0\0d\x01\x02\x01d\x01\0\0\x02\x01d\x01\0\0\0\0d\x01\x02\x01\0\0\x02\x01d\x01\0\0\x02\x01\x02\x01\0\0\x02\x01\x02\x01\x02\x01\x02\x01\x02\x01\x02\x01\0\0\0\0\x02\x01\x02\x01\x02\x01\0\0\x02\x01\x02\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x02\x01\0\0\0\0\x02\x01\x02\x01\0\0\0\0\0\0\0\0\0\0\x02\x01\x02\x01\0\0\0\0\0\0\xed\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x02\x01\0\0\0\0\x02\x01\0\0\0\0\0\0\x02\x01\x02\x01\0\0\x02\x01\0\0\0\0\x02\x01\x02\x01\0\0\0\0\0\0\0\0\0\0\0\0\x02\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x02\x01\x02\x01\0\0\x02\x01\x02\x01\x02\x01\x02\x01\0\0\0\0\0\0\0\0\0\0\x02\x01c\x01\x02\x01\0\0c\x01\x02\x01\0\0\0\0\x02\x01c\x01\0\0c\x01\x02\x01\0\0c\x01c\x01\0\0c\x01c\x01c\x01c\x01c\x01c\x01\0\0\0\0c\x01c\x01c\x01\0\0c\x01c\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0c\x01\0\0\0\0c\x01c\x01\0\0\0\0\0\0\0\0\0\0c\x01c\x01\0\0\0\0\0\0\f\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0c\x01\0\0\0\0c\x01\0\0\0\0\0\0c\x01c\x01\0\0c\x01\0\0\0\0c\x01c\x01\0\0\0\0\0\0\0\0\0\0\0\0c\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0c\x01c\x01\0\0c\x01c\x01c\x01c\x01\0\0\t\x01\0\0\0\0\t\x01c\x01\0\0c\x01\0\0\t\x01c\x01\t\x01\0\0c\x01\t\x01\t\x01\0\0c\x01\t\x01\0\0\t\x01\t\x01\t\x01\0\0\0\0\t\x01\t\x01\t\x01\0\0\t\x01\t\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\t\x01\0\0\0\0\t\x01\t\x01\0\0\0\0\0\0\0\0\0\0\t\x01\t\x01\0\0\0\0\0\0\x0b\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\t\x01\0\0\0\0\t\x01\0\0\0\0\0\0\t\x01\t\x01\0\0\t\x01\0\0\0\0\t\x01\t\x01\0\0\0\0\0\0\0\0\0\0\0\0\t\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\t\x01\t\x01\0\0\t\x01\t\x01\t\x01\t\x01\0\0\xed\0\0\0\0\0\xed\0\t\x01\0\0\t\x01\0\0\xed\0\t\x01\xed\0\0\0\t\x01\xed\0\xed\0\0\0\t\x01\xed\0\0\0\xed\0\xed\0\xed\0\0\0\0\0\xed\0\xed\0\xed\0\0\0\xed\0\xed\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xed\0\0\0\0\0\xed\0\xed\0\0\0\0\0\0\0\0\0\0\0\xed\0\xed\0\0\0\0\0\0\0\n\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xed\0\0\0\0\0\xed\0\0\0\0\0\0\0\xed\0\xed\0\0\0\xed\0\0\0\0\0\xed\0\xed\0\0\0\0\0\0\0\0\0\0\0\0\0\xed\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xed\0\xed\0\0\0\xed\0\xed\0\xed\0\xed\0\0\0\0\0\0\0\0\0\0\0\xed\0\f\x01\xed\0\0\0\f\x01\xed\0\0\0\0\0\xed\0\f\x01\0\0\f\x01\xed\0\0\0\f\x01\f\x01\0\0\0\0\f\x01\0\0\f\x01\f\x01\f\x01\0\0\0\0\f\x01\f\x01\f\x01\0\0\f\x01\f\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\f\x01\0\0\0\0\f\x01\f\x01\0\0\0\0\0\0\0\0\0\0\f\x01\f\x01\0\0\0\0\0\0\xcb\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\f\x01\0\0\0\0\f\x01\0\0\0\0\0\0\f\x01\f\x01\0\0\f\x01\0\0\0\0\f\x01\f\x01\0\0\0\0\0\0\0\0\0\0\0\0\f\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\f\x01\f\x01\0\0\f\x01\f\x01\f\x01\f\x01\0\0\x0b\x01\0\0\0\0\x0b\x01\f\x01\0\0\f\x01\0\0\x0b\x01\f\x01\x0b\x01\0\0\f\x01\x0b\x01\x0b\x01\0\0\f\x01\x0b\x01\0\0\x0b\x01\x0b\x01\x0b\x01\0\0\0\0\x0b\x01\x0b\x01\x0b\x01\0\0\x0b\x01\x0b\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x0b\x01\0\0\0\0\x0b\x01\x0b\x01\0\0\0\0\0\0\0\0\0\0\x0b\x01\x0b\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x0b\x01\0\0y\x02\x0b\x01\0\0\0\0\0\0\x0b\x01\x0b\x01\0\0\x0b\x01t\0\0\0\x0b\x01\x0b\x01\0\0\0\0\0\0\0\0\0\0\0\0\x0b\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x0b\x01\x0b\x01\0\0\x0b\x01\x0b\x01\x0b\x01\x0b\x01\0\0\n\x01\0\0\0\0\n\x01\x0b\x01\0\0\x0b\x01\0\0\n\x01\x0b\x01\n\x01\0\0\x0b\x01\n\x01\n\x01\0\0\x0b\x01\n\x01\0\0\n\x01\n\x01\n\x01\0\0\0\0\n\x01\n\x01\n\x01\0\0\n\x01\n\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\n\x01\0\0\0\0\n\x01\n\x01\0\0\0\0\0\0\0\0\0\0\n\x01\n\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\n\x01\0\0\0\0\n\x01\0\0\0\0\0\0\n\x01\n\x01\0\0\n\x01\0\0\0\0\n\x01\n\x01\0\0\xee\0\0\0\0\0\0\0\0\0\n\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\n\x01\n\x01\0\0\n\x01\n\x01\n\x01\n\x01\0\0\0\0\0\0\0\0\0\0\n\x01\xcb\0\n\x01\0\0\xcb\0\n\x01\0\0\0\0\n\x01\xcb\0\0\0\xcb\0\n\x01\0\0\xcb\0\xcb\0\0\0\0\0\xcb\0\0\0\xcb\0\xcb\0\xcb\0\0\0\0\0\xcb\0\xcb\0\xcb\0\0\0\xcb\0\xcb\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xcb\0\0\0\0\0\xcb\0\xcb\0\0\0\0\0\0\0\0\0\0\0\xcb\0\xcb\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xcb\0\0\0\0\0\xcb\0\0\0\0\0\0\0\xcb\0\xcb\0\0\0\xcb\0\0\0\0\0\xcb\0\xcb\0\0\0\0\0\0\0\0\0\0\0\0\0\xcb\0,\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xcb\0\xcb\0\0\0\xcb\0\0\0\xcb\0\xcb\0\0\0\0\0\0\0\0\0\0\0\xcb\0\0\0\xcb\0\0\0\0\0\xcb\0\0\0y\x02\xcb\0y\x02y\x02y\x02\xcb\0\0\0\0\0y\x02t\0\0\0\0\0\0\0y\x02\0\0\0\0\0\0y\x02y\x02y\x02\0\0\0\0t\0\0\0\0\0\0\0y\x02y\x02y\x02y\x02\0\0\0\0\0\0\0\0\0\0t\0y\x02t\0t\0\0\0\0\0y\x02\0\0\0\0\0\0\0\0\0\0y\x02y\x02\x89\0t\0\x8a\0\x8b\0 \0\0\0\x8c\0\0\0\0\0\xb1\x01\xf3\x02\0\0y\x02\0\0\0\0y\x02y\x02\0\0y\x02y\x02y\x02t\0y\x02\x04\x02t\0y\x02y\x02\0\0t\0t\0\0\0\0\0\0\0y\x02\0\0t\0\x91\0\0\0\0\0\0\0\0\0\0\0t\0\x92\0y\x02y\x02\0\0y\x02y\x02y\x02y\x02\0\0\0\0y\x02t\0\x93\0\x94\0\0\0t\0t\0\0\0y\x02y\x02\0\0y\x02\0\0\xee\0\0\0y\x02\xee\0t\0\0\0\0\0t\0\xee\0\0\0\xee\0\0\0\0\0\xee\0\xee\0\0\0\0\0\xee\0\0\0\xee\0\xee\0\xee\0\0\0\0\0\xee\0\0\0\xee\0\0\0\xee\0\xee\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xee\0\0\0\0\0\xee\0\xee\0\0\0\0\0\0\0\0\0\0\0\xee\0\xee\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x05\x02\0\0\0\0\xee\0\0\0\0\0\xee\0\0\0\0\0\0\0\xee\0\xee\0\0\0\xee\0\0\0\0\0\xee\0\xee\0\0\0\0\0\0\0\0\0\0\0\0\0\xee\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xee\0\xee\0\0\0\xee\0\xee\0\xee\0\xee\0\0\0\0\0\0\0\0\0\0\0\xee\0\0\0\xee\0\0\0\0\0\xee\0\0\0,\x02\xee\0,\x02,\x02,\x02\xee\0\0\0\0\0,\x02\0\0\0\0\0\0\0\0,\x02\0\0\0\0\0\0,\x02,\x02,\x02\0\0\0\0\0\0\0\0\0\0\0\0,\x02,\x02,\x02,\x02\0\0\0\0\0\0\0\0\0\0\0\0,\x02\0\0\0\0\0\0\0\0,\x02\0\0\0\0\0\0\0\0\0\0,\x02,\x02-\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0,\x02\0\0\0\0,\x02\0\0\0\0,\x02,\x02,\x02\0\0,\x02\0\0\0\0,\x02,\x02\0\0\0\0\0\0\0\0\0\0\0\0,\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0,\x02,\x02\0\0,\x02,\x02,\x02,\x02\0\0\x04\x02\0\0\x04\x02\x04\x02\x04\x02\0\0\0\0\0\0\x04\x02,\x02\0\0\0\0,\x02\x04\x02\0\0\0\0,\x02\x04\x02\x04\x02\x04\x02\0\0\0\0\0\0\0\0\0\0\0\0\x04\x02\x04\x02\x04\x02\x04\x02\0\0\0\0\0\0\0\0\0\0\0\0\x04\x02\0\0\0\0\0\0\0\0\x04\x02\0\0\0\0\0\0\0\0\0\0\x04\x02\x04\x02\x03\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\x02\0\0\0\0\x04\x02\0\0\0\0\x04\x02\x04\x02\x04\x02\0\0\x04\x02\0\0\0\0\x04\x02\x04\x02\0\0\0\0\0\0\0\0\0\0\0\0\x04\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\x02\x04\x02\0\0\x04\x02\x04\x02\x04\x02\0\0\0\0\x05\x02\x04\x02\x05\x02\x05\x02\x05\x02\0\0\0\0\0\0\x05\x02\x04\x02\0\0\0\0\x04\x02\x05\x02\0\0\0\0\x04\x02\x05\x02\x05\x02\x05\x02\0\0\0\0\0\0\0\0\0\0\0\0\x05\x02\x05\x02\x05\x02\x05\x02\0\0\0\0\0\0\0\0\0\0\0\0\x05\x02\0\0\0\0\0\0\0\0\x05\x02\0\0\0\0\0\0\0\0\0\0\x05\x02\x05\x02\x01\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x05\x02\0\0\0\0\x05\x02\0\0\0\0\x05\x02\x05\x02\x05\x02\0\0\x05\x02\0\0\0\0\x05\x02\x05\x02\0\0\0\0\0\0\0\0\0\0\0\0\x05\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x05\x02\x05\x02\0\0\x05\x02\x05\x02\x05\x02\0\0\0\0\0\0\x05\x02-\x02\0\0-\x02-\x02-\x02\0\0\0\0\x05\x02-\x02\0\0\x05\x02\0\0\0\0-\x02\x05\x02\0\0\0\0-\x02-\x02-\x02\0\0\0\0\0\0\0\0\0\0\0\0-\x02-\x02-\x02-\x02\0\0\0\0\0\0\0\0\0\0\0\0-\x02\0\0\0\0\0\0\0\0-\x02\0\0\0\0\0\0\0\0\0\0-\x02-\x02\x02\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0-\x02\0\0\0\0-\x02\0\0\0\0-\x02-\x02-\x02\0\0-\x02\0\0\0\0-\x02-\x02\0\0\0\0\0\0\0\0\0\0\0\0-\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0-\x02-\x02\0\0-\x02-\x02-\x02-\x02\0\0\x03\x02\0\0\x03\x02\x03\x02\x03\x02\0\0\0\0\0\0\x03\x02-\x02\0\0\0\0-\x02\x03\x02\0\0\0\0-\x02\x03\x02\x03\x02\x03\x02\0\0\0\0\0\0\0\0\0\0\0\0\x03\x02\x03\x02\x03\x02\x03\x02\0\0\0\0\0\0\0\0\0\0\0\0\x03\x02\0\0\0\0\0\0\0\0\x03\x02\0\0\0\0\0\0\0\0\0\0\x03\x02\x03\x02\0\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x03\x02\0\0\0\0\x03\x02\0\0\0\0\x03\x02\x03\x02\x03\x02\0\0\x03\x02\0\0\0\0\0\0\x03\x02\0\0\0\0\0\0\0\0\0\0\0\0\x03\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x03\x02\x03\x02\0\0\x03\x02\x03\x02\x03\x02\x03\x02\0\0\x01\x02\0\0\x01\x02\x01\x02\x01\x02\0\0\0\0\xc1\0\x01\x02\x03\x02\0\0\0\0\x03\x02\x01\x02\0\0\0\0\x03\x02\x01\x02\x01\x02\x01\x02\0\0\0\0\0\0\0\0\0\0\0\0\x01\x02\x01\x02\x01\x02\x01\x02\0\0\0\0\0\0\0\0\0\0\0\0\x01\x02\0\0\0\0\0\0\0\0\x01\x02\0\0\0\0\0\0\0\0\0\0\x01\x02\x01\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0R\0\0\0\0\0\0\0\x01\x02\0\0\0\0\x01\x02\0\0\0\0\x01\x02\x01\x02\x01\x02\0\0\x01\x02\0\0\0\0\0\0\x01\x02\0\0\0\0\0\0\0\0\0\0\0\0\x01\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\x02\x01\x02\0\0\x01\x02\x01\x02\x01\x02\x01\x02\0\0\0\0\0\0\x02\x02\0\0\x02\x02\x02\x02\x02\x02\0\0\0\0\x01\x02\x02\x02\0\0\x01\x02\0\0\0\0\x02\x02\x01\x02\0\0\0\0\x02\x02\x02\x02\x02\x02\0\0\0\0\0\0\0\0\0\0\0\0\x02\x02\x02\x02\x02\x02\x02\x02\0\0\0\0\0\0\0\0\0\0\0\0\x02\x02\0\0\0\0\0\0\0\0\x02\x02\0\0\0\0\0\0\0\0\0\0\x02\x02\x02\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x02\x02\0\0\0\0\x02\x02\0\0\0\0\x02\x02\x02\x02\x02\x02\xe2\x02\x02\x02\0\0\0\0\0\0\x02\x02\0\0\0\0\0\0\0\0\0\0\0\0\x02\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x02\x02\x02\x02\0\0\x02\x02\x02\x02\x02\x02\x02\x02\0\0\0\x02\0\0\0\x02\0\x02\0\x02\0\0\0\0\0\0\0\x02\x02\x02\0\0\0\0\x02\x02\0\x02\0\0\0\0\x02\x02\0\x02\0\x02\0\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\x02\0\x02\0\x02\0\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\x02\0\0\0\0\0\0\0\0\0\x02\0\0\0\0\0\0\0\0\0\0\0\x02\0\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xc1\0\0\0\0\x02\xc1\0\0\0\0\x02\0\0\0\0\0\x02\0\x02\0\x02\0\0\0\x02\xc1\0\0\0\0\0\0\x02\0\0\0\0\xc1\0\0\0\0\0\x81\0\0\x02\0\0\0\0\xc1\0\xc1\0\xc1\0\xc1\0\0\0\0\0\0\0\0\0\0\x02\0\x02\0\0\0\x02\0\x02\0\x02\0\x02\xc1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0R\0\0\x02\0\0R\0\0\x02\0\0\0\0\0\0\0\x02\0\0\0\0\xc1\0\0\0R\0\xc1\0\0\0\0\0\0\0\xc1\0\xc1\0\0\0\0\0\0\0\0\0\0\0\xc1\0R\0R\0R\0R\0\0\0\0\0\xc1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0R\0\0\0\0\0\xc1\0\0\0\xc1\0\0\0\xc1\0\xc1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xc1\0R\0\0\0\xc1\0R\0\0\0\0\0\xc1\0R\0R\0\0\0\0\0\0\0\0\0\0\0R\0\0\0\0\0\0\0y\0\0\0\0\0R\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0R\0\0\0R\0\0\0R\0R\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0R\0\0\0\0\0R\0\0\0\0\0\xe2\x02R\0\0\0\xe2\x02\0\0\xe2\x02\xe2\x02\xe2\x02\xe2\x02\0\0\0\0\xe2\x02\xe2\x02\xe2\x02\0\0\0\0\0\0\0\0\0\0\xe2\x02\0\0\0\0\0\0\0\0\0\0\0\0\xe2\x02\0\0\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\0\0\xe2\x02\0\0\0\0\xe2\x02\0\0\xe2\x02\0\0\0\0\0\0\0\0\0\0\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\0\0\0\0\xe2\x02\xe2\x02\0\0\0\0\xe2\x02\xe2\x02\xe2\x02\0\0\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\0\0\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xa9\x01\xe2\x02\0\0\xe2\x02\xe2\x02\0\0\0\0\xe2\x02\xe2\x02\0\0\xe2\x02\0\0\xe2\x02\0\0\xe2\x02\xe2\x02\xe2\x02\0\0\xe2\x02\xe2\x02\xe2\x02\0\0\0\0\0\0\xe2\x02\0\0\0\0\xe2\x02\0\0\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\0\0\0\0\xe2\x02\t\0\n\0\x0b\0\0\0\0\0\0\0\f\0\r\0\x0e\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x0f\0\x10\0\x11\0\x12\0\x13\0\x14\0\x15\0\0\0\0\0\0\0\0\0\x16\0\0\0\x17\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x18\0\x19\0\x1a\0\0\0\x1b\0\x1c\0\x1d\0\x1e\0\x1f\0\0\0\0\0 \0!\0\0\0\0\0\"\0#\0$\0\0\0\0\0%\0&\0\0\0'\0(\0\0\0)\0\0\0*\0+\0\0\0,\0r\x02-\0\0\0\0\0\0\0.\0/\0\0\x000\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\0z\0\0\0\0\0\0\x002\0\0\0\0\0\0\0\0\x003\x004\x005\x006\0\t\0\n\0\x0b\0\0\x007\0\0\0\f\0\r\0\x0e\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x0f\0\x10\0\x11\0\x12\0\x13\0\x14\0\x15\0\0\0\0\0\0\0\0\0\x16\0\0\0\x17\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x18\0\x19\0\x1a\0\0\0\x1b\0\x1c\0\x1d\0\x1e\0\x1f\0\0\0\0\0 \0!\0\0\0\0\0\"\0#\0$\0\0\0\0\0%\0&\0\0\0'\0(\0\0\0)\0\0\0*\0+\0\0\0,\0\0\0-\0\0\0\0\0\0\0.\0/\0\x87\x010\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0z\0\0\0\0\0\0\x002\0\0\0\0\0\0\0\0\x003\x004\x005\x006\0\0\0\0\0\0\0\0\x007\0\0\0\0\0\0\0\0\0\t\0\n\0\x0b\0\0\0\0\0\0\0\f\0\r\0\x0e\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x0f\0\x10\0\x11\0\x12\0\x13\0\x14\0\x15\0\0\0\0\0\0\0\0\0\x16\0\0\0\x17\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\0\x18\0\x19\0\x1a\0\0\0\x1b\0\x1c\0\x1d\0\x1e\0\x1f\0\0\0\0\0 \0!\0\0\0\0\0\"\0#\0$\0\0\0\0\0%\0&\0\0\0'\0(\0\0\0)\0\0\0*\0+\0\0\0,\0\0\0-\0\0\0\0\0\0\0.\0/\0\0\x000\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0z\0\0\0\0\0\0\x002\0\0\0\0\0\0\0\x84\x003\x004\x005\x006\0\0\0\0\0r\x02\0\x007\0\0\0r\x02\0\0r\x02\0\0r\x02\0\0r\x02\0\0r\x02r\x02r\x02r\x02\0\0r\x02r\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0r\x02r\x02r\x02r\x02r\x02r\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0r\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0r\x02r\x02r\x02r\x02r\x02r\x02\0\0r\x02r\x02\0\0\0\0r\x02r\x02\0\0\0\0r\x02r\x02r\x02r\x02r\x02r\x02\0\0k\x02r\x02\0\0r\x02r\x02\0\0r\x02\0\0\0\0\0\0\0\0r\x02r\x02\0\0\0\0r\x02\0\0\0\0\0\0\0\0r\x02\0\0r\x02r\x02\0\0r\x02r\x02r\x02r\x02\0\0\0\0\0\0r\x02\0\0\0\0r\x02\0\0r\x02\0\0r\x02r\x02r\x02\0\0\x87\x01r\x02\0\0\0\0\x87\x01\0\0\x87\x01\0\0\x87\x01\0\0\x87\x01\0\0\x87\x01\0\0\x87\x01\x87\x01\x85\0\x87\x01\x87\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x87\x01\0\0\0\0\x87\x01\x87\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x87\x01\x87\x01\x87\x01\x87\x01\0\0\x87\x01\0\0\x87\x01\x87\x01\0\0\0\0\x87\x01\0\0\0\0\0\0\0\0\x87\x01\x87\x01\x87\x01\0\0\0\0\0\0\0\0\x87\x01\0\0\x87\x01\x80\0\x82\0\x87\x01\0\0\x82\0\x82\0\0\0\0\0\x87\x01\0\0\0\0\x87\x01\0\0\0\0\x82\0\x82\0\x87\x01\0\0\x87\x01\x87\x01\x82\0\x87\x01\x87\x01\0\0\x87\x01\0\0\0\0\x82\0\x87\x01\x82\0\x82\0\x87\x01\0\0\x87\x01\0\0\0\0\x87\x01\x87\x01\0\0\0\0\x87\x01\0\0\x82\0\0\0\0\0\0\0\0\0\0\0\x82\0\x82\0\x82\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x84\0\0\0\x82\0\x84\0\x84\0\x82\0\0\0\0\0\x82\0\x82\0\x82\0\0\0\x82\0\x84\0\x84\0\0\0\x82\0\0\0\0\0\x84\0\0\0\0\0\0\0\x82\0\0\0\0\0\x84\0\0\0\x84\0\x84\0\0\0\0\0\0\0\0\0\0\0\x82\0\0\0\x82\0\0\0\x82\0\x82\0\x84\0\0\0\0\0\0\0\0\0\0\0\x84\0\x84\0\xb2\0\0\0\x82\0\0\0\0\0\x82\0\0\0\0\0\0\0\0\0\0\0\0\0\x84\0\0\0\0\0\x84\0\0\0\0\0\x84\0\x84\0\x84\0\0\0\x84\0\0\0\0\0\0\0\x84\0\0\0\0\0k\x02\0\0\0\0k\x02\x84\0\0\0\0\0\0\0k\x02\0\0\0\0\0\0\0\0k\x02k\x02\0\0\x84\0\0\0\x84\0k\x02\x84\0\x84\0}\x02\0\0\0\0\0\0k\x02\0\0k\x02k\x02\x83\x02\0\0\x84\0\0\0\0\0\x84\0\0\0\0\0\0\0\0\0\x89\0k\x02\x8a\0\x8b\0 \0\0\0\x8c\0\0\0\0\0\xb1\x01G\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x85\0\0\0k\x02\x85\0\x85\0k\x02\0\0}\x02k\x02k\x02k\x02\0\0\0\0\x85\0\x85\0\0\0k\x02\x91\0\0\0\x85\0\0\0\0\0k\x02k\x02\x92\0\0\0\x85\0\0\0\x85\0\x85\0\0\0\xe0\x02\0\0\0\0\0\0k\x02\x93\0\x94\0\0\0k\x02k\x02\x85\0\0\0\0\0\0\0\0\0\0\0\x85\0\x85\0\0\0\0\0k\x02\0\0\0\0k\x02\0\0\0\0\0\0\0\0\x80\0\0\0\x85\0\x80\0\x80\0\x85\0\0\0\0\0\0\0\x85\0\x85\0\0\0\x85\0\x80\0\x80\0\0\0\x85\0\0\0\0\0\x80\0\0\0\0\0\0\0\x85\0\0\0\0\0\x80\0\xd8\x01\x80\0\x80\0\0\0\0\0\0\0\0\0\0\0\x85\0\0\0\x85\0\0\0\x85\0\x85\0\x80\0\0\0\0\0\0\0\0\0\0\0\x80\0\x80\0\0\0\x82\x02\x85\0\0\0\x82\x02\x85\0\0\0\0\0\0\0\0\0\0\0\0\0\x80\0\0\0\x82\x02\x80\0\0\0\0\0\0\0\x80\0\x80\0\0\0\x80\0\0\0\0\0\0\0\x80\0\x82\x02\x82\x02\x82\x02\x82\x02\0\0\0\0\x80\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x02\0\0\0\0\x80\0\0\0\x80\0\0\0\x80\0\x80\0\0\0\0\0\0\0\x06\x02\0\0\0\0\0\0\0\0\0\0\xb2\0\x80\0\x82\x02\xb2\0\x80\0\0\0y\x02\0\0\x82\x02\x82\x02\x82\x02\x06\x02\0\0\xb2\0\0\0y\x02\x82\x02\0\0\0\0\0\0\0\0\0\0\0\0\x82\x02\0\0\0\0\xb2\0\xb2\0\xb2\0\xb2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x02\0\0\x82\x02y\x02\xb2\0\0\0y\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x02y\x02\0\0\x82\x02\0\0\0\0\0\0\0\0\x83\x02\0\0\xb2\0\x83\x02\0\0\0\0\x1a\x02\0\0\xb2\0\xb2\0\xb2\0\0\0\0\0\x83\x02\0\0\x1a\x02\xb2\0\0\0\0\0\0\0\0\0\0\0\0\0\xb2\0\0\0\0\0\x83\x02\x83\x02\x83\x02\x83\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xb2\0\0\0\xb2\0\x1a\x02\x83\x02\0\0\x1a\x02\x07\x02\0\0\0\0\0\0\0\0\0\0\0\0\xb2\0\x1a\x02\0\0\xb2\0\0\0\0\0\0\0\0\0\0\0\xe0\x02\x83\x02\0\0\xe0\x02\0\0z\x02\0\0\x83\x02\x83\x02\x83\x02\0\0\0\0\0\0\xe0\x02z\x02\x83\x02\0\0\0\0\0\0\xe0\x02\0\0\0\0\x83\x02\0\0\0\0\0\0\xe0\x02\0\0\xe0\x02\xe0\x02\0\0\0\0\0\0\0\0\0\0\0\0\x83\x02\0\0\x83\x02z\x02\xe0\x02\xe0\x02z\x02\0\0\0\0\0\0\0\0\xe0\x02\xe0\x02\0\0\x83\x02z\x02\0\0\x83\x02\0\0\xd8\x01\0\0\0\0\xd8\x01\0\0\0\0\xe0\x02\x07\x02\xd8\x01\xe0\x02\0\0\0\0\0\0\xd8\x01\xe0\x02\0\0\xe0\x02f\0\0\0\xd8\x01\xe0\x02\0\0\0\0\0\0\0\0\0\0\xd8\x01\xe0\x02\xd8\x01\xd8\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe0\x02\0\0\xd8\x01\0\0\xe0\x02\xe0\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe0\x02\0\0\0\0\xe0\x02\0\0\0\0\xd8\x01\0\0\0\0\xd8\x01\0\0\0\0\xd8\x01\xd8\x01\xd8\x01\0\0\0\0\0\0\0\x004\x02\xd8\x01\x06\x02\0\0\0\0\x06\x02\0\0\0\0\xd8\x01\0\0\x06\x02\xd5\x01\0\0\0\0\0\0\x06\x02\0\0\0\0\0\0\x06\x02\xd8\x01\x06\x02\x06\x02\0\0\xd8\x01\xd8\x01\0\0\x06\x02\x06\x02\0\0\x06\x02\x06\x02\x06\x02\0\0\0\0\0\0\xd8\x01\0\0\x06\x02\xd8\x01\0\0\0\0\0\0\x06\x02\0\0\x06\x02\0\0\x06\x02\x06\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x06\x02\xe0\x02\0\0\x06\x02\0\0\0\0\x06\x02\0\0\0\0\x06\x02\x06\x02\x06\x02\0\0\0\0\0\0\0\0\x06\x02\x06\x02\0\0\0\0\x06\x02\0\0\0\0\x06\x02\x06\x02\xb1\x01\x06\x02\x06\x02\x06\x02\0\0\0\0\0\0\0\0\x06\x02\x06\x02\0\0\x06\x02\0\0\0\0\0\0\x06\x02\x06\x02\0\0\0\0\x04\x02\0\0\0\0\0\0\0\0\0\0\0\0\x07\x02\x06\x02\x06\x02\x07\x02\x06\x02\0\0\x06\x02\0\0\x07\x02\0\0\x06\x02\0\0\0\0\x07\x02\0\0\0\0\0\0\0\0\x06\x02\x07\x02\0\0\x06\x02\0\0\0\0P\0\0\0\x07\x02\0\0\x07\x02\x07\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x07\x02\0\0\0\0\x89\0\0\0\x8a\0\x8b\0 \0\0\0\x8c\0\0\0\0\0\x8d\0\x8e\0\0\0\0\0\0\0\0\0\0\0\0\0\x07\x02\0\0\xc0\x01\x07\x02\0\0\0\0\x07\x02\x07\x02\x07\x02\0\0\x8f\0\0\0\0\0\x07\x02\x07\x02\0\0\0\0\x07\x02\x90\0\x91\0\x07\x02\x07\x02\xe2\x02\x0b\x02\0\0\x07\x02\x92\0f\0\0\0\0\0\x07\x02\0\0\0\0\x07\x02\0\0\0\0\x07\x02\x07\x02\x93\0\x94\0f\0\x05\x02\0\0\x07\x02\0\0\x07\x02\x07\x02\0\0\0\0\x07\x02\0\0\0\0\x07\x02f\0\0\0f\0f\0\0\0\x07\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x07\x02\0\0\0\0\x07\x02\xb1\x01\0\0\x07\x02\x07\x02\x07\x02\0\0f\0\0\0\0\0\x07\x02\x07\x02\0\0\0\0\xd5\x01f\0\0\0\xd5\x01\x07\x02\0\0\0\0f\0\xd5\x01\0\0\0\0\0\0\0\0\xd5\x01f\0\0\0\x07\x02\0\0\0\0\xd5\x01\x07\x02\0\0\0\0\0\0\x07\x02\0\0\xd5\x01\0\0\xd5\x01\xd5\x01f\0\0\0\x07\x02\0\0\0\0\x07\x02\0\0\0\0\0\0\0\0\0\0\xd5\x01f\0\0\0\0\0f\0\xb2\x01\0\0\0\0\0\0\xe0\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xd5\x01\0\0\xe0\x02\xd5\x01\0\0\0\0\xd5\x01\xd5\x01\xd5\x01\0\0\0\0\0\0\0\0\xb1\x01\xd5\x01\xe0\x02\xb1\x01\xe0\x02\xe0\x02\0\0\0\0\xd5\x01\0\0\0\0\0\0\0\0\xb1\x01\0\0\0\0\0\0\xe0\x02\0\0\xb1\x01\xd5\x01\0\0\0\0\0\0\xd5\x01\xd5\x01\xb1\x01\0\0\xb1\x01\xb1\x01\0\0\xb4\x01\0\0\0\0\0\0a\0\xd5\x01\xe0\x02\0\0\xd5\x01\0\0\xb1\x01\0\0\0\0\0\0\xe0\x02\0\0\0\0\0\0\0\0P\0\xe0\x02\0\0P\0\0\0\0\0\0\0\0\0\xe0\x02\0\0\0\0\xb1\x01\0\0P\0\xb1\x01\0\0\0\0\0\0\xb1\x01\xb1\x01\0\0\0\0\0\0\0\0\xe0\x02\xb1\x01P\0P\0P\0P\0\0\0\0\0\xb1\x01\0\0\0\0\0\0\xe0\x02\0\0y\x02\xe0\x02\xb3\x01P\0\0\0\0\0\xb1\x01\0\0\0\0\0\0\xb1\x01\xb1\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe2\x02\xb1\x01P\0\xe2\x02\xb1\x01P\0\0\0\0\0\xe2\x02P\0P\0\0\0\0\0\xe2\x02\0\0\0\0P\0\0\0\0\0\xe2\x02\0\0\0\0\0\0P\0\0\0\0\0\xe2\x02\0\0\xe2\x02\xe2\x02\0\0e\0\0\0\0\0\0\0P\0\0\0P\0\0\0P\0P\0\xe2\x02\0\0\0\0\0\0\0\0\0\0\0\0\xb5\x01\0\0\0\0P\0\0\0\0\0P\0\0\0\0\0\0\0\0\0\0\0\xb1\x01\xe2\x02\0\0\xb1\x01\xe2\x02\0\0\0\0\0\0\xe2\x02\xe2\x02\0\0\0\0\0\0\xb1\x01\0\0\xe2\x02\0\0\0\0\0\0\xb1\x01\0\0\0\0\xe2\x02\0\0\0\0\0\0\xb1\x01\0\0\xb1\x01\xb1\x01\0\0\0\0\0\0\0\0\xe2\x02\0\0\0\0\0\0\xe2\x02\xe2\x02\0\0\xb1\x01\0\0\0\0\0\0\0\0\0\0\xb8\x01\0\0\0\0\xe2\x02\0\0\0\0\xe2\x02\0\0\0\0\0\0\0\0\0\0\xb2\x01\0\0\xb1\x01\xb2\x01\0\0\xb1\x01\0\0\0\0\0\0\xb1\x01\xb1\x01\0\0\0\0\xb2\x01\0\0\0\0\xb1\x01\0\0\0\0\xb2\x01\0\0\0\0\0\0\xb1\x01\0\0\0\0\xb2\x01\0\0\xb2\x01\xb2\x01\0\0\0\0\0\0\0\0\0\0\xb1\x01\0\0\0\0\xe2\x02\xb1\x01\xb1\x01\xb2\x01\0\0\0\0\0\0\0\0\0\0u\0\0\0\0\0\0\0\xb1\x01\0\0\0\0\xb1\x01\0\0\0\0\0\0\0\0\xb4\x01\0\0\xb2\x01\xb4\x01a\0\xb2\x01\0\0\0\0\0\0\xb2\x01\xb2\x01\0\0\0\0\xb4\x01\0\0\0\0\xb2\x01a\0\0\0\xb4\x01\0\0\0\0\0\0\xb2\x01\0\0\0\0\xb4\x01\0\0\xb4\x01\xb4\x01a\0\0\0a\0a\0\0\0\xb2\x01\0\0\0\0\xa8\x01\xb2\x01\xb2\x01\xb4\x01\0\0\0\0\0\0a\0\0\0\0\0\0\0\0\0\0\0\xb2\x01\0\0\0\0\xb2\x01\0\0\0\0\0\0\0\0\xb3\x01\0\0\xb4\x01\xb3\x01\0\0\xb4\x01a\0\0\0\0\0\xb4\x01\xb4\x01\0\0\0\0\xb3\x01a\0\0\0\xb4\x01\0\0\0\0\xb3\x01a\0\0\0\0\0\xb4\x01\0\0\0\0\xb3\x01a\0\xb3\x01\xb3\x01\0\0\0\0\0\0\0\0\0\0\xb4\x01\0\0\0\0\xe0\x02\xb4\x01\xb4\x01\xb3\x01\0\0a\0\0\0\0\0\0\0\0\0\0\0\0\0e\0\xb4\x01\0\0\0\0\xb4\x01a\0\0\0\0\0a\0\0\0\0\0\xb3\x01\0\0e\0\xb3\x01\0\0\0\0\xb5\x01\xb3\x01\xb3\x01\xb5\x01\0\0\0\0\0\0\0\0\xb3\x01e\0\0\0e\0e\0\xb5\x01\0\0\xb3\x01\xe0\x02\0\0\0\0\xb5\x01\0\0\0\0\0\0\0\0e\0\0\0\xb5\x01\xb3\x01\xb5\x01\xb5\x01\0\0\xb3\x01\xb3\x01\0\0\0\0\0\0\0\0\0\0E\0\0\0\0\0\xb5\x01\0\0\xb3\x01e\0\0\0\xb3\x01\0\0\0\0\0\0\0\0\0\0e\0\0\0\0\0\0\0\0\0\0\0e\0\xb8\x01\0\0\xb5\x01\xb8\x01\0\0\xb5\x01e\0\0\0\0\0\xb5\x01\xb5\x01\0\0\0\0\xb8\x01\0\0\0\0\xb5\x01\0\0\0\0\xb8\x01\0\0\0\0e\0\xb5\x01F\0\0\0\xb8\x01\0\0\xb8\x01\xb8\x01\0\0\0\0\0\0\0\0e\0\xb5\x01\0\0e\0\0\0\xb5\x01\xb5\x01\xb8\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe2\x02\xb5\x01\0\0\0\0\xb5\x01\0\0\0\0\0\0\xe2\x02u\0\0\0\xb8\x01\0\0\xe2\x02\xb8\x01\0\0\0\0\0\0\xb8\x01\xb8\x01\0\0\0\0u\0\0\0\xd5\x01\xb8\x01\xe2\x02\0\0\xe2\x02\xe2\x02\0\0\0\0\xb8\x01\xd5\x01\0\0u\0\0\0u\0u\0\0\0\0\0\xe2\x02\0\0\0\0\xb8\x01\0\0\0\0\0\0\xb8\x01\xb8\x01u\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xa8\x01\xb8\x01\xe2\x02\0\0\xb8\x01\xe2\x02\0\0\0\0\0\0\xe2\x02\xe2\x02u\0\0\0\xa8\x01u\0\0\0\xe2\x02\0\0u\0u\0\0\0\0\0\0\0\xe2\x02\0\0u\0\xa8\x01\0\0\xa8\x01\xa8\x01\0\0\0\0u\0\0\0\0\0\xe2\x02\0\0\0\0\0\0\xe2\x02\xe2\x02\xa8\x01\0\0\0\0u\0\0\0\0\0\0\0u\0u\0\0\0\xe2\x02\xe0\x02\0\0\xe2\x02\0\0\0\0\0\0\0\0\xe0\x02u\0\xa8\x01\xe0\x02u\0\xa8\x01\0\0\0\0\0\0\xa8\x01\xa8\x01\0\0\0\0\xe0\x02\0\0{\0\xa8\x01\0\0\0\0\0\0\0\0\0\0\0\0\xa8\x01\0\0\0\0\xe0\x02\0\0\xe0\x02\xe0\x02\0\0\0\0\0\0\0\0\0\0\xa8\x01\0\0|\0\0\0\xa8\x01\xa8\x01\xe0\x02\0\0\0\0\0\0\xe0\x02\0\0\0\0\0\0\0\0\0\0\xa8\x01\0\0\0\0\xa8\x01\0\0\0\0\0\0\xe0\x02\0\0\0\0\xe0\x02\0\0\0\0\xe0\x02\0\0\0\0E\0\0\0\xe0\x02E\0\xe0\x02\0\0\xe0\x02\xe0\x02\xe0\x02\0\0\0\0\0\0\0\0E\0\0\0\xe0\x02\0\0\0\0\0\0\xe0\x02\0\0\0\0\0\0\0\0\0\0\0\0E\0\xe0\x02E\0E\0\0\0\xe0\x02\xe0\x02\0\0\0\0\0\0\0\0\0\0\0\0\xe0\x02E\0E\0\xe0\x02\xe0\x02\0\0F\0\xe0\x02\xe0\x02F\0\xe2\x02\0\0\0\0\0\0\xe0\x02\0\0\0\0\0\0\0\0F\0\xe2\x02\xe0\x02E\0\0\0\0\0E\0\0\0\0\0\0\0E\0E\0\0\0F\0\xe0\x02F\0F\0E\0\xe0\x02\xe0\x02\0\0\0\0\0\0\0\0E\0\0\0\0\0F\0F\0\0\0\xe0\x02\0\0\0\0\xe0\x02\0\0\0\0E\0\xd5\x01\0\0\0\0E\0E\0\0\0\0\0\0\0\xd5\x01\xd5\x01\0\0F\0\0\0\xd5\x01F\0E\0\0\0\0\0F\0F\0\0\0\0\0\xd5\x01\0\0\0\0F\0\xd5\x01\0\0\xd5\x01\xd5\x01\0\0\xe0\x02F\0\0\0\0\0\xd5\x01\0\0\xd5\x01\xd5\x01\0\0\0\0\xd5\x01\0\0\0\0F\0\0\0\0\0\0\0F\0F\0\xd5\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0F\0\xd5\x01\0\0\0\0\xd5\x01\0\0\0\0\xd5\x01\xd5\x01\xd5\x01\xd5\x01\0\0\0\0\xd5\x01\0\0\xd5\x01\xd5\x01\xd5\x01\xd5\x01\0\0\0\x006\0\xd5\x01\0\0\xd5\x01\0\0\0\0\xe0\x02\0\0\0\0\xe0\x02\xd5\x01\0\0\0\0\xd5\x01\0\0\0\0\0\0\xd5\x01\xd5\x01\xe0\x02\0\0\0\0\xd5\x01\0\0\0\0\0\0\xd5\x01\xd5\x01{\0\xd5\x01\0\0{\0\xe0\x02\0\0\xe0\x02\xe0\x02\0\0\0\0\xd5\x018\0\0\0{\0\0\0\0\0\0\0\0\0\xe0\x02\xe0\x02\0\0\0\0|\0\0\0\0\0|\0{\0\0\0{\0{\0\0\0\0\0\0\0\0\0\0\0|\0\0\0\0\0\0\0\xe0\x02\0\0{\0\xe0\x02\0\0\0\0\0\0\0\0\xe0\x02|\0\0\0|\0|\0\0\0\xe0\x02\0\0<\0\0\0\0\0\0\0\0\0\xe0\x02{\0\0\0|\0{\0\0\0\0\0\0\0{\0{\0\0\0\0\0\xe0\x02\0\0\0\0{\0\xe0\x02\xe0\x02\0\0\0\0\0\0\0\0{\0|\0\0\0\0\0|\0\0\0\xe0\x02\0\0|\0|\0\0\0\0\0{\0\0\0\0\0|\0{\0{\0?\0\xe2\x02\0\0\0\0|\0\0\0\0\0\0\0\0\0\xe2\x02{\0\xe2\x02\0\0\0\0\xe2\x02\0\0|\0\0\0\0\0\0\0|\0|\0@\0\0\0\xe2\x02\0\0\0\0\xe2\x02\0\0\xe2\x02\xe2\x02\xe0\x02|\0\0\0\0\0\0\0\0\0\xe2\x02\0\0\xe2\x02\xe2\x02\0\0\xe2\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe2\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe2\x02\0\0\0\0\xe2\x02\0\0\0\0\0\0\xe2\x02\xe2\x02\0\0\xe2\x02\0\0\0\0\xe2\x02\xe2\x02\0\0\xe0\x02\xe2\x02\xe2\x02\xe0\x02\0\0\xe2\x02\0\0\0\0\xe2\x02\0\0\0\0\0\0\0\0\xe0\x02\0\0\xe2\x02\0\0\xe2\x02\0\0\0\0\0\0\xe2\x02\xe2\x02\0\0\0\0\0\0\xe0\x02\xe2\x02\xe0\x02\xe0\x02\0\0\xe2\x02\xe2\x02\xe2\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe0\x02\0\0\xe2\x02\0\0'\x02\0\0'\x02'\x02'\x026\0'\x02\0\0\0\0'\x02'\x02\0\0\0\0\0\0\0\0\0\0\xe0\x02\0\x006\0\xe0\x02\0\0\0\0\0\0\0\0\xe0\x02\0\0\0\0'\x02\0\0\0\0\xe0\x026\0\0\x006\x006\0'\x02'\x02\xe0\x02\0\0\0\0\0\0\0\0\0\0'\x028\0\0\x006\0\0\0\0\0\xe0\x02\0\0\0\0\0\0\xe0\x02\xe0\x02'\x02'\x028\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe0\x026\0\0\0\0\x006\x008\0\0\x008\x008\x006\0\0\0\0\0\0\0\0\0\0\x006\0\0\0\0\0\0\0\0\x008\0\0\x006\0<\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x006\0\0\0<\0\0\x006\x006\x008\0\0\0\0\x008\0\0\0\0\0\0\0\0\x008\0<\x006\0<\0<\0\0\x008\0\0\0\0\0\0\0\0\0\0\0\0\x008\0\0\0\0\0<\0\0\0\0\0\0\0?\0\0\0\0\0\0\0\0\x008\0\0\0\0\0\0\x008\x008\0\0\0\0\0?\0\0\0\0\0<\0\0\0\0\0<\0\0\x008\0@\0\0\0<\0\0\0?\0\0\0?\0?\0<\0\xe0\x02\0\0\0\0\0\0@\0\0\0<\0\0\0\0\0\0\0?\0\0\0\0\0\xe0\x02\0\0\0\0\0\0@\0<\0@\0@\0\0\0<\0<\0\0\0\0\0\xe0\x02\0\0\xe0\x02\xe0\x02?\0\0\0@\0?\0<\0\0\0\0\0\0\0?\0\0\0\0\0\xe0\x02\0\0\0\0?\0\0\0\0\0\0\0\0\0\0\0\0\0?\0@\0\0\0\0\0@\0\0\0\0\0\0\0\0\0@\0\xe0\x02\0\0?\0\xe0\x02\0\0@\0?\0?\0\xe0\x02\0\0\0\0\0\0@\0\0\0\xe0\x02\0\0\0\0\0\0?\0\0\0\0\0\xe0\x02\0\0\0\0@\0\0\0\0\0\0\0@\0@\0\0\0\0\0\0\0\xe0\x02\0\0\0\0\0\0\xe0\x02\xe0\x02\xdb\x02@\0\0\0\0\0\0\0\xdb\x02\xdb\x02\xdb\x02\xdb\x02\0\0\xe0\x02\xdb\x02\xdb\x02\xdb\x02\xdb\x02\0\0\0\0\0\0\0\0\xdb\x02\0\0\0\0\0\0\0\0\0\0\0\0\xdb\x02\0\0\xdb\x02\xdb\x02\xdb\x02\xdb\x02\xdb\x02\xdb\x02\xdb\x02\0\0\0\0\0\0\0\0\xdb\x02\0\0\xdb\x02\0\0\0\0\0\0\0\0\0\0\xdb\x02\xdb\x02\xdb\x02\xdb\x02\xdb\x02\xdb\x02\xdb\x02\xdb\x02\xdb\x02\xdb\x02\xdb\x02\0\0\0\0\xdb\x02\xdb\x02\0\0\0\0\xdb\x02\xdb\x02\xdb\x02\xdb\x02\0\0\xdb\x02\xdb\x02\xdb\x02\xdb\x02\xdb\x02\0\0\xdb\x02\0\0\xdb\x02\xdb\x02\0\0\xdb\x02\0\0\xdb\x02\xdb\x02\0\0\0\0\xdb\x02\xdb\x02\0\0\xdb\x02\0\0\xdb\x02\0\0\0\0\xdb\x02\xdb\x02\0\0\0\0\xdb\x02\xdb\x02\0\0\0\0\0\0\xdb\x02\0\0\0\0\xdb\x02\0\0\xdb\x02\xdb\x02\xdb\x02\xdb\x02\xdb\x02\xdb\x02\0\0\0\0\xdb\x02#\x01$\x01%\x01\0\0\0\0\t\0\n\0&\x01\0\0'\x01\0\0\f\0\r\0\0\0\0\0(\x01)\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0*\x01\0\0\0\0\x11\0\x12\0\x13\0\x14\0\x15\0\0\0+\x01\0\0\0\0\x16\0\0\0\0\0,\x01-\x01.\x01/\x010\x01\0\0\0\0\x18\0\x19\0\x1a\0\0\0\x1b\0\x1c\0\x1d\0\x1e\0\x1f\0\0\0\0\0 \0\0\x001\x01\0\0\"\0#\0$\0\0\0\0\0\0\0&\0\0\x002\x013\x01\0\x004\x01\0\0*\0+\0\0\0,\0\0\0\0\0\0\x005\x016\x017\x018\x019\x01:\x01\0\0\0\0\0\0\0\0\0\0\0\0;\x01\0\0\0\0\0\0<\x01\0\0=\x012\0\0\0\0\0\0\0\0\x003\x004\0\0\x006\0#\x01$\x01%\x01\0\x007\0\t\0\n\0&\x01\0\0'\x01\0\0\f\0\r\0\0\0\0\0\0\0)\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0*\x01\0\0\0\0\x11\0\x12\0\x13\0\x14\0\x15\0\0\0+\x01\0\0\0\0\x16\0\0\0\0\0,\x01-\x01.\x01/\x010\x01\0\0\0\0\x18\0\x19\0\x1a\0\0\0\x1b\0\x1c\0\x1d\0\x1e\0\x1f\0\0\0\0\0 \0\0\x001\x01\0\0\"\0#\0$\0\0\0\0\0\0\0&\0\0\x002\x013\x01\0\x004\x01\0\0*\0+\0\0\0,\0\0\0\0\0\0\x005\x016\x017\x018\x019\x01:\x01\0\0\0\0\0\0\0\0\0\0\0\0;\x01\0\0\0\0\0\0<\x01\0\0=\x012\0\0\0\0\0\0\0\0\x003\x004\0\0\x006\0#\x01$\x01%\x01\0\x007\0\t\0\n\0&\x01\0\0'\x01\0\0\f\0\r\0\0\0\0\0\0\0)\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0*\x01\0\0\0\0\x11\0\x12\0\x13\0\x14\0\x15\0\0\0+\x01\0\0\0\0\x16\0\0\0\0\0,\x01-\x01.\x01/\x010\x01\0\0\0\0\x18\0\x19\0\x1a\0\0\0\x1b\0\x1c\0\x1d\0\x1e\0\x1f\0\0\0\0\0 \0\0\x001\x01\0\0\"\0#\0$\0\0\0\0\0\0\0&\0\0\x002\x013\x01\0\0Z\x03\0\0*\0+\0\0\0,\0\0\0\0\0\0\x005\x016\x017\x018\x019\x01:\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0<\x01\0\0=\x012\0\0\0\0\0\0\0\xe2\x023\x004\0\0\x006\0\xe2\x02\xe2\x02\xe2\x02\xe2\x027\0\0\0\xe2\x02\xe2\x02\0\0\0\0\0\0\0\0\0\0\0\0\xe2\x02\0\0\0\0\0\0\0\0\0\0\0\0\xe2\x02\0\0\xe2\x02\0\0\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\0\0\0\0\0\0\0\0\xe2\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\0\0\0\0\xe2\x02\xe2\x02\0\0\0\0\xe2\x02\xe2\x02\xe2\x02\0\0\0\0\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\0\0\0\0\0\0\xe2\x02\xe2\x02\0\0\xe2\x02\0\0\0\0\xe2\x02\0\0\0\0\xe2\x02\xe2\x02\0\0\xe2\x02\0\0\xe2\x02\0\0\0\0\0\0\xe2\x02\0\0\0\0\0\0\xe2\x02\0\0\0\0\0\0\xe2\x02\0\0\0\0\xe2\x02\0\0\xe2\x02\xe2\x02\0\0\xe2\x02\xe2\x02\xe2\x02^\x02\0\0\xe2\x02\0\0\0\0\xa5\x02\xa5\x02\xa5\x02\0\0\0\0\0\0\xa5\x02\xa5\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xa5\x02\xa5\x02\xa5\x02\xa5\x02\xa5\x02\0\0\0\0\0\0\0\0\xa5\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xa5\x02\xa5\x02\xa5\x02\0\0\xa5\x02\xa5\x02\xa5\x02\xa5\x02\xa5\x02\0\0\0\0\xa5\x02\0\0\0\0\0\0\xa5\x02\xa5\x02\xa5\x02\0\0\0\0\0\0\xa5\x02\0\0\xa5\x02\xa5\x02\0\0\0\0\0\0\xa5\x02\xa5\x02\0\0\xa5\x02\0\0\0\0\0\0\0\0\0\0\xa5\x02\xa5\x02_\x02\xa5\x02\0\0\0\0\0\0\xa6\x02\xa6\x02\xa6\x02^\x02\0\0\0\0\xa6\x02\xa6\x02\0\0\0\0\xa5\x02\0\0\0\0\0\0\0\0\xa5\x02\xa5\x02\0\0\xa5\x02\0\0\0\0\0\0\0\0\xa5\x02\0\0\xa6\x02\xa6\x02\xa6\x02\xa6\x02\xa6\x02\0\0\0\0\0\0\0\0\xa6\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xa6\x02\xa6\x02\xa6\x02\0\0\xa6\x02\xa6\x02\xa6\x02\xa6\x02\xa6\x02\0\0\0\0\xa6\x02\0\0\0\0\0\0\xa6\x02\xa6\x02\xa6\x02\0\0\0\0\0\0\xa6\x02\0\0\xa6\x02\xa6\x02\0\0\0\0\0\0\xa6\x02\xa6\x02\0\0\xa6\x02\0\0\0\0\0\0\0\0\0\0\xa6\x02\xa6\x02\\\x02\xa6\x02\0\0\0\0\0\0\xa7\x02\xa7\x02\xa7\x02_\x02\0\0\0\0\xa7\x02\xa7\x02\0\0\0\0\xa6\x02\0\0\0\0\0\0\0\0\xa6\x02\xa6\x02\0\0\xa6\x02\0\0\0\0\0\0\0\0\xa6\x02\0\0\xa7\x02\xa7\x02\xa7\x02\xa7\x02\xa7\x02\0\0\0\0\0\0\0\0\xa7\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xa7\x02\xa7\x02\xa7\x02\0\0\xa7\x02\xa7\x02\xa7\x02\xa7\x02\xa7\x02\0\0\0\0\xa7\x02\0\0\0\0\0\0\xa7\x02\xa7\x02\xa7\x02\0\0\0\0\0\0\xa7\x02\0\0\xa7\x02\xa7\x02\0\0\0\0\0\0\xa7\x02\xa7\x02\0\0\xa7\x02\0\0\0\0\0\0\0\0\0\0\xa7\x02\xa7\x02]\x02\xa7\x02\0\0\0\0\0\0\xa8\x02\xa8\x02\xa8\x02\\\x02\0\0\0\0\xa8\x02\xa8\x02\0\0\0\0\xa7\x02\0\0\0\0\0\0\0\0\xa7\x02\xa7\x02\0\0\xa7\x02\0\0\0\0\0\0\0\0\xa7\x02\0\0\xa8\x02\xa8\x02\xa8\x02\xa8\x02\xa8\x02\0\0\0\0\0\0\0\0\xa8\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xa8\x02\xa8\x02\xa8\x02\0\0\xa8\x02\xa8\x02\xa8\x02\xa8\x02\xa8\x02\0\0\0\0\xa8\x02\0\0\0\0\0\0\xa8\x02\xa8\x02\xa8\x02\0\0\0\0\0\0\xa8\x02\0\0\xa8\x02\xa8\x02\0\0\0\0\0\0\xa8\x02\xa8\x02\0\0\xa8\x02\0\0\0\0\0\0\0\0\0\0\xa8\x02\xa8\x02\0\0\xa8\x02\0\0\0\0\0\0\0\0\0\0\0\0]\x02\xeb\0\xec\0\xed\0\0\0\0\0\0\0\xa8\x02\0\0\xee\0\0\0\xef\0\xa8\x02\xa8\x02\0\0\xa8\x02\0\0\xf0\0\xf1\0\xf2\0\xa8\x02\0\0\xf3\0\xf4\0\xf5\0\0\0\xf6\0\xf7\0\xf8\0\0\0\xf9\0\xfa\0\xfb\0\xfc\0\0\0\0\0\0\0\xfd\0\xfe\0\xff\0\0\0\0\0\0\0\0\0\0\0\0\x01\x01\x01\0\0\0\0\0\0\0\0\x02\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x03\x01\x04\x01\0\0\0\0\0\0\0\0\x05\x01\x06\x01\0\0\0\0\0\0\x07\x01\b\x01\0\0\t\x01\0\0\n\x01\x0b\x01\f\x01\0\0\r\x01\0\0\0\0\0\0\0\0\0\0\x0e\x01\0\0\0\0\0\0\0\0\x0f\x01\0\0\0\0\0\0\0\0\0\0\x10\x01\b\x02\0\0\x11\x01\x12\x01\b\x02\x13\x01\x14\x01\x15\x01\x16\x01\x17\x01\0\0\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\0\0\b\x02\0\0\b\x02\0\0\0\0\xf5\x01\0\0\0\0\0\0\b\x02\b\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\b\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\b\x02\b\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\b\x02\0\0\0\0\0\0\b\x02\0\0\b\x02\b\x02\b\x02\0\0\b\x02\0\0\0\0\b\x02\0\0\0\0\0\0\0\0#\x01$\x01%\x01\0\0\0\0\0\0\n\0\xe1\x01\0\0'\x01\0\0\0\0\r\0\xf5\x01\b\x02\xe2\x01)\x01\0\0\b\x02\0\0\b\x02\0\0\0\0\b\x02\0\0\0\0\0\0*\x01\xa2\0\0\0\x11\0\x12\0\b\x02\0\0\b\x02\0\0+\x01\0\0\0\0\0\0\0\0\0\0,\x01-\x01.\x01/\x010\x01\0\0\0\0\x18\0\x19\0\x1a\0\0\0\xa3\0\xa4\0\0\0\xa5\0\xa6\0\0\0\0\0 \0\0\x001\x01\0\0\0\0\xa7\0\xa8\0\0\0\0\0\0\0\0\0\0\0\xe3\x01\xe4\x01\0\0\xe5\x01\0\0*\0\0\0\0\0\0\0\0\0\0\0\0\x005\x016\x01\xe6\x01\xe7\x019\x01\xe8\x01\0\0\0\0\0\0\0\0\0\0\0\0;\x01\0\0\0\0\xab\0<\x01\0\0=\x012\0\0\0\0\0\0\0\0\x003\0\0\0\0\x006\0\xac\0#\x01$\x01%\x01\0\0\0\0\0\0\n\0\xe1\x01\0\0'\x01\0\0\0\0\r\0\0\0\0\0\0\0)\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0*\x01\xa2\0\0\0\x11\0\x12\0\0\0\0\0\0\0\0\0+\x01\0\0\0\0\0\0\0\0\0\0,\x01-\x01.\x01/\x010\x01\0\0\0\0\x18\0\x19\0\x1a\0\0\0\xa3\0\xa4\0\0\0\xa5\0\xa6\0\0\0\0\0 \0\0\x001\x01\0\0\0\0\xa7\0\xa8\0\0\0\0\0\0\0\0\0\0\0\xe3\x01\xe4\x01\0\0\xe5\x01\0\0*\0\0\0\0\0\0\0\0\0\0\0\0\x005\x016\x01\xe6\x01\xe7\x019\x01\xe8\x01\0\0\0\0\0\0\0\0\0\0\0\0;\x01\0\0\0\0\xab\0<\x01\0\0=\x012\0\0\0\0\0\0\0\0\x003\0\0\0\x01\x036\0\xac\0#\x01$\x01%\x01\0\0\0\0\0\0\n\0\xe1\x01\0\0'\x01\0\0\0\0\r\0\0\0\0\0\0\0)\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0*\x01\xa2\0\0\0\x11\0\x12\0\0\0\0\0\0\0\0\0+\x01\0\0\0\0\0\0\0\0\0\0,\x01-\x01.\x01/\x010\x01\0\0\0\0\x18\0\x19\0\x1a\0\0\0\xa3\0\xa4\0\0\0\xa5\0\xa6\0\0\0\0\0 \0\0\x001\x01\0\0\0\0\xa7\0\xa8\0\0\0\0\0\0\0\0\0\0\0\xe3\x01\xe4\x01\0\0\xe5\x01\0\0*\0\0\0\0\0\0\0\0\0\0\0\0\x005\x016\x01\xe6\x01\xe7\x019\x01\xe8\x01\0\0\0\0\0\0\0\0\0\0\0\0;\x01\0\0\0\0\xab\0<\x01\0\0=\x012\0\0\0\0\0\0\0\0\x003\0\0\0\xca\x036\0\xac\0#\x01$\x01%\x01\0\0\0\0\0\0\n\0\xe1\x01\0\0'\x01\0\0\0\0\r\0\0\0\0\0\0\0)\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0*\x01\xa2\0\0\0\x11\0\x12\0\0\0\0\0\0\0\0\0+\x01\0\0\0\0\0\0\0\0\0\0,\x01-\x01.\x01/\x010\x01\0\0\0\0\x18\0\x19\0\x1a\0\0\0\xa3\0\xa4\0\0\0\xa5\0\xa6\0\0\0\0\0 \0\0\x001\x01\0\0\0\0\xa7\0\xa8\0\0\0\0\0\0\0\0\0\0\0\xe3\x01\xe4\x01\0\0\xe5\x01\0\0*\0\0\0\0\0\0\0\0\0\0\0\0\x005\x016\x01\xe6\x01\xe7\x019\x01\xe8\x01\0\0\0\0\0\0\0\0\0\0\0\0;\x01\0\0\0\0\xab\0<\x01\0\0=\x012\0\0\0\0\0\0\0\0\x003\0\0\0\b\x046\0\xac\0#\x01$\x01%\x01\0\0\0\0\0\0\n\0\xe1\x01\0\0'\x01\0\0\0\0\r\0\0\0\0\0\0\0)\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0*\x01\xa2\0\0\0\x11\0\x12\0\0\0\0\0\0\0\0\0+\x01\0\0\0\0\0\0\0\0\0\0,\x01-\x01.\x01/\x010\x01\0\0\0\0\x18\0\x19\0\x1a\0\0\0\xa3\0\xa4\0\0\0\xa5\0\xa6\0\0\0\0\0 \0\0\x001\x01\0\0\xdd\x02\xa7\0\xa8\0\0\0\0\0\0\0\n\0\0\0\xe3\x01\xe4\x01\0\0\xe5\x01\r\0*\0\0\0\0\0\0\0\0\0\0\0\0\x005\x016\x01\xe6\x01\xe7\x019\x01\xe8\x01\0\0\0\0\xa2\0\0\0\x11\0\x12\0;\x01\0\0\0\0\xab\0<\x01\0\0=\x012\0\0\0\0\0\0\0\0\x003\0\0\0\0\x006\0\xac\0\x18\0\x19\0\x1a\0\0\0\xa3\0\xa4\0\0\0\xa5\0\xa6\0\0\0\0\0 \0\0\0\0\0\0\0\xdf\x02\xa7\0\xa8\0\0\0\0\0\0\0\n\0\0\0\xa9\0\0\0\0\0\0\0\r\0*\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xaa\0\0\0\0\0\0\0\0\0\0\0\xa2\0\0\0\x11\0\x12\0\0\0\0\0\0\0\xab\0\0\0\0\0\0\x002\0\0\0\0\0\0\0\0\x003\0\0\0\0\x006\0\xac\0\x18\0\x19\0\x1a\0\0\0\xa3\0\xa4\0\0\0\xa5\0\xa6\0\0\0\0\0 \0\0\0\0\0\0\0\xe1\x02\xa7\0\xa8\0\0\0\0\0\0\0\n\0\0\0\xa9\0\0\0\0\0\0\0\r\0*\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xaa\0\0\0\0\0\0\0\0\0\0\0\xa2\0\0\0\x11\0\x12\0\0\0\0\0\0\0\xab\0\0\0\0\0\0\x002\0\0\0\0\0\0\0\0\x003\0\0\0\0\x006\0\xac\0\x18\0\x19\0\x1a\0\0\0\xa3\0\xa4\0\0\0\xa5\0\xa6\0\0\0\0\0 \0\0\0\0\0\0\0\0\0\xa7\0\xa8\0\0\0\0\0\0\0\0\0\0\0\xa9\0\0\0\0\0\0\0\0\0*\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xaa\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xab\0\0\0\0\0\0\x002\0\0\0\0\0\0\0\0\x003\0\0\0\0\x006\0\xac\0\t\0\n\0\x0b\0\0\0\0\0\0\0\f\0\r\0\x0e\x005\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x0f\0\x10\0\x11\0\x12\0\x13\0\x14\0\x15\0\0\0\0\0\0\0\0\0\x16\0\0\0\x17\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x18\0\x19\0\x1a\0\0\0\x1b\0\x1c\0\x1d\0\x1e\0\x1f\0\0\0\0\0 \0!\0\0\0\0\0\"\0#\0$\0\0\0\0\0%\0&\0\0\0'\0(\0\0\0)\0\0\0*\0+\0\0\0,\0\0\0-\0\0\0\0\0\0\0.\0/\0\0\x000\0\0\x006\x02\0\0\0\0\t\0\n\0\x0b\0\0\x001\0\0\0\f\0\r\0\x0e\x002\0\0\0\0\0\0\0\0\x003\x004\x005\x006\0\0\0\0\0\0\0\0\x007\0\x0f\0\x10\0\x11\0\x12\0\x13\0\x14\0\x15\0\0\0\0\0\0\0\0\0\x16\0\0\0\x17\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x18\0\x19\0\x1a\0\0\0\x1b\0\x1c\0\x1d\0\x1e\0\x1f\0\0\0\0\0 \0!\0\0\0\0\0\"\0#\0$\0\0\0\0\0%\0&\0\0\0'\0(\0\0\0)\0\0\0*\0+\0\0\0,\0\0\0-\0\0\0\0\0\0\0.\0/\0\0\x000\0\0\0\0\0\0\0\t\0\n\0\x0b\0\0\0\0\x001\0\f\0\r\0\0\0\0\x002\0\0\0\0\0\0\0\0\x003\x004\x005\x006\0\0\0\0\0\0\0\0\x007\0\0\0\x11\0\x12\0\x13\0\x14\0\x15\0\0\0\0\0\0\0\0\0\x16\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x18\0\x19\0\x1a\0\0\0\x1b\0\x1c\0\x1d\0\x1e\0\x1f\0\0\0\0\0 \0\0\0\0\0\0\0\"\0#\0$\0\0\0\0\0\0\0&\0\0\0'\0(\0\0\0\0\0\0\0*\0+\0\0\0,\0\0\0\0\0\0\0\0\0\0\0.\0/\0\0\x000\0\0\0\0\0\0\0\0\0\xe6\0\t\0\n\0\x0b\0\0\0\0\0\xe9\0\f\0\r\x002\0\0\0\0\0\0\0\0\x003\x004\0\0\x006\0\0\0\0\0\0\0\0\x007\0\0\0\0\0\0\0\x11\0\x12\0\x13\0\x14\0\x15\0\0\0\0\0\0\0\0\0\x16\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x18\0\x19\0\x1a\0\0\0\x1b\0\x1c\0\x1d\0\x1e\0\x1f\0\0\0\0\0 \0\0\0\0\0\0\0\"\0#\0$\0\0\0\0\0\0\0&\0\0\0'\0(\0\0\0\0\0\0\0*\0+\0\0\0,\0\0\0\0\0\0\0\0\0\0\0.\0/\0\0\x000\0\0\0\0\0\t\0\n\0\x0b\0\0\0\0\0\0\0\f\0\r\0\0\0\0\0\0\x002\0\0\0\0\0\0\0\0\x003\x004\0\0\x006\0\0\0\x06\x02\0\0\0\x007\0\x11\0\x12\0\x13\0\x14\0\x15\0\0\0\0\0\0\0\0\0\x16\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x18\0\x19\0\x1a\0\0\0\x1b\0\x1c\0\x1d\0\x1e\0\x1f\0\0\0\0\0 \0\0\0\0\0\0\0\"\0#\0$\0\0\0\0\0\0\0&\0\0\0'\0(\0\0\0\0\0\0\0*\0+\0\0\0,\0\0\0\0\0\0\0\0\0\0\0.\0/\0\0\x000\0\0\0\0\0\xe4\x02\xe4\x02\xe4\x02\0\0\0\0\0\0\xe4\x02\xe4\x02\0\0\0\0\0\x002\0\0\0\0\0\0\0\0\x003\x004\0\0\x006\0\0\0\xe4\x02\0\0\0\x007\0\xe4\x02\xe4\x02\xe4\x02\xe4\x02\xe4\x02\0\0\0\0\0\0\0\0\xe4\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe4\x02\xe4\x02\xe4\x02\0\0\xe4\x02\xe4\x02\xe4\x02\xe4\x02\xe4\x02\0\0\0\0\xe4\x02\0\0\0\0\0\0\xe4\x02\xe4\x02\xe4\x02\0\0\0\0\0\0\xe4\x02\0\0\xe4\x02\xe4\x02\0\0\0\0\0\0\xe4\x02\xe4\x02\0\0\xe4\x02\0\0\0\0\0\0\0\0\0\0\xe4\x02\xe4\x02\0\0\xe4\x02\0\0\0\0\t\0\n\0\x0b\0\0\0\0\0\0\0\f\0\r\0\0\0\0\0\0\0\xe4\x02\0\0\0\0\0\0\0\0\xe4\x02\xe4\x02\0\0\xe4\x02\0\0\0\0\0\0\0\0\xe4\x02\x11\0\x12\0\x13\0\x14\0\x15\0\0\0\0\0\0\0\0\0\x16\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x18\0\x19\0\x1a\0\0\0\x1b\0\x1c\0\x1d\0\x1e\0\x1f\0\0\0\0\0 \0\0\0\0\0\0\0\"\0#\0$\0\0\0\0\0\0\0&\0\0\0'\0(\0\0\0\0\0\0\0*\0+\0\0\0,\0\0\0\0\0\0\0\0\0\0\0.\0/\0\0\x000\0\0\0\0\0\xe4\x02\xe4\x02\xe4\x02\0\0\0\0\0\0\xe4\x02\xe4\x02\0\0\0\0\0\x002\0\0\0\0\0\0\0\0\x003\x004\0\0\x006\0\0\0\0\0\0\0\0\x007\0\xe4\x02\xe4\x02\xe4\x02\xe4\x02\xe4\x02\0\0\0\0\0\0\0\0\xe4\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe4\x02\xe4\x02\xe4\x02\0\0\xe4\x02\xe4\x02\xe4\x02\xe4\x02\xe4\x02\0\0\0\0\xe4\x02\0\0\0\0\0\0\xe4\x02\xe4\x02\xe4\x02\0\0\0\0\0\0\xe4\x02\0\0\xe4\x02\xe4\x02\0\0\0\0\0\0\xe4\x02\xe4\x02\0\0\xe4\x02\0\0\0\0\0\0\0\0\0\0\xe4\x02\xe4\x02\0\0\xe4\x02\0\0\0\0\0\0\n\0\0\0\0\0\0\0\0\0\0\0\r\0\0\0^\x03\0\0\xe4\x02C\x02\0\0\0\0\0\0\xe4\x02\xe4\x02\0\0\xe4\x02\0\0\0\0_\x03\0\0\xe4\x02\x11\0\x12\0\xf3\x01\0\0\xf3\x01\xf3\x01\xf3\x01\0\0\xf3\x01\0\0\0\0\xf3\x01\xf3\x01\0\0\0\0\0\0\0\0\0\0\0\0\x18\0\x19\0\x1a\0\x15\x02\0\0\xa4\0\0\0\xa5\0\xa6\0\0\0\xf3\x01 \0\0\0\0\0\0\0\0\0\xa7\0`\x03\xf3\x01\xf3\x01\0\0\0\0\0\0\xa9\0\n\0\0\0\xf3\x01\0\0*\0\0\0\r\0\0\0B\x02\0\0\x17\x02C\x02\0\0\xaa\0\xf3\x01\xf3\x01\0\0\0\0\x18\x02\0\0\0\0_\x03\0\0\0\0\x11\0\x12\0\xab\0\0\0\0\0\0\x002\0\0\0\0\0\x19\x02\0\x003\0\0\0\0\x006\0\xac\0\0\0\0\0\0\0\x18\0\x19\0\x1a\0\x15\x02\0\0\xa4\0\0\0\xa5\0\xa6\0\0\0\0\0 \0\0\0\0\0\0\0\0\0\xa7\0`\x03\0\0\0\0\0\0\0\0\0\0\xa9\0\n\0\0\0\0\0\0\0*\0\0\0\r\0\0\0\xb9\x03\0\0\x17\x02\0\0\0\0\xaa\0\0\0\0\0\0\0\0\0\x18\x02\0\0\0\0\xba\x03\0\0\0\0\x11\0\x12\0\xab\0\0\0\0\0\0\x002\0\0\0\0\0\x19\x02\0\x003\0\0\0\0\x006\0\xac\0\0\0\0\0\0\0\x18\0\x19\0\x1a\0\x15\x02\0\0\xa4\0\0\0\xa5\0\xa6\0\0\0\0\0 \0\0\0\0\0\0\0\0\0\xa7\0\xd4\x01\0\0\0\0\0\0\0\0\0\0\xa9\0\n\0\0\0\0\0\0\0*\0\0\0\r\0\0\0\x92\x05\0\0\x17\x02\0\0\0\0\xaa\0\0\0\0\0\0\0\0\0\x18\x02\0\0\0\0_\x03\0\0\0\0\x11\0\x12\0\xab\0\0\0\0\0\0\x002\0\0\0\0\0\x19\x02\0\x003\0\0\0\0\x006\0\xac\0\0\0\0\0\0\0\x18\0\x19\0\x1a\0\x15\x02\0\0\xa4\0\0\0\xa5\0\xa6\0\0\0\0\0 \0\0\0\0\0\0\0\0\0\xa7\0`\x03\0\0\0\0\0\0\n\0\0\0\xa9\0\0\0\0\0\0\0\r\0*\0\0\0\0\0\0\0\0\0\0\0\x17\x02\0\0\0\0\xaa\0\0\0\0\0\0\0\0\0\x18\x02\0\0\0\0\x11\0\x12\0\0\0\0\0\0\0\xab\0\0\0\0\0\0\x002\0\0\0\0\0\x19\x02\0\x003\0\0\0\0\x006\0\xac\0\x18\0\x19\0\x1a\0\x15\x02\0\0\xa4\0\0\0\xa5\0\xa6\0\0\0\0\0 \0\0\0\0\0\0\0\0\0\xa7\0\x0b\x03\0\0\0\0\0\0\n\0\0\0\xa9\0\0\0\f\x03\0\0\r\0*\0\0\0\0\0\0\0\0\0\0\0\x17\x02\0\0\0\0\xaa\0\0\0\0\0\0\0\0\0\x18\x02\0\0\0\0\x11\0\x12\0\0\0\0\0\0\0\xab\0\0\0\0\0\0\x002\0\0\0\0\0\x19\x02\0\x003\0\0\0\0\x006\0\xac\0\x18\0\x19\0\x1a\0\x15\x02\0\0\xa4\0\0\0\xa5\0\xa6\0\0\0\0\0 \0\0\0\0\0\0\0\0\0\xa7\0\xd4\x01\0\0\0\0\0\0\n\0\0\0\xa9\0\0\0E\x05\0\0\r\0*\0\0\0\0\0\0\0\0\0\0\0\x17\x02\0\0\0\0\xaa\0\0\0\0\0\0\0\0\0\x18\x02\0\0\0\0\x11\0\x12\0\0\0\0\0\0\0\xab\0\0\0\0\0\0\x002\0\0\0\0\0\x19\x02\0\x003\0\0\0\0\x006\0\xac\0\x18\0\x19\0\x1a\0\x15\x02\0\0\xa4\0\0\0\xa5\0\xa6\0\0\0\0\0 \0\0\0\0\0\0\0\0\0\xa7\0\x16\x02\0\0\0\0\0\0\n\0\0\0\xa9\0\0\0\0\0\0\0\r\0*\0\0\0\0\0\0\0\0\0\0\0\x17\x02\0\0\0\0\xaa\0\0\0\0\0\0\0\0\0\x18\x02\0\0\0\0\x11\0\x12\0\0\0\0\0\0\0\xab\0\0\0\0\0\0\x002\0\0\0\0\0\x19\x02\0\x003\0\0\0\0\x006\0\xac\0\x18\0\x19\0\x1a\0\x15\x02\0\0\xa4\0\0\0\xa5\0\xa6\0\0\0\0\0 \0\0\0\0\0\0\0\0\0\xa7\0\xd4\x01\0\0\0\0\0\0\xe4\x02\0\0\xa9\0\0\0\0\0\0\0\xe4\x02*\0\0\0\0\0\0\0\0\0\0\0\x17\x02\0\0\0\0\xaa\0\0\0\0\0\0\0\0\0\x18\x02\0\0\0\0\xe4\x02\xe4\x02\0\0\0\0\0\0\xab\0\0\0\0\0\0\x002\0\0\0\0\0\x19\x02\0\x003\0\0\0\0\x006\0\xac\0\xe4\x02\xe4\x02\xe4\x02\xe4\x02\0\0\xe4\x02\0\0\xe4\x02\xe4\x02\0\0\0\0\xe4\x02\0\0\0\0\0\0\0\0\xe4\x02\xe4\x02\0\0\0\0\0\0\n\0\0\0\xe4\x02\0\0\0\0\0\0\r\0\xe4\x02\0\0\0\0\0\0\0\0\0\0\xe4\x02\0\0\0\0\xe4\x02\0\0\0\0\0\0\0\0\xe4\x02\xa2\0\0\0\x11\0\x12\0\0\0\0\0\0\0\xe4\x02\0\0\0\0\0\0\xe4\x02\0\0\0\0\xe4\x02\0\0\xe4\x02\0\0\0\0\xe4\x02\xe4\x02\x18\0\x19\0\x1a\0\0\0\xa3\0\xa4\0\0\0\xa5\0\xa6\0\0\0\0\0 \0\0\0\0\0\0\0\0\0\xa7\0\xa8\0\0\0\0\0\0\0\0\0\0\0\xa9\0\0\0\0\0\0\0\n\0*\0\0\0\0\0\xdf\x01\0\0\r\0\0\0\0\0\0\0\xaa\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe6\0\0\0\0\0\0\0\xa2\0\xab\0\x11\0\x12\0\0\x002\0\0\0\0\0\0\0\0\x003\0\0\0\0\x006\0\xac\0\0\0\0\0\0\0\0\0\0\0\0\0\x18\0\x19\0\x1a\0\0\0\xa3\0\xa4\0\0\0\xa5\0\xa6\0\0\0\0\0 \0\0\0\0\0\0\0\0\0\xa7\0\xa8\0\0\0\0\0\0\0\0\0\0\0\xa9\0\xe4\x02\0\0\xe4\x02\0\0*\0\0\0\xe4\x02\0\0\0\0\0\0\0\0\0\0\0\0\xaa\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe4\x02\0\0\xe4\x02\xe4\x02\xab\0\0\0\0\0\0\x002\0\0\0\0\0\0\0\0\x003\0\0\0\0\x006\0\xac\0\0\0\0\0\0\0\xe4\x02\xe4\x02\xe4\x02\0\0\xe4\x02\xe4\x02\0\0\xe4\x02\xe4\x02\0\0\0\0\xe4\x02\0\0\0\0\0\0\0\0\xe4\x02\xe4\x02\0\0\0\0\0\0\xe4\x02\0\0\xe4\x02\0\0\0\0\0\0\xe4\x02\xe4\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe4\x02\0\0\0\0\0\0\0\0\0\0\xe4\x02\0\0\xe4\x02\xe4\x02\0\0\0\0\0\0\xe4\x02\0\0\0\0\0\0\xe4\x02\0\0\0\0\0\0\0\0\xe4\x02\0\0\0\0\xe4\x02\xe4\x02\xe4\x02\xe4\x02\xe4\x02\0\0\xe4\x02\xe4\x02\0\0\xe4\x02\xe4\x02\0\0\0\0\xe4\x02\0\0\0\0\0\0\0\0\xe4\x02\xe4\x02\0\0\0\0\0\0\0\0\0\0\xe4\x02\0\0\0\0\0\0\n\0\xe4\x02\0\0\0\0\0\0\0\0\r\0\0\0\0\0\0\0\xe4\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe4\x02\0\0\0\0\xa2\0\xe4\x02\x11\0\x12\0\0\0\xe4\x02\0\0\0\0\0\0\0\0\xe4\x02\0\0\0\0\xe4\x02\xe4\x02\0\0\0\0\0\0\0\0\0\0\0\0\x18\0\x19\0\x1a\0\0\0\xa3\0\xa4\0\0\0\xa5\0\xa6\0\0\0\0\0 \0\0\0\0\0\0\0\0\0\xa7\0\xa8\0\0\0\0\0\0\0\xe4\x02\0\0\xa9\0\0\0\0\0\0\0\xe4\x02*\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xaa\0\0\0\0\0\0\0\0\0\0\0\xe4\x02\0\0\xe4\x02\xe4\x02\0\0\0\0\0\0\xab\0\0\0\0\0\0\x002\0\0\0\0\0\0\0\0\x003\0\0\0\0\x006\0\xac\0\xe4\x02\xe4\x02\xe4\x02\0\0\xe4\x02\xe4\x02\0\0\xe4\x02\xe4\x02\0\0\0\0\xe4\x02\0\0\0\0\0\0\0\0\xe4\x02\xe4\x02\0\0\0\0\0\0\xa1\x02\0\0\xe4\x02\0\0\0\0\0\0\xa1\x02\xe4\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe4\x02\0\0\0\0\0\0\0\0\0\0\xa1\x02\0\0\xa1\x02\xa1\x02\0\0\0\0\0\0\xe4\x02\0\0\0\0\0\0\xe4\x02\0\0\0\0\0\0\0\0\xe4\x02\0\0\0\0\xe4\x02\xe4\x02\xa1\x02\xa1\x02\xa1\x02\0\0\xa1\x02\xa1\x02\0\0\xa1\x02\xa1\x02\0\0\0\0\xa1\x02\0\0\0\0\0\0\0\0\xa1\x02\xa1\x02\0\0\0\0\0\0\x8e\x02\0\0\xa1\x02\0\0\0\0\0\0\x8e\x02\xa1\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xa1\x02\0\0\0\0\0\0\0\0\0\0\x8e\x02\0\0\x8e\x02\x8e\x02\0\0\0\0\0\0\xa1\x02\0\0\0\0\0\0\xa1\x02\0\0\0\0\0\0\0\0\xa1\x02\0\0\0\0\xa1\x02\xa1\x02\x8e\x02\x8e\x02\x8e\x02\0\0\x8e\x02\x8e\x02\0\0\x8e\x02\x8e\x02\0\0\0\0\x8e\x02\0\0\0\0\0\0\0\0\x8e\x02\x8e\x02\0\0\0\0\0\0\n\0\0\0\x8e\x02\0\0\0\0\0\0\r\0\x8e\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x8e\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x11\0\x12\0\0\0\0\0\0\0\x8e\x02\0\0\0\0\0\0\x8e\x02\0\0\0\0\0\0\0\0\x8e\x02\0\0\0\0\x8e\x02\x8e\x02\x18\0\x19\0\x1a\0\0\0\0\0\xa4\0\0\0\xa5\0\xa6\0\0\0\0\0 \0\0\0\0\0\0\0\0\0\xa7\0\xd4\x01\0\0\0\0\0\0\0\0\0\0\xa9\0\n\0\x0b\0\0\0\0\0*\0\f\0\r\0\0\0\0\0\0\0\0\0\0\0\0\0\xaa\0\0\0\0\0|\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x11\0\x12\0\xab\0\0\0\0\0\0\x002\0\0\0\0\0\0\0\0\x003\0\0\0\0\x006\0\xac\0\0\0\0\0\0\0\x18\0\x19\0\x1a\0}\x01\0\0\x1c\0\x1d\0\x1e\0\x1f\0\0\0\0\0 \0\0\0\0\0\0\0\0\0\xa7\0\xc0\0\0\0\0\0\n\0\x0b\0\0\0\0\0\0\0\f\0\r\0\0\0*\0+\0\0\0\0\0\0\0\0\0~\x01\0\0\0\0\0\0\0\0\0\x000\0\0\0\x7f\x01\0\0\x11\0\x12\0\0\0\0\0\0\0\0\0\x80\x01\x81\x01\0\0\0\x002\0\0\0\0\0\x82\x01\0\x003\0\0\0\0\x006\0\x18\0\x19\0\x1a\0}\x01\0\0\x1c\0\x1d\0\x1e\0\x1f\0\0\0\0\0 \0\0\0\0\0\0\0\0\0\xa7\0\xc0\0\0\0\0\0\n\0\x0b\0\0\0\0\0\0\0\f\0\r\0\0\0*\0+\0\0\0\0\0\0\0\0\0~\x01\0\0\0\0\0\0\0\0\0\x000\0\0\0\x7f\x01\0\0\x11\0\x12\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x002\0\0\0\0\0\x82\x01\0\x003\0\0\0\0\x006\0\x18\0\x19\0\x1a\0\0\0\0\0\x1c\0\x1d\0\x1e\0\x1f\0\0\0\0\0 \0\0\0\0\0\0\0\0\0\xa7\0\xc0\0\0\0\0\0\n\0\x0b\0\0\0\0\0\0\0\f\0\r\0\0\0*\0+\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x000\0\0\0\0\0\0\0\x11\0\x12\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x002\0\0\0\0\0\0\0\0\x003\0\0\0\0\x006\0\x18\0\x19\0\x1a\0\0\0\0\0\x1c\0\x1d\0\x1e\0\x1f\0\0\0\0\0 \0\0\0\0\0\0\0\0\0\xdb\0\xc0\0\0\0\0\0\xe4\x02\xe4\x02\0\0\0\0\0\0\xe4\x02\xe4\x02\0\0*\0+\0\0\0\0\0\0\0\0\0\0\0\0\0\x90\x04\0\0\0\0\0\x000\0\0\0\0\0\xc8\0\xe4\x02\xe4\x02\x89\0\0\0\x8a\0\x8b\0 \0\x91\x04\x8c\0\0\x002\0\x8d\0\x8e\0\0\0\xc9\x003\0\0\0\0\x006\0\xe4\x02\xe4\x02\xe4\x02\0\0\0\0\xe4\x02\xe4\x02\xe4\x02\xe4\x02\0\0\x8f\0\xe4\x02\0\0\0\0\0\0\0\0\xe4\x02\xe4\x02\x90\0\x90\x03\0\0\x89\0\0\0\x8a\0\x8b\0 \0\x92\0\x8c\0\xe4\x02\xe4\x02\x8d\0\x92\x04\0\0\0\0\0\0\0\0\x90\x04\xb7\x05\x93\0\x94\0\xe4\x02\0\0\0\0\xc8\0\0\0\0\0\0\0\0\0\x8f\0\0\0\0\0\0\0\0\0\0\0\xe4\x02\x93\x04\x90\0\x91\0\xc9\0\xe4\x02\0\0\0\0\xe4\x02\0\0\x92\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xcb\0\0\0\0\0\x94\x04\x94\0\0\0\0\0\0\0\0\0\0\0\0\0\x89\0\0\0\x8a\0\x8b\0 \0\0\0\x8c\0\0\0\0\0\x8d\0\x92\x04\0\0\0\0\0\0\0\0\xd3\x03W\x01X\x01\0\0\0\0\0\0\0\0\0\0\0\0Y\x01\0\0\0\0\x8f\0\0\0\xd4\x03Z\x01[\x01\xd5\x03\\\x01\0\0\x90\0\x91\0\0\0\0\0\0\0\0\0\0\0]\x01\x92\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0^\x01\xcb\0\0\0\0\0\x94\x04\x94\0_\x01`\x01a\x01b\x01c\x01#\x01$\x01%\x01\0\0\0\0\0\0\0\0\xe1\x01\0\0'\x01\0\0\0\0\0\0\0\0\0\0d\x01)\x01\0\0\0\0\0\0\xb9\0\0\0\0\0\0\0\0\0e\x01f\x01*\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0+\x01g\x01h\x01i\x01j\x01k\x01,\x01-\x01.\x01/\x010\x01\0\0\0\0\xd6\x03\0\0\0\0\0\0\0\0\0\0m\x01\0\0\0\0\0\0\0\0\0\0\0\x001\x01\0\0\0\0\0\0W\x01X\x01\0\0\0\0\0\0\0\0\x10\x02\xe4\x01Y\x01\x11\x02\0\0\0\0\0\0\0\0Z\x01[\x01\0\0\\\x015\x016\x01\x12\x02\xe7\x019\x01\xe8\x01\0\0\0\0]\x01\0\0\0\0\0\0\0\0\0\0W\x01X\x01<\x01^\x01=\x01\0\0\0\0\0\0Y\x01_\x01`\x01a\x01b\x01c\x01Z\x01[\x01\0\0\\\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0]\x01\0\0\0\0d\x01\0\0\0\0\0\0\0\0\xb9\0^\x01\0\0\0\0\0\0e\x01f\x01_\x01`\x01a\x01b\x01c\x01\0\0\0\0\0\0\0\0\0\0g\x01h\x01i\x01j\x01k\x01\0\0\0\0\0\0\0\0\0\0d\x01W\x01X\x01l\x01\0\0\xb9\0\0\0\0\0m\x01Y\x01e\x01f\x01\0\0\0\0\0\0Z\x01[\x01\0\0\\\x01\0\0\0\0\0\0g\x01h\x01i\x01j\x01k\x01]\x01\0\0\0\0\0\0\x10\x04\0\0W\x01X\x01\0\0^\x01\0\0\0\0\0\0m\x01Y\x01_\x01`\x01a\x01b\x01c\x01Z\x01[\x01\0\0\\\x01\0\0\0\0\0\0\0\0\0\0\0\0r\x04\0\0]\x01\0\0\0\0d\x01\0\0\0\0\0\0\0\0\xb9\0^\x01\0\0\0\0\0\0e\x01f\x01_\x01`\x01a\x01b\x01c\x01\0\0\0\0\0\0\0\0\0\0g\x01h\x01i\x01j\x01k\x01\0\0\0\0\0\0\0\0?\x04d\x01W\x01X\x01\0\0\0\0\xb9\0\0\0\0\0m\x01Y\x01e\x01f\x01\0\0\0\0\0\0Z\x01[\x01\0\0\\\x01\0\0\0\0\0\0g\x01h\x01i\x01j\x01k\x01]\x01\0\0\0\0\0\0\0\0\0\0W\x01X\x01\0\0^\x01\0\0\0\0\0\0m\x01Y\x01_\x01`\x01a\x01b\x01c\x01Z\x01[\x01\0\0~\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0]\x01\0\0\0\0d\x01\0\0\0\0\0\0\0\0\xb9\0^\x01\0\0\0\0\0\0e\x01f\x01_\x01`\x01a\x01b\x01c\x01\0\0\0\0\0\0\0\0\0\0g\x01h\x01i\x01j\x01k\x01\0\0\0\0\0\0\0\0\0\0d\x01\xea\0\xea\0\0\0\0\0\xb9\0\0\0\0\0m\x01\xea\0e\x01f\x01\0\0\0\0\0\0\xea\0\xea\0\0\0\0\0\0\0\0\0\0\0g\x01h\x01i\x01j\x01k\x01\xea\0\0\0\0\0\0\0\0\0\0\0W\x01X\x01\0\0\xea\0\0\0\0\0\0\0m\x01Y\x01\xea\0\xea\0\xea\0\xea\0\xea\0Z\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0]\x01\0\0\0\0\xea\0\0\0\0\0\0\0\0\0\xea\0^\x01\0\0\0\0\0\0\xea\0\xea\0_\x01`\x01a\x01b\x01c\x01\0\0\0\0\0\0\0\0\0\0\xea\0\xea\0\xea\0\xea\0\xea\0\0\0\0\0\0\0\0\0\xea\0d\x01W\x01X\x01\0\0\0\0\xb9\0\0\0\0\0\xea\0Y\x01e\x01f\x01\0\0\0\0\0\0Z\x01\0\0\0\0\0\0\0\0\0\0\0\0g\x01h\x01i\x01j\x01k\x01]\x01\0\0\0\0\0\0\0\0\0\0\0\0R\x05\0\0^\x01\0\0\0\0\0\0m\x01\0\0_\x01`\x01a\x01b\x01c\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0W\x01X\x01\0\0\0\0\0\0\0\0\0\0\0\0d\x01\0\0\0\0\0\0\0\0\xb9\0Z\x01\0\0\0\0\0\0e\x01f\x01\0\0\0\0\0\0\0\0\0\0\0\0]\x01\0\0\0\0\0\0g\x01h\x01i\x01j\x01k\x01^\x01\0\0\0\0\0\0\0\0\0\0_\x01`\x01a\x01b\x01c\x01\0\0\0\0m\x01\0\0\0\0\0\0\0\0\0\0\x89\0\0\0\x8a\0\x8b\0 \0\0\0\x8c\0d\x01\0\0\x8d\0\x8e\0\0\0\xb9\0\0\0\0\0\0\0\0\0e\x01f\x01\xc0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x8f\0\0\0\0\0h\x01i\x01j\x01k\x01\0\0\x90\0\x91\0\0\0\0\0\0\0\0\0\0\0\0\0\x92\0\0\0\0\0\0\0m\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x93\0\x94\0",
  /* check */"\x03\0\x04\0^\0\x06\0\x02\0\x92\0\x02\0>\x01\x0f\0\x83\x01\xa3\0\x89\0\x0e\x02\x8f\0\xa4\0!\x01\n\0\x89\0\xba\x02\xc0\x01\x1d\0\x9e\0\r\x03\x8b\0\t\x02\xd1\0\t\0\xb2\x01\xd5\0\f\0a\x03\x7f\x03\x1f\0$\0\xab\0\x8f\x01\x13\0\x14\0\x15\0\x16\0V\x02\x0b\x007\x03\xf3\x02\x1b\0\xba\x02\f\x02\xd4\0\x0e\x02\xa6\x04\x01\0\"\0\x03\0\x04\0\x02\0&\0\xd1\0\f\x04\x1c\0!\0+\0,\0\xe8\0%\0\xea\0\x03\0\x04\0o\x01\x02\x004\0\x07\0\0\x007\0;\0\0\0\x93\x04\0\0\x02\x000\0\f\x02\x84\0\x0e\x02\x86\0I\x04\x1f\x01b\0\x8a\x04\x8b\x04_\0\x03\0\x02\0\x8c\x01\xbc\x04\x01\0\xd2\0B\x04\x11\x01n\x001\0\x02\0b\0\x02\0b\0U\x04C\x01\xc5\0\x01\x02\x02\x02;\0A\x01\0\0\x0f\x01n\0S\0n\0U\0V\0@\x01\0\x01%\x01\x0f\x02\xf8\x03\0\x014\x01\x07\x01\x04\x01C\x01\x82\0z\0\b\x01\x97\x04\x8c\0\n\x01`\x01Z\x01\0\x01\x0f\x01\x17\x04\x9a\x04\x12\x01\x05\x001\0\xb7\x01\0\x01\xb9\x01\0\x01\x89\0A\x01\0\x01\x07\x01b\0\x91\0\x86\x04\0\x01u\x01`\x01\0\x01\0\x01r\x01\xac\x03\0\x01\0\x01n\0C\x01b\0$\x04\0\x01\x96\0J\x02\0\x01\x11\x01\n\x01N\x02b\0\0\x01`\x01n\0\x80\0\x12\x05\x82\0\b\x01\x84\0^\x03\x86\0E\x01n\0b\0\0\x01C\x01\xc0\0\x80\0\xae\0\x82\0\xc4\0\x84\0b\0\x86\0b\0n\0\xd4\x03\xd5\x03\0\x01\0\x01\xae\x04\xbb\0\0\x01.\x05n\0\xd3\0n\0C\x01\xb9\0\xba\0A\x01`\x01\b\x02\x82\0\0\x01\xbc\0\0\x01\xd2\x04A\x01A\x01\0\x01L\x02\xa2\0\x84\x02C\x01\xa5\0\xa6\0|\x01r\x01\xd7\0\x8e\x01A\x01\xd9\x04s\x01\x0e\x01]\x01`\x01\t\0\xb2\0\xb3\0\f\0\t\x05\xe3\x04o\x01\x07\x05\xda\0`\x01\x13\0\x14\0\x15\0\x16\0\x8b\x03^\x01`\x01\x11\x05\x1b\0o\x01u\x01\0\x01`\x01\xd6\0O\x01\x88\x04^\x01o\x01o\x01&\0`\x01\xd0\0C\x01=\x02+\0,\0\xbe\x01u\x01^\x05\x04\x01o\x01^\x01v\x014\0x\x01-\x057\0\x18\x01\0\x01\x04\x01C\x01A\x01B\x01\b\x01]\x01]\x01\0\0\0\x01a\x01a\x01\x0f\x01`\x01\x16\x01\x12\x01\xbe\x04 \x01\xd6\0\x9f\x02\xde\x01\0\x02\xe0\x01\x0e\x01]\x01`\x01\x11\x01\x03\x01a\x01\xbf\x01A\x01`\x01\0\x01\x16\x01\xb7\x05\xd0\x01&\x01\0\x01\xa2\x01\0\x01K\x01C\x01@\x05N\x01\xce\x01\xdb\x04\x04\x01\x1e\x01\x1f\x01o\x01\b\x01\0\x01\x85\x02\x86\x02f\x05E\x05:\x01\x0f\x01\0\x01\0\x01\x12\x01J\x01\0\x01Q\x01C\x01\x1a\x01]\x01\xfa\x02S\x01u\x05a\x01J\x01\n\x01l\x01P\x01$\x02\0\x01p\x01\0\x01\x05\x02g\x04@\x01k\x01D\x01\x0f\x01\xa6\x02\xaa\x01\x80\x01\xac\x01\xad\x05\xae\x01 \x02\x15\x02E\x04^\x01G\x04\xff\x04\x1a\x02Q\x01\x1e\x01\x91\x01\x9a\x05w\x03\\\x01\x1a\x01`\x017\x03\n\x05T\x04C\x01\xb7\x02C\x01s\x013\x03]\x02\x91\x01M\x02\x91\x01\0\x01\0\x01\xa5\x04\0\x01C\x01}\x01~\x01]\x01\x81\x05\x81\x01s\x05\x83\x01/\x04^\x01\x93\x01^\x01\x16\x01B\x01\0\x01\0\x01\0\x01\x1b\x01\0\x01\x12\x01o\x01\x1b\x03]\x01?\x05\n\x01\0\x01\n\x01\0\x01\0\x01`\x01]\x01\xb0\x01`\x01I\x05^\x01\x11\x01\0\x01a\x01\xb7\x01\x03\x01\xb9\x01\xb2\x01\xb5\x03\x91\x01\xf4\x03\b\x01\x80\x02\0\x01\0\x01+\x05`\x01\x12\x01%\x01\x11\x01Y\x02l\x01\xc1\x01\x91\x01o\x01A\x03#\x01\b\x01\xcf\x01\x1c\x05%\x01\xaa\x01\x91\x01\xac\x01\x0f\x01\xae\x01\xbe\x03\xbf\x03\b\x01$\x01\xd3\x01\x88\x02\xf3\x04\x80\x02\xaa\x01\x91\x01\xac\x01\0\x01\xae\x01\x1e\x01\xdd\x01<\x01~\x05\x96\x02\x91\x01]\x01\x91\x01B\x01\0\x01`\x01\xef\x04`\x01\xe9\x01\x92\x03\xb9\x03\0\x01\0\x01\xac\x03\n\x01\xbe\x03\xbf\x03\xcb\x04p\x036\x01^\x01 \x01^\x01a\x01a\x01a\x01`\x01\xfc\x01\xfd\x01\0\x01|\x03B\x01\x01\x02\x02\x02^\x01\f\x02a\x01\x0e\x02\x84\x03^\x01\xa3\x02h\x01\0\x01^\x01`\x01\0\x01\x0f\x02\b\x01o\x01\xb1\x05\x16\x01\x14\x02/\x02\xd4\x03\xd5\x03`\x01`\x01\x1c\x04\0\x01\b\x01\x0f\x01\x12\x01\x0e\x01\0\x02\xbf\x04\"\x02\x0f\x01\xf6\x01\xf7\x01\xf8\x01^\x01\xc2\x02\xf2\x02l\x01\xd2\x02\xfe\x01o\x01B\x01C\x01\xc3\x02\xc4\x02\x1e\x01\xbc\x03\xe8\x02\x1b\x01\x06\x01\b\x01^\x01\x12\x01\\\x01;\x02B\x014\x02\b\x01\x1b\x01@\x02A\x01B\x01^\x01J\x01b\x05a\x01a\x02\xf2\x02\x17\x04\x1c\x02^\x01`\x01\x17\x03p\x01\0\x01d\x02C\x01b\x02c\x02\xd1\x03\x10\x01B\x01\x12\x01\x12\x01\x16\x01$\x01]\x01\xf6\x02C\x01\0\x01\x12\x01c\x01d\x01\x12\x01\r\x036\x02\x16\x01^\x01\x16\x01]\x01\xae\x02\x1b\x01=\x02`\x01`\x02`\x01\x13\x01\b\x01`\x01u\x01\x0e\x01\x16\x01\x89\x02\x8a\x02\x0f\x01]\x01\x1b\x01\0\x01I\x04\x99\x05]\x02~\x02Q\x02l\x01\x1e\x01*\x04o\x01`\x01\x0e\x04\x1e\x01`\x01\x0e\x01\x13\x02(\x05/\x01*\x05^\x01^\x01u\x01Z\x03\x12\x01\x9d\x02\0\0^\x01\x0e\x01\x12\x01\x97\x02a\x03=\x01\x12\x018\x01W\x03X\x03Y\x03\\\x01\x12\x01E\x01\xbc\x02G\x01^\x01B\x01#\x04B\x01C\x01s\x03B\x015\x02]\x01`\x01^\x01\xb7\x02a\x01\x16\x01c\x01d\x01c\x01d\x01\x04\x01a\x03B\x02C\x02?\x03]\x01B\x01C\x01\xc9\x02a\x01\x16\x01c\x01d\x01\x1b\x01u\x01`\x01\x17\x01L\x03\xeb\x03\xdc\x04\xed\x03\xee\x03\x1b\x01q\x01\xae\x02l\x01\x03\x01\x1b\x01o\x01u\x01l\x01\xe9\x02\xea\x02o\x01Q\x01\x16\x01`\x01\xae\x02\0\x01^\x01\xde\x02`\x01\xe0\x02\x1b\x01\xe2\x02\xe3\x02`\x01\x1b\x01^\x01\xa5\x04`\x01\xa4\x03\b\x01\xff\x02B\x01\xdc\x04`\x01\x13\x01\xbe\x04\x0f\x01\x17\x01\xbc\x03C\x01C\x01\x1a\x01\\\x01\f\x03\x88\x03\xfa\x02\x99\x03\x1b\x01\xcf\x02\xfe\x02\b\x01\x1e\x01\xd3\x02\x95\x03\x13\x01\xd2\x04B\x01\x0f\x01\xc0\x05`\x01Z\x01`\x01/\x010\x01\xdb\x04\xdc\x04\x0f\x03\x11\x01;\x02\xbc\x03\x1b\x01\x03\x01\x1e\x01`\x01\b\x016\x01=\x01\xa4\x02\0\x01A\x01\xe7\x03B\x01\x02\x01 \x03E\x01\xc0\x05G\x01B\x01\0\x01`\x01n\x01\x04\x01\x03\x01`\x01r\x01\b\x01\x13\x01$\x01/\x030\x03\x03\x03\x0e\x01\x0f\x01D\x01\xf3\x04\x12\x01\xc1\x02\x13\x01B\x01:\x03J\x03<\x03J\x03\b\x01\x1a\x01T\x03`\x01C\x01C\x03D\x03\x0e\x04Q\x03G\x03\\\x03/\x010\x01_\x03\x0e\x01q\x01l\x01\xd9\x02w\x03o\x01\x0e\x01D\x01/\x010\x01C\x01=\x01`\x01\x1b\x01\xe5\x04\x0e\x01A\x01B\x01?\x01E\x01C\x01G\x01=\x01l\x01\x0e\x04\r\x05o\x01C\x01\x1b\x01D\x01E\x01a\x01G\x01C\x01D\x01\0\0\0\x01?\x05@\x05\x0e\x01\x04\x01A\x01\x1d\x04\0\0\b\x01\x03\x01D\x01I\x05\x0e\x01}\x03\x0e\x01\x0f\x01\x88\x03#\x01\x12\x01\x83\x03`\x01\x90\x03B\x01C\x01u\x01\x1b\x01S\x04q\x013\x04b\x01\xb5\x03Q\x01\x03\x01]\x01\x92\x03\0\x01A\x01B\x01q\x01\x04\x01\x98\x03\xa1\x03<\x01\b\x01A\x01\n\x01Q\x01u\x01B\x01\x0e\x01\x0f\x01\xa3\x037\x04\x12\x01\xa6\x03B\x01\x0f\x01S\x04r\x01\x12\x01\xb7\x03\x1b\x01\x1b\x01\xaf\x03~\x05b\x01\x16\x01C\x01\\\x05\0\0E\x04\xbf\x03R\x04\xcd\x03\xce\x03\f\x01E\x04g\x04\x0e\x01Q\x01h\x05-\x01.\x01p\x01^\x04\xc5\x03h\x01\xdb\x03\xb5\x05\xb6\x05o\x01\x1b\x01\b\x01o\x01\x1f\x01q\x01`\x01A\x01\xd2\x03\x9b\x01^\x03C\x01C\x01\xd7\x03\xec\x03\xab\x03\xba\x03e\x03C\x01J\x01B\x01\r\x011\x012\x013\x01\xb1\x05\0\x01\xe5\x03A\x01]\x01\x03\x01U\x01A\x01a\x01\\\x01\xda\x05\x1c\x01\x1d\x01]\x01^\x01B\x01`\x01a\x01L\x01\n\x04H\x01\xa0\x05\xa1\x05f\x01)\x01M\x01\xcf\x03\x1a\x01o\x01\x04\x01\x01\x04\0\0\x1d\x04\b\x01V\x01s\x01\x0e\x01c\x01\x1b\x01\x05\0\x0b\x04\x07\0(\x01\x12\x01=\x01C\x01\xe3\x03@\x01[\x05o\x01\xde\x04g\x01E\x01\x18\x04\x19\x04\xc2\x05r\x01\x17\0K\x01\x04\x01\0\x01 \x04\xf3\x03\b\x01A\x01R\x010\x04&\x04`\x01A\x01\x0f\x01*\x04#\x01\x12\x01`\x01\0\x01\x16\x01\xd8\x05C\x01\x13\x018\x01\xde\x04\x1b\x01o\x01<\x01\n\x01\x1a\x01\x1b\x01;\x04A\x01E\x04\xe6\x05C\x01n\x01\0\0u\x01\\\x01<\x01\xef\x04J\x01\x0e\x01A\x01Z\x01B\x01P\x01A\x01M\x04/\x010\x01A\x01o\x01f\x04\x1c\x05\x1b\x01i\x04o\x01p\x01\xe2\x03Y\x04^\x01B\x01=\x01C\x01\xe8\x03A\x01\xea\x03r\x01A\x01D\x01E\x01`\0G\x01Z\x04|\x04}\x04o\x01A\x01\xf6\x03A\x01\0\0\0\x01h\x01\x16\x01\x1c\x05s\x04\x1f\x01U\x04o\x01o\x01\x90\x04\x1b\x01o\x01B\x01\r\x01\\\x01o\x01p\x01\x80\x04c\x01\x82\x04\x83\x04\x84\x04\x9d\x041\x012\x013\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01o\x01\x89\0X\x05q\x01p\x01A\x01\x8e\0\x8f\0\x95\x04\0\x01\xab\x04)\x01o\x018\x01o\x01\x1b\x01A\x01\x16\x01D\x01:\x05C\x01M\x01A\x01\xbc\x04A\x01\x86\x04\xa2\0\xa3\0G\x05\xa5\0\xa6\0=\x01\xa8\0X\x05@\x01\x1a\x01A\x01C\x01D\x01E\x01\0\x01\0\x01\xb2\0\xb3\0\x04\x01K\x01\xbb\x04A\x01\b\x01\x04\x01\n\x01o\x01R\x01\b\x01\x0e\x01C\x01\x1f\x01A\x01\x12\x01\x0e\x01\x0f\x01B\x01o\x01\x12\x01^\x01\xce\x04`\x01\x1b\x01b\x01c\x01o\x01\xdc\x04\xd0\0\xd1\x001\x012\x013\x01\xd5\0%\x01\xf0\x04n\x01h\x04o\x01q\x01\xe1\x04l\x04A\x01u\x01f\x01\0\x05\x1b\x01#\x01\x03\x05\xea\x04\x05\x05\x04\x01\x04\x01\xee\x04\x1b\x01\b\x01\b\x01\xe5\x04M\x01o\x01\x16\x01\xc8\x04\x0f\x01\x10\x05\xd9\x04\x12\x01\x12\x01\xfc\x04C\x01A\x01J\x01A\x01<\x01\0\x01\xe3\x04A\x01B\x01\x04\x01B\x01\b\x05\x93\x04\b\x01H\x01\n\x01\r\x05\x1b\x01C\x01\x0e\x01o\x01]\x01^\x01,\x05`\x01a\x01C\x01\x04\x01V\x01\0\0\x1b\x05\b\x01\x1b\x01\xa8\x04\\\x01 \x05B\x01\0\x01\x0f\x01\0\x01`\x01\x12\x01A\x01s\x01\x16\x01#\x01C\x01o\x01h\x01o\x01>\x05r\x01>\x05o\x01p\x01o\x015\x05C\x01\0\x01K\x014\x01N\x05;\x05V\x05W\x05\x1a\x01\xac\x05Z\x05A\x05\x03\x01<\x016\x01_\x058\x01%\x01A\x01B\x01\xd4\x04C\x01J\x01M\x05\r\x01A\x01B\x01\x1a\x01K\x01S\x05C\x01o\x01\x12\x01C\x01\0\x01Q\x01n\x05n\x01\\\x05\x1c\x01\x1d\x01]\x01^\x01H\x01`\x01a\x01d\x05E\x05U\x01(\x01h\x05\x83\x05)\x01\x13\x01e\x01m\x05\0\0V\x01\xfa\x04\0\x01\x1a\x01\x1b\x01o\x01s\x01o\x01\x16\x01\0\x01y\x05\\\x01\r\x01\x1b\x01o\x01=\x01\0\x01o\x01@\x01\x96\x05Z\x01\x0e\x05C\x01E\x01/\x010\x01\x89\x05\x1c\x01\x1d\x01K\x01\x17\x01p\x01\xa3\x05\x1a\x05\xab\x05\x1a\x01R\x01\x8f\x01=\x01%\x01)\x01\0\x01\x1a\x01$\x01r\x01D\x01E\x01\x17\x01G\x01\xa0\x05\xa1\x05\x04\x01b\x01c\x018\x01\b\x01`\x01\xa8\x053\x05\xbe\x05=\x01!\x01\x0f\x01@\x01n\x01\x12\x01\xcb\x05\xcc\x05E\x01\0\x01\xb0\x01C\x01A\x01\xb8\x05K\x01\x0e\x01\xbb\x05\xb7\x01%\x01\xb9\x01\xd3\x05R\x01\xc1\x05\xc2\x058\x01\xbf\x01\0\x01B\x01<\x01U\x01q\x01\0\x01@\x01A\x01B\x01\x1a\x01A\x01b\x01c\x01\0\x01\xce\x01\xcf\x01\xd5\x05\xea\x05\xe3\x03\xd8\x05\xd4\x01L\x01P\x01n\x01\xdd\x05\x16\x01\x1a\x01\xe0\x05C\x01\0\0a\x01\x1a\x01\xe5\x05\xe6\x05\xf3\x03\xe8\x05\xe9\x05B\x01]\x01\x1a\x01c\x01d\x01\x1b\x01H\x01a\x01\0\x01B\x01\x1b\x016\x01\x80\x058\x01\0\x01H\x01o\x01\xf6\x01\xf7\x01\xf8\x01V\x01u\x01A\x01B\x01\x04\x01\xfe\x01\x12\x01!\x01\b\x01V\x01\x92\x05\x0e\x01\x94\x05\x13\x01\x11\x01\x0f\x01a\x01\0\0\x12\x01\f\x02\x1a\x01\x0e\x02\x9e\x05\x16\x01\x1b\x01A\x01\x13\x02\x1b\x01\x15\x02\x16\x028\x01\x16\x01\0\x01\x1a\x02<\x01\x1c\x02L\x01_\x01@\x01A\x01B\x01/\x010\x01$\x02o\x01\xb5\x05\xb6\x05\0\x01o\x01(\x01`\x01\x13\x01\xbc\x05\x10\x01P\x01=\x01_\x01\n\x01\x1a\x01B\x015\x026\x02D\x01E\x01\x1b\x01G\x01o\x01C\x01=\x02\xcd\x05B\x01n\x01o\x01B\x02C\x02\x03\x01\xd4\x05\0\x01J\x01/\x010\x01C\x01\xda\x05L\x02M\x02o\x01\xde\x05\n\x01Q\x02K\x01o\x01\xe3\x05\xe4\x05=\x01\x04\x01`\x01R\x01n\x01\b\x01U\x01D\x01E\x01)\x02G\x01A\x01\x0f\x01-\x02q\x01\x12\x01A\x01o\x01p\x01\0\x01\x01\x01\x02\x01\x03\x01\0\x01\x1b\x01A\x01B\x01\b\x01\t\x01\n\x01o\x01\b\x01\r\x01\x0e\x01\x0e\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\0\0\x80\x02\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01B\x01C\x01D\x01q\x01_\x01o\x01$\x01%\x01A\x01B\x01(\x01)\x01*\x01+\x01^\x01C\x01\b\x01/\x010\x01n\x01o\x01B\x01C\x01\0\x01\x9f\x02C\x01D\x01\0\x01\x0e\x01\xa4\x02$\x01=\x01>\x01a\x01@\x01\x18\x02\x19\x02C\x01D\x01E\x01J\x01G\x01\x13\x01\x0e\x01J\x01K\x01\x13\x01\x16\x01\xb7\x02\x1a\x01o\x01\xba\x02R\x01\x1a\x01T\x01\\\x01\x16\x01\x1b\x01\xc1\x02\0\x01\xc3\x02\xc4\x02a\x01]\x01^\x01a\x01`\x01a\x01b\x01c\x01/\x010\x01\xcf\x02`\x01/\x01i\x01\xd3\x02k\x01\x13\x01\0\x01n\x01A\x01\xd9\x02q\x01=\x01\x1a\x01\0\x01u\x01=\x01\x03\x01\0\0D\x01E\x01o\x01G\x01D\x01E\x01i\x01G\x01\r\x01\x0e\x01^\x01o\x01^\x01B\x01^\x01/\x01\xf2\x02\xf3\x02`\x01u\x01\x1b\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01u\x01\x14\x01.\x01\x0e\x01=\x01A\x01\x16\x01?\x01\x03\x03Q\x01(\x01)\x01E\x01A\x01G\x01\0\x01\x0b\x03\x0e\x01\r\x03\x04\x01q\x01\x0e\x01\x16\x01\b\x01q\x01\n\x01\x02\x01J\x01\x17\x03\x0e\x01\x0f\x01=\x01\x1b\x03\x12\x01@\x01L\0B\x01C\x01D\x01E\x01u\x01`\x01\x1b\x01J\x01f\x01K\x016\x017\x018\x019\x01\x0f\x01\0\0R\x01B\x01^\x01A\x01q\x01A\x01B\x01\\\x01J\x01f\x01`\x01A\x01^\x01^\x01`\x01l\0b\x01c\x01A\x03A\x01\b\x01\x0e\x01\0\x01\x1b\x01X\x01\x1b\x01\x1b\x01\x1e\x01n\x01A\x01C\x01q\x01A\x01~\0\x0e\x01u\x01^\x01J\x01o\x01\x03\x01\x85\0\x13\x01\0\0Z\x03\x0e\x01X\x011\x01^\x03\x1a\x01`\x03a\x03o\x01A\x01\x06\x01e\x03n\x01]\x01^\x01J\x01`\x01a\x01o\x01A\x01B\x01\x1b\x01p\x03a\x01`\x01s\x03/\x010\x01g\x01\x1b\x01\x0e\x01`\x01A\x01`\x01|\x03s\x01(\x01\0\x01Z\x01\x15\x01=\x01\x04\x01\x84\x03A\x01\x1b\x01\b\x01\x88\x03\n\x01E\x01\x8b\x03G\x01\x0e\x01\x0f\x01A\x01?\x01?\x01\x10\x01g\x01\r\x01\x95\x03?\x01\x0e\x01l\x01\x03\x01\x1b\x01o\x016\x017\x018\x019\x01\x0e\x01\xa1\x03B\x01\x1c\x01\x1d\x01A\x01\x1b\x01A\x01B\x01\xd7\0`\x01\xab\x03J\x01f\x016\x01`\x01)\x01J\x01\b\x01\x16\x01\0\0`\x01q\x01\x10\x01`\x01\xb9\x03\xba\x03L\x01\xbc\x03L\x01\xbe\x03\xbf\x03\x1b\x01`\x01C\x01\x07\0=\x01J\x01\x1b\x01\x0e\x01\x14\x01J\x01Z\x01\0\x01E\x01r\x01`\x01\xcf\x03J\x01\xd1\x03K\x01\x17\0`\x01o\x01A\x01r\x01\x1c\0R\x01\x0e\x01]\x01]\x01^\x01\x13\x01`\x01a\x01\0\x01\xe2\x03\xe3\x03\x03\x01\x1a\x01J\x01\xe7\x03\xe8\x03b\x01\xea\x03\x15\x01\x0e\x01\x0e\x01\r\x01\x0e\x01\x0e\x01\x0e\x01s\x01\xf3\x03\x1b\x01n\x01\xf6\x03\x13\x01q\x01Z\x01/\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\x01\0\x02\0\x03\0\x04\0\x05\0\x06\0\x07\0r\x01\x0e\x01=\x01(\x01)\x01\x1b\x01]\x01\x0e\x01\x0e\x04D\x01E\x01\x16\x01G\x01\x0f\x01\x0e\x01\0\0\x0e\x01\x17\x04a\x01\0\0\0\0o\x01b\x01b\x01=\x01^\x01o\x01@\x01\b\x01#\x04R\x01D\x01E\x01A\x01^\x01$\x01\\\x01$\x01K\x01^\x01\0\x01/\x04,\x01-\x01.\x01R\x01`\x01J\x01\b\x017\x046\x01A\x01\x16\x01\r\x01q\x01A\x01A\x01^\x016\x01`\x01B\x04b\x01c\x01E\x04]\x01G\x04\x1a\x01I\x04\x1c\x01\x1d\x01H\x01I\x01\x92\0n\x01A\x01A\x01q\x01S\x04T\x04U\x04u\x01)\x01A\x01U\x01V\x01W\x01X\x01A\x01\xa2\0\xa3\0\xa4\0\xa5\0\xa6\0A\x01\xa8\0\x93\x01\r\x01g\x04h\x04\x80\0f\x01=\x01l\x04\x1c\x04\xb2\0\xb3\0\xde\x04C\x01D\x01E\x01Z\x04\x1c\x01\x1d\x01V\x04\x8e\x01K\x01\x80\x05X\x058\x05\xab\x01\xc7\x03\t\x03R\x018\x01)\x01:\x01;\x01<\x01\x86\x04>\x01`\x02\xa4\x01A\x01B\x01\xd0\0\xd1\0\x82\x01\xff\x01b\x01\xd5\0\x92\x04\x93\x04a\x02\xcf\x03=\x01=\x02\xd2\x02@\x01\xa6\0b\x04n\x01c\0E\x01q\x01f\x03\xc0\x05\xbc\x04\x1f\x04K\x01\\\x01\x12\x05\xcf\x01\xa8\x04\xff\xff\0\0R\x01c\x01\xc6\x04\xae\x04\x07\0\xbc\x02\xff\xff\xff\xff\x0b\0\0\x01\xff\xff\xff\xff\x03\x01o\x01p\x01\xff\xffb\x01c\x01\xff\xff\xbe\x04\xbf\x04\xff\xff\r\x01\xff\xff\xff\xff\x1c\0\x11\x01\xff\xffn\x01\xc8\x04\xff\xff\x16\x01\xcb\x04\xff\xff\xff\xff\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xd2\x04\xff\xff\xd4\x04\xff\xff\xff\xff\xff\xff0\0\xd9\x04\xff\xff\xdb\x04\xdc\x04)\x01\xde\x04\xff\xff\xff\xff\xff\xff\xff\xff\xe3\x04\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xef\x044\x01=\x01\xff\xff\xff\xff@\x01\xff\xffB\x01C\x01D\x01E\x01\xfa\x04S\0\xff\xffU\0V\0K\x01\xff\xffE\x01\xff\xff\xff\xffH\x01\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x0e\x05\xff\xff\xff\xff\xff\xff^\x01\xff\xff`\x01\0\x01b\x01c\x01\xff\xff\x04\x01\x1a\x05\xff\xff\x1c\x05\b\x01\xff\xff\n\x01\xff\xffO\x02n\x01\x0e\x01\0\x01q\x01T\x02\x12\x01(\x05u\x01*\x05o\x01\xff\xff\xff\xff\xff\xff\xff\xff\x1b\x01\xff\xff\xff\xff3\x05\xff\xff\xff\xff\xff\xff\x13\x01|\x01\xff\xff\0\0\xff\xff\xff\xff\xff\xff\x1a\x01?\x05@\x05\xff\xff\xff\xff\xff\xff\xff\xffE\x05\xff\xff\xff\xff\xff\xffI\x05\xa2\0\xa3\0\xff\xff\xa5\0\xa6\0\xff\xff\xa8\0\x7f\x02\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xffX\x05\xff\xff\xb2\0\xb3\0\xff\xff\xff\xff\xff\xffJ\x01\xa4\x01=\x01\xff\xff\xff\xff\xbc\0\xff\xff\xff\xff\xff\xff\xff\xffE\x01\xff\xffG\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xa2\x02`\x01a\x01\xff\xff\xd0\0\xd1\0\xff\xff\xff\xff\xff\xff\xff\xff~\x05\xff\xff\x80\x05\x81\x05\xda\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffs\x01\xff\xff\xff\xff\xff\xff\xd0\x01\xff\xff\xff\xff\xff\xff\xd4\x01\xff\xff\x92\x05\xff\xff\x94\x05q\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x9e\x05\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\x01\xff\xff\xff\xff\x03\x01\xff\xff\xff\xff\xff\xff\xb1\x05\xf6\x01\xf7\x01\xf8\x01\xb5\x05\xb6\x05\r\x01\xff\xff\xff\xff\xfe\x01\xff\xff\xbc\x05\0\x01\xff\xff\xff\xff\xc0\x05\x05\x02\xff\xff\xff\xff\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\r\x02\xff\xff\xff\xff\0\0\xcd\x05&\x01\xfd\x02\x13\x01\x15\x02\x16\x02)\x01\xd4\x05\xff\xff\x1a\x02\x1a\x01\x1c\x02\xff\xff\xda\x05\xff\xff\xff\xff\xff\xff\xde\x05\xff\xff$\x02\xff\xff:\x01\xe3\x05\xe4\x05)\x02\xff\xff=\x01\xff\xff-\x02\xff\xff\xff\xff/\x01\xff\xffD\x01E\x01\xff\xff\xff\xff6\x02\0\0\xff\xffK\x01\xff\xff\xff\xff\xff\xff=\x02=\x01\x06\x01R\x01\b\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xffG\x01\xff\xff\xff\xff5\x03\xff\xffM\x02`\x01\xff\xffb\x01Q\x02\xff\xff\xff\xff\xff\xff\xff\xff@\x03\xff\xffB\x03\xff\xff\xff\xffo\x01n\x01\xff\xff\xff\xffq\x01`\x02\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff}\x01~\x01\xff\xff\xff\xff\x81\x01\xff\xff\x83\x01\xff\xff8\x01q\x01:\x01;\x01<\x01\xff\xff>\x01\xff\xff\xff\xffA\x01B\x01\xff\xffg\x03\0\x01\xff\xff\x80\x02\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\xff\xff\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\xff\xff\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01~\x03\\\x01\x18\x01\x19\x01\x1a\x01\x83\x03\x1c\x01\x1d\x01c\x01\xff\xff\xff\xff\xff\xff\xa0\x02\xff\xff\xff\xff%\x01\xff\xff\xff\xff(\x01)\x01o\x01p\x01\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xd4\x01\xff\xffD\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xcf\x02R\x01\xbb\x03\xd2\x02\xd3\x02\xff\xff\xff\xff\xc0\x03\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xf6\x01\xf7\x01\xf8\x01\xff\xff\xff\xffi\x01\xff\xffk\x01\xfe\x01\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xf2\x02u\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\r\x02\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x15\x02\x16\x02\x03\x03\xff\xff\xef\x03\x1a\x02\xff\xff\x1c\x02\xff\xff\xff\xff\x0b\x03\xff\xff\r\x03\xff\xff\xff\xff\0\x01\0\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x17\x03\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\r\x01\xff\xff\xff\xff\xff\xff\0\x006\x02\xff\xff\x13\x01\xff\xff\xff\xff\xff\xff\xff\xff=\x02\x1a\x01\x1a\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff4\x03\xff\xff \x04\0\x01\xff\xff)\x01\xff\xff\x04\x01&\x04Q\x02\xff\xff\b\x01/\x01\n\x01\xff\xff\xff\xff\xff\xff\x0e\x01\xff\xff\xff\xff\xff\xff\x12\x01\xff\xff\xff\xff`\x02=\x01=\x01\xff\xff@\x01\xff\xff\x1b\x01\xff\xff\xff\xffE\x01E\x01\xff\xffG\x01\xff\xffZ\x03K\x01\xff\xff\xff\xff\xff\xff\xff\xff`\x03a\x03R\x01\xff\xff\xff\xff\xff\xff\x07\0\xff\xff\xff\xff\xff\xff\x0b\0\xff\xff\x80\x02\xff\xff^\x01\xff\xff\xff\xff\xff\xffb\x01s\x03\xff\xff\xff\xffv\x03\xff\xff\xff\xffc\x04C\x01\x1c\0\xff\xff\xff\xffn\x01\xff\xff\xff\xffJ\x01q\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff0\0\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01\x99\x03\xff\xff\x85\x04\xff\xff\x87\x04\xff\xff\x89\x04\xff\xff\xff\xff\x8c\x04\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffs\x01\xab\x03\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x9b\x04S\0\xff\xffU\0V\0\xff\xff\xff\xff\0\x01\xff\xff\xba\x03\xcf\x02\xbc\x03\xff\xff\xff\xff\xd3\x02\xff\xff\xff\xff\xac\x04\xad\x04\xff\xff\r\x01\xff\xff8\x01\xb2\x04:\x01;\x01<\x01\xff\xff>\x01\xff\xff\xcf\x03A\x01B\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xf2\x02P\x01\xff\xff)\x01S\x01\xe3\x03\xce\x04\xff\xff\xff\xff\xe7\x03\x89\0\xff\xff[\x01\\\x01\xff\xff\xff\xff\xff\xff\x03\x03\xff\xff\xff\xffc\x01\xf3\x03\xff\xff=\x01\xff\xff\x0b\x03\xff\xff\r\x03\xff\xffC\x01D\x01E\x01o\x01p\x01\xff\xff\xa2\0\xa3\0K\x01\xa5\0\xa6\0\xff\xff\xa8\0\xff\xff\xff\xffR\x01\x07\0\xff\xff\xff\xff\x0e\x04\xff\xff\xff\xff\xb2\0\xb3\0\xff\xff\x10\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffb\x01\xbc\0\xff\xff\x1d\x04\xff\xff\xff\xff\xff\xff\0\x01\xff\xff\xff\xff\x03\x01\xff\xffn\x01\xff\xff\x12\x05q\x01\xff\xff\xff\xff\xff\xff\xff\xff\r\x01\xd0\0\xd1\0\xff\xff\x11\x013\x04\xff\xff\xff\xff \x05\x16\x01\xff\xff\xda\0\xff\xff\x1a\x01\x1b\x01\x1c\x01\x1d\x01\0\0\xff\xff\xff\xff\xff\xff\xff\xff.\x05\xff\xff\xff\xff1\x05\xff\xff\xff\xff)\x01\xff\xff`\x03a\x03\xff\xff\xff\xff\xff\xff\xff\xff\0\x01S\x04\xff\xffU\x04\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xffB\x01C\x01D\x01E\x01g\x04d\0\xff\xff\xff\xffU\x05K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0^\x01\xff\xff`\x01\xff\xffb\x01c\x01&\x01\x86\x04\xff\xff\xff\xff\xff\xff8\x01\xff\xff:\x01;\x01<\x01n\x01>\x01`\0q\x01A\x01B\x01\xff\xffu\x01\xab\x03\xff\xff:\x01\x84\x05\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffS\x01\xa2\0\xa3\0\xbc\x03\xa5\0\xa6\0\xff\xff\xa8\0[\x01\\\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffc\x01\xb2\0\xb3\0\xff\xff\xff\xff\xff\xff\xcf\x03\xff\xff\xa7\x05\xa8\x05\xff\xffn\x01o\x01p\x01\x07\0\xff\xff\xaf\x05\0\x01\xff\xff\xc8\x04\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffo\x01\xe3\x03\xff\xff\xff\xff\xff\xff\xff\xff\xd0\0\xd1\0\r\x01\xff\xff\xff\xff\xd9\x04\0\x01\xff\xff}\x01~\x01\xde\x04\xf3\x03\x81\x01\xff\xff\x83\x01\xe3\x04\xff\xff\x1c\x01\x1d\x01\r\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xef\x04\xff\xff\xff\xff)\x01\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\xe2\x05\xff\xff\x0e\x04\xff\xff\xff\xff\xff\xff8\x01\xff\xff:\x01;\x01<\x01)\x01>\x01\xff\xff=\x01A\x01B\x01@\x01\xff\xff\0\0\xff\xff\xff\xffE\x01\xb0\x01\xff\xff\xff\xff\xff\xff\xff\xffK\x01\xff\xff\xb7\x01=\x01\xb9\x01S\x01@\x01R\x01\x1c\x05\xff\xffD\x01E\x01\xff\xff[\x01\\\x01\xff\xff\xff\xffK\x01\xff\xff\xff\xff\xff\xffc\x01\xff\xffb\x01R\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xd4\x01\xff\xffo\x01p\x01n\x01^\x01\xff\xff\xff\xff\xff\xffb\x01c\x01\xff\xffS\x04\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffE\x05Z\x04G\x05n\x01\xff\xff\xff\xffq\x01\r\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffg\x04\xff\xff\xf6\x01\xf7\x01\xf8\x01X\x05\xff\xffV\x01\x1c\x01\x1d\x01\xfe\x01\xa2\0\xa3\0\xff\xff\xa5\0\xa6\0\xff\xff\xa8\0\xff\xff\xff\xffg\x05)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xb2\0\xb3\0\xff\xff\xff\xff\0\0o\x01\x15\x02\x16\x02\xff\xff\xff\xff\xff\xff\x1a\x02\xff\xff\x1c\x02=\x01\x06\x01\0\x01@\x01\xff\xff\x03\x01\xff\xff\xff\xffE\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffK\x01\r\x01\xd0\0\xd1\0\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff6\x02\xff\xff\xff\xff\x1a\x01\x1b\x01\x1c\x01\x1d\x01=\x02\xff\xff\xff\xff\x9f\x05\xff\xffb\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffn\x01\xff\xff8\x01Q\x02:\x01;\x01<\x01\xc8\x04>\x01\xff\xff\xff\xffA\x01B\x01\xff\xff=\x01\xff\xff\xff\xff@\x01`\x02\x8f\x01C\x01D\x01E\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffK\x01\xde\x04\xff\xff\x0f\x01\xff\xff\xff\xff\xff\xffR\x01\xe5\x04\xff\xff\\\x01\xff\xff\xff\xff\xff\xff\xff\xff\xd4\x01\xff\xffc\x01\xef\x04^\x01\xff\xff`\x01\x80\x02b\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xffo\x01p\x01+\x01,\x01-\x01.\x01n\x01\xff\xff\xff\xffq\x01\xff\xff\xc0\x01\xff\xffu\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xf5\x01\xf6\x01\xf7\x01\xf8\x01\xcc\x01\xff\xff\xff\xffC\x01\xff\xff\xfe\x01\xff\xff\0\x01H\x01I\x01\xff\xff\x1c\x05\xff\xff\xff\xff\0\x01\xff\xff\xff\xff\x03\x01\xff\xff\xff\xff\xff\xffU\x01V\x01W\x01X\x01\xb7\x02\0\0\r\x01\x15\x02\x16\x02\xff\xff\xff\xff\xff\xff\x1a\x02\xff\xff\x1c\x02\xff\xff\xff\xfff\x01\xff\xff\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xffo\x01(\x02\xff\xff\xcf\x02\xff\xff\xff\xff\xff\xff\xd3\x02\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff6\x02\xff\xff8\x01\xff\xff:\x01;\x01<\x01=\x02>\x01\xff\xffX\x05A\x01B\x01\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xf2\x02\xff\xffg\x05\xff\xffQ\x02K\x01S\x01\xff\xff\xff\xff\0\0\xff\xff\xff\xffR\x01\xff\xff[\x01\\\x01\xff\xff\x03\x03\xff\xff\xff\xff\xff\xff\xff\xffc\x01\xff\xff^\x01\x0b\x03`\x01\r\x03b\x01c\x01\xff\xff\x06\x01\xff\xff\0\x01o\x01p\x01\xff\xff\xff\xff\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01L\x02\xff\xff\r\x01u\x01\xff\xff\xff\xff\xff\xff\x80\x02\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x9f\x05\x1a\x01\xff\xff\x1c\x01\x1d\x01\xd4\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff8\x01\xff\xff:\x01;\x01<\x01\0\0>\x01\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff=\x01\xff\xff\xff\xff\xf6\x01\xf7\x01\xf8\x01\xff\xffD\x01E\x01\xff\xff\xff\xff\xfe\x01\xff\x01\xff\xffK\x01\xff\xff`\x03a\x03\xff\xff\xff\xff\xff\xffR\x01\xff\xff\\\x01\xff\xff\xff\xff\xff\xff\0\x01\xff\xff\xff\xffc\x01\xff\xff\xff\xff\x9f\x02\x15\x02\x16\x02\xcf\x02b\x01\xff\xff\x1a\x02\xd3\x02\x1c\x02o\x01p\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xff\x88\x03\xff\xff\xff\xff\xff\xff\xff\xff\x8d\x03\xff\xff\xff\xff\x1e\0\x1f\0\xff\xff6\x02\xff\xff\xff\xff\xff\xff\xf2\x02\xff\xff\xff\xff=\x02\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff8\x01\xff\xff:\x01;\x01<\x01\x03\x03>\x01\xff\xff\xab\x03A\x01B\x01Q\x02\xff\xff\x0b\x03\xff\xff\r\x03\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\x01\xff\xff\xff\xff\x03\x01\xbc\x03\xff\xffS\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\r\x01[\x01\\\x01\xff\xffW\0X\0\xff\xff\xff\xff\xff\xffc\x01\xcf\x03\xff\xff\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xffo\x01p\x01\xff\xff\x80\x02\xff\xff\xff\xff\xff\xff)\x01\xff\xff\xe3\x03\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1b\x03\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xf3\x03\0\0=\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\x01\xff\xffE\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xffK\x01\xff\xff`\x03a\x03\xff\xff\r\x017\x03R\x01\xff\xff\xff\xff\xff\xff\x0e\x04\xff\xff\xff\xff\xff\xff\xff\xffA\x03\xff\xff\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xffb\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff)\x01\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\x86\x03\xcf\x02-\x04\xff\xff\xff\xff\xd3\x02\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffp\x03\xff\xff\xff\xffE\x04K\x01\x06\x01\0\x01\b\x01\xff\xff\xff\xff\xff\xffR\x01|\x03\xf2\x02\xab\x03\xff\xff\xff\xffS\x04\xff\xff\r\x01\x84\x03\xff\xff\xff\xff^\x01Z\x04`\x01\xff\xffb\x01c\x01\xff\xff\x03\x03\xbc\x03\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xffg\x04\x0b\x03n\x01\r\x03\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01)\x01\xff\xff\xff\xff\xcf\x03\xff\xff\xff\xff\xff\xff\xff\xff8\x01\xff\xff:\x01;\x01<\x01\xac\x03>\x01\xff\xff\xff\xffA\x01B\x01\xff\xff=\x01\xff\xff\xff\xff\xe3\x03\xff\xff\xff\xff\xb9\x03\xff\xffE\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffK\x01S\x01\xff\xff\xff\xff\xff\xff\xf3\x03\xff\xffR\x01\xff\xff[\x01\\\x01\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xd1\x03c\x01\xff\xff\xd4\x03\xd5\x03\xff\xff\xff\xffb\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffo\x01p\x01\xff\xff\x0e\x04\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xff`\x03a\x03\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xc8\x04W\x01X\x01Y\x01Z\x01[\x01\\\x01]\x01^\x01_\x01`\x01a\x01b\x01c\x01d\x01e\x01f\x01g\x01h\x01i\x01j\x01k\x01\xde\x04m\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xe5\x04\xff\xff\xff\xff\xff\xff\x17\x04\xff\xff\xff\xff\xff\xff{\x01\xff\xff\xef\x04\xff\xff\xff\xff\xff\xff\xff\xff\0\x01#\x04\x02\x01\x03\x01S\x04\x87\x01\xff\xff\xff\xff\b\x01\xff\xff\xff\xff\xff\xff\xff\xff\r\x01\xff\xff\xff\xff\xff\xff\x11\x01\x12\x01\x13\x01\xab\x03\xff\xff\xff\xff\xff\xffg\x04\xff\xff\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xffB\x04\xff\xff\xff\xff\xff\xff$\x01\xbc\x03\xff\xff\xff\xff\x1c\x05)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xcf\x03\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01\xff\xff\xff\xff\xff\xffK\x01\xe3\x03\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xf3\x03]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01X\x05\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\x0e\x04\xff\xff\xc8\x04\xff\xff\xff\xff\xff\xff\xff\xff8\x01\xff\xff:\x01;\x01<\x01\xa5\x04>\x01\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\xae\x04\xff\xff\xff\xff\xde\x04\xff\xff\xb3\x04\xb4\x04\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffS\x01\xff\xff\xff\xff\xbe\x04\xff\xff\xff\xff!\x02\xef\x04[\x01\\\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff*\x02c\x01\0\x01\xff\xff.\x02\x03\x01\xff\xff1\x02\xff\xff\xff\xff\b\x01\xff\xff\n\x01o\x01p\x01\r\x01\x0e\x01\xdb\x04\xff\xff\x11\x01S\x04\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\0\0\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1c\x05\xff\xff%\x01g\x04\xf3\x04(\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffb\x02c\x02\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x88\x02]\x01^\x01X\x05`\x01a\x01b\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffi\x01\xff\xffk\x018\x05\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff?\x05\xff\xffu\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffI\x05\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff8\x01\xc8\x04:\x01;\x01<\x01\0\x01>\x01\xff\xff\x03\x01A\x01B\x01\xff\xff\xff\xff\b\x01\xff\xff\n\x01\xff\xff\0\0\r\x01\x0e\x01\xff\xff\xff\xff\x11\x01\xde\x04\x13\x01\x14\x01\x15\x01S\x01\xff\xff\x18\x01\x19\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01[\x01\\\x01\xff\xff\xff\xff\xff\xff\xef\x04\xff\xff%\x01c\x01~\x05(\x01)\x01\x81\x05\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xe8\x02o\x01p\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\x1c\x05\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xb1\x05\x12\x03\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff6\x03\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffX\x05\xff\xff\xff\xff\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\x06\x01\x07\x01\b\x01\t\x01\n\x01\x0b\x01\f\x01\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\x16\x01\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xffn\x03(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x011\x012\x013\x014\x01\xff\xff6\x017\x018\x019\x01\xff\xff\xff\xff<\x01=\x01>\x01?\x01@\x01A\x01B\x01C\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xffM\x01N\x01\xff\xff\xff\xff\xff\xffR\x01S\x01T\x01U\x01V\x01W\x01X\x01Y\x01\xff\xff[\x01\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01d\x01\xff\xfff\x01g\x01\xff\xffi\x01j\x01k\x01l\x01\0\0n\x01o\x01\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\x04\x01\xff\xff\x06\x01\x07\x01\b\x01\t\x01\n\x01\x0b\x01\f\x01\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xda\x03\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x011\x012\x013\x014\x01\xff\xff6\x017\x018\x019\x01\xff\xff\xff\xff<\x01=\x01>\x01\xff\xff@\x01A\x01B\x01C\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xffM\x01N\x01\xff\xff\xff\xff\xff\xffR\x01S\x01T\x01U\x01V\x01W\x01X\x01Y\x01\xff\xff[\x01\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01d\x01\xff\xfff\x01g\x01\0\0i\x01j\x01k\x01l\x01\xff\xffn\x01o\x01\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\xff\xff\xff\xff\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xffr\x04\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01~\x04\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01U\x01V\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\0\0\xff\xfff\x01\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xaf\x04\xb0\x04\xb1\x04u\x01\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\x06\x01\x07\x01\b\x01\t\x01\n\x01\x0b\x01\f\x01\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\x16\x01\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x011\x012\x013\x014\x01\xff\xff6\x017\x018\x019\x01\xff\xff\xff\xff<\x01=\x01>\x01\xff\xff@\x01A\x01B\x01C\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xffM\x01N\x01\xff\xff\xff\xff\xff\xffR\x01S\x01T\x01U\x01V\x01W\x01X\x01Y\x01\xff\xff[\x01\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01d\x01\0\0f\x01g\x01\xff\xffi\x01j\x01k\x01l\x01\xff\xffn\x01o\x01\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\x04\x01\xff\xff\x06\x01\x07\x01\b\x01\t\x01\n\x01\x0b\x01\f\x01\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x011\x012\x013\x014\x01\xff\xff6\x017\x018\x019\x01\xff\xff\xff\xff<\x01=\x01>\x01\xff\xff@\x01A\x01B\x01C\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xffM\x01N\x01\xff\xff\xff\xff\xff\xffR\x01S\x01T\x01U\x01V\x01W\x01X\x01Y\x01\xff\xff[\x01\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01d\x01\0\0f\x01g\x01\xff\xffi\x01j\x01k\x01l\x01\xff\xffn\x01o\x01\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\x06\x01\x07\x01\b\x01\t\x01\n\x01\x0b\x01\f\x01\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\x16\x01\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x011\x012\x013\x014\x01\xff\xff6\x017\x018\x019\x01\xff\xff\xff\xff<\x01=\x01>\x01\xff\xff@\x01A\x01B\x01C\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xffM\x01N\x01\xff\xff\xff\xff\xff\xffR\x01S\x01T\x01U\x01V\x01W\x01X\x01Y\x01\xff\xff[\x01\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01d\x01\0\0f\x01g\x01\xff\xffi\x01j\x01k\x01l\x01\xff\xffn\x01o\x01\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\x06\x01\x07\x01\b\x01\t\x01\n\x01\x0b\x01\f\x01\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\x16\x01\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x011\x012\x013\x014\x01\xff\xff6\x017\x018\x019\x01\xff\xff\xff\xff<\x01=\x01>\x01\xff\xff@\x01A\x01B\x01C\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xffM\x01N\x01\xff\xff\xff\xff\xff\xffR\x01S\x01T\x01U\x01V\x01W\x01X\x01Y\x01\xff\xff[\x01\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01d\x01\0\0f\x01g\x01\xff\xffi\x01j\x01k\x01l\x01\xff\xffn\x01o\x01\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\x06\x01\x07\x01\b\x01\t\x01\n\x01\x0b\x01\f\x01\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\x16\x01\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x011\x012\x013\x014\x01\xff\xff6\x017\x018\x019\x01\xff\xff\xff\xff<\x01=\x01>\x01\xff\xff@\x01A\x01B\x01C\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xffM\x01N\x01\xff\xff\xff\xff\xff\xffR\x01S\x01T\x01U\x01V\x01W\x01X\x01Y\x01\xff\xff[\x01\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01d\x01\0\0f\x01g\x01\xff\xffi\x01j\x01k\x01l\x01\xff\xffn\x01o\x01\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\0\x01\x01\x01\x02\x01\x03\x01\x04\x01\xff\xff\x06\x01\x07\x01\b\x01\t\x01\n\x01\x0b\x01\f\x01\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x011\x012\x013\x014\x01\xff\xff6\x017\x018\x019\x01\xff\xff\xff\xff<\x01=\x01>\x01\xff\xff@\x01A\x01B\x01C\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xffM\x01N\x01\xff\xff\xff\xff\xff\xffR\x01S\x01T\x01U\x01V\x01W\x01X\x01Y\x01\xff\xff[\x01\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01\xff\xff\xff\xff\0\0f\x01g\x01\xff\xffi\x01j\x01k\x01l\x01\xff\xffn\x01o\x01\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\x04\x01\xff\xff\x06\x01\x07\x01\b\x01\t\x01\n\x01\x0b\x01\f\x01\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x011\x012\x013\x014\x01\xff\xff6\x017\x018\x019\x01\xff\xff\xff\xff<\x01=\x01>\x01\xff\xff@\x01A\x01B\x01C\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xffM\x01N\x01\xff\xff\xff\xff\xff\xffR\x01S\x01T\x01U\x01V\x01W\x01X\x01Y\x01\xff\xff[\x01\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01\0\0\xff\xff\xff\xfff\x01g\x01\xff\xffi\x01j\x01k\x01l\x01\xff\xffn\x01o\x01\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\x04\x01\xff\xff\x06\x01\x07\x01\b\x01\t\x01\n\x01\x0b\x01\f\x01\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x011\x012\x013\x014\x01\xff\xff6\x017\x018\x019\x01\xff\xff\xff\xff<\x01=\x01>\x01\xff\xff@\x01A\x01B\x01C\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xffM\x01N\x01\xff\xff\xff\xff\xff\xffR\x01S\x01T\x01U\x01V\x01W\x01X\x01Y\x01\xff\xff[\x01\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01\0\0\xff\xff\xff\xfff\x01g\x01\xff\xffi\x01j\x01k\x01l\x01\xff\xffn\x01o\x01\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\x16\x01\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x01\xff\xff\xff\xff\xff\xff4\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01S\x01T\x01U\x01V\x01W\x01X\x01\xff\xff\xff\xff[\x01\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01d\x01\0\0f\x01\xff\xff\xff\xffi\x01j\x01k\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\x16\x01\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x01\xff\xff\xff\xff\xff\xff4\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01S\x01T\x01U\x01V\x01W\x01X\x01\xff\xff\xff\xff[\x01\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01d\x01\0\0f\x01\xff\xff\xff\xffi\x01j\x01k\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01U\x01V\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01\xff\xff\0\0\xff\xfff\x01\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\xff\xff\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01U\x01V\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\0\0\xff\xfff\x01\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01U\x01V\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01\xff\xff\0\0\xff\xfff\x01\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01U\x01V\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01\xff\xff\0\0\xff\xfff\x01\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01U\x01V\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01\0\0\xff\xff\xff\xfff\x01\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01U\x01V\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01\0\0\xff\xff\xff\xfff\x01\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01U\x01V\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\0\0\xff\xfff\x01\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01U\x01V\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\0\0\xff\xfff\x01\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01U\x01V\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\0\0\xff\xfff\x01\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01U\x01V\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\0\0\xff\xfff\x01\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01U\x01V\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\0\0\xff\xfff\x01\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01U\x01V\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\0\0\xff\xfff\x01\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01U\x01V\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\0\0\xff\xfff\x01\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01\xff\xffV\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\0\0\xff\xff\xff\xff\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01\xff\xffV\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\0\0\xff\xff\xff\xff\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01\xff\xffV\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\0\0\xff\xff\xff\xff\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01\xff\xffV\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\0\0\xff\xff\xff\xff\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01\xff\xffV\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\0\0\xff\xff\xff\xff\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01\xff\xffV\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\0\0\xff\xff\xff\xff\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff\xff\xff\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01U\x01\xff\xff\xff\xffX\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\0\0\xff\xfff\x01\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\xff\xff\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\0\0\xff\xff\xff\xff\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\xff\xff\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\0\0\xff\xff\xff\xff\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\xff\xff\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\xff\xff\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xffR\x01\xff\xffT\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\xff\xff\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xff\0\0D\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffi\x01\0\x01k\x01\xff\xff\x03\x01n\x01\xff\xff\xff\xffq\x01\b\x01\t\x01\n\x01u\x01\xff\xff\r\x01\x0e\x01\xff\xff\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff%\x01\xff\xff\xff\xff(\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xff\0\0D\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\0\x01\xff\xffq\x01\x03\x01\xff\xff\xff\xffu\x01\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\xff\xff\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff%\x01\xff\xff\xff\xff(\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\0\0\xff\xff@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffi\x01\0\x01k\x01\xff\xff\x03\x01n\x01\xff\xff\xff\xffq\x01\b\x01\xff\xff\n\x01u\x01\xff\xff\r\x01\x0e\x01\xff\xff\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff%\x01\xff\xff\xff\xff(\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffi\x01\0\x01k\x01\xff\xff\x03\x01n\x01\xff\xff\xff\xffq\x01\b\x01\xff\xff\n\x01u\x01\xff\xff\r\x01\x0e\x01\xff\xff\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff%\x01\xff\xff\xff\xff(\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffi\x01\0\x01k\x01\xff\xff\x03\x01n\x01\xff\xff\xff\xffq\x01\b\x01\xff\xff\n\x01u\x01\xff\xff\r\x01\x0e\x01\xff\xff\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff%\x01\xff\xff\xff\xff(\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\0\x01\xff\xff\xff\xff\x03\x01i\x01\xff\xffk\x01\xff\xff\b\x01n\x01\n\x01\xff\xffq\x01\r\x01\x0e\x01\xff\xffu\x01\x11\x01\xff\xff\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff%\x01\xff\xff\xff\xff(\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\0\x01\xff\xff\xff\xff\x03\x01i\x01\xff\xffk\x01\xff\xff\b\x01n\x01\n\x01\xff\xffq\x01\r\x01\x0e\x01\xff\xffu\x01\x11\x01\xff\xff\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff%\x01\xff\xff\xff\xff(\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffi\x01\0\x01k\x01\xff\xff\x03\x01n\x01\xff\xff\xff\xffq\x01\b\x01\xff\xff\n\x01u\x01\xff\xff\r\x01\x0e\x01\xff\xff\xff\xff\x11\x01\xff\xff\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff%\x01\xff\xff\xff\xff(\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\0\x01\xff\xff\xff\xff\x03\x01i\x01\xff\xffk\x01\xff\xff\b\x01n\x01\n\x01\xff\xffq\x01\r\x01\x0e\x01\xff\xffu\x01\x11\x01\xff\xff\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff%\x01\xff\xff\xff\xff(\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\0\0@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xffG\x01\0\0\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\0\x01\xff\xff\xff\xff\x03\x01i\x01\xff\xffk\x01\xff\xff\b\x01n\x01\n\x01\xff\xffq\x01\r\x01\x0e\x01\xff\xffu\x01\x11\x01\xff\xff\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff%\x01\xff\xff\xff\xff(\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffi\x01\0\x01k\x01\xff\xff\x03\x01n\x01\xff\xff\xff\xffq\x01\b\x01\xff\xff\n\x01u\x01\xff\xff\r\x01\x0e\x01\xff\xff\xff\xff\x11\x01\xff\xff\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff%\x01\xff\xff\xff\xff(\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01\xff\xffb\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\0\x01q\x01\x02\x01\x03\x01\x04\x01u\x01\xff\xff\xff\xff\b\x01\0\x01\xff\xff\xff\xff\xff\xff\r\x01\xff\xff\xff\xff\xff\xff\x11\x01\x12\x01\x13\x01\xff\xff\xff\xff\r\x01\xff\xff\xff\xff\xff\xff\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1a\x01$\x01\x1c\x01\x1d\x01\xff\xff\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x018\x01)\x01:\x01;\x01<\x01\xff\xff>\x01\xff\xff\xff\xffA\x01B\x01\xff\xff=\x01\xff\xff\xff\xff@\x01A\x01\xff\xffC\x01D\x01E\x01=\x01G\x01\0\0@\x01J\x01K\x01\xff\xffD\x01E\x01\xff\xff\xff\xff\xff\xffR\x01\xff\xffK\x01\\\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01c\x01]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\xff\xfff\x01^\x01o\x01p\x01\xff\xffb\x01c\x01\xff\xffn\x01o\x01\xff\xffq\x01\xff\xff\0\x01\xff\xffu\x01\x03\x01n\x01\xff\xff\xff\xffq\x01\b\x01\xff\xff\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\xff\xff\xff\xff\x11\x01\xff\xff\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff%\x01\xff\xff\xff\xff(\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\0\x01q\x01\x02\x01\x03\x01\x04\x01u\x01\xff\xff\xff\xff\b\x01\xff\xff\xff\xff\xff\xff\xff\xff\r\x01\xff\xff\xff\xff\xff\xff\x11\x01\x12\x01\x13\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01\xff\xff\xff\xff\xff\xff\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\0\x01\xff\xff\x02\x01\x03\x01\x04\x01\xff\xff\xff\xff\xff\xff\b\x01n\x01\xff\xff\xff\xffq\x01\r\x01\xff\xff\xff\xffu\x01\x11\x01\x12\x01\x13\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01\xff\xff\xff\xff\xff\xff\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01\xff\xff\xff\xff\0\x01f\x01\x02\x01\x03\x01\x04\x01\xff\xff\xff\xff\xff\xff\b\x01n\x01\xff\xff\xff\xffq\x01\r\x01\xff\xff\xff\xffu\x01\x11\x01\x12\x01\x13\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01\xff\xff\xff\xff\xff\xff\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01\xff\xff\xff\xff\xff\xfff\x01\0\x01\xff\xff\x02\x01\x03\x01\x04\x01\xff\xff\xff\xffn\x01\b\x01\xff\xffq\x01\xff\xff\xff\xff\r\x01u\x01\xff\xff\xff\xff\x11\x01\x12\x01\x13\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01\xff\xff\xff\xff\xff\xff\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\0\x01\xff\xff\x02\x01\x03\x01\x04\x01\xff\xff\xff\xff\xff\xff\b\x01n\x01\xff\xff\xff\xffq\x01\r\x01\xff\xff\xff\xffu\x01\x11\x01\x12\x01\x13\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01\xff\xff\xff\xff\xff\xff\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01\xff\xff\xff\xff\xff\xffK\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\0\x01\xff\xff\x02\x01\x03\x01\x04\x01\xff\xff\xff\xff\0\0\b\x01n\x01\xff\xff\xff\xffq\x01\r\x01\xff\xff\xff\xffu\x01\x11\x01\x12\x01\x13\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01\xff\xff\xff\xff\xff\xff\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01\xff\xff\xff\xff\xff\xffK\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\xff\xff\xff\xff\0\x01\xff\xff\x02\x01\x03\x01\x04\x01\xff\xff\xff\xffn\x01\b\x01\xff\xffq\x01\xff\xff\xff\xff\r\x01u\x01\xff\xff\xff\xff\x11\x01\x12\x01\x13\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01\xff\xff\xff\xff\xff\xff\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\0\0G\x01\xff\xff\xff\xff\xff\xffK\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\0\x01\xff\xff\x02\x01\x03\x01\x04\x01\xff\xff\xff\xff\xff\xff\b\x01n\x01\xff\xff\xff\xffq\x01\r\x01\xff\xff\xff\xffu\x01\x11\x01\x12\x01\x13\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01\xff\xff\xff\xff\xff\xff\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\x01\xff\xff=\x01\x03\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01\r\x01\xff\xff\xff\xffK\x01\xff\xff\xff\xff\x13\x01\xff\xff\xff\xff\0\0R\x01\xff\xff\xff\xff\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\x01n\x01\xff\xff\x03\x01q\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\xff\xff=\x01\xff\xff\r\x01@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffK\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff)\x01\xff\xff\xff\xff^\x01\xff\xff`\x01\xff\xffb\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffn\x01=\x01\xff\xffq\x01@\x01\xff\xff\xff\xffu\x01D\x01E\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffK\x01\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff^\x01\xff\xff`\x01\xff\xffb\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\0\x01u\x01\xff\xff\x03\x01\xff\xff\x05\x01\x06\x01\x07\x01\b\x01\xff\xff\xff\xff\x0b\x01\f\x01\r\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x13\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff$\x01\xff\xff\xff\xff'\x01\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x011\x012\x013\x014\x015\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01=\x01\xff\xff\xff\xff@\x01A\x01B\x01\xff\xffD\x01E\x01F\x01G\x01H\x01I\x01\xff\xffK\x01L\x01M\x01N\x01\0\0P\x01\xff\xffR\x01S\x01\xff\xff\xff\xffV\x01W\x01\xff\xffY\x01\xff\xff[\x01\xff\xff]\x01^\x01_\x01\xff\xffa\x01b\x01c\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xffj\x01\xff\xffl\x01m\x01n\x01o\x01p\x01q\x01\xff\xff\xff\xfft\x01\x05\x01\x06\x01\x07\x01\xff\xff\xff\xff\xff\xff\x0b\x01\f\x01\r\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1c\x01\x1d\x01\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff\xff\xff\xff\xff\xff\xff'\x01\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01=\x01\xff\xff\xff\xff@\x01A\x01B\x01\xff\xff\xff\xffE\x01F\x01\xff\xffH\x01I\x01\xff\xffK\x01\xff\xffM\x01N\x01\xff\xffP\x01\0\0R\x01\xff\xff\xff\xff\xff\xffV\x01W\x01\xff\xffY\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffb\x01c\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01m\x01n\x01o\x01\x05\x01\x06\x01\x07\x01\xff\xfft\x01\xff\xff\x0b\x01\f\x01\r\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1c\x01\x1d\x01\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff\xff\xff\xff\xff\xff\xff'\x01\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01=\x01\xff\xff\xff\xff@\x01A\x01B\x01\xff\xff\xff\xffE\x01F\x01\xff\xffH\x01I\x01\xff\xffK\x01\xff\xffM\x01N\x01\xff\xffP\x01\xff\xffR\x01\xff\xff\xff\xff\xff\xffV\x01W\x01\0\0Y\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffc\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01m\x01n\x01o\x01\xff\xff\xff\xff\xff\xff\xff\xfft\x01\xff\xff\xff\xff\xff\xff\xff\xff\x05\x01\x06\x01\x07\x01\xff\xff\xff\xff\xff\xff\x0b\x01\f\x01\r\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1c\x01\x1d\x01\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff\xff\xff\xff\xff\xff\xff'\x01\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\x001\x012\x013\x01\xff\xff5\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01=\x01\xff\xff\xff\xff@\x01A\x01B\x01\xff\xff\xff\xffE\x01F\x01\xff\xffH\x01I\x01\xff\xffK\x01\xff\xffM\x01N\x01\xff\xffP\x01\xff\xffR\x01\xff\xff\xff\xff\xff\xffV\x01W\x01\xff\xffY\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffc\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\0\0l\x01m\x01n\x01o\x01\xff\xff\xff\xff\0\x01\xff\xfft\x01\xff\xff\x04\x01\xff\xff\x06\x01\xff\xff\b\x01\xff\xff\n\x01\xff\xff\f\x01\r\x01\x0e\x01\x0f\x01\xff\xff\x11\x01\x12\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1a\x01\x1b\x01\x1c\x01\x1d\x01\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff1\x012\x013\x014\x015\x016\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01=\x01\xff\xff\xff\xff@\x01A\x01B\x01C\x01D\x01E\x01\xff\xff\0\0H\x01\xff\xffJ\x01K\x01\xff\xffM\x01\xff\xff\xff\xff\xff\xff\xff\xffR\x01S\x01\xff\xff\xff\xffV\x01\xff\xff\xff\xff\xff\xff\xff\xff[\x01\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xffj\x01\xff\xffl\x01\xff\xffn\x01o\x01p\x01\xff\xff\0\x01s\x01\xff\xff\xff\xff\x04\x01\xff\xff\x06\x01\xff\xff\b\x01\xff\xff\n\x01\xff\xff\f\x01\xff\xff\x0e\x01\x0f\x01\0\0\x11\x01\x12\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1b\x01\xff\xff\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff1\x012\x013\x014\x01\xff\xff6\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01C\x01\xff\xff\xff\xff\xff\xff\xff\xffH\x01\xff\xffJ\x01\0\0\0\x01M\x01\xff\xff\x03\x01\x04\x01\xff\xff\xff\xffS\x01\xff\xff\xff\xffV\x01\xff\xff\xff\xff\r\x01\x0e\x01[\x01\xff\xff]\x01^\x01\x13\x01`\x01a\x01\xff\xffc\x01\xff\xff\xff\xff\x1a\x01g\x01\x1c\x01\x1d\x01j\x01\xff\xffl\x01\xff\xff\xff\xffo\x01p\x01\xff\xff\xff\xffs\x01\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\x01\xff\xff=\x01\x03\x01\x04\x01@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01\r\x01\x0e\x01\xff\xffK\x01\xff\xff\xff\xff\x13\x01\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff^\x01\xff\xff`\x01\xff\xffb\x01c\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\0\0\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01\xff\xff\xff\xff\xff\xffK\x01\xff\xff\xff\xff\0\x01\xff\xff\xff\xff\x03\x01R\x01\xff\xff\xff\xff\xff\xff\b\x01\xff\xff\xff\xff\xff\xff\xff\xff\r\x01\x0e\x01\xff\xff^\x01\xff\xff`\x01\x13\x01b\x01c\x01\x16\x01\xff\xff\xff\xff\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\0\0\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xff\xff\xff8\x01)\x01:\x01;\x01<\x01\xff\xff>\x01\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\x01\xff\xff=\x01\x03\x01\x04\x01@\x01\xff\xffB\x01C\x01D\x01E\x01\xff\xff\xff\xff\r\x01\x0e\x01\xff\xffK\x01\\\x01\xff\xff\x13\x01\xff\xff\xff\xffQ\x01R\x01c\x01\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\0\0\xff\xff\xff\xff\xff\xff^\x01o\x01p\x01\xff\xffb\x01c\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xff\xff\xff\0\x01\xff\xff=\x01\x03\x01\x04\x01@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xffG\x01\r\x01\x0e\x01\xff\xffK\x01\xff\xff\xff\xff\x13\x01\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\x1a\x01\0\0\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff^\x01\xff\xff`\x01\xff\xffb\x01c\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\0\x01n\x01\xff\xff\x03\x01q\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\r\x01@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xffG\x01\xff\xff\xff\xff\xff\xffK\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff)\x01\xff\xff\xff\xff^\x01\xff\xff`\x01\xff\xffb\x01c\x01\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\x01n\x01=\x01\x03\x01q\x01\xff\xffA\x01\xff\xffC\x01D\x01E\x01\0\0\xff\xff\r\x01\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff`\x01\xff\xffb\x01c\x01)\x01\xff\xfff\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffn\x01o\x01\xff\xffq\x01\xff\xff\xff\xff\xff\xff\xff\xff\0\x01\xff\xff=\x01\x03\x01\xff\xff\xff\xffA\x01\xff\xffC\x01D\x01E\x01\xff\xff\xff\xff\r\x01\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff`\x01\xff\xffb\x01c\x01)\x01\xff\xfff\x01\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffn\x01o\x01\xff\xffq\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\x01=\x01\xff\xff\x03\x01\xff\xffA\x01\xff\xffC\x01D\x01E\x01\xff\xff\xff\xff\xff\xff\r\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\x13\x01\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff`\x01\xff\xffb\x01c\x01(\x01)\x01f\x01\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xffn\x01o\x01\xff\xffq\x01\xff\xff\0\x01\xff\xff\xff\xff\x03\x01\xff\xff\xff\xff=\x01\0\0\b\x01@\x01\xff\xff\xff\xff\xff\xff\r\x01E\x01\xff\xffG\x01\0\0\xff\xff\x13\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1a\x01R\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff^\x01\xff\xff)\x01\xff\xffb\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xff\xff\xff\xff\xff\xff\xffJ\x01K\x01\0\x01\xff\xff\xff\xff\x03\x01\xff\xff\xff\xffR\x01\xff\xff\b\x01\0\0\xff\xff\xff\xff\xff\xff\r\x01\xff\xff\xff\xff\xff\xff\0\x01^\x01\x13\x01\x03\x01\xff\xffb\x01c\x01\xff\xff\b\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\r\x01\xff\xff\xff\xff\xff\xffn\x01\xff\xff\x13\x01q\x01\xff\xff\xff\xff\xff\xff)\x01\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff)\x01\0\0\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xff\xff\xff\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01R\x01\0\0C\x01D\x01E\x01\xff\xff\xff\xff\xff\xff\xff\xffJ\x01K\x01\xff\xff^\x01\xff\xff\xff\xff\xff\xffb\x01R\x01\xff\xff\xff\xfff\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\x01n\x01^\x01\x03\x01q\x01\xff\xffb\x01\xff\xff\b\x01\xff\xfff\x01\xff\xff\xff\xff\r\x01\xff\xff\xff\xff\xff\xff\xff\xffn\x01\x13\x01\xff\xffq\x01\xff\xff\xff\xff\0\0\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff)\x01\xff\xff\xff\xff8\x01\xff\xff:\x01;\x01<\x01\xff\xff>\x01\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xffK\x01@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffS\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\0\x01[\x01\\\x01\x03\x01R\x01\0\0`\x01\xff\xff\b\x01c\x01\0\x01\xff\xff\xff\xff\r\x01\xff\xff\xff\xff^\x01\xff\xff\xff\xff\x13\x01b\x01o\x01p\x01\r\x01f\x01\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\0\0\xff\xffC\x01D\x01E\x01\xff\xff=\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\0\x01E\x01\xff\xff\x03\x01R\x01\xff\xff\xff\xffK\x01\b\x01\xff\xff\xff\xff\xff\xff\xff\xff\r\x01R\x01\xff\xff^\x01\xff\xff\xff\xff\x13\x01b\x01\xff\xff\xff\xff\xff\xfff\x01\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01b\x01\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff)\x01n\x01\xff\xff\xff\xffq\x01\0\0\xff\xff\xff\xff\xff\xff\0\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\r\x01@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xff\xff\xff\xff\xff\xff\xff\0\x01K\x01\x1a\x01\x03\x01\x1c\x01\x1d\x01\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\r\x01\xff\xff\xff\xff\xff\xff)\x01\xff\xff\x13\x01^\x01\xff\xff\xff\xff\xff\xffb\x01c\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\0\0\xff\xff\xff\xff\xff\xff\0\0n\x01=\x01\xff\xffq\x01\xff\xff)\x01\xff\xff\xff\xff\xff\xffE\x01\xff\xff\xff\xff\xff\xff\xff\xff\0\x01K\x01\xff\xff\x03\x01\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff=\x01\xff\xff\r\x01@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xff\xff\xff\xff\xff\xff\xffb\x01K\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xffn\x01\xff\xffX\x01q\x01\0\0)\x01\xff\xff\xff\xff^\x01\xff\xff\xff\xff\xff\xffb\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\x01n\x01=\x01\x03\x01q\x01@\x01\xff\xff\xff\xff\b\x01D\x01E\x01\xff\xff\xff\xff\r\x01\xff\xff\xff\xffK\x01\xff\xff\xff\xff\x13\x01\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\0\0\xff\xff\xff\xff\xff\xff^\x01\xff\xff`\x01\xff\xffb\x01c\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\x01=\x01\xff\xff\x03\x01@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xff\xff\xff\xff\xff\r\x01\xff\xffK\x01\xff\xff\xff\xff\xff\xff\x13\x01\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff^\x01\xff\xff\xff\xff\xff\xffb\x01c\x01\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\x01\xff\xff=\x01\x03\x01\xff\xff@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xff\xff\xff\r\x01\xff\xff\xff\xffK\x01\xff\xff\xff\xff\x13\x01\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff^\x01\xff\xff\xff\xff\0\0b\x01c\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xff\xff\xff\0\x01\xff\xff=\x01\x03\x01\0\x01@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xff\xff\xff\r\x01\xff\xff\xff\xffK\x01\r\x01\xff\xff\x13\x01\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff^\x01\xff\xff\xff\xff\0\0b\x01c\x01)\x01\xff\xff\xff\xff\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xff\xff\xff\0\x01\xff\xff=\x01\x03\x01\xff\xff@\x01=\x01\xff\xff\xff\xffD\x01E\x01\xff\xff\xff\xff\r\x01E\x01\xff\xffK\x01\xff\xff\xff\xff\x13\x01K\x01\xff\xff\xff\xffR\x01\xff\xff\xff\xff\x1a\x01R\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff^\x01\xff\xff\xff\xff\0\0b\x01c\x01)\x01\xff\xffb\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\x01n\x01\xff\xff\xff\xffq\x01n\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff=\x01\xff\xff\r\x01@\x01\xff\xff\xff\xff\0\x01D\x01E\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xffK\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\r\x01\xff\xffR\x01\0\0\xff\xff\xff\xff\x13\x01\xff\xff\xff\xff\xff\xff\xff\xff)\x01\xff\xff\x1a\x01^\x01\x1c\x01\x1d\x01\xff\xffb\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff)\x01\xff\xffn\x01=\x01\xff\xffq\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffE\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffK\x01\0\x01\xff\xff=\x01\x03\x01\xff\xff@\x01R\x01\xff\xff\xff\xffD\x01E\x01\xff\xff\xff\xff\r\x01\xff\xff\xff\xffK\x01\xff\xff\xff\xff\x13\x01\xff\xff\xff\xffb\x01R\x01\0\0\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xffn\x01^\x01\xff\xffq\x01\xff\xffb\x01c\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\x01n\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xff\b\x01\0\x01\xff\xff=\x01\xff\xff\r\x01@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xff\xff\xff\r\x01\xff\xff\0\0K\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xffR\x01\0\0\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff)\x01\xff\xff\xff\xff^\x01\xff\xff\xff\xff\xff\xffb\x01c\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\x01n\x01=\x01\xff\xffq\x01@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01=\x01\xff\xff\r\x01@\x01\xff\xffK\x01\xff\xffD\x01E\x01\xff\xff\xff\xff\xff\xffR\x01\xff\xffK\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xffR\x01\xff\xff\xff\xff^\x01\xff\xff\xff\xff\xff\xffb\x01c\x01)\x01\xff\xff\xff\xff^\x01\xff\xff\xff\xff\xff\xffb\x01c\x01\xff\xffn\x01\0\0\xff\xffq\x01\xff\xff\xff\xff\xff\xff\xff\xff\0\x01n\x01=\x01\x03\x01q\x01@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xff\xff\xff\r\x01\xff\xff\0\0K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff^\x01\xff\xff\0\0\xff\xffb\x01c\x01)\x01\xff\xff\xff\xff\xff\xff\0\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xff\r\x01\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xff\0\x01\xff\xffE\x01\x03\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\r\x01\xff\xffR\x01\xff\xff\xff\xff\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1a\x01^\x01\x1c\x01\x1d\x01\xff\xffb\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01(\x01)\x01@\x01n\x01\xff\xff\0\x01q\x01E\x01\x03\x01\0\0\xff\xff\xff\xff\xff\xffK\x01\xff\xff\xff\xff\xff\xff\xff\xff\r\x01\0\0R\x01=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xff\x1a\x01^\x01\x1c\x01\x1d\x01K\x01b\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff(\x01)\x01\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff^\x01\0\x01\xff\xff\xff\xffb\x01c\x01\xff\xff\xff\xff\xff\xff\b\x01\0\x01\xff\xff=\x01\xff\xff\r\x01@\x01n\x01\xff\xff\xff\xffD\x01E\x01\xff\xff\xff\xff\r\x01\xff\xff\xff\xffK\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\0\0R\x01\xff\xff\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff)\x01\xff\xff\xff\xff^\x01\xff\xff\xff\xff\xff\xffb\x01c\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffn\x01=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01=\x01\xff\xff\xff\xff@\x01\xff\xffK\x01C\x01D\x01E\x01\xff\xff\xff\xff\0\0R\x01\xff\xffK\x01\xff\xff\xff\xff\0\x01\xff\xff\xff\xff\x03\x01R\x01\xff\xff\xff\xff^\x01\xff\xff\xff\xff\xff\xffb\x01c\x01\r\x01\xff\xff\xff\xff^\x01\xff\xff\xff\xff\xff\xffb\x01c\x01\0\x01n\x01\xff\xff\x03\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xffn\x01\0\0\xff\xff\r\x01\xff\xff\xff\xff\xff\xff\xff\xff(\x01)\x01\xff\xff\xff\xff\0\x01\xff\xff\xff\xff\x03\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\r\x01\xff\xff\xff\xff\xff\xff=\x01\xff\xff)\x01@\x01\xff\xff\xff\xff\xff\xff\xff\xffE\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xffK\x01\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xffR\x01=\x01\xff\xff)\x01@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xff\xff\xff^\x01\xff\xff\xff\xffK\x01b\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xffR\x01=\x01\xff\xff\xff\xff@\x01\xff\xffn\x01\xff\xffD\x01E\x01\xff\xff\xff\xff^\x01\xff\xff\xff\xffK\x01b\x01c\x01\0\0\0\x01\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01n\x01\0\x01\xff\xff\xff\xff\r\x01\xff\xff^\x01\xff\xff\xff\xff\xff\xffb\x01c\x01\0\0\xff\xff\r\x01\xff\xff\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\0\0n\x01\xff\xff\xff\xff\xff\xff\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xff=\x01\xff\xff\xff\xff@\x01K\x01\xff\xff\0\x01D\x01E\x01\x03\x01\xff\xffR\x01\xff\xff\xff\xffK\x01\xff\xff\xff\xff\xff\xff\xff\xff\r\x01\xff\xffR\x01\xff\xff^\x01\xff\xff\xff\xff\xff\xffb\x01c\x01\xff\xff\xff\xff\xff\xff\x1a\x01^\x01\x1c\x01\x1d\x01\xff\xffb\x01c\x01n\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff)\x01\xff\xffn\x01\xff\xff8\x01\xff\xff:\x01;\x01<\x01\0\x01>\x01\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\r\x01@\x01\xff\xff\xff\xff\xff\xff\xff\xffE\x01\xff\xff\xff\xffS\x01\xff\xff\xff\xffK\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01[\x01\\\x01R\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffc\x01\0\x01\xff\xff)\x01\xff\xff\xff\xff^\x01\xff\xff\xff\xff\xff\xffb\x01c\x01o\x01p\x01\r\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffn\x01=\x01\xff\xff\xff\xff@\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01E\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffK\x01\xff\xff\xff\xff\xff\xff\xff\xff)\x01\xff\xffR\x01\0\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff^\x01\xff\xff\r\x01\xff\xffb\x01c\x01=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xff\xff\xff\xff\xffE\x01\x1a\x01n\x01\x1c\x01\x1d\x01\xff\xffK\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff)\x01\xff\xff\xff\xff\xff\xff\0\x01\xff\xff\xff\xff\xff\xff\xff\xff^\x01\xff\xff\xff\xff\xff\xffb\x01c\x01\xff\xff\xff\xff\r\x01\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xffn\x01\0\x01\xff\xffE\x01\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01K\x01\0\x01\xff\xff\xff\xff\xff\xff\r\x01\xff\xffR\x01\xff\xff\xff\xff\xff\xff)\x01\xff\xff\xff\xff\r\x01\xff\xff\xff\xff\xff\xff\x1a\x01^\x01\x1c\x01\x1d\x01\xff\xffb\x01c\x01\xff\xff\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01=\x01\xff\xff)\x01@\x01n\x01\xff\xff\xff\xff\xff\xffE\x01\xff\xff\xff\xff)\x01\xff\xff\xff\xffK\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xff\xff\xff\xff\xffE\x01=\x01\xff\xff^\x01@\x01\xff\xffK\x01b\x01c\x01E\x01\xff\xff\xff\xff\xff\xffR\x01\xff\xffK\x01\xff\xff\xff\xff\xff\xffn\x01\xff\xff\xff\xffR\x01\xff\xff\xff\xff^\x01\xff\xff\xff\xff\xff\xffb\x01c\x01\xff\xff\xff\xff\xff\xff^\x01\xff\xff\xff\xff\xff\xffb\x01c\x01\0\x01n\x01\xff\xff\xff\xff\xff\xff\x05\x01\x06\x01\x07\x01\b\x01\xff\xffn\x01\x0b\x01\f\x01\r\x01\x0e\x01\xff\xff\xff\xff\xff\xff\xff\xff\x13\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff\xff\xff\xff\xff\xff\xff'\x01\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x011\x012\x013\x014\x015\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01=\x01\xff\xff\xff\xff@\x01A\x01B\x01C\x01\xff\xffE\x01F\x01G\x01H\x01I\x01\xff\xffK\x01\xff\xffM\x01N\x01\xff\xffP\x01\xff\xffR\x01S\x01\xff\xff\xff\xffV\x01W\x01\xff\xffY\x01\xff\xff[\x01\xff\xff\xff\xff^\x01_\x01\xff\xff\xff\xffb\x01c\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xffj\x01\xff\xffl\x01m\x01n\x01o\x01p\x01q\x01\xff\xff\xff\xfft\x01\0\x01\x01\x01\x02\x01\xff\xff\xff\xff\x05\x01\x06\x01\x07\x01\xff\xff\t\x01\xff\xff\x0b\x01\f\x01\xff\xff\xff\xff\x0f\x01\x10\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1b\x01\xff\xff\xff\xff\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff$\x01\xff\xff\xff\xff'\x01\xff\xff\xff\xff*\x01+\x01,\x01-\x01.\x01\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01\xff\xff>\x01\xff\xff@\x01A\x01B\x01\xff\xff\xff\xff\xff\xffF\x01\xff\xffH\x01I\x01\xff\xffK\x01\xff\xffM\x01N\x01\xff\xffP\x01\xff\xff\xff\xff\xff\xffT\x01U\x01V\x01W\x01X\x01Y\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff`\x01\xff\xff\xff\xff\xff\xffd\x01\xff\xfff\x01g\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01m\x01\xff\xffo\x01\0\x01\x01\x01\x02\x01\xff\xfft\x01\x05\x01\x06\x01\x07\x01\xff\xff\t\x01\xff\xff\x0b\x01\f\x01\xff\xff\xff\xff\xff\xff\x10\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1b\x01\xff\xff\xff\xff\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff$\x01\xff\xff\xff\xff'\x01\xff\xff\xff\xff*\x01+\x01,\x01-\x01.\x01\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01\xff\xff>\x01\xff\xff@\x01A\x01B\x01\xff\xff\xff\xff\xff\xffF\x01\xff\xffH\x01I\x01\xff\xffK\x01\xff\xffM\x01N\x01\xff\xffP\x01\xff\xff\xff\xff\xff\xffT\x01U\x01V\x01W\x01X\x01Y\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff`\x01\xff\xff\xff\xff\xff\xffd\x01\xff\xfff\x01g\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01m\x01\xff\xffo\x01\0\x01\x01\x01\x02\x01\xff\xfft\x01\x05\x01\x06\x01\x07\x01\xff\xff\t\x01\xff\xff\x0b\x01\f\x01\xff\xff\xff\xff\xff\xff\x10\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1b\x01\xff\xff\xff\xff\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff$\x01\xff\xff\xff\xff'\x01\xff\xff\xff\xff*\x01+\x01,\x01-\x01.\x01\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01\xff\xff>\x01\xff\xff@\x01A\x01B\x01\xff\xff\xff\xff\xff\xffF\x01\xff\xffH\x01I\x01\xff\xffK\x01\xff\xffM\x01N\x01\xff\xffP\x01\xff\xff\xff\xff\xff\xffT\x01U\x01V\x01W\x01X\x01Y\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffd\x01\xff\xfff\x01g\x01\xff\xff\xff\xff\xff\xff\0\x01l\x01m\x01\xff\xffo\x01\x05\x01\x06\x01\x07\x01\b\x01t\x01\xff\xff\x0b\x01\f\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x13\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1a\x01\xff\xff\x1c\x01\xff\xff\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff\xff\xff\xff\xff\xff\xff'\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x011\x012\x013\x014\x015\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01=\x01\xff\xff\xff\xff@\x01A\x01B\x01\xff\xff\xff\xffE\x01F\x01G\x01H\x01I\x01\xff\xff\xff\xff\xff\xffM\x01N\x01\xff\xffP\x01\xff\xff\xff\xffS\x01\xff\xff\xff\xffV\x01W\x01\xff\xffY\x01\xff\xff[\x01\xff\xff\xff\xff\xff\xff_\x01\xff\xff\xff\xff\xff\xffc\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xffj\x01\xff\xffl\x01m\x01\xff\xffo\x01p\x01q\x01\0\x01\xff\xfft\x01\xff\xff\xff\xff\x05\x01\x06\x01\x07\x01\xff\xff\xff\xff\xff\xff\x0b\x01\f\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff\xff\xff\xff\xff\xff\xff'\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff@\x01A\x01B\x01\xff\xff\xff\xff\xff\xffF\x01\xff\xffH\x01I\x01\xff\xff\xff\xff\xff\xffM\x01N\x01\xff\xffP\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01W\x01\0\x01Y\x01\xff\xff\xff\xff\xff\xff\x05\x01\x06\x01\x07\x01`\x01\xff\xff\xff\xff\x0b\x01\f\x01\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01m\x01\xff\xffo\x01\xff\xff\xff\xff\xff\xff\xff\xfft\x01\xff\xff\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff\xff\xff\xff\xff\xff\xff'\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff@\x01A\x01B\x01\xff\xff\xff\xff\xff\xffF\x01\xff\xffH\x01I\x01\xff\xff\xff\xff\xff\xffM\x01N\x01\xff\xffP\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01W\x01\0\x01Y\x01\xff\xff\xff\xff\xff\xff\x05\x01\x06\x01\x07\x01`\x01\xff\xff\xff\xff\x0b\x01\f\x01\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01m\x01\xff\xffo\x01\xff\xff\xff\xff\xff\xff\xff\xfft\x01\xff\xff\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff\xff\xff\xff\xff\xff\xff'\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff@\x01A\x01B\x01\xff\xff\xff\xff\xff\xffF\x01\xff\xffH\x01I\x01\xff\xff\xff\xff\xff\xffM\x01N\x01\xff\xffP\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01W\x01\0\x01Y\x01\xff\xff\xff\xff\xff\xff\x05\x01\x06\x01\x07\x01`\x01\xff\xff\xff\xff\x0b\x01\f\x01\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01m\x01\xff\xffo\x01\xff\xff\xff\xff\xff\xff\xff\xfft\x01\xff\xff\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff\xff\xff\xff\xff\xff\xff'\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff@\x01A\x01B\x01\xff\xff\xff\xff\xff\xffF\x01\xff\xffH\x01I\x01\xff\xff\xff\xff\xff\xffM\x01N\x01\xff\xffP\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01W\x01\xff\xffY\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff`\x01\x03\x01\x04\x01\x05\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\x0b\x01\xff\xff\r\x01l\x01m\x01\xff\xffo\x01\xff\xff\x13\x01\x14\x01\x15\x01t\x01\xff\xff\x18\x01\x19\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\x1e\x01\xff\xff \x01!\x01\"\x01#\x01\xff\xff\xff\xff\xff\xff'\x01(\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff5\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff@\x01A\x01\xff\xff\xff\xff\xff\xff\xff\xffF\x01G\x01\xff\xff\xff\xff\xff\xffK\x01L\x01\xff\xffN\x01\xff\xffP\x01Q\x01R\x01\xff\xffT\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffZ\x01\xff\xff\xff\xff\xff\xff\xff\xff_\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffe\x01\0\x01\xff\xffh\x01i\x01\x04\x01k\x01l\x01m\x01n\x01o\x01\xff\xffq\x01r\x01s\x01t\x01u\x01\xff\xff\x11\x01\xff\xff\x13\x01\xff\xff\xff\xff\x16\x01\xff\xff\xff\xff\xff\xff\x1a\x01\x1b\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff\xff\xffA\x01\xff\xffC\x01D\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01\xff\xff\xff\xff\xff\xff\xff\xff\0\x01\x01\x01\x02\x01\xff\xff\xff\xff\xff\xff\x06\x01\x07\x01\xff\xff\t\x01\xff\xff\xff\xff\f\x01\\\x01]\x01\x0f\x01\x10\x01\xff\xffa\x01\xff\xffc\x01\xff\xff\xff\xfff\x01\xff\xff\xff\xff\xff\xff\x1b\x01\x1c\x01\xff\xff\x1e\x01\x1f\x01o\x01\xff\xffq\x01\xff\xff$\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff*\x01+\x01,\x01-\x01.\x01\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff>\x01\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffH\x01I\x01\xff\xffK\x01\xff\xffM\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffT\x01U\x01V\x01W\x01X\x01Y\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff`\x01\xff\xff\xff\xffc\x01d\x01\xff\xfff\x01g\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01\xff\xff\xff\xffo\x01p\x01\0\x01\x01\x01\x02\x01\xff\xff\xff\xff\xff\xff\x06\x01\x07\x01\xff\xff\t\x01\xff\xff\xff\xff\f\x01\xff\xff\xff\xff\xff\xff\x10\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1b\x01\x1c\x01\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xff\xff\xff$\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff*\x01+\x01,\x01-\x01.\x01\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff>\x01\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffH\x01I\x01\xff\xffK\x01\xff\xffM\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffT\x01U\x01V\x01W\x01X\x01Y\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff`\x01\xff\xff\xff\xffc\x01d\x01\xff\xfff\x01g\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01\xff\xffn\x01o\x01p\x01\0\x01\x01\x01\x02\x01\xff\xff\xff\xff\xff\xff\x06\x01\x07\x01\xff\xff\t\x01\xff\xff\xff\xff\f\x01\xff\xff\xff\xff\xff\xff\x10\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1b\x01\x1c\x01\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xff\xff\xff$\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff*\x01+\x01,\x01-\x01.\x01\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff>\x01\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffH\x01I\x01\xff\xffK\x01\xff\xffM\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffT\x01U\x01V\x01W\x01X\x01Y\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff`\x01\xff\xff\xff\xffc\x01d\x01\xff\xfff\x01g\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01\xff\xffn\x01o\x01p\x01\0\x01\x01\x01\x02\x01\xff\xff\xff\xff\xff\xff\x06\x01\x07\x01\xff\xff\t\x01\xff\xff\xff\xff\f\x01\xff\xff\xff\xff\xff\xff\x10\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1b\x01\x1c\x01\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xff\xff\xff$\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff*\x01+\x01,\x01-\x01.\x01\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff>\x01\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffH\x01I\x01\xff\xffK\x01\xff\xffM\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffT\x01U\x01V\x01W\x01X\x01Y\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff`\x01\xff\xff\xff\xffc\x01d\x01\xff\xfff\x01g\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01\xff\xffn\x01o\x01p\x01\0\x01\x01\x01\x02\x01\xff\xff\xff\xff\xff\xff\x06\x01\x07\x01\xff\xff\t\x01\xff\xff\xff\xff\f\x01\xff\xff\xff\xff\xff\xff\x10\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1b\x01\x1c\x01\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xff\xff\xff$\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff*\x01+\x01,\x01-\x01.\x01\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff>\x01\xff\xff\0\x01A\x01B\x01\xff\xff\xff\xff\xff\xff\x06\x01\xff\xffH\x01I\x01\xff\xffK\x01\f\x01M\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffT\x01U\x01V\x01W\x01X\x01Y\x01\xff\xff\xff\xff\x1c\x01\xff\xff\x1e\x01\x1f\x01`\x01\xff\xff\xff\xffc\x01d\x01\xff\xfff\x01g\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01\xff\xff\xff\xffo\x01p\x011\x012\x013\x01\xff\xff5\x016\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\0\x01A\x01B\x01\xff\xff\xff\xff\xff\xff\x06\x01\xff\xffH\x01\xff\xff\xff\xff\xff\xff\f\x01M\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1c\x01\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xffc\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01\xff\xff\xff\xffo\x01p\x011\x012\x013\x01\xff\xff5\x016\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\0\x01A\x01B\x01\xff\xff\xff\xff\xff\xff\x06\x01\xff\xffH\x01\xff\xff\xff\xff\xff\xff\f\x01M\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1c\x01\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xffc\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01\xff\xff\xff\xffo\x01p\x011\x012\x013\x01\xff\xff5\x016\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffH\x01\xff\xff\xff\xff\xff\xff\xff\xffM\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffc\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01\xff\xff\xff\xffo\x01p\x01\x05\x01\x06\x01\x07\x01\xff\xff\xff\xff\xff\xff\x0b\x01\f\x01\r\x01\x0e\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1c\x01\x1d\x01\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff\xff\xff\xff\xff\xff\xff'\x01\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01=\x01\xff\xff\xff\xff@\x01A\x01B\x01\xff\xff\xff\xffE\x01F\x01\xff\xffH\x01I\x01\xff\xffK\x01\xff\xffM\x01N\x01\xff\xffP\x01\xff\xffR\x01\xff\xff\xff\xff\xff\xffV\x01W\x01\xff\xffY\x01\xff\xff[\x01\xff\xff\xff\xff\x05\x01\x06\x01\x07\x01\xff\xffb\x01\xff\xff\x0b\x01\f\x01\r\x01g\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01m\x01n\x01o\x01\xff\xff\xff\xff\xff\xff\xff\xfft\x01\x1c\x01\x1d\x01\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff\xff\xff\xff\xff\xff\xff'\x01\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01=\x01\xff\xff\xff\xff@\x01A\x01B\x01\xff\xff\xff\xffE\x01F\x01\xff\xffH\x01I\x01\xff\xffK\x01\xff\xffM\x01N\x01\xff\xffP\x01\xff\xffR\x01\xff\xff\xff\xff\xff\xffV\x01W\x01\xff\xffY\x01\xff\xff\xff\xff\xff\xff\x05\x01\x06\x01\x07\x01\xff\xff\xff\xffb\x01\x0b\x01\f\x01\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01m\x01n\x01o\x01\xff\xff\xff\xff\xff\xff\xff\xfft\x01\xff\xff\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff\xff\xff\xff\xff\xff\xff'\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff@\x01A\x01B\x01\xff\xff\xff\xff\xff\xffF\x01\xff\xffH\x01I\x01\xff\xff\xff\xff\xff\xffM\x01N\x01\xff\xffP\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01W\x01\xff\xffY\x01\xff\xff\xff\xff\xff\xff\xff\xff^\x01\x05\x01\x06\x01\x07\x01\xff\xff\xff\xff\n\x01\x0b\x01\f\x01g\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01m\x01\xff\xffo\x01\xff\xff\xff\xff\xff\xff\xff\xfft\x01\xff\xff\xff\xff\xff\xff\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff\xff\xff\xff\xff\xff\xff'\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff@\x01A\x01B\x01\xff\xff\xff\xff\xff\xffF\x01\xff\xffH\x01I\x01\xff\xff\xff\xff\xff\xffM\x01N\x01\xff\xffP\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01W\x01\xff\xffY\x01\xff\xff\xff\xff\x05\x01\x06\x01\x07\x01\xff\xff\xff\xff\xff\xff\x0b\x01\f\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01m\x01\xff\xffo\x01\xff\xff\x1a\x01\xff\xff\xff\xfft\x01\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff\xff\xff\xff\xff\xff\xff'\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff@\x01A\x01B\x01\xff\xff\xff\xff\xff\xffF\x01\xff\xffH\x01I\x01\xff\xff\xff\xff\xff\xffM\x01N\x01\xff\xffP\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01W\x01\xff\xffY\x01\xff\xff\xff\xff\x05\x01\x06\x01\x07\x01\xff\xff\xff\xff\xff\xff\x0b\x01\f\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01m\x01\xff\xffo\x01\xff\xff\x1a\x01\xff\xff\xff\xfft\x01\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff\xff\xff\xff\xff\xff\xff'\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff@\x01A\x01B\x01\xff\xff\xff\xff\xff\xffF\x01\xff\xffH\x01I\x01\xff\xff\xff\xff\xff\xffM\x01N\x01\xff\xffP\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01W\x01\xff\xffY\x01\xff\xff\xff\xff\x05\x01\x06\x01\x07\x01\xff\xff\xff\xff\xff\xff\x0b\x01\f\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01m\x01\xff\xffo\x01\xff\xff\xff\xff\xff\xff\xff\xfft\x01\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff\xff\xff\xff\xff\xff\xff'\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff@\x01A\x01B\x01\xff\xff\xff\xff\xff\xffF\x01\xff\xffH\x01I\x01\xff\xff\xff\xff\xff\xffM\x01N\x01\xff\xffP\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01W\x01\xff\xffY\x01\xff\xff\xff\xff\x05\x01\x06\x01\x07\x01\xff\xff\xff\xff\xff\xff\x0b\x01\f\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01m\x01\xff\xffo\x01\xff\xff\xff\xff\xff\xff\xff\xfft\x01\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff\xff\xff\xff\xff\xff\xff'\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff@\x01A\x01B\x01\xff\xff\xff\xff\xff\xffF\x01\xff\xffH\x01I\x01\xff\xff\xff\xff\xff\xffM\x01N\x01\xff\xffP\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01W\x01\xff\xffY\x01\xff\xff\xff\xff\xff\xff\x06\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\f\x01\xff\xff\x0e\x01\xff\xffg\x01\x11\x01\xff\xff\xff\xff\xff\xffl\x01m\x01\xff\xffo\x01\xff\xff\xff\xff\x1b\x01\xff\xfft\x01\x1e\x01\x1f\x018\x01\xff\xff:\x01;\x01<\x01\xff\xff>\x01\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff1\x012\x013\x014\x01\xff\xff6\x01\xff\xff8\x019\x01\xff\xffS\x01<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01[\x01\\\x01\xff\xff\xff\xff\xff\xffH\x01\x06\x01\xff\xffc\x01\xff\xffM\x01\xff\xff\f\x01\xff\xff\x0e\x01\xff\xffS\x01\x11\x01\xff\xffV\x01o\x01p\x01\xff\xff\xff\xff[\x01\xff\xff\xff\xff\x1b\x01\xff\xff\xff\xff\x1e\x01\x1f\x01c\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xffj\x01\xff\xffl\x01\xff\xff\xff\xffo\x01p\x01\xff\xff\xff\xff\xff\xff1\x012\x013\x014\x01\xff\xff6\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffH\x01\x06\x01\xff\xff\xff\xff\xff\xffM\x01\xff\xff\f\x01\xff\xff\x0e\x01\xff\xffS\x01\xff\xff\xff\xffV\x01\xff\xff\xff\xff\xff\xff\xff\xff[\x01\xff\xff\xff\xff\x1b\x01\xff\xff\xff\xff\x1e\x01\x1f\x01c\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xffj\x01\xff\xffl\x01\xff\xff\xff\xffo\x01p\x01\xff\xff\xff\xff\xff\xff1\x012\x013\x014\x01\xff\xff6\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffH\x01\x06\x01\xff\xff\xff\xff\xff\xffM\x01\xff\xff\f\x01\xff\xff\x0e\x01\xff\xffS\x01\xff\xff\xff\xffV\x01\xff\xff\xff\xff\xff\xff\xff\xff[\x01\xff\xff\xff\xff\x1b\x01\xff\xff\xff\xff\x1e\x01\x1f\x01c\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xffj\x01\xff\xffl\x01\xff\xff\xff\xffo\x01p\x01\xff\xff\xff\xff\xff\xff1\x012\x013\x014\x01\xff\xff6\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\x06\x01\xff\xffH\x01\xff\xff\xff\xff\xff\xff\f\x01M\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffS\x01\xff\xff\xff\xffV\x01\xff\xff\xff\xff\xff\xff\xff\xff[\x01\xff\xff\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xffc\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xffj\x01\xff\xffl\x01\xff\xff\xff\xffo\x01p\x011\x012\x013\x014\x01\xff\xff6\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\x06\x01\xff\xffH\x01\xff\xffJ\x01\xff\xff\f\x01M\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffS\x01\xff\xff\xff\xffV\x01\xff\xff\xff\xff\xff\xff\xff\xff[\x01\xff\xff\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xffc\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xffj\x01\xff\xffl\x01\xff\xff\xff\xffo\x01p\x011\x012\x013\x014\x01\xff\xff6\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\x06\x01\xff\xffH\x01\xff\xffJ\x01\xff\xff\f\x01M\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffS\x01\xff\xff\xff\xffV\x01\xff\xff\xff\xff\xff\xff\xff\xff[\x01\xff\xff\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xffc\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xffj\x01\xff\xffl\x01\xff\xff\xff\xffo\x01p\x011\x012\x013\x014\x01\xff\xff6\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\x06\x01\xff\xffH\x01\xff\xff\xff\xff\xff\xff\f\x01M\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffS\x01\xff\xff\xff\xffV\x01\xff\xff\xff\xff\xff\xff\xff\xff[\x01\xff\xff\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xffc\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xffj\x01\xff\xffl\x01\xff\xff\xff\xffo\x01p\x011\x012\x013\x014\x01\xff\xff6\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\x06\x01\xff\xffH\x01\xff\xff\xff\xff\xff\xff\f\x01M\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffS\x01\xff\xff\xff\xffV\x01\xff\xff\xff\xff\xff\xff\xff\xff[\x01\xff\xff\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xffc\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xffj\x01\xff\xffl\x01\xff\xff\xff\xffo\x01p\x011\x012\x013\x014\x01\xff\xff6\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\x06\x01\xff\xffH\x01\xff\xff\xff\xff\xff\xff\f\x01M\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffS\x01\xff\xff\xff\xffV\x01\xff\xff\xff\xff\xff\xff\xff\xff[\x01\x1c\x01\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xffc\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xffj\x01\xff\xffl\x01\xff\xff\xff\xffo\x01p\x011\x012\x013\x01\xff\xff5\x016\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffH\x01\xff\xff\xff\xff\xff\xff\x06\x01M\x01\xff\xff\xff\xff\n\x01\xff\xff\f\x01\xff\xff\xff\xff\xff\xffV\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff^\x01\xff\xff\xff\xff\xff\xff\x1c\x01c\x01\x1e\x01\x1f\x01\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01\xff\xff\xff\xffo\x01p\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffH\x01\x06\x01\xff\xff\b\x01\xff\xffM\x01\xff\xff\f\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1c\x01\xff\xff\x1e\x01\x1f\x01c\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01\xff\xff\xff\xffo\x01p\x01\xff\xff\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\x06\x01\xff\xffH\x01\xff\xff\xff\xff\xff\xff\f\x01M\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1c\x01\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xffc\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01\xff\xff\xff\xffo\x01p\x011\x012\x013\x01\xff\xff5\x016\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffH\x01\xff\xff\xff\xff\xff\xff\x06\x01M\x01\xff\xff\xff\xff\xff\xff\xff\xff\f\x01\xff\xff\xff\xff\xff\xffV\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff_\x01\xff\xff\xff\xff\x1c\x01c\x01\x1e\x01\x1f\x01\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01\xff\xff\xff\xffo\x01p\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\x06\x01\xff\xffH\x01\xff\xff\xff\xff\xff\xff\f\x01M\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1c\x01\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xffc\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01\xff\xff\xff\xffo\x01p\x011\x012\x013\x01\xff\xff5\x016\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\x06\x01\xff\xffH\x01\xff\xff\xff\xff\xff\xff\f\x01M\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1c\x01\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xffc\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01\xff\xff\xff\xffo\x01p\x011\x012\x013\x01\xff\xff5\x016\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\x06\x01\xff\xffH\x01\xff\xff\xff\xff\xff\xff\f\x01M\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1c\x01\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xffc\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01\xff\xff\xff\xffo\x01p\x011\x012\x013\x01\xff\xff5\x016\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\x06\x01\xff\xffH\x01\xff\xff\xff\xff\xff\xff\f\x01M\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xffc\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01\xff\xff\xff\xffo\x01p\x011\x012\x013\x01\xff\xff\xff\xff6\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffH\x01\x06\x01\x07\x01\xff\xff\xff\xffM\x01\x0b\x01\f\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01\xff\xff\xff\xff\x16\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1e\x01\x1f\x01c\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01\xff\xff\xff\xffo\x01p\x01\xff\xff\xff\xff\xff\xff1\x012\x013\x014\x01\xff\xff6\x017\x018\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\x06\x01\x07\x01\xff\xff\xff\xff\xff\xff\x0b\x01\f\x01\xff\xffM\x01N\x01\xff\xff\xff\xff\xff\xff\xff\xffS\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffY\x01\xff\xff[\x01\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xff\xff\xffc\x01d\x01\xff\xff\xff\xffg\x01\xff\xff\xff\xffj\x01\xff\xffl\x01\xff\xff\xff\xffo\x011\x012\x013\x014\x01\xff\xff6\x017\x018\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\x06\x01\x07\x01\xff\xff\xff\xff\xff\xff\x0b\x01\f\x01\xff\xffM\x01N\x01\xff\xff\xff\xff\xff\xff\xff\xffS\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffY\x01\xff\xff[\x01\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xffj\x01\xff\xffl\x01\xff\xff\xff\xffo\x011\x012\x013\x01\xff\xff\xff\xff6\x017\x018\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\x06\x01\x07\x01\xff\xff\xff\xff\xff\xff\x0b\x01\f\x01\xff\xffM\x01N\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffY\x01\xff\xff\xff\xff\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01\xff\xff\xff\xffo\x011\x012\x013\x01\xff\xff\xff\xff6\x017\x018\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\x06\x01\x07\x01\xff\xff\xff\xff\xff\xff\x0b\x01\f\x01\xff\xffM\x01N\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\xff\xff\xff\xff\xff\xffY\x01\xff\xff\xff\xff\x0f\x01\x1e\x01\x1f\x018\x01\xff\xff:\x01;\x01<\x01\x17\x01>\x01\xff\xffg\x01A\x01B\x01\xff\xff\x1e\x01l\x01\xff\xff\xff\xffo\x011\x012\x013\x01\xff\xff\xff\xff6\x017\x018\x019\x01\xff\xffS\x01<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01[\x01\\\x01\xff\xff8\x01\xff\xff:\x01;\x01<\x01c\x01>\x01M\x01N\x01A\x01B\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01n\x01o\x01p\x01Y\x01\xff\xff\xff\xff\x0f\x01\xff\xff\xff\xff\xff\xff\xff\xffS\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffg\x01Z\x01[\x01\\\x01\x1e\x01l\x01\xff\xff\xff\xffo\x01\xff\xffc\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffl\x01\xff\xff\xff\xffo\x01p\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff8\x01\xff\xff:\x01;\x01<\x01\xff\xff>\x01\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\xff\xff\0\x01\x01\x01\x02\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\t\x01\xff\xff\xff\xffS\x01\xff\xff\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\xff\xff[\x01\\\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1b\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01l\x01\xff\xff\xff\xffo\x01p\x01*\x01+\x01,\x01-\x01.\x01\0\x01\x01\x01\x02\x01\xff\xff\xff\xff\xff\xff\xff\xff\x07\x01\xff\xff\t\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff>\x01\x10\x01\xff\xff\xff\xff\xff\xffC\x01\xff\xff\xff\xff\xff\xff\xff\xffH\x01I\x01\x1b\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01T\x01U\x01V\x01W\x01X\x01*\x01+\x01,\x01-\x01.\x01\xff\xff\xff\xff`\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xfff\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff>\x01\xff\xff\xff\xff\xff\xff\x01\x01\x02\x01\xff\xff\xff\xff\xff\xff\xff\xffH\x01I\x01\t\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\x0f\x01\x10\x01\xff\xff\x12\x01T\x01U\x01V\x01W\x01X\x01Y\x01\xff\xff\xff\xff\x1b\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x01\x01\x02\x01d\x01$\x01f\x01\xff\xff\xff\xff\xff\xff\t\x01*\x01+\x01,\x01-\x01.\x01\x0f\x01\x10\x01\xff\xff\x12\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1b\x01\xff\xff\xff\xff>\x01\xff\xff\xff\xff\xff\xff\xff\xffC\x01$\x01\xff\xff\xff\xff\xff\xffH\x01I\x01*\x01+\x01,\x01-\x01.\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffT\x01U\x01V\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff>\x01\x01\x01\x02\x01a\x01\xff\xffC\x01\xff\xff\xff\xfff\x01\t\x01H\x01I\x01\xff\xff\xff\xff\xff\xff\x0f\x01\x10\x01\xff\xff\x12\x01\xff\xff\xff\xff\xff\xffT\x01U\x01V\x01W\x01X\x01\x1b\x01\xff\xff\xff\xff\xff\xff]\x01\xff\xff\x01\x01\x02\x01\xff\xff$\x01\xff\xff\xff\xff\xff\xfff\x01\t\x01*\x01+\x01,\x01-\x01.\x01\x0f\x01\x10\x01\xff\xff\x12\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x19\x01\xff\xff\x1b\x01\xff\xff\xff\xff>\x01\xff\xff\xff\xff\xff\xff\xff\xffC\x01$\x01\xff\xff\xff\xff\xff\xffH\x01I\x01*\x01+\x01,\x01-\x01.\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffT\x01U\x01V\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01>\x01\x01\x01\x02\x01\xff\xff\xff\xffC\x01\xff\xff\xff\xfff\x01\t\x01H\x01I\x01\xff\xff\xff\xff\xff\xff\x0f\x01\x10\x01\xff\xff\x12\x01\xff\xff\xff\xff\xff\xffT\x01U\x01V\x01W\x01X\x01\x1b\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x01\x01\x02\x01\xff\xff$\x01\xff\xff\xff\xff\xff\xfff\x01\t\x01*\x01+\x01,\x01-\x01.\x01\x0f\x01\x10\x01\xff\xff\x12\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1b\x01\xff\xff\xff\xff>\x01\xff\xff\xff\xff\xff\xff\xff\xffC\x01$\x01\xff\xff\xff\xff\xff\xffH\x01I\x01*\x01+\x01,\x01-\x01.\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffT\x01U\x01V\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff>\x01\x01\x01\x02\x01\xff\xff\xff\xffC\x01\xff\xff\xff\xfff\x01\t\x01H\x01I\x01\xff\xff\xff\xff\xff\xff\x0f\x01\x10\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffT\x01U\x01V\x01W\x01X\x01\x1b\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x01\x01\x02\x01\xff\xff$\x01\xff\xff\xff\xff\xff\xfff\x01\t\x01*\x01+\x01,\x01-\x01.\x01\x0f\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1b\x01\xff\xff\xff\xff>\x01\xff\xff\xff\xff\xff\xff\xff\xffC\x01$\x01\xff\xff\xff\xff\xff\xffH\x01I\x01*\x01+\x01,\x01-\x01.\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffT\x01U\x01V\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01>\x01\x01\x01\x02\x01\xff\xff\xff\xffC\x01\xff\xff\xff\xfff\x01\t\x01H\x01I\x01\xff\xff\xff\xff\xff\xff\x0f\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffT\x01U\x01V\x01W\x01X\x01\x1b\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff`\x01\xff\xff$\x01\xff\xff\xff\xff\xff\xfff\x01\xff\xff*\x01+\x01,\x01-\x01.\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x01\x01\x02\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff>\x01\xff\xff\xff\xff\xff\xff\xff\xffC\x01\x0f\x01\xff\xff\xff\xff\xff\xffH\x01I\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1b\x01\xff\xff\xff\xff\xff\xffT\x01U\x01V\x01W\x01X\x01$\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff*\x01+\x01,\x01-\x01.\x01\xff\xff\xff\xfff\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff8\x01\xff\xff:\x01;\x01<\x01\xff\xff>\x01>\x01\xff\xffA\x01B\x01\xff\xffC\x01\xff\xff\xff\xff\xff\xff\xff\xffH\x01I\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffS\x01\xff\xff\xff\xffU\x01V\x01W\x01X\x01\xff\xff[\x01\\\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffc\x01\xff\xff\xff\xff\xff\xfff\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffo\x01p\x01",
  /* error_function */Parsing.parse_error,
  /* names_const */"AMPERAMPER\0AMPERSAND\0AND\0AS\0ASSERT\0BACKQUOTE\0BANG\0BAR\0BARBAR\0BARRBRACKET\0BEGIN\0CLASS\0COLON\0COLONCOLON\0COLONEQUAL\0COLONGREATER\0COMMA\0CONSTRAINT\0DO\0DONE\0DOT\0DOTDOT\0DOWNTO\0ELSE\0END\0EOF\0EQUAL\0EXCEPTION\0EXTERNAL\0FALSE\0FOR\0FUN\0FUNCTION\0FUNCTOR\0GREATER\0GREATERRBRACE\0GREATERRBRACKET\0IF\0IN\0INCLUDE\0INHERIT\0INITIALIZER\0LAZY\0LBRACE\0LBRACELESS\0LBRACKET\0LBRACKETBAR\0LBRACKETLESS\0LBRACKETGREATER\0LBRACKETPERCENT\0LBRACKETPERCENTPERCENT\0LESS\0LESSMINUS\0LET\0LPAREN\0LBRACKETAT\0LBRACKETATAT\0LBRACKETATATAT\0MATCH\0METHOD\0MINUS\0MINUSDOT\0MINUSGREATER\0MODULE\0MUTABLE\0NEW\0NONREC\0OBJECT\0OF\0OPEN\0OR\0PERCENT\0PLUS\0PLUSDOT\0PLUSEQ\0PRIVATE\0QUESTION\0QUOTE\0RBRACE\0RBRACKET\0REC\0RPAREN\0SEMI\0SEMISEMI\0SHARP\0SIG\0STAR\0STRUCT\0THEN\0TILDE\0TO\0TRUE\0TRY\0TYPE\0UNDERSCORE\0VAL\0VIRTUAL\0WHEN\0WHILE\0WITH\0EOL\0",
  /* names_block */"CHAR\0FLOAT\0INFIXOP0\0INFIXOP1\0INFIXOP2\0INFIXOP3\0INFIXOP4\0INT\0INT32\0INT64\0LABEL\0LIDENT\0NATIVEINT\0OPTLABEL\0PREFIXOP\0SHARPOP\0STRING\0UIDENT\0COMMENT\0DOCSTRING\0"
];

function implementation(lexfun, lexbuf) {
  return Parsing.yyparse(yytables, 1, lexfun, lexbuf);
}

function type_of_directive(x) {
  if (typeof x === "number") {
    return /* Dir_type_null */4;
  } else {
    switch (x.tag | 0) {
      case 0 : 
          return /* Dir_type_bool */0;
      case 1 : 
          return /* Dir_type_float */1;
      case 2 : 
          return /* Dir_type_int */2;
      case 3 : 
          return /* Dir_type_string */3;
      
    }
  }
}

function string_of_type_directive(x) {
  switch (x) {
    case 0 : 
        return "bool";
    case 1 : 
        return "float";
    case 2 : 
        return "int";
    case 3 : 
        return "string";
    case 4 : 
        return "null";
    
  }
}

var $$Error$4 = Caml_exceptions.create("Ocaml_typedtree_test.Lexer.Error");

function assert_same_type(lexbuf, x, y) {
  var lhs = type_of_directive(x);
  var rhs = type_of_directive(y);
  if (Caml_obj.caml_notequal(lhs, rhs)) {
    throw [
          $$Error$4,
          /* Conditional_expr_expected_type */Block.__(7, [
              lhs,
              rhs
            ]),
          curr(lexbuf)
        ];
  } else {
    return y;
  }
}

var directive_built_in_values = Hashtbl.create(/* None */0, 51);

Hashtbl.replace(directive_built_in_values, "OCAML_VERSION", /* Dir_string */Block.__(3, [Sys.ocaml_version]));

var $js;

var exit = 0;

var i;

try {
  i = Bytes.rindex(Caml_string.bytes_of_string(Sys.ocaml_version), /* "+" */43);
  exit = 1;
}
catch (exn$1){
  if (exn$1 === Caml_builtin_exceptions.not_found) {
    $js = "";
  } else {
    throw exn$1;
  }
}

if (exit === 1) {
  $js = $$String.sub(Sys.ocaml_version, i + 1 | 0, (Sys.ocaml_version.length - i | 0) - 1 | 0);
}

var v = /* Dir_string */Block.__(3, [$js]);

Hashtbl.replace(directive_built_in_values, "OCAML_PATCH", v);

Hashtbl.replace(directive_built_in_values, "OS_TYPE", /* Dir_string */Block.__(3, ["Unix"]));

Hashtbl.replace(directive_built_in_values, "BIG_ENDIAN", /* Dir_bool */Block.__(0, [Sys.big_endian]));

Hashtbl.replace(directive_built_in_values, "WORD_SIZE", /* Dir_int */Block.__(2, [Sys.word_size]));

function semantic_version_parse(str, start, last_index) {
  var aux = function (_start, _acc, last_index) {
    while(true) {
      var acc = _acc;
      var start = _start;
      if (start <= last_index) {
        var c = str.charCodeAt(start);
        if (c === /* "." */46) {
          return /* tuple */[
                  acc,
                  start + 1 | 0
                ];
        } else {
          var v = c - /* "0" */48 | 0;
          if (v >= 0 && v <= 9) {
            _acc = Caml_int32.imul(acc, 10) + v | 0;
            _start = start + 1 | 0;
            continue ;
            
          } else {
            return /* tuple */[
                    acc,
                    start
                  ];
          }
        }
      } else {
        return /* tuple */[
                acc,
                start
              ];
      }
    };
  };
  var match = aux(start, 0, last_index);
  var match$1 = aux(match[1], 0, last_index);
  var match$2 = aux(match$1[1], 0, last_index);
  var patch_end = match$2[1];
  var additional = $$String.sub(str, patch_end, (last_index - patch_end | 0) + 1 | 0);
  return /* tuple */[
          /* tuple */[
            match[0],
            match$1[0],
            match$2[0]
          ],
          additional
        ];
}

function defined(str) {
  var exit = 0;
  var val;
  try {
    val = Hashtbl.find(directive_built_in_values, str);
    exit = 1;
  }
  catch (exn){
    try {
      Caml_sys.caml_sys_getenv(str);
      return /* true */1;
    }
    catch (exn$1){
      return /* false */0;
    }
  }
  if (exit === 1) {
    if (typeof val === "number") {
      return /* false */0;
    } else {
      return /* true */1;
    }
  }
  
}

function query(_, str) {
  var exit = 0;
  var v;
  try {
    v = Hashtbl.find(directive_built_in_values, str);
    exit = 1;
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      var exit$1 = 0;
      var v$1;
      try {
        v$1 = Caml_sys.caml_sys_getenv(str);
        exit$1 = 2;
      }
      catch (exn$1){
        if (exn$1 === Caml_builtin_exceptions.not_found) {
          return /* Dir_bool */Block.__(0, [/* false */0]);
        } else {
          throw exn$1;
        }
      }
      if (exit$1 === 2) {
        try {
          return /* Dir_bool */Block.__(0, [Pervasives.bool_of_string(v$1)]);
        }
        catch (exn$2){
          try {
            return /* Dir_int */Block.__(2, [Caml_format.caml_int_of_string(v$1)]);
          }
          catch (exn$3){
            try {
              return /* Dir_float */Block.__(1, [Caml_format.caml_float_of_string(v$1)]);
            }
            catch (exn$4){
              return /* Dir_string */Block.__(3, [v$1]);
            }
          }
        }
      }
      
    } else {
      throw exn;
    }
  }
  if (exit === 1) {
    if (typeof v === "number") {
      return /* Dir_bool */Block.__(0, [/* false */0]);
    } else {
      return v;
    }
  }
  
}

function value_of_token(loc, t) {
  if (typeof t === "number") {
    switch (t) {
      case 29 : 
          return /* Dir_bool */Block.__(0, [/* false */0]);
      case 91 : 
          return /* Dir_bool */Block.__(0, [/* true */1]);
      default:
        throw [
              $$Error$4,
              /* Unexpected_token_in_conditional */4,
              loc
            ];
    }
  } else {
    switch (t.tag | 0) {
      case 1 : 
          return /* Dir_float */Block.__(1, [Caml_format.caml_float_of_string(t[0])]);
      case 7 : 
          return /* Dir_int */Block.__(2, [t[0]]);
      case 16 : 
          return /* Dir_string */Block.__(3, [t[0][0]]);
      case 17 : 
          return query(loc, t[0]);
      default:
        throw [
              $$Error$4,
              /* Unexpected_token_in_conditional */4,
              loc
            ];
    }
  }
}

function directive_parse(token_with_comments, lexbuf) {
  var look_ahead = [/* None */0];
  var token = function () {
    var v = look_ahead[0];
    if (v) {
      look_ahead[0] = /* None */0;
      return v[0];
    } else {
      var _param = /* () */0;
      while(true) {
        var t = Curry._1(token_with_comments, lexbuf);
        if (typeof t === "number") {
          switch (t) {
            case 25 : 
                throw [
                      $$Error$4,
                      /* Unterminated_if */2,
                      curr(lexbuf)
                    ];
            case 100 : 
                _param = /* () */0;
                continue ;
                default:
              return t;
          }
        } else {
          switch (t.tag | 0) {
            case 18 : 
            case 19 : 
                _param = /* () */0;
                continue ;
                default:
              return t;
          }
        }
      };
    }
  };
  var push = function (e) {
    if (look_ahead[0] !== /* None */0) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "parsing/lexer.mll",
              312,
              4
            ]
          ];
    }
    look_ahead[0] = /* Some */[e];
    return /* () */0;
  };
  var token_op = function (calc, no, lhs) {
    var op = token(/* () */0);
    var exit = 0;
    if (typeof op === "number") {
      switch (op) {
        case 26 : 
        case 34 : 
        case 51 : 
            exit = 1;
            break;
        default:
          return Curry._1(no, op);
      }
    } else if (op.tag === 2) {
      switch (op[0]) {
        case "=~" : 
            if (calc) {
              var exit$1 = 0;
              if (typeof lhs === "number") {
                exit$1 = 2;
              } else if (lhs.tag === 3) {
                var curr_loc = curr(lexbuf);
                var rhs = value_of_token(curr_loc, token(/* () */0));
                var exit$2 = 0;
                if (typeof rhs === "number") {
                  exit$2 = 3;
                } else if (rhs.tag === 3) {
                  var loc = curr_loc;
                  var lhs$1 = lhs[0];
                  var str = rhs[0];
                  var last_index = str.length - 1 | 0;
                  if (last_index < 0) {
                    throw [
                          $$Error$4,
                          /* Illegal_semver */Block.__(6, [str]),
                          loc
                        ];
                  } else {
                    var v = str.charCodeAt(0);
                    var match;
                    var exit$3 = 0;
                    if (v !== 94) {
                      if (v >= 63) {
                        if (v !== 126) {
                          exit$3 = 1;
                        } else {
                          match = /* tuple */[
                            /* Approximate */-617782220,
                            semantic_version_parse(str, 1, last_index)
                          ];
                        }
                      } else if (v >= 60) {
                        switch (v - 60 | 0) {
                          case 0 : 
                              if (last_index) {
                                match = str[1] === "=" ? /* tuple */[
                                    /* Le */17049,
                                    semantic_version_parse(str, 2, last_index)
                                  ] : /* tuple */[
                                    /* Lt */17064,
                                    semantic_version_parse(str, 1, last_index)
                                  ];
                              } else {
                                throw [
                                      $$Error$4,
                                      /* Illegal_semver */Block.__(6, [str]),
                                      loc
                                    ];
                              }
                              break;
                          case 1 : 
                              exit$3 = 1;
                              break;
                          case 2 : 
                              if (last_index) {
                                match = str[1] === "=" ? /* tuple */[
                                    /* Ge */15934,
                                    semantic_version_parse(str, 2, last_index)
                                  ] : /* tuple */[
                                    /* Gt */15949,
                                    semantic_version_parse(str, 1, last_index)
                                  ];
                              } else {
                                throw [
                                      $$Error$4,
                                      /* Illegal_semver */Block.__(6, [str]),
                                      loc
                                    ];
                              }
                              break;
                          
                        }
                      } else {
                        exit$3 = 1;
                      }
                    } else {
                      match = /* tuple */[
                        /* Compatible */785637236,
                        semantic_version_parse(str, 1, last_index)
                      ];
                    }
                    if (exit$3 === 1) {
                      match = /* tuple */[
                        /* Exact */172069535,
                        semantic_version_parse(str, 0, last_index)
                      ];
                    }
                    var version = match[1][0];
                    var major = version[0];
                    var pred = match[0];
                    var match$1 = semantic_version_parse(lhs$1, 0, lhs$1.length - 1 | 0);
                    var lversion = match$1[0];
                    var l_major = lversion[0];
                    if (pred >= 17049) {
                      if (pred >= 172069535) {
                        if (pred >= 785637236) {
                          return +(major === l_major);
                        } else {
                          return Caml_obj.caml_equal(lversion, version);
                        }
                      } else if (pred >= 17064) {
                        return Caml_obj.caml_lessthan(lversion, version);
                      } else {
                        return Caml_obj.caml_lessequal(lversion, version);
                      }
                    } else if (pred !== 15934) {
                      if (pred >= 15949) {
                        return Caml_obj.caml_greaterthan(lversion, version);
                      } else if (major === l_major) {
                        return +(version[1] === lversion[1]);
                      } else {
                        return /* false */0;
                      }
                    } else {
                      return Caml_obj.caml_greaterequal(lversion, version);
                    }
                  }
                } else {
                  exit$2 = 3;
                }
                if (exit$2 === 3) {
                  throw [
                        $$Error$4,
                        /* Conditional_expr_expected_type */Block.__(7, [
                            /* Dir_type_string */3,
                            type_of_directive(lhs)
                          ]),
                        curr(lexbuf)
                      ];
                }
                
              } else {
                exit$1 = 2;
              }
              if (exit$1 === 2) {
                throw [
                      $$Error$4,
                      /* Conditional_expr_expected_type */Block.__(7, [
                          /* Dir_type_string */3,
                          type_of_directive(lhs)
                        ]),
                      curr(lexbuf)
                    ];
              }
              
            } else {
              return /* true */1;
            }
            break;
        case "<=" : 
        case "<>" : 
        case ">=" : 
            exit = 1;
            break;
        default:
          return Curry._1(no, op);
      }
    } else {
      return Curry._1(no, op);
    }
    if (exit === 1) {
      var f;
      var exit$4 = 0;
      if (typeof op === "number") {
        switch (op) {
          case 26 : 
              f = Caml_obj.caml_equal;
              break;
          case 34 : 
              f = Caml_obj.caml_greaterthan;
              break;
          case 51 : 
              f = Caml_obj.caml_lessthan;
              break;
          default:
            exit$4 = 2;
        }
      } else if (op.tag === 2) {
        switch (op[0]) {
          case "<=" : 
              f = Caml_obj.caml_lessequal;
              break;
          case "<>" : 
              f = Caml_obj.caml_notequal;
              break;
          default:
            exit$4 = 2;
        }
      } else {
        exit$4 = 2;
      }
      if (exit$4 === 2) {
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "parsing/lexer.mll",
                331,
                17
              ]
            ];
      }
      var curr_loc$1 = curr(lexbuf);
      var rhs$1 = value_of_token(curr_loc$1, token(/* () */0));
      if (calc) {
        return Curry._2(f, lhs, assert_same_type(lexbuf, lhs, rhs$1));
      } else {
        return /* true */1;
      }
    }
    
  };
  var parse_or_aux = function (calc, v) {
    var e = token(/* () */0);
    if (typeof e === "number") {
      if (e !== 8) {
        push(e);
        return v;
      } else {
        var calc$1 = calc && 1 - v;
        var b = parse_or_aux(calc$1, parse_and_aux(calc$1, parse_relation(calc$1)));
        if (v) {
          return /* true */1;
        } else {
          return b;
        }
      }
    } else {
      push(e);
      return v;
    }
  };
  var parse_relation = function (calc) {
    var curr_token = token(/* () */0);
    var curr_loc = curr(lexbuf);
    if (typeof curr_token === "number") {
      switch (curr_token) {
        case 29 : 
            return /* false */0;
        case 54 : 
            var v = parse_or_aux(calc, parse_and_aux(calc, parse_relation(calc)));
            var match = token(/* () */0);
            if (typeof match === "number") {
              if (match !== 81) {
                throw [
                      $$Error$4,
                      /* Unterminated_paren_in_conditional */1,
                      curr(lexbuf)
                    ];
              } else {
                return v;
              }
            } else {
              throw [
                    $$Error$4,
                    /* Unterminated_paren_in_conditional */1,
                    curr(lexbuf)
                  ];
            }
            break;
        case 91 : 
            return /* true */1;
        default:
          throw [
                $$Error$4,
                /* Unexpected_token_in_conditional */4,
                curr_loc
              ];
      }
    } else {
      switch (curr_token.tag | 0) {
        case 1 : 
            return token_op(calc, (function () {
                          throw [
                                $$Error$4,
                                /* Conditional_expr_expected_type */Block.__(7, [
                                    /* Dir_type_bool */0,
                                    /* Dir_type_float */1
                                  ]),
                                curr_loc
                              ];
                        }), /* Dir_float */Block.__(1, [Caml_format.caml_float_of_string(curr_token[0])]));
        case 7 : 
            return token_op(calc, (function () {
                          throw [
                                $$Error$4,
                                /* Conditional_expr_expected_type */Block.__(7, [
                                    /* Dir_type_bool */0,
                                    /* Dir_type_int */2
                                  ]),
                                curr_loc
                              ];
                        }), /* Dir_int */Block.__(2, [curr_token[0]]));
        case 11 : 
            var r = curr_token[0];
            var exit = 0;
            switch (r) {
              case "defined" : 
              case "undefined" : 
                  exit = 1;
                  break;
              default:
                throw [
                      $$Error$4,
                      /* Unexpected_token_in_conditional */4,
                      curr_loc
                    ];
            }
            if (exit === 1) {
              var t = token(/* () */0);
              var loc = curr(lexbuf);
              if (typeof t === "number") {
                throw [
                      $$Error$4,
                      /* Unexpected_token_in_conditional */4,
                      loc
                    ];
              } else if (t.tag === 17) {
                var s = t[0];
                if (calc) {
                  if (Caml_string.get(r, 0) === /* "u" */117) {
                    return 1 - defined(s);
                  } else {
                    return defined(s);
                  }
                } else {
                  return /* true */1;
                }
              } else {
                throw [
                      $$Error$4,
                      /* Unexpected_token_in_conditional */4,
                      loc
                    ];
              }
            }
            break;
        case 16 : 
            return token_op(calc, (function () {
                          throw [
                                $$Error$4,
                                /* Conditional_expr_expected_type */Block.__(7, [
                                    /* Dir_type_bool */0,
                                    /* Dir_type_string */3
                                  ]),
                                curr_loc
                              ];
                        }), /* Dir_string */Block.__(3, [curr_token[0][0]]));
        case 17 : 
            var value_v = query(curr_loc, curr_token[0]);
            return token_op(calc, (function (e) {
                          push(e);
                          var exit = 0;
                          if (typeof value_v === "number") {
                            exit = 1;
                          } else if (value_v.tag) {
                            exit = 1;
                          } else {
                            return value_v[0];
                          }
                          if (exit === 1) {
                            var ty = type_of_directive(value_v);
                            throw [
                                  $$Error$4,
                                  /* Conditional_expr_expected_type */Block.__(7, [
                                      /* Dir_type_bool */0,
                                      ty
                                    ]),
                                  curr_loc
                                ];
                          }
                          
                        }), value_v);
        default:
          throw [
                $$Error$4,
                /* Unexpected_token_in_conditional */4,
                curr_loc
              ];
      }
    }
  };
  var parse_and_aux = function (calc, v) {
    var e = token(/* () */0);
    if (typeof e === "number") {
      if (e !== 0) {
        push(e);
        return v;
      } else {
        var calc$1 = calc && v;
        var b = parse_and_aux(calc$1, parse_relation(calc$1));
        if (v) {
          return b;
        } else {
          return /* false */0;
        }
      }
    } else {
      push(e);
      return v;
    }
  };
  var v = parse_or_aux(/* true */1, parse_and_aux(/* true */1, parse_relation(/* true */1)));
  var match = token(/* () */0);
  if (typeof match === "number") {
    if (match !== 88) {
      throw [
            $$Error$4,
            /* Expect_hash_then_in_conditional */5,
            curr(lexbuf)
          ];
    } else {
      return v;
    }
  } else {
    throw [
          $$Error$4,
          /* Expect_hash_then_in_conditional */5,
          curr(lexbuf)
        ];
  }
}

function is_elif(i) {
  if (typeof i === "number" || !(i.tag === 11 && i[0] === "elif")) {
    return /* false */0;
  } else {
    return /* true */1;
  }
}

var keyword_table = create_hashtable(149, /* :: */[
      /* tuple */[
        "and",
        /* AND */2
      ],
      /* :: */[
        /* tuple */[
          "as",
          /* AS */3
        ],
        /* :: */[
          /* tuple */[
            "assert",
            /* ASSERT */4
          ],
          /* :: */[
            /* tuple */[
              "begin",
              /* BEGIN */10
            ],
            /* :: */[
              /* tuple */[
                "class",
                /* CLASS */11
              ],
              /* :: */[
                /* tuple */[
                  "constraint",
                  /* CONSTRAINT */17
                ],
                /* :: */[
                  /* tuple */[
                    "do",
                    /* DO */18
                  ],
                  /* :: */[
                    /* tuple */[
                      "done",
                      /* DONE */19
                    ],
                    /* :: */[
                      /* tuple */[
                        "downto",
                        /* DOWNTO */22
                      ],
                      /* :: */[
                        /* tuple */[
                          "else",
                          /* ELSE */23
                        ],
                        /* :: */[
                          /* tuple */[
                            "end",
                            /* END */24
                          ],
                          /* :: */[
                            /* tuple */[
                              "exception",
                              /* EXCEPTION */27
                            ],
                            /* :: */[
                              /* tuple */[
                                "external",
                                /* EXTERNAL */28
                              ],
                              /* :: */[
                                /* tuple */[
                                  "false",
                                  /* FALSE */29
                                ],
                                /* :: */[
                                  /* tuple */[
                                    "for",
                                    /* FOR */30
                                  ],
                                  /* :: */[
                                    /* tuple */[
                                      "fun",
                                      /* FUN */31
                                    ],
                                    /* :: */[
                                      /* tuple */[
                                        "function",
                                        /* FUNCTION */32
                                      ],
                                      /* :: */[
                                        /* tuple */[
                                          "functor",
                                          /* FUNCTOR */33
                                        ],
                                        /* :: */[
                                          /* tuple */[
                                            "if",
                                            /* IF */37
                                          ],
                                          /* :: */[
                                            /* tuple */[
                                              "in",
                                              /* IN */38
                                            ],
                                            /* :: */[
                                              /* tuple */[
                                                "include",
                                                /* INCLUDE */39
                                              ],
                                              /* :: */[
                                                /* tuple */[
                                                  "inherit",
                                                  /* INHERIT */40
                                                ],
                                                /* :: */[
                                                  /* tuple */[
                                                    "initializer",
                                                    /* INITIALIZER */41
                                                  ],
                                                  /* :: */[
                                                    /* tuple */[
                                                      "lazy",
                                                      /* LAZY */42
                                                    ],
                                                    /* :: */[
                                                      /* tuple */[
                                                        "let",
                                                        /* LET */53
                                                      ],
                                                      /* :: */[
                                                        /* tuple */[
                                                          "match",
                                                          /* MATCH */58
                                                        ],
                                                        /* :: */[
                                                          /* tuple */[
                                                            "method",
                                                            /* METHOD */59
                                                          ],
                                                          /* :: */[
                                                            /* tuple */[
                                                              "module",
                                                              /* MODULE */63
                                                            ],
                                                            /* :: */[
                                                              /* tuple */[
                                                                "mutable",
                                                                /* MUTABLE */64
                                                              ],
                                                              /* :: */[
                                                                /* tuple */[
                                                                  "new",
                                                                  /* NEW */65
                                                                ],
                                                                /* :: */[
                                                                  /* tuple */[
                                                                    "nonrec",
                                                                    /* NONREC */66
                                                                  ],
                                                                  /* :: */[
                                                                    /* tuple */[
                                                                      "object",
                                                                      /* OBJECT */67
                                                                    ],
                                                                    /* :: */[
                                                                      /* tuple */[
                                                                        "of",
                                                                        /* OF */68
                                                                      ],
                                                                      /* :: */[
                                                                        /* tuple */[
                                                                          "open",
                                                                          /* OPEN */69
                                                                        ],
                                                                        /* :: */[
                                                                          /* tuple */[
                                                                            "or",
                                                                            /* OR */70
                                                                          ],
                                                                          /* :: */[
                                                                            /* tuple */[
                                                                              "private",
                                                                              /* PRIVATE */75
                                                                            ],
                                                                            /* :: */[
                                                                              /* tuple */[
                                                                                "rec",
                                                                                /* REC */80
                                                                              ],
                                                                              /* :: */[
                                                                                /* tuple */[
                                                                                  "sig",
                                                                                  /* SIG */85
                                                                                ],
                                                                                /* :: */[
                                                                                  /* tuple */[
                                                                                    "struct",
                                                                                    /* STRUCT */87
                                                                                  ],
                                                                                  /* :: */[
                                                                                    /* tuple */[
                                                                                      "then",
                                                                                      /* THEN */88
                                                                                    ],
                                                                                    /* :: */[
                                                                                      /* tuple */[
                                                                                        "to",
                                                                                        /* TO */90
                                                                                      ],
                                                                                      /* :: */[
                                                                                        /* tuple */[
                                                                                          "true",
                                                                                          /* TRUE */91
                                                                                        ],
                                                                                        /* :: */[
                                                                                          /* tuple */[
                                                                                            "try",
                                                                                            /* TRY */92
                                                                                          ],
                                                                                          /* :: */[
                                                                                            /* tuple */[
                                                                                              "type",
                                                                                              /* TYPE */93
                                                                                            ],
                                                                                            /* :: */[
                                                                                              /* tuple */[
                                                                                                "val",
                                                                                                /* VAL */95
                                                                                              ],
                                                                                              /* :: */[
                                                                                                /* tuple */[
                                                                                                  "virtual",
                                                                                                  /* VIRTUAL */96
                                                                                                ],
                                                                                                /* :: */[
                                                                                                  /* tuple */[
                                                                                                    "when",
                                                                                                    /* WHEN */97
                                                                                                  ],
                                                                                                  /* :: */[
                                                                                                    /* tuple */[
                                                                                                      "while",
                                                                                                      /* WHILE */98
                                                                                                    ],
                                                                                                    /* :: */[
                                                                                                      /* tuple */[
                                                                                                        "with",
                                                                                                        /* WITH */99
                                                                                                      ],
                                                                                                      /* :: */[
                                                                                                        /* tuple */[
                                                                                                          "mod",
                                                                                                          /* INFIXOP3 */Block.__(5, ["mod"])
                                                                                                        ],
                                                                                                        /* :: */[
                                                                                                          /* tuple */[
                                                                                                            "land",
                                                                                                            /* INFIXOP3 */Block.__(5, ["land"])
                                                                                                          ],
                                                                                                          /* :: */[
                                                                                                            /* tuple */[
                                                                                                              "lor",
                                                                                                              /* INFIXOP3 */Block.__(5, ["lor"])
                                                                                                            ],
                                                                                                            /* :: */[
                                                                                                              /* tuple */[
                                                                                                                "lxor",
                                                                                                                /* INFIXOP3 */Block.__(5, ["lxor"])
                                                                                                              ],
                                                                                                              /* :: */[
                                                                                                                /* tuple */[
                                                                                                                  "lsl",
                                                                                                                  /* INFIXOP4 */Block.__(6, ["lsl"])
                                                                                                                ],
                                                                                                                /* :: */[
                                                                                                                  /* tuple */[
                                                                                                                    "lsr",
                                                                                                                    /* INFIXOP4 */Block.__(6, ["lsr"])
                                                                                                                  ],
                                                                                                                  /* :: */[
                                                                                                                    /* tuple */[
                                                                                                                      "asr",
                                                                                                                      /* INFIXOP4 */Block.__(6, ["asr"])
                                                                                                                    ],
                                                                                                                    /* [] */0
                                                                                                                  ]
                                                                                                                ]
                                                                                                              ]
                                                                                                            ]
                                                                                                          ]
                                                                                                        ]
                                                                                                      ]
                                                                                                    ]
                                                                                                  ]
                                                                                                ]
                                                                                              ]
                                                                                            ]
                                                                                          ]
                                                                                        ]
                                                                                      ]
                                                                                    ]
                                                                                  ]
                                                                                ]
                                                                              ]
                                                                            ]
                                                                          ]
                                                                        ]
                                                                      ]
                                                                    ]
                                                                  ]
                                                                ]
                                                              ]
                                                            ]
                                                          ]
                                                        ]
                                                      ]
                                                    ]
                                                  ]
                                                ]
                                              ]
                                            ]
                                          ]
                                        ]
                                      ]
                                    ]
                                  ]
                                ]
                              ]
                            ]
                          ]
                        ]
                      ]
                    ]
                  ]
                ]
              ]
            ]
          ]
        ]
      ]
    ]);

var initial_string_buffer = new Array(256);

var string_buff = [initial_string_buffer];

var string_index = [0];

function reset_string_buffer() {
  string_buff[0] = initial_string_buffer;
  string_index[0] = 0;
  return /* () */0;
}

function store_string_char(c) {
  if (string_index[0] >= string_buff[0].length) {
    var new_buff = Caml_string.caml_create_string((string_buff[0].length << 1));
    Bytes.blit(string_buff[0], 0, new_buff, 0, string_buff[0].length);
    string_buff[0] = new_buff;
  }
  string_buff[0][string_index[0]] = c;
  string_index[0] = string_index[0] + 1 | 0;
  return /* () */0;
}

function store_string(s) {
  for(var i = 0 ,i_finish = s.length - 1 | 0; i <= i_finish; ++i){
    store_string_char(Caml_string.get(s, i));
  }
  return /* () */0;
}

function get_stored_string() {
  var s = Bytes.sub_string(string_buff[0], 0, string_index[0]);
  string_buff[0] = initial_string_buffer;
  return s;
}

var string_start_loc = [none];

var comment_start_loc = [/* [] */0];

var is_in_string = [/* false */0];

var print_warnings = [/* true */1];

var if_then_else = [/* Dir_out */2];

var sharp_look_ahead = [/* None */0];

function with_comment_buffer(comment, lexbuf) {
  var start_loc = curr(lexbuf);
  comment_start_loc[0] = /* :: */[
    start_loc,
    /* [] */0
  ];
  reset_string_buffer(/* () */0);
  var end_loc = Curry._1(comment, lexbuf);
  var s = get_stored_string(/* () */0);
  reset_string_buffer(/* () */0);
  var loc_000 = /* loc_start */start_loc[/* loc_start */0];
  var loc_001 = /* loc_end */end_loc[/* loc_end */1];
  var loc_002 = /* loc_ghost */start_loc[/* loc_ghost */2];
  var loc = /* record */[
    loc_000,
    loc_001,
    loc_002
  ];
  return /* tuple */[
          s,
          loc
        ];
}

function char_for_backslash(c) {
  if (c >= 110) {
    if (c >= 117) {
      return c;
    } else {
      switch (c - 110 | 0) {
        case 0 : 
            return /* "\n" */10;
        case 4 : 
            return /* "\r" */13;
        case 1 : 
        case 2 : 
        case 3 : 
        case 5 : 
            return c;
        case 6 : 
            return /* "\t" */9;
        
      }
    }
  } else if (c !== 98) {
    return c;
  } else {
    return /* "\b" */8;
  }
}

function char_for_decimal_code(lexbuf, i) {
  var c = (Caml_int32.imul(100, Lexing.lexeme_char(lexbuf, i) - 48 | 0) + Caml_int32.imul(10, Lexing.lexeme_char(lexbuf, i + 1 | 0) - 48 | 0) | 0) + (Lexing.lexeme_char(lexbuf, i + 2 | 0) - 48 | 0) | 0;
  if (c < 0 || c > 255) {
    if (comment_start_loc[0] !== /* [] */0) {
      return /* "x" */120;
    } else {
      throw [
            $$Error$4,
            /* Illegal_escape */Block.__(1, [Lexing.lexeme(lexbuf)]),
            curr(lexbuf)
          ];
    }
  } else {
    return Char.chr(c);
  }
}

function char_for_hexadecimal_code(lexbuf, i) {
  var d1 = Lexing.lexeme_char(lexbuf, i);
  var val1 = d1 >= 97 ? d1 - 87 | 0 : (
      d1 >= 65 ? d1 - 55 | 0 : d1 - 48 | 0
    );
  var d2 = Lexing.lexeme_char(lexbuf, i + 1 | 0);
  var val2 = d2 >= 97 ? d2 - 87 | 0 : (
      d2 >= 65 ? d2 - 55 | 0 : d2 - 48 | 0
    );
  return Char.chr((val1 << 4) + val2 | 0);
}

function cvt_int_literal(s) {
  return -Caml_format.caml_int_of_string("-" + s) | 0;
}

function cvt_int32_literal(s) {
  return -Caml_format.caml_int32_of_string("-" + $$String.sub(s, 0, s.length - 1 | 0)) | 0;
}

function cvt_int64_literal(s) {
  return Caml_int64.neg(Caml_format.caml_int64_of_string("-" + $$String.sub(s, 0, s.length - 1 | 0)));
}

function cvt_nativeint_literal(s) {
  return -Caml_format.caml_nativeint_of_string("-" + $$String.sub(s, 0, s.length - 1 | 0));
}

function remove_underscores(s) {
  var l = s.length;
  var b = Caml_string.caml_create_string(l);
  var _src = 0;
  var _dst = 0;
  while(true) {
    var dst = _dst;
    var src = _src;
    if (src >= l) {
      if (dst >= l) {
        return s;
      } else {
        return Bytes.sub_string(b, 0, dst);
      }
    } else {
      var c = Caml_string.get(s, src);
      if (c !== 95) {
        b[dst] = c;
        _dst = dst + 1 | 0;
        _src = src + 1 | 0;
        continue ;
        
      } else {
        _src = src + 1 | 0;
        continue ;
        
      }
    }
  };
}

function get_label_name(lexbuf) {
  var s = Lexing.lexeme(lexbuf);
  var name = $$String.sub(s, 1, s.length - 2 | 0);
  if (Hashtbl.mem(keyword_table, name)) {
    throw [
          $$Error$4,
          /* Keyword_as_label */Block.__(4, [name]),
          curr(lexbuf)
        ];
  }
  return name;
}

function update_loc(lexbuf, file, line, absolute, chars) {
  var pos = lexbuf[/* lex_curr_p */11];
  var new_file = file ? file[0] : pos[/* pos_fname */0];
  lexbuf[/* lex_curr_p */11] = /* record */[
    /* pos_fname */new_file,
    /* pos_lnum */absolute ? line : pos[/* pos_lnum */1] + line | 0,
    /* pos_bol */pos[/* pos_cnum */3] - chars | 0,
    /* pos_cnum */pos[/* pos_cnum */3]
  ];
  return /* () */0;
}

var preprocessor = [/* None */0];

var escaped_newlines = [/* false */0];

function warn_latin1(lexbuf) {
  return prerr_warning(curr(lexbuf), /* Deprecated */Block.__(0, ["ISO-Latin1 characters in identifiers"]));
}

var comment_list = [/* [] */0];

function add_comment(com) {
  comment_list[0] = /* :: */[
    com,
    comment_list[0]
  ];
  return /* () */0;
}

function add_docstring_comment(ds) {
  return add_comment(/* tuple */[
              ds[/* ds_body */0],
              ds[/* ds_loc */1]
            ]);
}

function report_error$2(ppf, param) {
  if (typeof param === "number") {
    switch (param) {
      case 0 : 
          return Format.fprintf(ppf, /* Format */[
                      /* String_literal */Block.__(11, [
                          "String literal not terminated",
                          /* End_of_format */0
                        ]),
                      "String literal not terminated"
                    ]);
      case 1 : 
          return Format.fprintf(ppf, /* Format */[
                      /* String_literal */Block.__(11, [
                          "Unterminated parens in conditional predicate",
                          /* End_of_format */0
                        ]),
                      "Unterminated parens in conditional predicate"
                    ]);
      case 2 : 
          return Format.fprintf(ppf, /* Format */[
                      /* String_literal */Block.__(11, [
                          "#if not terminated",
                          /* End_of_format */0
                        ]),
                      "#if not terminated"
                    ]);
      case 3 : 
          return Format.fprintf(ppf, /* Format */[
                      /* String_literal */Block.__(11, [
                          "#else not terminated",
                          /* End_of_format */0
                        ]),
                      "#else not terminated"
                    ]);
      case 4 : 
          return Format.fprintf(ppf, /* Format */[
                      /* String_literal */Block.__(11, [
                          "Unexpected token in conditional predicate",
                          /* End_of_format */0
                        ]),
                      "Unexpected token in conditional predicate"
                    ]);
      case 5 : 
          return Format.fprintf(ppf, /* Format */[
                      /* String_literal */Block.__(11, [
                          "Expect `then` after conditioal predicate",
                          /* End_of_format */0
                        ]),
                      "Expect `then` after conditioal predicate"
                    ]);
      case 6 : 
          return Format.fprintf(ppf, /* Format */[
                      /* String_literal */Block.__(11, [
                          "Unexpected directive",
                          /* End_of_format */0
                        ]),
                      "Unexpected directive"
                    ]);
      
    }
  } else {
    switch (param.tag | 0) {
      case 0 : 
          return Curry._1(Format.fprintf(ppf, /* Format */[
                          /* String_literal */Block.__(11, [
                              "Illegal character (",
                              /* String */Block.__(2, [
                                  /* No_padding */0,
                                  /* Char_literal */Block.__(12, [
                                      /* ")" */41,
                                      /* End_of_format */0
                                    ])
                                ])
                            ]),
                          "Illegal character (%s)"
                        ]), Char.escaped(param[0]));
      case 1 : 
          return Curry._1(Format.fprintf(ppf, /* Format */[
                          /* String_literal */Block.__(11, [
                              "Illegal backslash escape in string or character (",
                              /* String */Block.__(2, [
                                  /* No_padding */0,
                                  /* Char_literal */Block.__(12, [
                                      /* ")" */41,
                                      /* End_of_format */0
                                    ])
                                ])
                            ]),
                          "Illegal backslash escape in string or character (%s)"
                        ]), param[0]);
      case 2 : 
          return Format.fprintf(ppf, /* Format */[
                      /* String_literal */Block.__(11, [
                          "Comment not terminated",
                          /* End_of_format */0
                        ]),
                      "Comment not terminated"
                    ]);
      case 3 : 
          return Curry._2(Format.fprintf(ppf, /* Format */[
                          /* String_literal */Block.__(11, [
                              "This comment contains an unterminated string literal",
                              /* Formatting_lit */Block.__(17, [
                                  /* Flush_newline */4,
                                  /* Alpha */Block.__(15, [/* String_literal */Block.__(11, [
                                          "String literal begins here",
                                          /* End_of_format */0
                                        ])])
                                ])
                            ]),
                          "This comment contains an unterminated string literal@.%aString literal begins here"
                        ]), print_error, param[1]);
      case 4 : 
          return Curry._1(Format.fprintf(ppf, /* Format */[
                          /* Char_literal */Block.__(12, [
                              /* "`" */96,
                              /* String */Block.__(2, [
                                  /* No_padding */0,
                                  /* String_literal */Block.__(11, [
                                      "' is a keyword, it cannot be used as label name",
                                      /* End_of_format */0
                                    ])
                                ])
                            ]),
                          "`%s' is a keyword, it cannot be used as label name"
                        ]), param[0]);
      case 5 : 
          return Curry._1(Format.fprintf(ppf, /* Format */[
                          /* String_literal */Block.__(11, [
                              "Integer literal exceeds the range of representable integers of type ",
                              /* String */Block.__(2, [
                                  /* No_padding */0,
                                  /* End_of_format */0
                                ])
                            ]),
                          "Integer literal exceeds the range of representable integers of type %s"
                        ]), param[0]);
      case 6 : 
          return Curry._1(Format.fprintf(ppf, /* Format */[
                          /* String_literal */Block.__(11, [
                              "Illegal semantic version string ",
                              /* String */Block.__(2, [
                                  /* No_padding */0,
                                  /* End_of_format */0
                                ])
                            ]),
                          "Illegal semantic version string %s"
                        ]), param[0]);
      case 7 : 
          return Curry._2(Format.fprintf(ppf, /* Format */[
                          /* String_literal */Block.__(11, [
                              "Conditional expression type mismatch (",
                              /* String */Block.__(2, [
                                  /* No_padding */0,
                                  /* Char_literal */Block.__(12, [
                                      /* "," */44,
                                      /* String */Block.__(2, [
                                          /* No_padding */0,
                                          /* Char_literal */Block.__(12, [
                                              /* ")" */41,
                                              /* End_of_format */0
                                            ])
                                        ])
                                    ])
                                ])
                            ]),
                          "Conditional expression type mismatch (%s,%s)"
                        ]), string_of_type_directive(param[0]), string_of_type_directive(param[1]));
      
    }
  }
}

register_error_of_exn((function (param) {
        if (param[0] === $$Error$4) {
          return /* Some */[error_of_printer(param[2], report_error$2, param[1])];
        } else {
          return /* None */0;
        }
      }));

var __ocaml_lex_tables = /* record */[
  /* lex_base */"\0\0\xa4\xff\xa5\xff\xe0\0\x03\x01&\x01I\x01l\x01\x8f\x01\xbc\xff\xb2\x01\xd7\x01\xc4\xff[\0\xfc\x01\x1f\x02D\0G\0T\0B\x02\xd5\xff\xd7\xff\xda\xffe\x02\xc4\x02\xe7\x02Y\0\xff\0\x05\x03\xec\xffR\x03s\x03\xbc\x03\x8c\x04\\\x05,\x06\x0b\x07g\x077\b}\0\xfe\xff\x01\0\x05\0\xff\xff\x06\0\x07\0\x16\t4\t\x04\n\xfa\xff\xf9\xff\xd4\n\xa4\x0b\xf7\xff\xf6\xff\xed\xff\xee\xff\xef\xff]\0v\x02[\0n\0\xe7\x02\x07\x04\xd7\x04e\x02\xfe\x02v\0\xc2\xff\xeb\xffx\x05\x84\f`\0q\0\x0b\0\xea\xff\xe9\xff\xe5\xff\xe5\x04\x80\0s\0\xe8\xff\xe0\0u\0\xe7\xffw\x06\x93\0\xe6\xff\x92\0\xe1\xff\x94\0\xe0\xff\xd9\0\x84\f\xdf\xff\xab\f\xaf\b\xae\x06\xde\xff\f\0\x18\x01,\x01P\x01-\x01\xde\xff\r\0\xd9\f\0\r#\rI\r\xd2\xff\xce\xff\xcf\xff\xd0\xff\xcc\xffl\r\x9a\0\xb7\0\xc5\xff\xc6\xff\xc7\xff\xc7\0\xb6\xff\xb8\xff\xbf\xff\x8f\r\xbb\xff\xbd\xff\xb2\r\xd5\r\xf8\r\x1b\x0e\xeb\x05\xf3\xff\xf4\xff\x11\0\xf5\xff>\x02\xac\x07\xfd\xff\xdf\0\xf1\0\xff\xff\xfe\xff\xfc\xff\xc8\x07-\x0e\xfa\0\xfc\0\x12\0\xfb\xff\xfa\xff\xf9\xff\x80\t\x1e\x03\x03\x01\xf8\xff\\\x03\x04\x01\xf7\xffO\n\x05\x01\xf6\xff+\x01\xc7\x01\xf7\xff\xf8\xff\xf9\xff;\x01v\x0e\xff\xff\xfa\xff\x1f\x0b$\x04\xfd\xff&\x01E\x01^\x01\xfc\x04\xfc\xff\xef\x0b\xfb\xff_\x01\xb5\x01\xfc\xff\xee\x06\xfe\xff\xff\xffo\x01p\x01\xfd\xffJ\x07\x10\x01\x13\x012\x01?\x01\x1a\x01k\x01!\x01\x13\0\xff\xff",
  /* lex_backtrk */"\xff\xff\xff\xff\xff\xffX\0W\0T\0S\0L\0J\0\xff\xffA\0>\0\xff\xff7\x006\x004\x002\0.\0,\0O\0\xff\xff\xff\xff\xff\xff#\0\"\0)\0'\0&\0<\0\xff\xff\x0e\0\x0e\0\r\0\f\0\x0b\0\n\0\x07\0\x04\0\x03\0\x02\0\xff\xff[\0[\0\xff\xff\xff\xff\xff\xffR\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x0f\0\xff\xff\xff\xff\xff\xff\x0e\0\x0e\0\x0e\0\x0f\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1a\0\x1a\0\x1a\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1b\0\xff\xff\x1c\0\xff\xff\x1d\0V\0\xff\xffY\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\0U\0P\0+\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff5\0F\0E\0\xff\xff\xff\xff\xff\xffH\0\xff\xff\xff\xff\xff\xff?\0\xff\xff\xff\xffQ\0K\0N\0M\0\xff\xff\xff\xff\xff\xff\f\0\xff\xff\f\0\f\0\xff\xff\f\0\f\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\b\0\b\0\xff\xff\xff\xff\x05\0\x05\0\xff\xff\x01\0\x05\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x03\0\xff\xff\xff\xff\x03\0\xff\xff\xff\xff\xff\xff\x02\0\xff\xff\xff\xff\x01\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff",
  /* lex_default */"\x01\0\0\0\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\0\0\0\0\xff\xff\xff\xff\xff\xff\xff\xffH\0\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\0\0\xff\xff\xff\xff\0\0\0\0\0\0\0\0\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\0\0\xff\xffM\0\xff\xff\xff\xff\xff\xff\0\0\0\0\0\0\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\0\0\xff\xff\xff\xff\0\0\xff\xff\0\0\xff\xff\0\0\xff\xff\xff\xff\0\0\xff\xffd\0\xff\xff\0\0\xff\xffd\0e\0d\0g\0\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\0\0\0\0\0\0\0\0\xff\xff\xff\xff\xff\xff\0\0\0\0\0\0\xff\xff\0\0\0\0\0\0\xff\xff\0\0\0\0\xff\xff\xff\xff\xff\xff\xff\xff\x85\0\0\0\0\0\xff\xff\0\0\x93\0\xff\xff\0\0\xff\xff\xff\xff\0\0\0\0\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\0\0\0\0\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\0\0\xff\xff\xff\xff\0\0\xff\xff\xa5\0\0\0\0\0\0\0\xff\xff\xab\0\0\0\0\0\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\0\0\xff\xff\xb8\0\0\0\xff\xff\0\0\0\0\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xc2\0\xc5\0\xff\xff\xc5\0\xff\xff\xff\xff\0\0",
  /* lex_trans */"\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0'\0(\0(\0'\0)\0-\0+\0+\0(\0,\0,\0-\0I\0b\0h\0J\0c\0i\0\x86\0\x94\0\xc8\0\xa3\0\x95\0'\0\b\0\x1d\0\x18\0\x06\0\x04\0\x17\0\x1b\0\x1a\0\x15\0\x19\0\x07\0\x14\0\x13\0\x12\0\x03\0\x1f\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x11\0\x10\0\x0f\0\x0e\0\n\0$\0\x05\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0\r\0*\0\f\0\x05\0&\0\x16\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0\x1c\0\x0b\0\t\0%\0r\0t\0q\0n\0X\0p\0o\0'\0L\0C\0'\0C\0A\0A\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0w\0K\0v\0Q\0u\0T\0'\0@\0@\0@\0@\0@\0@\0@\0@\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0R\0R\0R\0R\0R\0R\0R\0R\0R\0R\0W\0Y\0Z\0[\0\\\0{\0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0x\0 \0 \0 \0 \0 \0 \0 \0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0y\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\x02\0\x03\0[\0\\\0\x03\0\x03\0\x03\0z\0\x8f\0I\0\x03\0\x03\0J\0\x03\0\x03\0\x03\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0\x03\0\x8e\0\x03\0\x03\0\x03\0\x03\0\x03\0\x98\0b\0\x97\0\x03\0c\0\xff\xff\x03\0\x03\0\x03\0\x9c\0\x9f\0\xa2\0\x03\0\x03\0\xaf\0\x03\0\x03\0\x03\0\xc1\0\xc2\0\x86\0b\0h\0\xa3\0c\0i\0\xc6\0\xc3\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\xc7\0\xa7\0\xaf\0\x05\0\xb6\0\xc4\0\x05\0\x05\0\x05\0\0\0g\0\xaf\0\x05\0\x05\0\xb1\0\x05\0\x05\0\x05\0\0\0\0\0\0\0f\0b\0G\0\x03\0c\0\x03\0\0\0\x05\0\x03\0\x05\0\x05\0\x05\0\x05\0\x05\0\0\0\xaf\0\xa7\0\x06\0\xb1\0\xb6\0\x06\0\x06\0\x06\0f\0\0\0e\0\x06\0\x06\0\xc4\0\x06\0\x06\0\x06\0\xbb\0\xbb\0\0\0\xbd\0\xbd\0\0\0\x03\0\0\0\x03\0\0\0\x06\0\x05\0\x06\0\x06\0\x06\0\x06\0\x06\0\0\0\0\0\0\0k\0\0\0\0\0k\0k\0k\0\0\0\0\0\0\0k\0k\0\0\0k\0\x83\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\x05\0\0\0\x05\0\0\0k\0\x06\0k\0\x82\0k\0k\0k\0\0\0\0\0\0\0\x80\0\0\0\0\0\x80\0\x80\0\x80\0\0\0\0\0\0\0\x80\0\x80\0\0\0\x80\0\x80\0\x80\0\xbb\0\0\0\0\0\xbc\0\0\0\0\0\x06\0\0\0\x06\0\0\0\x80\0k\0\x80\0\x81\0\x80\0\x80\0\x80\0\0\0\xa7\0\0\0\x06\0\xa8\0\0\0\x06\0\x06\0\x06\0\0\0\0\0\0\0\x06\0\x06\0\0\0\x06\0\x06\0\x06\0\0\0\0\0\0\0\0\0\0\0\0\0k\0\xaa\0k\0\0\0\x06\0\x80\0\x06\0\x06\0\x06\0\x06\0\x06\0\0\0\0\0\0\0\0\0\0\0\x06\0\0\0\0\0\x06\0\x06\0\x06\0\0\0\xff\xff\0\0\x06\0\x06\0\0\0\x06\0\x06\0\x06\0\0\0\0\0\0\0\0\0\x80\0\0\0\x80\0\0\0\x7f\0\x06\0\x06\0\0\0\x06\0\x06\0\x06\0\x06\0\x06\0\xff\xff\0\0\0\0\0\0\0\0\x06\0\0\0\0\0\x06\0\x06\0\x06\0\xa9\0\0\0\0\0\x06\0\x06\0\0\0\x06\0\x06\0\x06\0\xff\xff\xff\xff\x06\0~\0\x06\0\xb9\0\xff\xff\0\0|\0\x06\0\x06\0\0\0\x06\0\x06\0\x06\0\x06\0\x06\0\0\0\0\0\xff\xff\x06\0\0\0\0\0\x06\0\x06\0\x06\0\0\0\0\0\x94\0\x06\0\x06\0\x95\0s\0\x06\0\x06\0\0\0\xff\xff\0\0\0\0}\0\0\0\x06\0\0\0\0\0\0\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\0\0\0\0\0\0k\0\0\0\x96\0k\0k\0k\0\0\0\0\0\xff\xffk\0k\0\0\0k\0l\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\x06\0\0\0\x06\0\0\0k\0\x06\0k\0k\0m\0k\0k\0\0\0\0\0\0\0\x06\0\0\0\0\0\x06\0\x06\0j\0\0\0\0\0\0\0\x06\0\x06\0\0\0\x06\0\x06\0\x06\0A\0A\0\0\0\0\0\0\0\x92\0\x06\0\0\0\x06\0\0\0\x06\0k\0\x06\0\x06\0\x06\0\x06\0\x06\0;\0;\0;\0;\0;\0;\0;\0;\0;\0;\0\0\x008\0\0\0\0\0\0\0\xba\0\0\0\0\0\0\0\0\0\0\0:\0\0\0\0\0k\0\0\0k\0\0\0\0\0\x06\0A\0\0\0\0\0\xa6\0\0\0\0\0\0\0\0\0\0\0a\0\0\0\0\0\0\x009\0\0\x007\0\0\0;\0\0\0\0\0\0\0\0\0\0\0:\0\0\0\0\0\0\0\0\0\0\0\x06\0\0\0\x06\0a\0_\0\0\0_\0_\0_\0_\0\0\0\0\0\0\0_\0_\0\0\0_\0_\0_\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0_\0\0\0_\0_\0_\0_\0_\0\0\0\0\0\0\0\x03\0\0\0\0\0\x03\0\x03\0\x03\0\0\0\0\0^\0]\0\x03\0\0\0\x03\0\x03\0\x03\0?\0?\0?\0?\0?\0?\0?\0?\0?\0?\0\x03\0_\0\x03\0\x03\0\x03\0\x03\0\x03\0?\0?\0?\0?\0?\0?\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0\0\0\0\0\0\0\0\0\0\0\0\0\xff\xff\0\0_\0D\0_\0\0\0\0\0\x03\0\0\0\0\0?\0?\0?\0?\0?\0?\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\0\0\0\0\0\0\0\0\0\0B\0\0\0\0\0\0\0\0\0\0\0\x03\0F\0\x03\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0;\0E\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x9e\0\x9e\0\x9e\0\x9e\0\x9e\0\x9e\0\x9e\0\x9e\0\x9e\0\x9e\0\0\0:\0\0\0\0\0\0\0\0\0\0\0\0\x008\0\0\0\0\0;\0\0\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\0\0\0\0\0\0\0\0\x1e\0\0\0\0\0\0\0<\0\0\0:\0:\0\0\0\0\0\0\0\0\0\0\x009\x008\x007\0\0\0=\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0>\0\0\0\0\0\0\0\0\0\0\0\0\0\x1e\0\0\0\0\0<\0\0\0\0\0:\0\0\0\0\0\0\0\0\0\0\0\0\x009\0\0\x007\0=\0 \0\0\0\0\0\0\0\0\0\0\0\0\0\0\0>\0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0\0\0\0\0\0\0\0\0\0\0\0\0\0\0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0\0\0\0\0\0\0\0\0 \0\0\0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0?\0?\0?\0?\0?\0?\0?\0?\0?\0?\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0?\0?\0?\0?\0?\0?\0\0\0\0\0\0\0\0\0\0\x008\0\xb2\0\xb2\0\xb2\0\xb2\0\xb2\0\xb2\0\xb2\0\xb2\0\xb2\0\xb2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0?\0\0\0?\0?\0?\0?\0?\0?\0\0\0\0\0\0\0\0\0\0\x009\0\0\x007\0\0\0\0\0\0\0\0\0\0\0\0\0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0\0\0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0!\0 \0 \0 \0 \0 \0 \0 \0 \0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0\0\0\0\0\0\0\0\0!\0\0\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0@\0@\0@\0@\0@\0@\0@\0@\0\0\0\0\0\0\0\0\0\0\0\0\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0\0\0\0\0\0\0\0\x008\0\0\0\0\0U\0U\0U\0U\0U\0U\0\xb3\0\xb3\0\xb3\0\xb3\0\xb3\0\xb3\0\xb3\0\xb3\0\xb3\0\xb3\0@\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x009\0\0\x007\0U\0U\0U\0U\0U\0U\0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0\0\0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0\"\0 \0 \0 \0 \0 \0 \0 \0 \0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\0\0\0\0\0\0\0\0\"\0\0\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0F\0\0\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0\0\0E\0\x86\0\0\0\0\0\x87\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x8b\0\0\0\0\0\0\0\0\0\x89\0\x8d\0\0\0\x8c\0\0\0\0\0\0\0\0\0\0\0\0\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\0\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0#\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0\x8a\0\0\0\0\0\0\0\0\0\0\0\0\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0\0\0\0\0\0\0\0\0#\0\0\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0\0\0\0\0\0\0\0\0\0\0\0\0a\0V\0V\0V\0V\0V\0V\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0V\0V\0V\0V\0V\0V\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0\0\0\0\0\0\0\x88\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\0\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\0\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0.\0\0\0\0\0.\0.\0.\0\0\0\0\0\0\0.\0.\0\0\0.\0.\0.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0.\0\0\0.\0.\0.\0.\0.\0\0\0\xbf\0\0\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0.\x004\0\xbe\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\0\0\0.\0.\0.\0\0\0.\0.\0.\0\0\0\0\0\0\0.\0.\0\0\0.\0.\0.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0.\0\0\0.\0.\0.\0.\0.\0\0\0\xbf\0\0\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0.\x000\0\xbe\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\0\0\0.\0\0\0.\0\0\0\0\0\0\0\0\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\0\0\x003\x003\x003\x003\x003\x003\x003\x003\0\x91\0\0\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x90\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\0\0\x90\0\0\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0#\0/\0/\0/\0/\0/\0/\0/\0/\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0\0\0\0\0\0\0\0\0#\0\0\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0\0\0\0\0\0\0\0\0\0\0\0\0f\0b\0\0\0\0\0c\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0f\0\0\0e\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\0\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\0\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0.\0\0\0\0\0.\0.\0.\0\0\0\0\0\0\0.\0.\0\0\0.\0.\0.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0.\0\0\0.\0.\0.\0.\0.\0\0\0\0\0\0\0\0\0/\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\x002\0\0\0\0\0\0\0\0\0\0\0.\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0\0\0\0\0\0\0.\0/\0.\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0\xff\xff\xa0\0\xa0\0\xa0\0\xa0\0\xa0\0\xa0\0\xa0\0\xa0\0\xa0\0\xa0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xa0\0\xa0\0\xa0\0\xa0\0\xa0\0\xa0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xa0\0\xa0\0\xa0\0\xa0\0\xa0\0\xa0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0\0\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\x000\0/\0/\0/\0/\0/\0/\0/\0/\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x001\0\0\0\0\0\0\0\0\0\0\0\0\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\0\0\0\0\0\0\0\0\x000\0\0\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\0\xa1\0\xa1\0\xa1\0\xa1\0\xa1\0\xa1\0\xa1\0\xa1\0\xa1\0\xa1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xa1\0\xa1\0\xa1\0\xa1\0\xa1\0\xa1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xa1\0\xa1\0\xa1\0\xa1\0\xa1\0\xa1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0\0\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\x003\0/\0/\0/\0/\0/\0/\0/\0/\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x006\0\0\0\0\0\0\0\0\0\0\0\0\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\0\0\0\0\0\0\0\0\x003\0\0\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\0\xb4\0\xb4\0\xb4\0\xb4\0\xb4\0\xb4\0\xb4\0\xb4\0\xb4\0\xb4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xb4\0\xb4\0\xb4\0\xb4\0\xb4\0\xb4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xb4\0\xb4\0\xb4\0\xb4\0\xb4\0\xb4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\0\0\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x004\x003\x003\x003\x003\x003\x003\x003\x003\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x005\0\0\0\0\0\0\0\0\0\0\0\0\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\0\0\0\0\0\0\0\0\x004\0\0\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\0\xb5\0\xb5\0\xb5\0\xb5\0\xb5\0\xb5\0\xb5\0\xb5\0\xb5\0\xb5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xb5\0\xb5\0\xb5\0\xb5\0\xb5\0\xb5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xb5\0\xb5\0\xb5\0\xb5\0\xb5\0\xb5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\0\0\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\0\0\x003\x003\x003\x003\x003\x003\x003\x003\0P\0]\0P\0\0\0]\0]\0]\0P\0\0\0\0\0]\0]\0\0\0]\0]\0]\0O\0O\0O\0O\0O\0O\0O\0O\0O\0O\0]\0\0\0]\0]\0]\0]\0]\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_\0\0\0_\0_\0_\0_\0\0\0\0\0\0\0_\0_\0\0\0_\0_\0_\0\0\0\0\0\0\0\0\0\0\0P\0\0\0]\0\0\0\0\0_\0P\0_\0_\0_\0_\0_\0\0\0\0\0\0\0\0\0\0\0\0\0P\0\0\0\0\0\0\0P\0\0\0P\0\0\0\x06\0\0\0N\0\x06\0\x06\0\x06\0]\0\0\0]\0\x06\0\x06\0\0\0\x06\0\x06\0\x06\0_\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x06\0\0\0\x06\0\x06\0\x06\0\x06\0\x06\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0k\0\0\0\0\0k\0k\0k\0_\0\0\0_\0k\0k\0\0\0k\0k\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x06\0\0\0\0\0k\0\0\0k\0k\0k\0k\0k\0\0\0\0\0\0\0k\0\0\0\0\0k\0k\0k\0\0\0\0\0\0\0k\0k\0\0\0k\0k\0k\0\0\0\0\0\x06\0\0\0\x06\0\0\0\0\0\0\0\0\0\0\0k\0k\0k\0k\0k\0k\0k\0\0\0\0\0\0\0\0\0\0\0\0\0k\0\0\0\0\0k\0k\0k\0\0\0\0\0\0\0k\0k\0\0\0k\0k\0k\0\0\0\0\0\0\0k\0\0\0k\0\0\0\0\0k\0\0\0k\0\xff\xffk\0k\0k\0k\0k\0\0\0\0\0\0\0\x06\0\0\0\0\0\x06\0\x06\0\x06\0\0\0\0\0\0\0\x06\0\x06\0\0\0\x06\0\x06\0\x06\0\0\0\0\0\0\0k\0\0\0k\0\0\0\0\0\0\0\0\0\x06\0k\0\x06\0\x06\0\x06\0\x06\0\x06\0\0\0\0\0\0\0\x06\0\0\0\0\0\x06\0\x06\0\x06\0\0\0\0\0\0\0\x06\0\x06\0\0\0\x06\0\x06\0\x06\0\0\0\0\0\0\0\0\0\0\0\0\0k\0\0\0k\0\0\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\0\0\0\0\0\0\x80\0\0\0\0\0\x80\0\x80\0\x80\0\0\0\0\0\0\0\x80\0\x80\0\0\0\x80\0\x80\0\x80\0\0\0\0\0\0\0\0\0\0\0\0\0\x06\0\0\0\x06\0\0\0\x80\0\x06\0\x80\0\x80\0\x80\0\x80\0\x80\0\0\0\0\0\0\0\x80\0\0\0\0\0\x80\0\x80\0\x80\0\0\0\0\0\0\0\x80\0\x80\0\0\0\x80\0\x80\0\x80\0\0\0\0\0\0\0\0\0\0\0\0\0\x06\0\0\0\x06\0\0\0\x80\0\x80\0\x80\0\x80\0\x80\0\x80\0\x80\0\0\0\0\0\0\0k\0\0\0\0\0k\0k\0k\0\0\0\0\0\0\0k\0k\0\0\0k\0k\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\x80\0\0\0\x80\0\0\0k\0\x80\0k\0k\0k\0k\0k\0\0\0\0\0\0\0k\0\0\0\0\0k\0k\0k\0\0\0\0\0\0\0k\0k\0\0\0k\0k\0k\0\0\0\0\0\x9b\0\0\0\x9b\0\0\0\x80\0\0\0\x80\0\x9b\0k\0k\0k\0k\0k\0k\0k\0\0\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0k\0\0\0k\0\0\0\0\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\xaf\0\0\0\0\0\xb0\0\0\0\0\0\0\0\0\0\0\0\x9b\0\0\0\0\0\0\0\0\0\0\0\x9b\0\0\0\0\0\0\0\0\0\0\0\0\0\xae\0k\0\xae\0k\0\0\0\x9b\0\0\0\xae\0\0\0\x9b\0\0\0\x9b\0\0\0\0\0\0\0\x99\0\xad\0\xad\0\xad\0\xad\0\xad\0\xad\0\xad\0\xad\0\xad\0\xad\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xae\0\0\0\0\0\0\0\0\0\0\0\xae\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xae\0\0\0\0\0\0\0\xae\0\0\0\xae\0\0\0\0\0\0\0\xac\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xff\xff",
  /* lex_check */"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\0\0)\0\0\0\0\0)\0*\0,\0-\0*\0,\0-\0J\0c\0i\0J\0c\0i\0\x87\0\x95\0\xc7\0\x87\0\x95\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x10\0\r\0\x11\0\x12\0\x1a\0\x11\0\x11\0'\0H\0:\0'\0:\0<\0<\0:\0:\0:\0:\0:\0:\0:\0:\0:\0:\0\r\0I\0\r\0P\0\r\0S\0'\0=\0=\0=\0=\0=\0=\0=\0=\0C\0C\0C\0C\0C\0C\0C\0C\0C\0C\0O\0O\0O\0O\0O\0O\0O\0O\0O\0O\0V\0X\0X\0Z\0Z\0t\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\r\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0u\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x03\0\\\0\\\0\x03\0\x03\0\x03\0y\0\x8c\0\x1b\0\x03\0\x03\0\x1b\0\x03\0\x03\0\x03\0R\0R\0R\0R\0R\0R\0R\0R\0R\0R\0\x03\0\x8d\0\x03\0\x03\0\x03\0\x03\0\x03\0\x93\0d\0\x94\0\x04\0d\0\x1b\0\x04\0\x04\0\x04\0\x9b\0\x9e\0\xa1\0\x04\0\x04\0\xaf\0\x04\0\x04\0\x04\0\xc0\0\xc1\0\xa3\0e\0g\0\xa3\0e\0g\0\xc4\0\xc2\0\x04\0\x03\0\x04\0\x04\0\x04\0\x04\0\x04\0\xc6\0\xa8\0\xaf\0\x05\0\xa8\0\xc3\0\x05\0\x05\0\x05\0\xff\xffe\0\xb0\0\x05\0\x05\0\xb0\0\x05\0\x05\0\x05\0\xff\xff\xff\xff\xff\xfff\0f\0\x1b\0\x03\0f\0\x03\0\xff\xff\x05\0\x04\0\x05\0\x05\0\x05\0\x05\0\x05\0\xff\xff\xb1\0\xb6\0\x06\0\xb1\0\xb6\0\x06\0\x06\0\x06\0f\0\xff\xfff\0\x06\0\x06\0\xc5\0\x06\0\x06\0\x06\0\xbc\0\xbd\0\xff\xff\xbc\0\xbd\0\xff\xff\x04\0\xff\xff\x04\0\xff\xff\x06\0\x05\0\x06\0\x06\0\x06\0\x06\0\x06\0\xff\xff\xff\xff\xff\xff\x07\0\xff\xff\xff\xff\x07\0\x07\0\x07\0\xff\xff\xff\xff\xff\xff\x07\0\x07\0\xff\xff\x07\0\x07\0\x07\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x05\0\xff\xff\x05\0\xff\xff\x07\0\x06\0\x07\0\x07\0\x07\0\x07\0\x07\0\xff\xff\xff\xff\xff\xff\b\0\xff\xff\xff\xff\b\0\b\0\b\0\xff\xff\xff\xff\xff\xff\b\0\b\0\xff\xff\b\0\b\0\b\0\xb7\0\xff\xff\xff\xff\xb7\0\xff\xff\xff\xff\x06\0\xff\xff\x06\0\xff\xff\b\0\x07\0\b\0\b\0\b\0\b\0\b\0\xff\xff\xa4\0\xff\xff\n\0\xa4\0\xff\xff\n\0\n\0\n\0\xff\xff\xff\xff\xff\xff\n\0\n\0\xff\xff\n\0\n\0\n\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x07\0\xa4\0\x07\0\xff\xff\n\0\b\0\n\0\n\0\n\0\n\0\n\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x0b\0\xff\xff\xff\xff\x0b\0\x0b\0\x0b\0\xff\xff\x1b\0\xff\xff\x0b\0\x0b\0\xff\xff\x0b\0\x0b\0\x0b\0\xff\xff\xff\xff\xff\xff\xff\xff\b\0\xff\xff\b\0\xff\xff\n\0\n\0\x0b\0\xff\xff\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0d\0\xff\xff\xff\xff\xff\xff\xff\xff\x0e\0\xff\xff\xff\xff\x0e\0\x0e\0\x0e\0\xa4\0\xff\xff\xff\xff\x0e\0\x0e\0\xff\xff\x0e\0\x0e\0\x0e\0e\0g\0\n\0\n\0\n\0\xb7\0\xc2\0\xff\xff\x0b\0\x0b\0\x0e\0\xff\xff\x0e\0\x0e\0\x0e\0\x0e\0\x0e\0\xff\xff\xff\xff\xc3\0\x0f\0\xff\xff\xff\xff\x0f\0\x0f\0\x0f\0\xff\xff\xff\xff\x89\0\x0f\0\x0f\0\x89\0\x0f\0\x0f\0\x0f\0\xff\xfff\0\xff\xff\xff\xff\x0b\0\xff\xff\x0b\0\xff\xff\xff\xff\xff\xff\x0f\0\x0e\0\x0f\0\x0f\0\x0f\0\x0f\0\x0f\0\xff\xff\xff\xff\xff\xff\x13\0\xff\xff\x89\0\x13\0\x13\0\x13\0\xff\xff\xff\xff\xc5\0\x13\0\x13\0\xff\xff\x13\0\x13\0\x13\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x0e\0\xff\xff\x0e\0\xff\xff\x13\0\x0f\0\x13\0\x13\0\x13\0\x13\0\x13\0\xff\xff\xff\xff\xff\xff\x17\0\xff\xff\xff\xff\x17\0\x17\0\x17\0\xff\xff\xff\xff\xff\xff\x17\0\x17\0\xff\xff\x17\0\x17\0\x17\0A\0A\0\xff\xff\xff\xff\xff\xff\x89\0\x0f\0\xff\xff\x0f\0\xff\xff\x17\0\x13\0\x17\0\x17\0\x17\0\x17\0\x17\0;\0;\0;\0;\0;\0;\0;\0;\0;\0;\0\xff\xffA\0\xff\xff\xff\xff\xff\xff\xb7\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff;\0\xff\xff\xff\xff\x13\0\xff\xff\x13\0\xff\xff\xff\xff\x17\0A\0\xff\xff\xff\xff\xa4\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x18\0\xff\xff\xff\xff\xff\xffA\0\xff\xffA\0\xff\xff;\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff;\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x17\0\xff\xff\x17\0\x18\0\x18\0\xff\xff\x18\0\x18\0\x18\0\x18\0\xff\xff\xff\xff\xff\xff\x18\0\x18\0\xff\xff\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\xff\xff\x18\0\x18\0\x18\0\x18\0\x18\0\xff\xff\xff\xff\xff\xff\x19\0\xff\xff\xff\xff\x19\0\x19\0\x19\0\xff\xff\xff\xff\x19\0\x19\0\x19\0\xff\xff\x19\0\x19\0\x19\0>\0>\0>\0>\0>\0>\0>\0>\0>\0>\0\x19\0\x18\0\x19\0\x19\0\x19\0\x19\0\x19\0>\0>\0>\0>\0>\0>\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x89\0\xff\xff\x18\0\x1c\0\x18\0\xff\xff\xff\xff\x19\0\xff\xff\xff\xff>\0>\0>\0>\0>\0>\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffB\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x19\0\x1c\0\x19\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1e\0\x1c\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\xff\xff\x1e\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1e\0\xff\xff\xff\xff\x1f\0\xff\xff\x1f\0\x1f\0\x1f\0\x1f\0\x1f\0\x1f\0\x1f\0\x1f\0\x1f\0\x1f\0\xff\xff\xff\xff\xff\xff\xff\xff\x1e\0\xff\xff\xff\xff\xff\xff\x1f\0\xff\xff\x1e\0\x1f\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1e\0\x1f\0\x1e\0\xff\xff\x1f\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1f\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1f\0\xff\xff\xff\xff\x1f\0\xff\xff\xff\xff\x1f\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1f\0\xff\xff\x1f\0\x1f\0 \0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1f\0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0\xff\xff\xff\xff\xff\xff\xff\xff \0\xff\xff \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0?\0?\0?\0?\0?\0?\0?\0?\0?\0?\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff?\0?\0?\0?\0?\0?\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff?\0\xad\0\xad\0\xad\0\xad\0\xad\0\xad\0\xad\0\xad\0\xad\0\xad\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff?\0\xff\xff?\0?\0?\0?\0?\0?\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff?\0\xff\xff?\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0\xff\xff \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0!\0 \0 \0 \0 \0 \0 \0 \0 \0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0\xff\xff\xff\xff\xff\xff\xff\xff!\0\xff\xff!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0@\0@\0@\0@\0@\0@\0@\0@\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffN\0N\0N\0N\0N\0N\0N\0N\0N\0N\0\xff\xff\xff\xff\xff\xff\xff\xff@\0\xff\xff\xff\xffN\0N\0N\0N\0N\0N\0\xb2\0\xb2\0\xb2\0\xb2\0\xb2\0\xb2\0\xb2\0\xb2\0\xb2\0\xb2\0@\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff@\0\xff\xff@\0N\0N\0N\0N\0N\0N\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0\xff\xff!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0\"\0!\0!\0!\0!\0!\0!\0!\0!\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\xff\xff\xff\xff\xff\xff\xff\xff\"\0\xff\xff\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0F\0\xff\xffF\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0\xff\xffF\0\x84\0\xff\xff\xff\xff\x84\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x84\0\xff\xff\xff\xff\xff\xff\xff\xff\x84\0\x84\0\xff\xff\x84\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\xff\xff\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0#\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0\x84\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0\xff\xff\xff\xff\xff\xff\xff\xff#\0\xff\xff#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffa\0U\0U\0U\0U\0U\0U\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffa\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffU\0U\0U\0U\0U\0U\0a\0a\0a\0a\0a\0a\0a\0a\0a\0a\0\xff\xff\xff\xff\xff\xff\x84\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0\xff\xff#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0\xff\xff#\0#\0#\0#\0#\0#\0#\0#\0$\0\xff\xff\xff\xff$\0$\0$\0\xff\xff\xff\xff\xff\xff$\0$\0\xff\xff$\0$\0$\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\0\xff\xff$\0$\0$\0$\0$\0\xff\xff\xb9\0\xff\xff\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0$\0$\0\xb9\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0\xff\xff$\0%\0$\0\xff\xff%\0%\0%\0\xff\xff\xff\xff\xff\xff%\0%\0\xff\xff%\0%\0%\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff%\0\xff\xff%\0%\0%\0%\0%\0\xff\xff\xbf\0\xff\xff\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0%\0%\0\xbf\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0\xff\xff%\0\xff\xff%\0\xff\xff\xff\xff\xff\xff\xff\xff$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0\xff\xff$\0$\0$\0$\0$\0$\0$\0$\0\x8a\0\xff\xff\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x91\0\x8a\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\xff\xff\x91\0\xff\xff%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0&\0%\0%\0%\0%\0%\0%\0%\0%\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0\xff\xff\xff\xff\xff\xff\xff\xff&\0\xff\xff&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff`\0`\0\xff\xff\xff\xff`\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff`\0\xff\xff`\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0\xff\xff&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0\xff\xff&\0&\0&\0&\0&\0&\0&\0&\0.\0\xff\xff\xff\xff.\0.\0.\0\xff\xff\xff\xff\xff\xff.\0.\0\xff\xff.\0.\0.\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff.\0\xff\xff.\0.\0.\0.\0.\0\xff\xff\xff\xff\xff\xff\xff\xff/\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff.\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0\xff\xff\xff\xff\xff\xff.\0/\0.\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0`\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0\xff\xff/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\x000\0/\0/\0/\0/\0/\0/\0/\0/\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff0\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\0\xff\xff\xff\xff\xff\xff\xff\xff0\0\xff\xff0\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\0\xa0\0\xa0\0\xa0\0\xa0\0\xa0\0\xa0\0\xa0\0\xa0\0\xa0\0\xa0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xa0\0\xa0\0\xa0\0\xa0\0\xa0\0\xa0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xa0\0\xa0\0\xa0\0\xa0\0\xa0\0\xa0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff0\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\0\xff\xff0\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x003\x000\x000\x000\x000\x000\x000\x000\x000\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff3\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\0\xff\xff\xff\xff\xff\xff\xff\xff3\0\xff\xff3\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\0\xac\0\xac\0\xac\0\xac\0\xac\0\xac\0\xac\0\xac\0\xac\0\xac\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xac\0\xac\0\xac\0\xac\0\xac\0\xac\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xac\0\xac\0\xac\0\xac\0\xac\0\xac\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff3\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\0\xff\xff3\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x004\x003\x003\x003\x003\x003\x003\x003\x003\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff4\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\0\xff\xff\xff\xff\xff\xff\xff\xff4\0\xff\xff4\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\0\xb4\0\xb4\0\xb4\0\xb4\0\xb4\0\xb4\0\xb4\0\xb4\0\xb4\0\xb4\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xb4\0\xb4\0\xb4\0\xb4\0\xb4\0\xb4\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xb4\0\xb4\0\xb4\0\xb4\0\xb4\0\xb4\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff4\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\0\xff\xff4\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\0\xff\xff4\x004\x004\x004\x004\x004\x004\x004\0G\0]\0G\0\xff\xff]\0]\0]\0G\0\xff\xff\xff\xff]\0]\0\xff\xff]\0]\0]\0G\0G\0G\0G\0G\0G\0G\0G\0G\0G\0]\0\xff\xff]\0]\0]\0]\0]\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff_\0\xff\xff_\0_\0_\0_\0\xff\xff\xff\xff\xff\xff_\0_\0\xff\xff_\0_\0_\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffG\0\xff\xff]\0\xff\xff\xff\xff_\0G\0_\0_\0_\0_\0_\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffG\0\xff\xff\xff\xff\xff\xffG\0\xff\xffG\0\xff\xffj\0\xff\xffG\0j\0j\0j\0]\0\xff\xff]\0j\0j\0\xff\xffj\0j\0j\0_\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffj\0\xff\xffj\0j\0j\0j\0j\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffk\0\xff\xff\xff\xffk\0k\0k\0_\0\xff\xff_\0k\0k\0\xff\xffk\0k\0k\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffj\0\xff\xff\xff\xffk\0\xff\xffk\0k\0k\0k\0k\0\xff\xff\xff\xff\xff\xffl\0\xff\xff\xff\xffl\0l\0l\0\xff\xff\xff\xff\xff\xffl\0l\0\xff\xffl\0l\0l\0\xff\xff\xff\xffj\0\xff\xffj\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffl\0k\0l\0l\0l\0l\0l\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffm\0\xff\xff\xff\xffm\0m\0m\0\xff\xff\xff\xff\xff\xffm\0m\0\xff\xffm\0m\0m\0\xff\xff\xff\xff\xff\xffk\0\xff\xffk\0\xff\xff\xff\xffl\0\xff\xffm\0G\0m\0m\0m\0m\0m\0\xff\xff\xff\xff\xff\xffs\0\xff\xff\xff\xffs\0s\0s\0\xff\xff\xff\xff\xff\xffs\0s\0\xff\xffs\0s\0s\0\xff\xff\xff\xff\xff\xffl\0\xff\xffl\0\xff\xff\xff\xff\xff\xff\xff\xffs\0m\0s\0s\0s\0s\0s\0\xff\xff\xff\xff\xff\xff}\0\xff\xff\xff\xff}\0}\0}\0\xff\xff\xff\xff\xff\xff}\0}\0\xff\xff}\0}\0}\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffm\0\xff\xffm\0\xff\xff}\0s\0}\0}\0}\0}\0}\0\xff\xff\xff\xff\xff\xff\x80\0\xff\xff\xff\xff\x80\0\x80\0\x80\0\xff\xff\xff\xff\xff\xff\x80\0\x80\0\xff\xff\x80\0\x80\0\x80\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffs\0\xff\xffs\0\xff\xff\x80\0}\0\x80\0\x80\0\x80\0\x80\0\x80\0\xff\xff\xff\xff\xff\xff\x81\0\xff\xff\xff\xff\x81\0\x81\0\x81\0\xff\xff\xff\xff\xff\xff\x81\0\x81\0\xff\xff\x81\0\x81\0\x81\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff}\0\xff\xff}\0\xff\xff\x81\0\x80\0\x81\0\x81\0\x81\0\x81\0\x81\0\xff\xff\xff\xff\xff\xff\x82\0\xff\xff\xff\xff\x82\0\x82\0\x82\0\xff\xff\xff\xff\xff\xff\x82\0\x82\0\xff\xff\x82\0\x82\0\x82\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x80\0\xff\xff\x80\0\xff\xff\x82\0\x81\0\x82\0\x82\0\x82\0\x82\0\x82\0\xff\xff\xff\xff\xff\xff\x83\0\xff\xff\xff\xff\x83\0\x83\0\x83\0\xff\xff\xff\xff\xff\xff\x83\0\x83\0\xff\xff\x83\0\x83\0\x83\0\xff\xff\xff\xff\x92\0\xff\xff\x92\0\xff\xff\x81\0\xff\xff\x81\0\x92\0\x83\0\x82\0\x83\0\x83\0\x83\0\x83\0\x83\0\xff\xff\x92\0\x92\0\x92\0\x92\0\x92\0\x92\0\x92\0\x92\0\x92\0\x92\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x82\0\xff\xff\x82\0\xff\xff\xff\xff\x83\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xa9\0\xff\xff\xff\xff\xa9\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x92\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x92\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xa9\0\x83\0\xa9\0\x83\0\xff\xff\x92\0\xff\xff\xa9\0\xff\xff\x92\0\xff\xff\x92\0\xff\xff\xff\xff\xff\xff\x92\0\xa9\0\xa9\0\xa9\0\xa9\0\xa9\0\xa9\0\xa9\0\xa9\0\xa9\0\xa9\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xa9\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xa9\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xa9\0\xff\xff\xff\xff\xff\xff\xa9\0\xff\xff\xa9\0\xff\xff\xff\xff\xff\xff\xa9\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xa9\0",
  /* lex_base_code */"\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\n\0$\0\f\0\0\0\0\0\0\0\x02\0\0\0\x1b\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\x02\0\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
  /* lex_backtrk_code */"\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0'\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
  /* lex_default_code */"\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x13\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
  /* lex_trans_code */"\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0$\0$\0\0\0$\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\x01\0\x16\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x07\0\x01\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
  /* lex_check_code */"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x18\0e\0\xa9\0\xb0\0e\0\xb1\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x18\0\xff\xffe\0\0\0f\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff`\0a\0\xff\xff\xff\xff\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0a\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffa\0a\0a\0a\0a\0a\0a\0a\0a\0a\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffe\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff",
  /* lex_code */"\xff\x04\xff\xff\x05\xff\xff\x07\xff\x06\xff\xff\x03\xff\0\x04\x01\x05\xff\x07\xff\xff\x06\xff\x07\xff\xff\0\x04\x01\x05\x03\x06\x02\x07\xff\x01\xff\xff\0\x01\xff"
];

function token(lexbuf) {
  lexbuf[/* lex_mem */9] = Caml_array.caml_make_vect(8, -1);
  var lexbuf$1 = lexbuf;
  var ___ocaml_lex_state = 0;
  while(true) {
    var __ocaml_lex_state = ___ocaml_lex_state;
    var __ocaml_lex_state$1 = Lexing.new_engine(__ocaml_lex_tables, __ocaml_lex_state, lexbuf$1);
    if (__ocaml_lex_state$1 > 91 || __ocaml_lex_state$1 < 0) {
      Curry._1(lexbuf$1[/* refill_buff */0], lexbuf$1);
      ___ocaml_lex_state = __ocaml_lex_state$1;
      continue ;
      
    } else {
      switch (__ocaml_lex_state$1) {
        case 0 : 
            if (!escaped_newlines[0]) {
              throw [
                    $$Error$4,
                    /* Illegal_character */Block.__(0, [Lexing.lexeme_char(lexbuf$1, 0)]),
                    curr(lexbuf$1)
                  ];
            }
            update_loc(lexbuf$1, /* None */0, 1, /* false */0, 0);
            return token(lexbuf$1);
        case 1 : 
            update_loc(lexbuf$1, /* None */0, 1, /* false */0, 0);
            return /* EOL */100;
        case 2 : 
            return token(lexbuf$1);
        case 3 : 
            return /* UNDERSCORE */94;
        case 4 : 
            return /* TILDE */89;
        case 5 : 
            return /* LABEL */Block.__(10, [get_label_name(lexbuf$1)]);
        case 6 : 
            warn_latin1(lexbuf$1);
            return /* LABEL */Block.__(10, [get_label_name(lexbuf$1)]);
        case 7 : 
            return /* QUESTION */76;
        case 8 : 
            return /* OPTLABEL */Block.__(13, [get_label_name(lexbuf$1)]);
        case 9 : 
            warn_latin1(lexbuf$1);
            return /* OPTLABEL */Block.__(13, [get_label_name(lexbuf$1)]);
        case 10 : 
            var s = Lexing.lexeme(lexbuf$1);
            try {
              return Hashtbl.find(keyword_table, s);
            }
            catch (exn){
              if (exn === Caml_builtin_exceptions.not_found) {
                return /* LIDENT */Block.__(11, [s]);
              } else {
                throw exn;
              }
            }
            break;
        case 11 : 
            warn_latin1(lexbuf$1);
            return /* LIDENT */Block.__(11, [Lexing.lexeme(lexbuf$1)]);
        case 12 : 
            return /* UIDENT */Block.__(17, [Lexing.lexeme(lexbuf$1)]);
        case 13 : 
            warn_latin1(lexbuf$1);
            return /* UIDENT */Block.__(17, [Lexing.lexeme(lexbuf$1)]);
        case 14 : 
            try {
              return /* INT */Block.__(7, [cvt_int_literal(Lexing.lexeme(lexbuf$1))]);
            }
            catch (raw_exn){
              var exn$1 = Js_exn.internalToOCamlException(raw_exn);
              if (exn$1[0] === Caml_builtin_exceptions.failure) {
                throw [
                      $$Error$4,
                      /* Literal_overflow */Block.__(5, ["int"]),
                      curr(lexbuf$1)
                    ];
              } else {
                throw exn$1;
              }
            }
            break;
        case 15 : 
            return /* FLOAT */Block.__(1, [remove_underscores(Lexing.lexeme(lexbuf$1))]);
        case 16 : 
            try {
              return /* INT32 */Block.__(8, [cvt_int32_literal(Lexing.lexeme(lexbuf$1))]);
            }
            catch (raw_exn$1){
              var exn$2 = Js_exn.internalToOCamlException(raw_exn$1);
              if (exn$2[0] === Caml_builtin_exceptions.failure) {
                throw [
                      $$Error$4,
                      /* Literal_overflow */Block.__(5, ["int32"]),
                      curr(lexbuf$1)
                    ];
              } else {
                throw exn$2;
              }
            }
            break;
        case 17 : 
            try {
              return /* INT64 */Block.__(9, [cvt_int64_literal(Lexing.lexeme(lexbuf$1))]);
            }
            catch (raw_exn$2){
              var exn$3 = Js_exn.internalToOCamlException(raw_exn$2);
              if (exn$3[0] === Caml_builtin_exceptions.failure) {
                throw [
                      $$Error$4,
                      /* Literal_overflow */Block.__(5, ["int64"]),
                      curr(lexbuf$1)
                    ];
              } else {
                throw exn$3;
              }
            }
            break;
        case 18 : 
            try {
              return /* NATIVEINT */Block.__(12, [cvt_nativeint_literal(Lexing.lexeme(lexbuf$1))]);
            }
            catch (raw_exn$3){
              var exn$4 = Js_exn.internalToOCamlException(raw_exn$3);
              if (exn$4[0] === Caml_builtin_exceptions.failure) {
                throw [
                      $$Error$4,
                      /* Literal_overflow */Block.__(5, ["nativeint"]),
                      curr(lexbuf$1)
                    ];
              } else {
                throw exn$4;
              }
            }
            break;
        case 19 : 
            reset_string_buffer(/* () */0);
            is_in_string[0] = /* true */1;
            var string_start = lexbuf$1[/* lex_start_p */10];
            string_start_loc[0] = curr(lexbuf$1);
            string(lexbuf$1);
            is_in_string[0] = /* false */0;
            lexbuf$1[/* lex_start_p */10] = string_start;
            return /* STRING */Block.__(16, [/* tuple */[
                        get_stored_string(/* () */0),
                        /* None */0
                      ]]);
        case 20 : 
            reset_string_buffer(/* () */0);
            var delim = Lexing.lexeme(lexbuf$1);
            var delim$1 = $$String.sub(delim, 1, delim.length - 2 | 0);
            is_in_string[0] = /* true */1;
            var string_start$1 = lexbuf$1[/* lex_start_p */10];
            string_start_loc[0] = curr(lexbuf$1);
            __ocaml_lex_quoted_string_rec(delim$1, lexbuf$1, 183);
            is_in_string[0] = /* false */0;
            lexbuf$1[/* lex_start_p */10] = string_start$1;
            return /* STRING */Block.__(16, [/* tuple */[
                        get_stored_string(/* () */0),
                        /* Some */[delim$1]
                      ]]);
        case 21 : 
            update_loc(lexbuf$1, /* None */0, 1, /* false */0, 1);
            return /* CHAR */Block.__(0, [Lexing.lexeme_char(lexbuf$1, 1)]);
        case 22 : 
            return /* CHAR */Block.__(0, [Lexing.lexeme_char(lexbuf$1, 1)]);
        case 23 : 
            return /* CHAR */Block.__(0, [char_for_backslash(Lexing.lexeme_char(lexbuf$1, 2))]);
        case 24 : 
            return /* CHAR */Block.__(0, [char_for_decimal_code(lexbuf$1, 2)]);
        case 25 : 
            return /* CHAR */Block.__(0, [char_for_hexadecimal_code(lexbuf$1, 3)]);
        case 26 : 
            var l = Lexing.lexeme(lexbuf$1);
            var esc = $$String.sub(l, 1, l.length - 1 | 0);
            throw [
                  $$Error$4,
                  /* Illegal_escape */Block.__(1, [esc]),
                  curr(lexbuf$1)
                ];
        case 27 : 
            var match = with_comment_buffer(comment, lexbuf$1);
            return /* COMMENT */Block.__(18, [/* tuple */[
                        match[0],
                        match[1]
                      ]]);
        case 28 : 
            var match$1 = with_comment_buffer(comment, lexbuf$1);
            return /* DOCSTRING */Block.__(19, [docstring(match$1[0], match$1[1])]);
        case 29 : 
            var stars = Lexing.sub_lexeme(lexbuf$1, lexbuf$1[/* lex_start_pos */4], lexbuf$1[/* lex_curr_pos */5]);
            var match$2 = with_comment_buffer((function(stars){
                return function (lexbuf) {
                  store_string("*" + stars);
                  return __ocaml_lex_comment_rec(lexbuf, 132);
                }
                }(stars)), lexbuf$1);
            return /* COMMENT */Block.__(18, [/* tuple */[
                        match$2[0],
                        match$2[1]
                      ]]);
        case 30 : 
            if (print_warnings[0]) {
              prerr_warning(curr(lexbuf$1), /* Comment_start */0);
            }
            var match$3 = with_comment_buffer(comment, lexbuf$1);
            return /* COMMENT */Block.__(18, [/* tuple */[
                        match$3[0],
                        match$3[1]
                      ]]);
        case 31 : 
            var stars$1 = Lexing.sub_lexeme(lexbuf$1, lexbuf$1[/* lex_start_pos */4], lexbuf$1[/* lex_curr_pos */5] - 2 | 0);
            return /* COMMENT */Block.__(18, [/* tuple */[
                        stars$1,
                        curr(lexbuf$1)
                      ]]);
        case 32 : 
            var loc = curr(lexbuf$1);
            prerr_warning(loc, /* Comment_not_end */1);
            lexbuf$1[/* lex_curr_pos */5] = lexbuf$1[/* lex_curr_pos */5] - 1 | 0;
            var curpos = lexbuf$1[/* lex_curr_p */11];
            lexbuf$1[/* lex_curr_p */11] = /* record */[
              /* pos_fname */curpos[/* pos_fname */0],
              /* pos_lnum */curpos[/* pos_lnum */1],
              /* pos_bol */curpos[/* pos_bol */2],
              /* pos_cnum */curpos[/* pos_cnum */3] - 1 | 0
            ];
            return /* STAR */86;
        case 33 : 
            var num = Lexing.sub_lexeme(lexbuf$1, Caml_array.caml_array_get(lexbuf$1[/* lex_mem */9], 0), Caml_array.caml_array_get(lexbuf$1[/* lex_mem */9], 1));
            var name = Lexing.sub_lexeme_opt(lexbuf$1, Caml_array.caml_array_get(lexbuf$1[/* lex_mem */9], 3), Caml_array.caml_array_get(lexbuf$1[/* lex_mem */9], 2));
            update_loc(lexbuf$1, name, Caml_format.caml_int_of_string(num), /* true */1, 0);
            return token(lexbuf$1);
        case 34 : 
            return /* SHARP */84;
        case 35 : 
            return /* AMPERSAND */1;
        case 36 : 
            return /* AMPERAMPER */0;
        case 37 : 
            return /* BACKQUOTE */5;
        case 38 : 
            return /* QUOTE */77;
        case 39 : 
            return /* LPAREN */54;
        case 40 : 
            return /* RPAREN */81;
        case 41 : 
            return /* STAR */86;
        case 42 : 
            return /* COMMA */16;
        case 43 : 
            return /* MINUSGREATER */62;
        case 44 : 
            return /* DOT */20;
        case 45 : 
            return /* DOTDOT */21;
        case 46 : 
            return /* COLON */12;
        case 47 : 
            return /* COLONCOLON */13;
        case 48 : 
            return /* COLONEQUAL */14;
        case 49 : 
            return /* COLONGREATER */15;
        case 50 : 
            return /* SEMI */82;
        case 51 : 
            return /* SEMISEMI */83;
        case 52 : 
            return /* LESS */51;
        case 53 : 
            return /* LESSMINUS */52;
        case 54 : 
            return /* EQUAL */26;
        case 55 : 
            return /* LBRACKET */45;
        case 56 : 
            return /* LBRACKETBAR */46;
        case 57 : 
            return /* LBRACKETLESS */47;
        case 58 : 
            return /* LBRACKETGREATER */48;
        case 59 : 
            return /* RBRACKET */79;
        case 60 : 
            return /* LBRACE */43;
        case 61 : 
            return /* LBRACELESS */44;
        case 62 : 
            return /* BAR */7;
        case 63 : 
            return /* BARBAR */8;
        case 64 : 
            return /* BARRBRACKET */9;
        case 65 : 
            return /* GREATER */34;
        case 66 : 
            return /* GREATERRBRACKET */36;
        case 67 : 
            return /* RBRACE */78;
        case 68 : 
            return /* GREATERRBRACE */35;
        case 69 : 
            return /* LBRACKETAT */55;
        case 70 : 
            return /* LBRACKETPERCENT */49;
        case 71 : 
            return /* LBRACKETPERCENTPERCENT */50;
        case 72 : 
            return /* LBRACKETATAT */56;
        case 73 : 
            return /* LBRACKETATATAT */57;
        case 74 : 
            return /* BANG */6;
        case 75 : 
            return /* INFIXOP0 */Block.__(2, ["!="]);
        case 76 : 
            return /* PLUS */72;
        case 77 : 
            return /* PLUSDOT */73;
        case 78 : 
            return /* PLUSEQ */74;
        case 79 : 
            return /* MINUS */60;
        case 80 : 
            return /* MINUSDOT */61;
        case 81 : 
        case 82 : 
            return /* PREFIXOP */Block.__(14, [Lexing.lexeme(lexbuf$1)]);
        case 83 : 
            return /* INFIXOP0 */Block.__(2, [Lexing.lexeme(lexbuf$1)]);
        case 84 : 
            return /* INFIXOP1 */Block.__(3, [Lexing.lexeme(lexbuf$1)]);
        case 85 : 
            return /* INFIXOP2 */Block.__(4, [Lexing.lexeme(lexbuf$1)]);
        case 86 : 
            return /* INFIXOP4 */Block.__(6, [Lexing.lexeme(lexbuf$1)]);
        case 87 : 
            return /* PERCENT */71;
        case 88 : 
            return /* INFIXOP3 */Block.__(5, [Lexing.lexeme(lexbuf$1)]);
        case 89 : 
            return /* SHARPOP */Block.__(15, [Lexing.lexeme(lexbuf$1)]);
        case 90 : 
            if (if_then_else[0] !== /* Dir_out */2) {
              if (if_then_else[0]) {
                throw [
                      $$Error$4,
                      /* Unterminated_else */3,
                      curr(lexbuf$1)
                    ];
              } else {
                throw [
                      $$Error$4,
                      /* Unterminated_if */2,
                      curr(lexbuf$1)
                    ];
              }
            } else {
              return /* EOF */25;
            }
            break;
        case 91 : 
            throw [
                  $$Error$4,
                  /* Illegal_character */Block.__(0, [Lexing.lexeme_char(lexbuf$1, 0)]),
                  curr(lexbuf$1)
                ];
        
      }
    }
  };
}

function __ocaml_lex_quoted_string_rec(delim, lexbuf, ___ocaml_lex_state) {
  while(true) {
    var __ocaml_lex_state = ___ocaml_lex_state;
    var __ocaml_lex_state$1 = Lexing.engine(__ocaml_lex_tables, __ocaml_lex_state, lexbuf);
    if (__ocaml_lex_state$1 > 3 || __ocaml_lex_state$1 < 0) {
      Curry._1(lexbuf[/* refill_buff */0], lexbuf);
      ___ocaml_lex_state = __ocaml_lex_state$1;
      continue ;
      
    } else {
      switch (__ocaml_lex_state$1) {
        case 0 : 
            update_loc(lexbuf, /* None */0, 1, /* false */0, 0);
            store_string(Lexing.lexeme(lexbuf));
            ___ocaml_lex_state = 183;
            continue ;
            case 1 : 
            is_in_string[0] = /* false */0;
            throw [
                  $$Error$4,
                  /* Unterminated_string */0,
                  string_start_loc[0]
                ];
        case 2 : 
            var edelim = Lexing.lexeme(lexbuf);
            var edelim$1 = $$String.sub(edelim, 1, edelim.length - 2 | 0);
            if (delim === edelim$1) {
              return /* () */0;
            } else {
              store_string(Lexing.lexeme(lexbuf));
              ___ocaml_lex_state = 183;
              continue ;
              
            }
            break;
        case 3 : 
            store_string_char(Lexing.lexeme_char(lexbuf, 0));
            ___ocaml_lex_state = 183;
            continue ;
            
      }
    }
  };
}

function string(lexbuf) {
  lexbuf[/* lex_mem */9] = Caml_array.caml_make_vect(2, -1);
  var lexbuf$1 = lexbuf;
  var ___ocaml_lex_state = 164;
  while(true) {
    var __ocaml_lex_state = ___ocaml_lex_state;
    var __ocaml_lex_state$1 = Lexing.new_engine(__ocaml_lex_tables, __ocaml_lex_state, lexbuf$1);
    if (__ocaml_lex_state$1 > 8 || __ocaml_lex_state$1 < 0) {
      Curry._1(lexbuf$1[/* refill_buff */0], lexbuf$1);
      ___ocaml_lex_state = __ocaml_lex_state$1;
      continue ;
      
    } else {
      switch (__ocaml_lex_state$1) {
        case 0 : 
            return /* () */0;
        case 1 : 
            var space = Lexing.sub_lexeme(lexbuf$1, Caml_array.caml_array_get(lexbuf$1[/* lex_mem */9], 0), lexbuf$1[/* lex_curr_pos */5]);
            update_loc(lexbuf$1, /* None */0, 1, /* false */0, space.length);
            return string(lexbuf$1);
        case 2 : 
            store_string_char(char_for_backslash(Lexing.lexeme_char(lexbuf$1, 1)));
            return string(lexbuf$1);
        case 3 : 
            store_string_char(char_for_decimal_code(lexbuf$1, 1));
            return string(lexbuf$1);
        case 4 : 
            store_string_char(char_for_hexadecimal_code(lexbuf$1, 2));
            return string(lexbuf$1);
        case 5 : 
            if (comment_start_loc[0] !== /* [] */0) {
              return string(lexbuf$1);
            } else {
              var loc = curr(lexbuf$1);
              prerr_warning(loc, /* Illegal_backslash */7);
              store_string_char(Lexing.lexeme_char(lexbuf$1, 0));
              store_string_char(Lexing.lexeme_char(lexbuf$1, 1));
              return string(lexbuf$1);
            }
            break;
        case 6 : 
            if (!comment_start_loc[0]) {
              prerr_warning(curr(lexbuf$1), /* Eol_in_string */14);
            }
            update_loc(lexbuf$1, /* None */0, 1, /* false */0, 0);
            store_string(Lexing.lexeme(lexbuf$1));
            return string(lexbuf$1);
        case 7 : 
            is_in_string[0] = /* false */0;
            throw [
                  $$Error$4,
                  /* Unterminated_string */0,
                  string_start_loc[0]
                ];
        case 8 : 
            store_string_char(Lexing.lexeme_char(lexbuf$1, 0));
            return string(lexbuf$1);
        
      }
    }
  };
}

function comment(lexbuf) {
  return __ocaml_lex_comment_rec(lexbuf, 132);
}

function __ocaml_lex_comment_rec(lexbuf, ___ocaml_lex_state) {
  while(true) {
    var __ocaml_lex_state = ___ocaml_lex_state;
    var __ocaml_lex_state$1 = Lexing.engine(__ocaml_lex_tables, __ocaml_lex_state, lexbuf);
    if (__ocaml_lex_state$1 > 12 || __ocaml_lex_state$1 < 0) {
      Curry._1(lexbuf[/* refill_buff */0], lexbuf);
      ___ocaml_lex_state = __ocaml_lex_state$1;
      continue ;
      
    } else {
      switch (__ocaml_lex_state$1) {
        case 0 : 
            comment_start_loc[0] = /* :: */[
              curr(lexbuf),
              comment_start_loc[0]
            ];
            store_string(Lexing.lexeme(lexbuf));
            ___ocaml_lex_state = 132;
            continue ;
            case 1 : 
            var match = comment_start_loc[0];
            if (match) {
              var l = match[1];
              if (l) {
                comment_start_loc[0] = l;
                store_string(Lexing.lexeme(lexbuf));
                ___ocaml_lex_state = 132;
                continue ;
                
              } else {
                comment_start_loc[0] = /* [] */0;
                return curr(lexbuf);
              }
            } else {
              throw [
                    Caml_builtin_exceptions.assert_failure,
                    [
                      "parsing/lexer.mll",
                      989,
                      16
                    ]
                  ];
            }
            break;
        case 2 : 
            string_start_loc[0] = curr(lexbuf);
            store_string_char(/* "\"" */34);
            is_in_string[0] = /* true */1;
            try {
              string(lexbuf);
            }
            catch (raw_exn){
              var exn = Js_exn.internalToOCamlException(raw_exn);
              if (exn[0] === $$Error$4) {
                var match$1 = exn[1];
                if (typeof match$1 === "number") {
                  if (match$1 !== 0) {
                    throw exn;
                  } else {
                    var match$2 = comment_start_loc[0];
                    if (match$2) {
                      var start = List.hd(List.rev(comment_start_loc[0]));
                      comment_start_loc[0] = /* [] */0;
                      throw [
                            $$Error$4,
                            /* Unterminated_string_in_comment */Block.__(3, [
                                start,
                                exn[2]
                              ]),
                            match$2[0]
                          ];
                    } else {
                      throw [
                            Caml_builtin_exceptions.assert_failure,
                            [
                              "parsing/lexer.mll",
                              1003,
                              18
                            ]
                          ];
                    }
                  }
                } else {
                  throw exn;
                }
              } else {
                throw exn;
              }
            }
            is_in_string[0] = /* false */0;
            store_string_char(/* "\"" */34);
            ___ocaml_lex_state = 132;
            continue ;
            case 3 : 
            var delim = Lexing.lexeme(lexbuf);
            var delim$1 = $$String.sub(delim, 1, delim.length - 2 | 0);
            string_start_loc[0] = curr(lexbuf);
            store_string(Lexing.lexeme(lexbuf));
            is_in_string[0] = /* true */1;
            try {
              __ocaml_lex_quoted_string_rec(delim$1, lexbuf, 183);
            }
            catch (raw_exn$1){
              var exn$1 = Js_exn.internalToOCamlException(raw_exn$1);
              if (exn$1[0] === $$Error$4) {
                var match$3 = exn$1[1];
                if (typeof match$3 === "number") {
                  if (match$3 !== 0) {
                    throw exn$1;
                  } else {
                    var match$4 = comment_start_loc[0];
                    if (match$4) {
                      var start$1 = List.hd(List.rev(comment_start_loc[0]));
                      comment_start_loc[0] = /* [] */0;
                      throw [
                            $$Error$4,
                            /* Unterminated_string_in_comment */Block.__(3, [
                                start$1,
                                exn$1[2]
                              ]),
                            match$4[0]
                          ];
                    } else {
                      throw [
                            Caml_builtin_exceptions.assert_failure,
                            [
                              "parsing/lexer.mll",
                              1023,
                              18
                            ]
                          ];
                    }
                  }
                } else {
                  throw exn$1;
                }
              } else {
                throw exn$1;
              }
            }
            is_in_string[0] = /* false */0;
            store_string_char(/* "|" */124);
            store_string(delim$1);
            store_string_char(/* "}" */125);
            ___ocaml_lex_state = 132;
            continue ;
            case 5 : 
            update_loc(lexbuf, /* None */0, 1, /* false */0, 1);
            store_string(Lexing.lexeme(lexbuf));
            ___ocaml_lex_state = 132;
            continue ;
            case 10 : 
            var match$5 = comment_start_loc[0];
            if (match$5) {
              var start$2 = List.hd(List.rev(comment_start_loc[0]));
              comment_start_loc[0] = /* [] */0;
              throw [
                    $$Error$4,
                    /* Unterminated_comment */Block.__(2, [start$2]),
                    match$5[0]
                  ];
            } else {
              throw [
                    Caml_builtin_exceptions.assert_failure,
                    [
                      "parsing/lexer.mll",
                      1053,
                      16
                    ]
                  ];
            }
            break;
        case 11 : 
            update_loc(lexbuf, /* None */0, 1, /* false */0, 0);
            store_string(Lexing.lexeme(lexbuf));
            ___ocaml_lex_state = 132;
            continue ;
            case 4 : 
        case 6 : 
        case 7 : 
        case 8 : 
        case 9 : 
        case 12 : 
            store_string(Lexing.lexeme(lexbuf));
            ___ocaml_lex_state = 132;
            continue ;
            
      }
    }
  };
}

function at_bol(lexbuf) {
  var pos = lexbuf[/* lex_start_p */10];
  return +(pos[/* pos_cnum */3] === pos[/* pos_bol */2]);
}

function token_with_comments(lexbuf) {
  var match = preprocessor[0];
  if (match) {
    return Curry._2(match[0][1], token, lexbuf);
  } else {
    return token(lexbuf);
  }
}

function token$1(lexbuf) {
  var post_pos = lexbuf[/* lex_curr_p */11];
  var attach = function (lines, docs, pre_pos) {
    if (typeof docs === "number") {
      return /* () */0;
    } else if (docs.tag) {
      var b = docs[2];
      var f = docs[1];
      var a = docs[0];
      if (lines >= 2) {
        set_post_docstrings(post_pos, List.rev(a));
        set_post_extra_docstrings(post_pos, List.rev_append(f, List.rev(b)));
        set_floating_docstrings(pre_pos, List.rev_append(f, List.rev(b)));
        return set_pre_extra_docstrings(pre_pos, List.rev(a));
      } else {
        set_post_docstrings(post_pos, List.rev(a));
        set_post_extra_docstrings(post_pos, List.rev_append(f, List.rev(b)));
        set_floating_docstrings(pre_pos, List.rev(f));
        set_pre_extra_docstrings(pre_pos, List.rev(a));
        return set_pre_docstrings(pre_pos, b);
      }
    } else {
      var a$1 = docs[0];
      if (lines >= 2) {
        set_post_docstrings(post_pos, List.rev(a$1));
        return set_pre_extra_docstrings(pre_pos, List.rev(a$1));
      } else {
        set_post_docstrings(post_pos, List.rev(a$1));
        return set_pre_docstrings(pre_pos, a$1);
      }
    }
  };
  var loop = function (_lines, _docs, lexbuf) {
    while(true) {
      var docs = _docs;
      var lines = _lines;
      var tok = token_with_comments(lexbuf);
      var exit = 0;
      if (typeof tok === "number") {
        switch (tok) {
          case 84 : 
              if (at_bol(lexbuf)) {
                var lexbuf$1 = lexbuf;
                var cont = (function(lines,docs){
                return function cont(lexbuf) {
                  return loop(lines, docs, lexbuf);
                }
                }(lines,docs));
                var look_ahead = function (token) {
                  sharp_look_ahead[0] = /* Some */[token];
                  return /* SHARP */84;
                };
                var if_then_else$1 = if_then_else[0];
                var match = token_with_comments(lexbuf$1);
                var exit$1 = 0;
                if (typeof match === "number") {
                  switch (match) {
                    case 23 : 
                        if (if_then_else$1 !== 0) {
                          throw [
                                $$Error$4,
                                /* Unexpected_directive */6,
                                curr(lexbuf$1)
                              ];
                        } else {
                          exit$1 = 1;
                        }
                        break;
                    case 24 : 
                        if (if_then_else$1 >= 2) {
                          throw [
                                $$Error$4,
                                /* Unexpected_directive */6,
                                curr(lexbuf$1)
                              ];
                        } else {
                          if_then_else[0] = /* Dir_out */2;
                          return Curry._1(cont, lexbuf$1);
                        }
                        break;
                    case 37 : 
                        if (if_then_else$1 >= 2) {
                          if (directive_parse(token_with_comments, lexbuf$1)) {
                            if_then_else[0] = /* Dir_if_true */0;
                            return Curry._1(cont, lexbuf$1);
                          } else {
                            var _param = /* () */0;
                            while(true) {
                              var token = token_with_comments(lexbuf$1);
                              if (token === /* EOF */25) {
                                throw [
                                      $$Error$4,
                                      /* Unterminated_if */2,
                                      curr(lexbuf$1)
                                    ];
                              } else if (token === /* SHARP */84 && at_bol(lexbuf$1)) {
                                var token$1 = token_with_comments(lexbuf$1);
                                var exit$2 = 0;
                                if (typeof token$1 === "number") {
                                  var switcher = token$1 - 23 | 0;
                                  if (switcher === 0 || switcher === 1) {
                                    if (switcher !== 0) {
                                      if_then_else[0] = /* Dir_out */2;
                                      return Curry._1(cont, lexbuf$1);
                                    } else {
                                      if_then_else[0] = /* Dir_if_false */1;
                                      return Curry._1(cont, lexbuf$1);
                                    }
                                  } else if (switcher !== 14) {
                                    exit$2 = 1;
                                  } else {
                                    throw [
                                          $$Error$4,
                                          /* Unexpected_directive */6,
                                          curr(lexbuf$1)
                                        ];
                                  }
                                } else {
                                  exit$2 = 1;
                                }
                                if (exit$2 === 1) {
                                  if (is_elif(token$1) && directive_parse(token_with_comments, lexbuf$1)) {
                                    if_then_else[0] = /* Dir_if_true */0;
                                    return Curry._1(cont, lexbuf$1);
                                  } else {
                                    _param = /* () */0;
                                    continue ;
                                    
                                  }
                                }
                                
                              } else {
                                _param = /* () */0;
                                continue ;
                                
                              }
                            };
                          }
                        } else {
                          throw [
                                $$Error$4,
                                /* Unexpected_directive */6,
                                curr(lexbuf$1)
                              ];
                        }
                        break;
                    default:
                      return Curry._1(look_ahead, match);
                  }
                } else if (match.tag === 11) {
                  if (match[0] === "elif") {
                    if (if_then_else$1 !== 0) {
                      throw [
                            $$Error$4,
                            /* Unexpected_directive */6,
                            curr(lexbuf$1)
                          ];
                    } else {
                      exit$1 = 1;
                    }
                  } else {
                    return Curry._1(look_ahead, match);
                  }
                } else {
                  return Curry._1(look_ahead, match);
                }
                if (exit$1 === 1) {
                  if (if_then_else$1 !== 0) {
                    return Curry._1(look_ahead, match);
                  } else {
                    var _else_seen = +(match === /* ELSE */23);
                    while(true) {
                      var else_seen = _else_seen;
                      var token$2 = token_with_comments(lexbuf$1);
                      if (token$2 === /* EOF */25) {
                        throw [
                              $$Error$4,
                              /* Unterminated_else */3,
                              curr(lexbuf$1)
                            ];
                      } else if (token$2 === /* SHARP */84 && at_bol(lexbuf$1)) {
                        var token$3 = token_with_comments(lexbuf$1);
                        var exit$3 = 0;
                        if (typeof token$3 === "number") {
                          var switcher$1 = token$3 - 23 | 0;
                          if (switcher$1 === 0 || switcher$1 === 1) {
                            if (switcher$1 !== 0) {
                              if_then_else[0] = /* Dir_out */2;
                              return Curry._1(cont, lexbuf$1);
                            } else if (else_seen) {
                              throw [
                                    $$Error$4,
                                    /* Unexpected_directive */6,
                                    curr(lexbuf$1)
                                  ];
                            } else {
                              _else_seen = /* true */1;
                              continue ;
                              
                            }
                          } else if (switcher$1 !== 14) {
                            exit$3 = 1;
                          } else {
                            throw [
                                  $$Error$4,
                                  /* Unexpected_directive */6,
                                  curr(lexbuf$1)
                                ];
                          }
                        } else {
                          exit$3 = 1;
                        }
                        if (exit$3 === 1) {
                          if (else_seen && is_elif(token$3)) {
                            throw [
                                  $$Error$4,
                                  /* Unexpected_directive */6,
                                  curr(lexbuf$1)
                                ];
                          } else {
                            continue ;
                            
                          }
                        }
                        
                      } else {
                        continue ;
                        
                      }
                    };
                  }
                }
                
              } else {
                exit = 1;
              }
              break;
          case 100 : 
              var lines$prime = lines !== 0 ? /* BlankLine */2 : /* NewLine */1;
              _lines = lines$prime;
              continue ;
              default:
            exit = 1;
        }
      } else {
        switch (tok.tag | 0) {
          case 18 : 
              var match$1 = tok[0];
              add_comment(/* tuple */[
                    match$1[0],
                    match$1[1]
                  ]);
              var lines$prime$1 = lines >= 2 ? /* BlankLine */2 : /* NoLine */0;
              _lines = lines$prime$1;
              continue ;
              case 19 : 
              var doc = tok[0];
              add_docstring_comment(doc);
              var docs$prime;
              if (typeof docs === "number") {
                docs$prime = lines >= 2 ? /* Before */Block.__(1, [
                      /* [] */0,
                      /* [] */0,
                      /* :: */[
                        doc,
                        /* [] */0
                      ]
                    ]) : /* After */Block.__(0, [/* :: */[
                        doc,
                        /* [] */0
                      ]]);
              } else if (docs.tag) {
                var b = docs[2];
                var f = docs[1];
                var a = docs[0];
                docs$prime = lines >= 2 ? /* Before */Block.__(1, [
                      a,
                      Pervasives.$at(b, f),
                      /* :: */[
                        doc,
                        /* [] */0
                      ]
                    ]) : /* Before */Block.__(1, [
                      a,
                      f,
                      /* :: */[
                        doc,
                        b
                      ]
                    ]);
              } else {
                var a$1 = docs[0];
                docs$prime = lines >= 2 ? /* Before */Block.__(1, [
                      a$1,
                      /* [] */0,
                      /* :: */[
                        doc,
                        /* [] */0
                      ]
                    ]) : /* After */Block.__(0, [/* :: */[
                        doc,
                        a$1
                      ]]);
              }
              _docs = docs$prime;
              _lines = /* NoLine */0;
              continue ;
              default:
            exit = 1;
        }
      }
      if (exit === 1) {
        attach(lines, docs, lexbuf[/* lex_start_p */10]);
        return tok;
      }
      
    };
  };
  var match = sharp_look_ahead[0];
  if (match) {
    sharp_look_ahead[0] = /* None */0;
    return match[0];
  } else {
    return loop(/* NoLine */0, /* Initial */0, lexbuf);
  }
}

function init$1() {
  sharp_look_ahead[0] = /* None */0;
  if_then_else[0] = /* Dir_out */2;
  is_in_string[0] = /* false */0;
  comment_start_loc[0] = /* [] */0;
  comment_list[0] = /* [] */0;
  var match = preprocessor[0];
  if (match) {
    return Curry._1(match[0][0], /* () */0);
  } else {
    return /* () */0;
  }
}

function skip_phrase(lexbuf) {
  while(true) {
    try {
      var match = token$1(lexbuf);
      if (typeof match === "number" && !(match !== 25 && match !== 83)) {
        return /* () */0;
      } else {
        return skip_phrase(lexbuf);
      }
    }
    catch (raw_exn){
      var exn = Js_exn.internalToOCamlException(raw_exn);
      if (exn[0] === $$Error$4) {
        var $js = exn[1];
        if (typeof $js === "number") {
          if ($js) {
            throw exn;
          } else {
            continue ;
            
          }
        } else {
          switch ($js.tag | 0) {
            case 0 : 
            case 2 : 
            case 3 : 
                continue ;
                default:
              throw exn;
          }
        }
      } else {
        throw exn;
      }
    }
  };
}

function maybe_skip_phrase(lexbuf) {
  if (Parsing.is_current_lookahead(/* SEMISEMI */83) || Parsing.is_current_lookahead(/* EOF */25)) {
    return /* () */0;
  } else {
    return skip_phrase(lexbuf);
  }
}

function wrap$1(parsing_fun, lexbuf) {
  try {
    init(/* () */0);
    init$1(/* () */0);
    var ast = Curry._2(parsing_fun, token$1, lexbuf);
    Parsing.clear_parser(/* () */0);
    warn_bad_docstrings(/* () */0);
    return ast;
  }
  catch (raw_err){
    var err = Js_exn.internalToOCamlException(raw_err);
    var exit = 0;
    var exit$1 = 0;
    if (err[0] === $$Error$4) {
      var $js = err[1];
      if (typeof $js === "number") {
        exit$1 = 2;
      } else if ($js.tag) {
        exit$1 = 2;
      } else if (input_name[0] === "//toplevel//") {
        skip_phrase(lexbuf);
        throw err;
      } else {
        exit$1 = 2;
      }
    } else {
      exit$1 = 2;
    }
    if (exit$1 === 2) {
      if (err[0] === $$Error$3) {
        if (input_name[0] === "//toplevel//") {
          maybe_skip_phrase(lexbuf);
          throw err;
        } else if (err === Parsing.Parse_error) {
          exit = 1;
        } else if (err === Escape_error) {
          exit = 1;
        } else {
          throw err;
        }
      } else if (err === Parsing.Parse_error) {
        exit = 1;
      } else if (err === Escape_error) {
        exit = 1;
      } else {
        throw err;
      }
    }
    if (exit === 1) {
      var loc = curr(lexbuf);
      if (input_name[0] === "//toplevel//") {
        maybe_skip_phrase(lexbuf);
      }
      throw [
            $$Error$3,
            /* Other */Block.__(5, [loc])
          ];
    }
    
  }
}

function iter_pattern_desc(f, param) {
  if (typeof param === "number") {
    return /* () */0;
  } else {
    switch (param.tag | 0) {
      case 4 : 
          return List.iter(f, param[2]);
      case 5 : 
          return may(f, param[1]);
      case 6 : 
          return List.iter((function (param) {
                        return Curry._1(f, param[2]);
                      }), param[0]);
      case 3 : 
      case 7 : 
          return List.iter(f, param[0]);
      case 8 : 
          Curry._1(f, param[0]);
          return Curry._1(f, param[1]);
      case 1 : 
      case 9 : 
          return Curry._1(f, param[0]);
      default:
        return /* () */0;
    }
  }
}

function map_pattern_desc(f, d) {
  if (typeof d === "number") {
    return d;
  } else {
    switch (d.tag | 0) {
      case 1 : 
          return /* Tpat_alias */Block.__(1, [
                    Curry._1(f, d[0]),
                    d[1],
                    d[2]
                  ]);
      case 3 : 
          return /* Tpat_tuple */Block.__(3, [List.map(f, d[0])]);
      case 4 : 
          return /* Tpat_construct */Block.__(4, [
                    d[0],
                    d[1],
                    List.map(f, d[2])
                  ]);
      case 5 : 
          var match = d[1];
          if (match) {
            return /* Tpat_variant */Block.__(5, [
                      d[0],
                      /* Some */[Curry._1(f, match[0])],
                      d[2]
                    ]);
          } else {
            return d;
          }
      case 6 : 
          return /* Tpat_record */Block.__(6, [
                    List.map((function (param) {
                            return /* tuple */[
                                    param[0],
                                    param[1],
                                    Curry._1(f, param[2])
                                  ];
                          }), d[0]),
                    d[1]
                  ]);
      case 7 : 
          return /* Tpat_array */Block.__(7, [List.map(f, d[0])]);
      case 8 : 
          return /* Tpat_or */Block.__(8, [
                    Curry._1(f, d[0]),
                    Curry._1(f, d[1]),
                    d[2]
                  ]);
      case 9 : 
          return /* Tpat_lazy */Block.__(9, [Curry._1(f, d[0])]);
      default:
        return d;
    }
  }
}

var idents = [/* [] */0];

function bound_idents(_pat) {
  while(true) {
    var pat = _pat;
    var d = pat[/* pat_desc */0];
    if (typeof d === "number") {
      return iter_pattern_desc(bound_idents, d);
    } else {
      switch (d.tag | 0) {
        case 0 : 
            idents[0] = /* :: */[
              /* tuple */[
                d[0],
                d[1]
              ],
              idents[0]
            ];
            return /* () */0;
        case 1 : 
            bound_idents(d[0]);
            idents[0] = /* :: */[
              /* tuple */[
                d[1],
                d[2]
              ],
              idents[0]
            ];
            return /* () */0;
        case 8 : 
            _pat = d[0];
            continue ;
            default:
          return iter_pattern_desc(bound_idents, d);
      }
    }
  };
}

function pat_bound_idents(pat) {
  idents[0] = /* [] */0;
  bound_idents(pat);
  var res = idents[0];
  idents[0] = /* [] */0;
  return res;
}

function rev_let_bound_idents_with_loc(bindings) {
  idents[0] = /* [] */0;
  List.iter((function (vb) {
          return bound_idents(vb[/* vb_pat */0]);
        }), bindings);
  var res = idents[0];
  idents[0] = /* [] */0;
  return res;
}

function let_bound_idents(pat) {
  return List.map((function (prim) {
                return prim[0];
              }), List.rev(rev_let_bound_idents_with_loc(pat)));
}

function alpha_pat(env, p) {
  var d = p[/* pat_desc */0];
  var exit = 0;
  if (typeof d === "number") {
    exit = 1;
  } else {
    switch (d.tag | 0) {
      case 0 : 
          var newrecord = p.slice();
          var $js;
          try {
            $js = /* Tpat_var */Block.__(0, [
                List.assoc(d[0], env),
                d[1]
              ]);
          }
          catch (exn){
            if (exn === Caml_builtin_exceptions.not_found) {
              $js = /* Tpat_any */0;
            } else {
              throw exn;
            }
          }
          newrecord[/* pat_desc */0] = $js;
          return newrecord;
      case 1 : 
          var new_p = alpha_pat(env, d[0]);
          try {
            var newrecord$1 = p.slice();
            newrecord$1[/* pat_desc */0] = /* Tpat_alias */Block.__(1, [
                new_p,
                List.assoc(d[1], env),
                d[2]
              ]);
            return newrecord$1;
          }
          catch (exn$1){
            if (exn$1 === Caml_builtin_exceptions.not_found) {
              return new_p;
            } else {
              throw exn$1;
            }
          }
          break;
      default:
        exit = 1;
    }
  }
  if (exit === 1) {
    var newrecord$2 = p.slice();
    newrecord$2[/* pat_desc */0] = map_pattern_desc((function (param) {
            return alpha_pat(env, param);
          }), d);
    return newrecord$2;
  }
  
}

function enter_structure(t) {
  return t;
}

function enter_value_description(t) {
  return t;
}

function enter_type_declaration(t) {
  return t;
}

function enter_type_extension(t) {
  return t;
}

function enter_extension_constructor(t) {
  return t;
}

function enter_pattern(t) {
  return t;
}

function enter_expression(t) {
  return t;
}

function enter_package_type(t) {
  return t;
}

function enter_signature(t) {
  return t;
}

function enter_signature_item(t) {
  return t;
}

function enter_module_type_declaration(t) {
  return t;
}

function enter_module_type(t) {
  return t;
}

function enter_module_expr(t) {
  return t;
}

function enter_with_constraint(t) {
  return t;
}

function enter_class_expr(t) {
  return t;
}

function enter_class_signature(t) {
  return t;
}

function enter_class_declaration(t) {
  return t;
}

function enter_class_description(t) {
  return t;
}

function enter_class_type_declaration(t) {
  return t;
}

function enter_class_type(t) {
  return t;
}

function enter_class_type_field(t) {
  return t;
}

function enter_core_type(t) {
  return t;
}

function enter_class_structure(t) {
  return t;
}

function enter_class_field(t) {
  return t;
}

function enter_structure_item(t) {
  return t;
}

function leave_value_description(t) {
  return t;
}

function leave_type_declaration(t) {
  return t;
}

function leave_type_extension(t) {
  return t;
}

function leave_extension_constructor(t) {
  return t;
}

function leave_package_type(t) {
  return t;
}

function leave_module_type_declaration(t) {
  return t;
}

function leave_with_constraint(t) {
  return t;
}

function leave_class_signature(t) {
  return t;
}

function leave_class_declaration(t) {
  return t;
}

function leave_class_description(t) {
  return t;
}

function leave_class_type_declaration(t) {
  return t;
}

function leave_class_type_field(t) {
  return t;
}

function leave_class_structure(t) {
  return t;
}

function leave_class_field(t) {
  return t;
}

function TypedtreeMap_000(funarg) {
  var map_structure = function (str) {
    var str$1 = Curry._1(funarg[/* enter_structure */0], str);
    var str_items = List.map(map_structure_item, str$1[/* str_items */0]);
    return Curry._1(funarg[/* leave_structure */25], /* record */[
                /* str_items */str_items,
                /* str_type */str$1[/* str_type */1],
                /* str_final_env */str$1[/* str_final_env */2]
              ]);
  };
  var map_binding = function (vb) {
    return /* record */[
            /* vb_pat */map_pattern(vb[/* vb_pat */0]),
            /* vb_expr */map_expression(vb[/* vb_expr */1]),
            /* vb_attributes */vb[/* vb_attributes */2],
            /* vb_loc */vb[/* vb_loc */3]
          ];
  };
  var map_expression = function (exp) {
    var exp$1 = Curry._1(funarg[/* enter_expression */6], exp);
    var match = exp$1[/* exp_desc */0];
    var exp_desc;
    switch (match.tag | 0) {
      case 2 : 
          exp_desc = /* Texp_let */Block.__(2, [
              match[0],
              List.map(map_binding, match[1]),
              map_expression(match[2])
            ]);
          break;
      case 3 : 
          exp_desc = /* Texp_function */Block.__(3, [
              match[0],
              List.map(map_case, match[1]),
              match[2]
            ]);
          break;
      case 4 : 
          exp_desc = /* Texp_apply */Block.__(4, [
              map_expression(match[0]),
              List.map((function (param) {
                      var expo = param[1];
                      var expo$1 = expo ? /* Some */[map_expression(expo[0])] : expo;
                      return /* tuple */[
                              param[0],
                              expo$1,
                              param[2]
                            ];
                    }), match[1])
            ]);
          break;
      case 5 : 
          exp_desc = /* Texp_match */Block.__(5, [
              map_expression(match[0]),
              List.map(map_case, match[1]),
              List.map(map_case, match[2]),
              match[3]
            ]);
          break;
      case 6 : 
          exp_desc = /* Texp_try */Block.__(6, [
              map_expression(match[0]),
              List.map(map_case, match[1])
            ]);
          break;
      case 7 : 
          exp_desc = /* Texp_tuple */Block.__(7, [List.map(map_expression, match[0])]);
          break;
      case 8 : 
          exp_desc = /* Texp_construct */Block.__(8, [
              match[0],
              match[1],
              List.map(map_expression, match[2])
            ]);
          break;
      case 9 : 
          var expo = match[1];
          var expo$1 = expo ? /* Some */[map_expression(expo[0])] : expo;
          exp_desc = /* Texp_variant */Block.__(9, [
              match[0],
              expo$1
            ]);
          break;
      case 10 : 
          var expo$2 = match[1];
          var list = List.map((function (param) {
                  return /* tuple */[
                          param[0],
                          param[1],
                          map_expression(param[2])
                        ];
                }), match[0]);
          var expo$3 = expo$2 ? /* Some */[map_expression(expo$2[0])] : expo$2;
          exp_desc = /* Texp_record */Block.__(10, [
              list,
              expo$3
            ]);
          break;
      case 11 : 
          exp_desc = /* Texp_field */Block.__(11, [
              map_expression(match[0]),
              match[1],
              match[2]
            ]);
          break;
      case 12 : 
          exp_desc = /* Texp_setfield */Block.__(12, [
              map_expression(match[0]),
              match[1],
              match[2],
              map_expression(match[3])
            ]);
          break;
      case 13 : 
          exp_desc = /* Texp_array */Block.__(13, [List.map(map_expression, match[0])]);
          break;
      case 14 : 
          var expo$4 = match[2];
          exp_desc = /* Texp_ifthenelse */Block.__(14, [
              map_expression(match[0]),
              map_expression(match[1]),
              expo$4 ? /* Some */[map_expression(expo$4[0])] : expo$4
            ]);
          break;
      case 15 : 
          exp_desc = /* Texp_sequence */Block.__(15, [
              map_expression(match[0]),
              map_expression(match[1])
            ]);
          break;
      case 16 : 
          exp_desc = /* Texp_while */Block.__(16, [
              map_expression(match[0]),
              map_expression(match[1])
            ]);
          break;
      case 17 : 
          exp_desc = /* Texp_for */Block.__(17, [
              match[0],
              match[1],
              map_expression(match[2]),
              map_expression(match[3]),
              match[4],
              map_expression(match[5])
            ]);
          break;
      case 18 : 
          exp_desc = /* Texp_send */Block.__(18, [
              map_expression(match[0]),
              match[1],
              may_map(map_expression, match[2])
            ]);
          break;
      case 0 : 
      case 1 : 
      case 19 : 
      case 20 : 
          exp_desc = exp$1[/* exp_desc */0];
          break;
      case 21 : 
          exp_desc = /* Texp_setinstvar */Block.__(21, [
              match[0],
              match[1],
              match[2],
              map_expression(match[3])
            ]);
          break;
      case 22 : 
          exp_desc = /* Texp_override */Block.__(22, [
              match[0],
              List.map((function (param) {
                      return /* tuple */[
                              param[0],
                              param[1],
                              map_expression(param[2])
                            ];
                    }), match[1])
            ]);
          break;
      case 23 : 
          exp_desc = /* Texp_letmodule */Block.__(23, [
              match[0],
              match[1],
              map_module_expr(match[2]),
              map_expression(match[3])
            ]);
          break;
      case 24 : 
          exp_desc = /* Texp_assert */Block.__(24, [map_expression(match[0])]);
          break;
      case 25 : 
          exp_desc = /* Texp_lazy */Block.__(25, [map_expression(match[0])]);
          break;
      case 26 : 
          exp_desc = /* Texp_object */Block.__(26, [
              map_class_structure(match[0]),
              match[1]
            ]);
          break;
      case 27 : 
          exp_desc = /* Texp_pack */Block.__(27, [map_module_expr(match[0])]);
          break;
      
    }
    var exp_extra = List.map(map_exp_extra, exp$1[/* exp_extra */2]);
    return Curry._1(funarg[/* leave_expression */31], /* record */[
                /* exp_desc */exp_desc,
                /* exp_loc */exp$1[/* exp_loc */1],
                /* exp_extra */exp_extra,
                /* exp_type */exp$1[/* exp_type */3],
                /* exp_env */exp$1[/* exp_env */4],
                /* exp_attributes */exp$1[/* exp_attributes */5]
              ]);
  };
  var map_core_type = function (ct) {
    var ct$1 = Curry._1(funarg[/* enter_core_type */21], ct);
    var match = ct$1[/* ctyp_desc */0];
    var ctyp_desc;
    if (typeof match === "number") {
      ctyp_desc = ct$1[/* ctyp_desc */0];
    } else {
      switch (match.tag | 0) {
        case 0 : 
            ctyp_desc = ct$1[/* ctyp_desc */0];
            break;
        case 1 : 
            ctyp_desc = /* Ttyp_arrow */Block.__(1, [
                match[0],
                map_core_type(match[1]),
                map_core_type(match[2])
              ]);
            break;
        case 2 : 
            ctyp_desc = /* Ttyp_tuple */Block.__(2, [List.map(map_core_type, match[0])]);
            break;
        case 3 : 
            ctyp_desc = /* Ttyp_constr */Block.__(3, [
                match[0],
                match[1],
                List.map(map_core_type, match[2])
              ]);
            break;
        case 4 : 
            ctyp_desc = /* Ttyp_object */Block.__(4, [
                List.map((function (param) {
                        return /* tuple */[
                                param[0],
                                param[1],
                                map_core_type(param[2])
                              ];
                      }), match[0]),
                match[1]
              ]);
            break;
        case 5 : 
            ctyp_desc = /* Ttyp_class */Block.__(5, [
                match[0],
                match[1],
                List.map(map_core_type, match[2])
              ]);
            break;
        case 6 : 
            ctyp_desc = /* Ttyp_alias */Block.__(6, [
                map_core_type(match[0]),
                match[1]
              ]);
            break;
        case 7 : 
            ctyp_desc = /* Ttyp_variant */Block.__(7, [
                List.map(map_row_field, match[0]),
                match[1],
                match[2]
              ]);
            break;
        case 8 : 
            ctyp_desc = /* Ttyp_poly */Block.__(8, [
                match[0],
                map_core_type(match[1])
              ]);
            break;
        case 9 : 
            ctyp_desc = /* Ttyp_package */Block.__(9, [map_package_type(match[0])]);
            break;
        
      }
    }
    return Curry._1(funarg[/* leave_core_type */46], /* record */[
                /* ctyp_desc */ctyp_desc,
                /* ctyp_type */ct$1[/* ctyp_type */1],
                /* ctyp_env */ct$1[/* ctyp_env */2],
                /* ctyp_loc */ct$1[/* ctyp_loc */3],
                /* ctyp_attributes */ct$1[/* ctyp_attributes */4]
              ]);
  };
  var map_class_expr = function (cexpr) {
    var cexpr$1 = Curry._1(funarg[/* enter_class_expr */14], cexpr);
    var match = cexpr$1[/* cl_desc */0];
    var cl_desc;
    switch (match.tag | 0) {
      case 0 : 
          cl_desc = /* Tcl_ident */Block.__(0, [
              match[0],
              match[1],
              List.map(map_core_type, match[2])
            ]);
          break;
      case 1 : 
          cl_desc = /* Tcl_structure */Block.__(1, [map_class_structure(match[0])]);
          break;
      case 2 : 
          cl_desc = /* Tcl_fun */Block.__(2, [
              match[0],
              map_pattern(match[1]),
              List.map((function (param) {
                      return /* tuple */[
                              param[0],
                              param[1],
                              map_expression(param[2])
                            ];
                    }), match[2]),
              map_class_expr(match[3]),
              match[4]
            ]);
          break;
      case 3 : 
          cl_desc = /* Tcl_apply */Block.__(3, [
              map_class_expr(match[0]),
              List.map((function (param) {
                      return /* tuple */[
                              param[0],
                              may_map(map_expression, param[1]),
                              param[2]
                            ];
                    }), match[1])
            ]);
          break;
      case 4 : 
          cl_desc = /* Tcl_let */Block.__(4, [
              match[0],
              List.map(map_binding, match[1]),
              List.map((function (param) {
                      return /* tuple */[
                              param[0],
                              param[1],
                              map_expression(param[2])
                            ];
                    }), match[2]),
              map_class_expr(match[3])
            ]);
          break;
      case 5 : 
          var match$1 = match[1];
          var cl = match[0];
          cl_desc = match$1 ? /* Tcl_constraint */Block.__(5, [
                map_class_expr(cl),
                /* Some */[map_class_type(match$1[0])],
                match[2],
                match[3],
                match[4]
              ]) : /* Tcl_constraint */Block.__(5, [
                map_class_expr(cl),
                /* None */0,
                match[2],
                match[3],
                match[4]
              ]);
          break;
      
    }
    return Curry._1(funarg[/* leave_class_expr */39], /* record */[
                /* cl_desc */cl_desc,
                /* cl_loc */cexpr$1[/* cl_loc */1],
                /* cl_type */cexpr$1[/* cl_type */2],
                /* cl_env */cexpr$1[/* cl_env */3],
                /* cl_attributes */cexpr$1[/* cl_attributes */4]
              ]);
  };
  var map_case = function (param) {
    return /* record */[
            /* c_lhs */map_pattern(param[/* c_lhs */0]),
            /* c_guard */may_map(map_expression, param[/* c_guard */1]),
            /* c_rhs */map_expression(param[/* c_rhs */2])
          ];
  };
  var map_class_structure = function (cs) {
    var cs$1 = Curry._1(funarg[/* enter_class_structure */22], cs);
    var cstr_self = map_pattern(cs$1[/* cstr_self */0]);
    var cstr_fields = List.map(map_class_field, cs$1[/* cstr_fields */1]);
    return Curry._1(funarg[/* leave_class_structure */47], /* record */[
                /* cstr_self */cstr_self,
                /* cstr_fields */cstr_fields,
                /* cstr_type */cs$1[/* cstr_type */2],
                /* cstr_meths */cs$1[/* cstr_meths */3]
              ]);
  };
  var map_module_expr = function (mexpr) {
    var mexpr$1 = Curry._1(funarg[/* enter_module_expr */12], mexpr);
    var match = mexpr$1[/* mod_desc */0];
    var mod_desc;
    switch (match.tag | 0) {
      case 0 : 
          mod_desc = mexpr$1[/* mod_desc */0];
          break;
      case 1 : 
          mod_desc = /* Tmod_structure */Block.__(1, [map_structure(match[0])]);
          break;
      case 2 : 
          mod_desc = /* Tmod_functor */Block.__(2, [
              match[0],
              match[1],
              may_map(map_module_type, match[2]),
              map_module_expr(match[3])
            ]);
          break;
      case 3 : 
          mod_desc = /* Tmod_apply */Block.__(3, [
              map_module_expr(match[0]),
              map_module_expr(match[1]),
              match[2]
            ]);
          break;
      case 4 : 
          var match$1 = match[2];
          var mod_type = match[1];
          var mexpr$2 = match[0];
          mod_desc = match$1 ? /* Tmod_constraint */Block.__(4, [
                map_module_expr(mexpr$2),
                mod_type,
                /* Tmodtype_explicit */[map_module_type(match$1[0])],
                match[3]
              ]) : /* Tmod_constraint */Block.__(4, [
                map_module_expr(mexpr$2),
                mod_type,
                /* Tmodtype_implicit */0,
                match[3]
              ]);
          break;
      case 5 : 
          mod_desc = /* Tmod_unpack */Block.__(5, [
              map_expression(match[0]),
              match[1]
            ]);
          break;
      
    }
    return Curry._1(funarg[/* leave_module_expr */37], /* record */[
                /* mod_desc */mod_desc,
                /* mod_loc */mexpr$1[/* mod_loc */1],
                /* mod_type */mexpr$1[/* mod_type */2],
                /* mod_env */mexpr$1[/* mod_env */3],
                /* mod_attributes */mexpr$1[/* mod_attributes */4]
              ]);
  };
  var map_exp_extra = function (exp_extra) {
    var attrs = exp_extra[2];
    var loc = exp_extra[1];
    var desc = exp_extra[0];
    switch (desc.tag | 0) {
      case 0 : 
          return /* tuple */[
                  /* Texp_constraint */Block.__(0, [map_core_type(desc[0])]),
                  loc,
                  attrs
                ];
      case 1 : 
          var match = desc[0];
          if (match) {
            return /* tuple */[
                    /* Texp_coerce */Block.__(1, [
                        /* Some */[map_core_type(match[0])],
                        map_core_type(desc[1])
                      ]),
                    loc,
                    attrs
                  ];
          } else {
            return /* tuple */[
                    /* Texp_coerce */Block.__(1, [
                        /* None */0,
                        map_core_type(desc[1])
                      ]),
                    loc,
                    attrs
                  ];
          }
      case 3 : 
          var match$1 = desc[0];
          if (match$1) {
            return /* tuple */[
                    /* Texp_poly */Block.__(3, [/* Some */[map_core_type(match$1[0])]]),
                    loc,
                    attrs
                  ];
          } else {
            return exp_extra;
          }
      case 2 : 
      case 4 : 
          return exp_extra;
      
    }
  };
  var map_pattern = function (pat) {
    var pat$1 = Curry._1(funarg[/* enter_pattern */5], pat);
    var match = pat$1[/* pat_desc */0];
    var pat_desc;
    if (typeof match === "number") {
      pat_desc = pat$1[/* pat_desc */0];
    } else {
      switch (match.tag | 0) {
        case 1 : 
            var pat1 = map_pattern(match[0]);
            pat_desc = /* Tpat_alias */Block.__(1, [
                pat1,
                match[1],
                match[2]
              ]);
            break;
        case 3 : 
            pat_desc = /* Tpat_tuple */Block.__(3, [List.map(map_pattern, match[0])]);
            break;
        case 4 : 
            pat_desc = /* Tpat_construct */Block.__(4, [
                match[0],
                match[1],
                List.map(map_pattern, match[2])
              ]);
            break;
        case 5 : 
            var pato = match[1];
            var pato$1 = pato ? /* Some */[map_pattern(pato[0])] : pato;
            pat_desc = /* Tpat_variant */Block.__(5, [
                match[0],
                pato$1,
                match[2]
              ]);
            break;
        case 6 : 
            pat_desc = /* Tpat_record */Block.__(6, [
                List.map((function (param) {
                        return /* tuple */[
                                param[0],
                                param[1],
                                map_pattern(param[2])
                              ];
                      }), match[0]),
                match[1]
              ]);
            break;
        case 7 : 
            pat_desc = /* Tpat_array */Block.__(7, [List.map(map_pattern, match[0])]);
            break;
        case 8 : 
            pat_desc = /* Tpat_or */Block.__(8, [
                map_pattern(match[0]),
                map_pattern(match[1]),
                match[2]
              ]);
            break;
        case 9 : 
            pat_desc = /* Tpat_lazy */Block.__(9, [map_pattern(match[0])]);
            break;
        default:
          pat_desc = pat$1[/* pat_desc */0];
      }
    }
    var pat_extra = List.map(map_pat_extra, pat$1[/* pat_extra */2]);
    return Curry._1(funarg[/* leave_pattern */30], /* record */[
                /* pat_desc */pat_desc,
                /* pat_loc */pat$1[/* pat_loc */1],
                /* pat_extra */pat_extra,
                /* pat_type */pat$1[/* pat_type */3],
                /* pat_env */pat$1[/* pat_env */4],
                /* pat_attributes */pat$1[/* pat_attributes */5]
              ]);
  };
  var map_class_type = function (ct) {
    var ct$1 = Curry._1(funarg[/* enter_class_type */19], ct);
    var match = ct$1[/* cltyp_desc */0];
    var cltyp_desc;
    switch (match.tag | 0) {
      case 0 : 
          cltyp_desc = /* Tcty_constr */Block.__(0, [
              match[0],
              match[1],
              List.map(map_core_type, match[2])
            ]);
          break;
      case 1 : 
          cltyp_desc = /* Tcty_signature */Block.__(1, [map_class_signature(match[0])]);
          break;
      case 2 : 
          cltyp_desc = /* Tcty_arrow */Block.__(2, [
              match[0],
              map_core_type(match[1]),
              map_class_type(match[2])
            ]);
          break;
      
    }
    return Curry._1(funarg[/* leave_class_type */44], /* record */[
                /* cltyp_desc */cltyp_desc,
                /* cltyp_type */ct$1[/* cltyp_type */1],
                /* cltyp_env */ct$1[/* cltyp_env */2],
                /* cltyp_loc */ct$1[/* cltyp_loc */3],
                /* cltyp_attributes */ct$1[/* cltyp_attributes */4]
              ]);
  };
  var map_type_declaration = function (decl) {
    var decl$1 = Curry._1(funarg[/* enter_type_declaration */2], decl);
    var typ_params = List.map(map_type_parameter, decl$1[/* typ_params */2]);
    var typ_cstrs = List.map((function (param) {
            return /* tuple */[
                    map_core_type(param[0]),
                    map_core_type(param[1]),
                    param[2]
                  ];
          }), decl$1[/* typ_cstrs */4]);
    var match = decl$1[/* typ_kind */5];
    var typ_kind;
    if (typeof match === "number") {
      typ_kind = match ? /* Ttype_open */1 : /* Ttype_abstract */0;
    } else if (match.tag) {
      var list = List.map((function (ld) {
              var newrecord = ld.slice();
              newrecord[/* ld_type */3] = map_core_type(ld[/* ld_type */3]);
              return newrecord;
            }), match[0]);
      typ_kind = /* Ttype_record */Block.__(1, [list]);
    } else {
      var list$1 = List.map(map_constructor_declaration, match[0]);
      typ_kind = /* Ttype_variant */Block.__(0, [list$1]);
    }
    var typ_manifest = may_map(map_core_type, decl$1[/* typ_manifest */7]);
    return Curry._1(funarg[/* leave_type_declaration */27], /* record */[
                /* typ_id */decl$1[/* typ_id */0],
                /* typ_name */decl$1[/* typ_name */1],
                /* typ_params */typ_params,
                /* typ_type */decl$1[/* typ_type */3],
                /* typ_cstrs */typ_cstrs,
                /* typ_kind */typ_kind,
                /* typ_private */decl$1[/* typ_private */6],
                /* typ_manifest */typ_manifest,
                /* typ_loc */decl$1[/* typ_loc */8],
                /* typ_attributes */decl$1[/* typ_attributes */9]
              ]);
  };
  var map_signature = function (sg) {
    var sg$1 = Curry._1(funarg[/* enter_signature */8], sg);
    var sig_items = List.map(map_signature_item, sg$1[/* sig_items */0]);
    return Curry._1(funarg[/* leave_signature */33], /* record */[
                /* sig_items */sig_items,
                /* sig_type */sg$1[/* sig_type */1],
                /* sig_final_env */sg$1[/* sig_final_env */2]
              ]);
  };
  var map_with_constraint = function (cstr) {
    var cstr$1 = Curry._1(funarg[/* enter_with_constraint */13], cstr);
    var $js;
    switch (cstr$1.tag | 0) {
      case 0 : 
          $js = /* Twith_type */Block.__(0, [map_type_declaration(cstr$1[0])]);
          break;
      case 2 : 
          $js = /* Twith_typesubst */Block.__(2, [map_type_declaration(cstr$1[0])]);
          break;
      case 1 : 
      case 3 : 
          $js = cstr$1;
          break;
      
    }
    return Curry._1(funarg[/* leave_with_constraint */38], $js);
  };
  var map_module_type = function (mty) {
    var mty$1 = Curry._1(funarg[/* enter_module_type */11], mty);
    var match = mty$1[/* mty_desc */0];
    var mty_desc;
    switch (match.tag | 0) {
      case 1 : 
          mty_desc = /* Tmty_signature */Block.__(1, [map_signature(match[0])]);
          break;
      case 2 : 
          mty_desc = /* Tmty_functor */Block.__(2, [
              match[0],
              match[1],
              may_map(map_module_type, match[2]),
              map_module_type(match[3])
            ]);
          break;
      case 3 : 
          mty_desc = /* Tmty_with */Block.__(3, [
              map_module_type(match[0]),
              List.map((function (param) {
                      return /* tuple */[
                              param[0],
                              param[1],
                              map_with_constraint(param[2])
                            ];
                    }), match[1])
            ]);
          break;
      case 4 : 
          mty_desc = /* Tmty_typeof */Block.__(4, [map_module_expr(match[0])]);
          break;
      case 0 : 
      case 5 : 
          mty_desc = mty$1[/* mty_desc */0];
          break;
      
    }
    return Curry._1(funarg[/* leave_module_type */36], /* record */[
                /* mty_desc */mty_desc,
                /* mty_type */mty$1[/* mty_type */1],
                /* mty_env */mty$1[/* mty_env */2],
                /* mty_loc */mty$1[/* mty_loc */3],
                /* mty_attributes */mty$1[/* mty_attributes */4]
              ]);
  };
  var map_type_parameter = function (param) {
    return /* tuple */[
            map_core_type(param[0]),
            param[1]
          ];
  };
  var map_value_description = function (v) {
    var v$1 = Curry._1(funarg[/* enter_value_description */1], v);
    var val_desc = map_core_type(v$1[/* val_desc */2]);
    var newrecord = v$1.slice();
    return Curry._1(funarg[/* leave_value_description */26], (newrecord[/* val_desc */2] = val_desc, newrecord));
  };
  var map_module_binding = function (x) {
    return /* record */[
            /* mb_id */x[/* mb_id */0],
            /* mb_name */x[/* mb_name */1],
            /* mb_expr */map_module_expr(x[/* mb_expr */2]),
            /* mb_attributes */x[/* mb_attributes */3],
            /* mb_loc */x[/* mb_loc */4]
          ];
  };
  var map_class_type_declaration = function (cd) {
    var cd$1 = Curry._1(funarg[/* enter_class_type_declaration */18], cd);
    var ci_params = List.map(map_type_parameter, cd$1[/* ci_params */1]);
    var ci_expr = map_class_type(cd$1[/* ci_expr */7]);
    var newrecord = cd$1.slice();
    return Curry._1(funarg[/* leave_class_type_declaration */43], (newrecord[/* ci_params */1] = ci_params, newrecord[/* ci_expr */7] = ci_expr, newrecord));
  };
  var map_extension_constructor = function (ext) {
    var ext$1 = Curry._1(funarg[/* enter_extension_constructor */4], ext);
    var match = ext$1[/* ext_kind */3];
    var ext_kind;
    if (match.tag) {
      ext_kind = /* Text_rebind */Block.__(1, [
          match[0],
          match[1]
        ]);
    } else {
      var args = List.map(map_core_type, match[0]);
      var ret = may_map(map_core_type, match[1]);
      ext_kind = /* Text_decl */Block.__(0, [
          args,
          ret
        ]);
    }
    var newrecord = ext$1.slice();
    return Curry._1(funarg[/* leave_extension_constructor */29], (newrecord[/* ext_kind */3] = ext_kind, newrecord));
  };
  var map_type_extension = function (tyext) {
    var tyext$1 = Curry._1(funarg[/* enter_type_extension */3], tyext);
    var tyext_params = List.map(map_type_parameter, tyext$1[/* tyext_params */2]);
    var tyext_constructors = List.map(map_extension_constructor, tyext$1[/* tyext_constructors */3]);
    return Curry._1(funarg[/* leave_type_extension */28], /* record */[
                /* tyext_path */tyext$1[/* tyext_path */0],
                /* tyext_txt */tyext$1[/* tyext_txt */1],
                /* tyext_params */tyext_params,
                /* tyext_constructors */tyext_constructors,
                /* tyext_private */tyext$1[/* tyext_private */4],
                /* tyext_attributes */tyext$1[/* tyext_attributes */5]
              ]);
  };
  var map_class_declaration = function (cd) {
    var cd$1 = Curry._1(funarg[/* enter_class_declaration */16], cd);
    var ci_params = List.map(map_type_parameter, cd$1[/* ci_params */1]);
    var ci_expr = map_class_expr(cd$1[/* ci_expr */7]);
    var newrecord = cd$1.slice();
    return Curry._1(funarg[/* leave_class_declaration */41], (newrecord[/* ci_params */1] = ci_params, newrecord[/* ci_expr */7] = ci_expr, newrecord));
  };
  var map_module_type_declaration = function (mtd) {
    var mtd$1 = Curry._1(funarg[/* enter_module_type_declaration */10], mtd);
    return Curry._1(funarg[/* leave_module_type_declaration */35], /* record */[
                /* mtd_id */mtd$1[/* mtd_id */0],
                /* mtd_name */mtd$1[/* mtd_name */1],
                /* mtd_type */may_map(map_module_type, mtd$1[/* mtd_type */2]),
                /* mtd_attributes */mtd$1[/* mtd_attributes */3],
                /* mtd_loc */mtd$1[/* mtd_loc */4]
              ]);
  };
  var map_class_description = function (cd) {
    var cd$1 = Curry._1(funarg[/* enter_class_description */17], cd);
    var ci_params = List.map(map_type_parameter, cd$1[/* ci_params */1]);
    var ci_expr = map_class_type(cd$1[/* ci_expr */7]);
    var newrecord = cd$1.slice();
    return Curry._1(funarg[/* leave_class_description */42], (newrecord[/* ci_params */1] = ci_params, newrecord[/* ci_expr */7] = ci_expr, newrecord));
  };
  var map_row_field = function (rf) {
    if (rf.tag) {
      return /* Tinherit */Block.__(1, [map_core_type(rf[0])]);
    } else {
      return /* Ttag */Block.__(0, [
                rf[0],
                rf[1],
                rf[2],
                List.map(map_core_type, rf[3])
              ]);
    }
  };
  var map_package_type = function (pack) {
    var pack$1 = Curry._1(funarg[/* enter_package_type */7], pack);
    var pack_fields = List.map((function (param) {
            return /* tuple */[
                    param[0],
                    map_core_type(param[1])
                  ];
          }), pack$1[/* pack_fields */1]);
    return Curry._1(funarg[/* leave_package_type */32], /* record */[
                /* pack_path */pack$1[/* pack_path */0],
                /* pack_fields */pack_fields,
                /* pack_type */pack$1[/* pack_type */2],
                /* pack_txt */pack$1[/* pack_txt */3]
              ]);
  };
  var map_class_type_field = function (ctf) {
    var ctf$1 = Curry._1(funarg[/* enter_class_type_field */20], ctf);
    var x = ctf$1[/* ctf_desc */0];
    var ctf_desc;
    switch (x.tag | 0) {
      case 0 : 
          ctf_desc = /* Tctf_inherit */Block.__(0, [map_class_type(x[0])]);
          break;
      case 1 : 
          var match = x[0];
          ctf_desc = /* Tctf_val */Block.__(1, [/* tuple */[
                match[0],
                match[1],
                match[2],
                map_core_type(match[3])
              ]]);
          break;
      case 2 : 
          var match$1 = x[0];
          ctf_desc = /* Tctf_method */Block.__(2, [/* tuple */[
                match$1[0],
                match$1[1],
                match$1[2],
                map_core_type(match$1[3])
              ]]);
          break;
      case 3 : 
          var match$2 = x[0];
          ctf_desc = /* Tctf_constraint */Block.__(3, [/* tuple */[
                map_core_type(match$2[0]),
                map_core_type(match$2[1])
              ]]);
          break;
      case 4 : 
          ctf_desc = x;
          break;
      
    }
    return Curry._1(funarg[/* leave_class_type_field */45], /* record */[
                /* ctf_desc */ctf_desc,
                /* ctf_loc */ctf$1[/* ctf_loc */1],
                /* ctf_attributes */ctf$1[/* ctf_attributes */2]
              ]);
  };
  var map_signature_item = function (item) {
    var item$1 = Curry._1(funarg[/* enter_signature_item */9], item);
    var x = item$1[/* sig_desc */0];
    var sig_desc;
    switch (x.tag | 0) {
      case 0 : 
          sig_desc = /* Tsig_value */Block.__(0, [map_value_description(x[0])]);
          break;
      case 1 : 
          sig_desc = /* Tsig_type */Block.__(1, [List.map(map_type_declaration, x[0])]);
          break;
      case 2 : 
          sig_desc = /* Tsig_typext */Block.__(2, [map_type_extension(x[0])]);
          break;
      case 3 : 
          sig_desc = /* Tsig_exception */Block.__(3, [map_extension_constructor(x[0])]);
          break;
      case 4 : 
          var md = x[0];
          sig_desc = /* Tsig_module */Block.__(4, [/* record */[
                /* md_id */md[/* md_id */0],
                /* md_name */md[/* md_name */1],
                /* md_type */map_module_type(md[/* md_type */2]),
                /* md_attributes */md[/* md_attributes */3],
                /* md_loc */md[/* md_loc */4]
              ]]);
          break;
      case 5 : 
          sig_desc = /* Tsig_recmodule */Block.__(5, [List.map((function (md) {
                      return /* record */[
                              /* md_id */md[/* md_id */0],
                              /* md_name */md[/* md_name */1],
                              /* md_type */map_module_type(md[/* md_type */2]),
                              /* md_attributes */md[/* md_attributes */3],
                              /* md_loc */md[/* md_loc */4]
                            ];
                    }), x[0])]);
          break;
      case 6 : 
          sig_desc = /* Tsig_modtype */Block.__(6, [map_module_type_declaration(x[0])]);
          break;
      case 7 : 
          sig_desc = item$1[/* sig_desc */0];
          break;
      case 8 : 
          var incl = x[0];
          sig_desc = /* Tsig_include */Block.__(8, [/* record */[
                /* incl_mod */map_module_type(incl[/* incl_mod */0]),
                /* incl_type */incl[/* incl_type */1],
                /* incl_loc */incl[/* incl_loc */2],
                /* incl_attributes */incl[/* incl_attributes */3]
              ]]);
          break;
      case 9 : 
          sig_desc = /* Tsig_class */Block.__(9, [List.map(map_class_description, x[0])]);
          break;
      case 10 : 
          sig_desc = /* Tsig_class_type */Block.__(10, [List.map(map_class_type_declaration, x[0])]);
          break;
      case 11 : 
          sig_desc = x;
          break;
      
    }
    return Curry._1(funarg[/* leave_signature_item */34], /* record */[
                /* sig_desc */sig_desc,
                /* sig_env */item$1[/* sig_env */1],
                /* sig_loc */item$1[/* sig_loc */2]
              ]);
  };
  var map_structure_item = function (item) {
    var item$1 = Curry._1(funarg[/* enter_structure_item */24], item);
    var match = item$1[/* str_desc */0];
    var str_desc;
    switch (match.tag | 0) {
      case 0 : 
          str_desc = /* Tstr_eval */Block.__(0, [
              map_expression(match[0]),
              match[1]
            ]);
          break;
      case 1 : 
          str_desc = /* Tstr_value */Block.__(1, [
              match[0],
              List.map(map_binding, match[1])
            ]);
          break;
      case 2 : 
          str_desc = /* Tstr_primitive */Block.__(2, [map_value_description(match[0])]);
          break;
      case 3 : 
          str_desc = /* Tstr_type */Block.__(3, [List.map(map_type_declaration, match[0])]);
          break;
      case 4 : 
          str_desc = /* Tstr_typext */Block.__(4, [map_type_extension(match[0])]);
          break;
      case 5 : 
          str_desc = /* Tstr_exception */Block.__(5, [map_extension_constructor(match[0])]);
          break;
      case 6 : 
          str_desc = /* Tstr_module */Block.__(6, [map_module_binding(match[0])]);
          break;
      case 7 : 
          var list = List.map(map_module_binding, match[0]);
          str_desc = /* Tstr_recmodule */Block.__(7, [list]);
          break;
      case 8 : 
          str_desc = /* Tstr_modtype */Block.__(8, [map_module_type_declaration(match[0])]);
          break;
      case 9 : 
          str_desc = /* Tstr_open */Block.__(9, [match[0]]);
          break;
      case 10 : 
          var list$1 = List.map((function (param) {
                  return /* tuple */[
                          map_class_declaration(param[0]),
                          param[1],
                          param[2]
                        ];
                }), match[0]);
          str_desc = /* Tstr_class */Block.__(10, [list$1]);
          break;
      case 11 : 
          var list$2 = List.map((function (param) {
                  return /* tuple */[
                          param[0],
                          param[1],
                          map_class_type_declaration(param[2])
                        ];
                }), match[0]);
          str_desc = /* Tstr_class_type */Block.__(11, [list$2]);
          break;
      case 12 : 
          var incl = match[0];
          str_desc = /* Tstr_include */Block.__(12, [/* record */[
                /* incl_mod */map_module_expr(incl[/* incl_mod */0]),
                /* incl_type */incl[/* incl_type */1],
                /* incl_loc */incl[/* incl_loc */2],
                /* incl_attributes */incl[/* incl_attributes */3]
              ]]);
          break;
      case 13 : 
          str_desc = /* Tstr_attribute */Block.__(13, [match[0]]);
          break;
      
    }
    return Curry._1(funarg[/* leave_structure_item */49], /* record */[
                /* str_desc */str_desc,
                /* str_loc */item$1[/* str_loc */1],
                /* str_env */item$1[/* str_env */2]
              ]);
  };
  var map_constructor_declaration = function (cd) {
    return /* record */[
            /* cd_id */cd[/* cd_id */0],
            /* cd_name */cd[/* cd_name */1],
            /* cd_args */List.map(map_core_type, cd[/* cd_args */2]),
            /* cd_res */may_map(map_core_type, cd[/* cd_res */3]),
            /* cd_loc */cd[/* cd_loc */4],
            /* cd_attributes */cd[/* cd_attributes */5]
          ];
  };
  var map_class_field = function (cf) {
    var cf$1 = Curry._1(funarg[/* enter_class_field */23], cf);
    var x = cf$1[/* cf_desc */0];
    var cf_desc;
    switch (x.tag | 0) {
      case 0 : 
          cf_desc = /* Tcf_inherit */Block.__(0, [
              x[0],
              map_class_expr(x[1]),
              x[2],
              x[3],
              x[4]
            ]);
          break;
      case 1 : 
          var match = x[3];
          var ident = x[2];
          var mut = x[1];
          var lab = x[0];
          cf_desc = match.tag ? /* Tcf_val */Block.__(1, [
                lab,
                mut,
                ident,
                /* Tcfk_concrete */Block.__(1, [
                    match[0],
                    map_expression(match[1])
                  ]),
                x[4]
              ]) : /* Tcf_val */Block.__(1, [
                lab,
                mut,
                ident,
                /* Tcfk_virtual */Block.__(0, [map_core_type(match[0])]),
                x[4]
              ]);
          break;
      case 2 : 
          var match$1 = x[2];
          var priv = x[1];
          var lab$1 = x[0];
          cf_desc = match$1.tag ? /* Tcf_method */Block.__(2, [
                lab$1,
                priv,
                /* Tcfk_concrete */Block.__(1, [
                    match$1[0],
                    map_expression(match$1[1])
                  ])
              ]) : /* Tcf_method */Block.__(2, [
                lab$1,
                priv,
                /* Tcfk_virtual */Block.__(0, [map_core_type(match$1[0])])
              ]);
          break;
      case 3 : 
          cf_desc = /* Tcf_constraint */Block.__(3, [
              map_core_type(x[0]),
              map_core_type(x[1])
            ]);
          break;
      case 4 : 
          cf_desc = /* Tcf_initializer */Block.__(4, [map_expression(x[0])]);
          break;
      case 5 : 
          cf_desc = x;
          break;
      
    }
    return Curry._1(funarg[/* leave_class_field */48], /* record */[
                /* cf_desc */cf_desc,
                /* cf_loc */cf$1[/* cf_loc */1],
                /* cf_attributes */cf$1[/* cf_attributes */2]
              ]);
  };
  var map_class_signature = function (cs) {
    var cs$1 = Curry._1(funarg[/* enter_class_signature */15], cs);
    var csig_self = map_core_type(cs$1[/* csig_self */0]);
    var csig_fields = List.map(map_class_type_field, cs$1[/* csig_fields */1]);
    return Curry._1(funarg[/* leave_class_signature */40], /* record */[
                /* csig_self */csig_self,
                /* csig_fields */csig_fields,
                /* csig_type */cs$1[/* csig_type */2]
              ]);
  };
  var map_pat_extra = function (pat_extra) {
    var match = pat_extra[0];
    if (typeof match === "number" || match.tag) {
      return pat_extra;
    } else {
      return /* tuple */[
              /* Tpat_constraint */Block.__(0, [map_core_type(match[0])]),
              pat_extra[1],
              pat_extra[2]
            ];
    }
  };
  return [
          map_structure,
          map_pattern,
          map_structure_item,
          map_expression,
          map_class_expr,
          map_signature,
          map_signature_item,
          map_module_type
        ];
}

var need_to_clear_env;

try {
  Caml_sys.caml_sys_getenv("OCAML_BINANNOT_WITHENV");
  need_to_clear_env = /* false */0;
}
catch (exn$2){
  if (exn$2 === Caml_builtin_exceptions.not_found) {
    need_to_clear_env = /* true */1;
  } else {
    throw exn$2;
  }
}

function leave_pattern(p) {
  var newrecord = p.slice();
  newrecord[/* pat_env */4] = keep_only_summary(p[/* pat_env */4]);
  return newrecord;
}

function leave_expression(e) {
  var exp_extra = List.map((function (exp_extra) {
          var match = exp_extra[0];
          if (match.tag === 2) {
            return /* tuple */[
                    /* Texp_open */Block.__(2, [
                        match[0],
                        match[1],
                        match[2],
                        keep_only_summary(match[3])
                      ]),
                    exp_extra[1],
                    exp_extra[2]
                  ];
          } else {
            return exp_extra;
          }
        }), e[/* exp_extra */2]);
  return /* record */[
          /* exp_desc */e[/* exp_desc */0],
          /* exp_loc */e[/* exp_loc */1],
          /* exp_extra */exp_extra,
          /* exp_type */e[/* exp_type */3],
          /* exp_env */keep_only_summary(e[/* exp_env */4]),
          /* exp_attributes */e[/* exp_attributes */5]
        ];
}

function leave_class_expr(c) {
  return /* record */[
          /* cl_desc */c[/* cl_desc */0],
          /* cl_loc */c[/* cl_loc */1],
          /* cl_type */c[/* cl_type */2],
          /* cl_env */keep_only_summary(c[/* cl_env */3]),
          /* cl_attributes */c[/* cl_attributes */4]
        ];
}

function leave_module_expr(m) {
  return /* record */[
          /* mod_desc */m[/* mod_desc */0],
          /* mod_loc */m[/* mod_loc */1],
          /* mod_type */m[/* mod_type */2],
          /* mod_env */keep_only_summary(m[/* mod_env */3]),
          /* mod_attributes */m[/* mod_attributes */4]
        ];
}

function leave_structure(s) {
  return /* record */[
          /* str_items */s[/* str_items */0],
          /* str_type */s[/* str_type */1],
          /* str_final_env */keep_only_summary(s[/* str_final_env */2])
        ];
}

function leave_structure_item(str) {
  return /* record */[
          /* str_desc */str[/* str_desc */0],
          /* str_loc */str[/* str_loc */1],
          /* str_env */keep_only_summary(str[/* str_env */2])
        ];
}

function leave_module_type(m) {
  return /* record */[
          /* mty_desc */m[/* mty_desc */0],
          /* mty_type */m[/* mty_type */1],
          /* mty_env */keep_only_summary(m[/* mty_env */2]),
          /* mty_loc */m[/* mty_loc */3],
          /* mty_attributes */m[/* mty_attributes */4]
        ];
}

function leave_signature(s) {
  return /* record */[
          /* sig_items */s[/* sig_items */0],
          /* sig_type */s[/* sig_type */1],
          /* sig_final_env */keep_only_summary(s[/* sig_final_env */2])
        ];
}

function leave_signature_item(s) {
  return /* record */[
          /* sig_desc */s[/* sig_desc */0],
          /* sig_env */keep_only_summary(s[/* sig_env */1]),
          /* sig_loc */s[/* sig_loc */2]
        ];
}

function leave_core_type(c) {
  return /* record */[
          /* ctyp_desc */c[/* ctyp_desc */0],
          /* ctyp_type */c[/* ctyp_type */1],
          /* ctyp_env */keep_only_summary(c[/* ctyp_env */2]),
          /* ctyp_loc */c[/* ctyp_loc */3],
          /* ctyp_attributes */c[/* ctyp_attributes */4]
        ];
}

function leave_class_type(c) {
  return /* record */[
          /* cltyp_desc */c[/* cltyp_desc */0],
          /* cltyp_type */c[/* cltyp_type */1],
          /* cltyp_env */keep_only_summary(c[/* cltyp_env */2]),
          /* cltyp_loc */c[/* cltyp_loc */3],
          /* cltyp_attributes */c[/* cltyp_attributes */4]
        ];
}

var ClearEnv = Curry._1(TypedtreeMap_000, /* module */[
      /* enter_structure */enter_structure,
      /* enter_value_description */enter_value_description,
      /* enter_type_declaration */enter_type_declaration,
      /* enter_type_extension */enter_type_extension,
      /* enter_extension_constructor */enter_extension_constructor,
      /* enter_pattern */enter_pattern,
      /* enter_expression */enter_expression,
      /* enter_package_type */enter_package_type,
      /* enter_signature */enter_signature,
      /* enter_signature_item */enter_signature_item,
      /* enter_module_type_declaration */enter_module_type_declaration,
      /* enter_module_type */enter_module_type,
      /* enter_module_expr */enter_module_expr,
      /* enter_with_constraint */enter_with_constraint,
      /* enter_class_expr */enter_class_expr,
      /* enter_class_signature */enter_class_signature,
      /* enter_class_declaration */enter_class_declaration,
      /* enter_class_description */enter_class_description,
      /* enter_class_type_declaration */enter_class_type_declaration,
      /* enter_class_type */enter_class_type,
      /* enter_class_type_field */enter_class_type_field,
      /* enter_core_type */enter_core_type,
      /* enter_class_structure */enter_class_structure,
      /* enter_class_field */enter_class_field,
      /* enter_structure_item */enter_structure_item,
      /* leave_structure */leave_structure,
      /* leave_value_description */leave_value_description,
      /* leave_type_declaration */leave_type_declaration,
      /* leave_type_extension */leave_type_extension,
      /* leave_extension_constructor */leave_extension_constructor,
      /* leave_pattern */leave_pattern,
      /* leave_expression */leave_expression,
      /* leave_package_type */leave_package_type,
      /* leave_signature */leave_signature,
      /* leave_signature_item */leave_signature_item,
      /* leave_module_type_declaration */leave_module_type_declaration,
      /* leave_module_type */leave_module_type,
      /* leave_module_expr */leave_module_expr,
      /* leave_with_constraint */leave_with_constraint,
      /* leave_class_expr */leave_class_expr,
      /* leave_class_signature */leave_class_signature,
      /* leave_class_declaration */leave_class_declaration,
      /* leave_class_description */leave_class_description,
      /* leave_class_type_declaration */leave_class_type_declaration,
      /* leave_class_type */leave_class_type,
      /* leave_class_type_field */leave_class_type_field,
      /* leave_core_type */leave_core_type,
      /* leave_class_structure */leave_class_structure,
      /* leave_class_field */leave_class_field,
      /* leave_structure_item */leave_structure_item
    ]);

function clear_part(p) {
  switch (p.tag | 0) {
    case 0 : 
        return /* Partial_structure */Block.__(0, [Curry._1(ClearEnv[/* map_structure */0], p[0])]);
    case 1 : 
        return /* Partial_structure_item */Block.__(1, [Curry._1(ClearEnv[/* map_structure_item */2], p[0])]);
    case 2 : 
        return /* Partial_expression */Block.__(2, [Curry._1(ClearEnv[/* map_expression */3], p[0])]);
    case 3 : 
        return /* Partial_pattern */Block.__(3, [Curry._1(ClearEnv[/* map_pattern */1], p[0])]);
    case 4 : 
        return /* Partial_class_expr */Block.__(4, [Curry._1(ClearEnv[/* map_class_expr */4], p[0])]);
    case 5 : 
        return /* Partial_signature */Block.__(5, [Curry._1(ClearEnv[/* map_signature */5], p[0])]);
    case 6 : 
        return /* Partial_signature_item */Block.__(6, [Curry._1(ClearEnv[/* map_signature_item */6], p[0])]);
    case 7 : 
        return /* Partial_module_type */Block.__(7, [Curry._1(ClearEnv[/* map_module_type */7], p[0])]);
    
  }
}

function clear_env(binary_annots) {
  if (need_to_clear_env) {
    switch (binary_annots.tag | 0) {
      case 0 : 
          return binary_annots;
      case 1 : 
          return /* Implementation */Block.__(1, [Curry._1(ClearEnv[/* map_structure */0], binary_annots[0])]);
      case 2 : 
          return /* Interface */Block.__(2, [Curry._1(ClearEnv[/* map_signature */5], binary_annots[0])]);
      case 3 : 
          return /* Partial_implementation */Block.__(3, [$$Array.map(clear_part, binary_annots[0])]);
      case 4 : 
          return /* Partial_interface */Block.__(4, [$$Array.map(clear_part, binary_annots[0])]);
      
    }
  } else {
    return binary_annots;
  }
}

function output_cmt(oc, _) {
  Pervasives.output_string(oc, "Caml2012T004");
  return Caml_missing_polyfill.not_implemented("caml_output_value not implemented by bucklescript yet\n");
}

var saved_types = [/* [] */0];

var value_deps = [/* [] */0];

function clear() {
  saved_types[0] = /* [] */0;
  value_deps[0] = /* [] */0;
  return /* () */0;
}

function add_saved_type(b) {
  saved_types[0] = /* :: */[
    b,
    saved_types[0]
  ];
  return /* () */0;
}

function record_value_dependency(vd1, vd2) {
  if (Caml_obj.caml_notequal(vd1[/* val_loc */2], vd2[/* val_loc */2])) {
    value_deps[0] = /* :: */[
      /* tuple */[
        vd1,
        vd2
      ],
      value_deps[0]
    ];
    return /* () */0;
  } else {
    return 0;
  }
}

function save_cmt(filename, modname, binary_annots, sourcefile, initial_env, sg) {
  if (binary_annotations[0] && !print_types[0]) {
    var imports$1 = imports(/* () */0);
    var oc = Pervasives.open_out_bin(filename);
    var this_crc;
    if (sg) {
      var cmi_001 = /* cmi_sign */sg[0];
      var cmi_003 = /* cmi_flags */recursive_types[0] ? /* :: */[
          /* Rectypes */0,
          /* [] */0
        ] : /* [] */0;
      var cmi = /* record */[
        /* cmi_name */modname,
        cmi_001,
        /* cmi_crcs */imports$1,
        cmi_003
      ];
      this_crc = /* Some */[output_cmi(filename, oc, cmi)];
    } else {
      this_crc = /* None */0;
    }
    var source_digest = may_map(Digest.file, sourcefile);
    var cmt_001 = /* cmt_annots */clear_env(binary_annots);
    var cmt_002 = /* cmt_value_dependencies */value_deps[0];
    var cmt_003 = /* cmt_comments */List.rev(comment_list[0]);
    var cmt_006 = /* cmt_builddir */Caml_sys.caml_sys_getcwd(/* () */0);
    var cmt_007 = /* cmt_loadpath */load_path[0];
    var cmt_009 = /* cmt_initial_env */need_to_clear_env ? keep_only_summary(initial_env) : initial_env;
    var cmt_010 = /* cmt_imports */List.sort(Caml_obj.caml_compare, imports$1);
    var cmt = /* record */[
      /* cmt_modname */modname,
      cmt_001,
      cmt_002,
      cmt_003,
      /* cmt_args */Sys.argv,
      /* cmt_sourcefile */sourcefile,
      cmt_006,
      cmt_007,
      /* cmt_source_digest */source_digest,
      cmt_009,
      cmt_010,
      /* cmt_interface_digest */this_crc,
      /* cmt_use_summaries */need_to_clear_env
    ];
    output_cmt(oc, cmt);
    Caml_io.caml_ml_flush(oc);
    Caml_missing_polyfill.not_implemented("caml_ml_close_channel not implemented by bucklescript yet\n");
  }
  return clear(/* () */0);
}

var Unify = Caml_exceptions.create("Ocaml_typedtree_test.Ctype.Unify");

var Tags = Caml_exceptions.create("Ocaml_typedtree_test.Ctype.Tags");

register_error_of_exn((function (param) {
        if (param[0] === Tags) {
          return /* Some */[Curry._2(errorf(/* Some */[in_file(input_name[0])], /* None */0, /* None */0, /* Format */[
                            /* String_literal */Block.__(11, [
                                "In this program,",
                                /* Formatting_lit */Block.__(17, [
                                    /* Break */Block.__(0, [
                                        "@ ",
                                        1,
                                        0
                                      ]),
                                    /* String_literal */Block.__(11, [
                                        "variant constructors",
                                        /* Formatting_lit */Block.__(17, [
                                            /* Break */Block.__(0, [
                                                "@ ",
                                                1,
                                                0
                                              ]),
                                            /* Char_literal */Block.__(12, [
                                                /* "`" */96,
                                                /* String */Block.__(2, [
                                                    /* No_padding */0,
                                                    /* String_literal */Block.__(11, [
                                                        " and `",
                                                        /* String */Block.__(2, [
                                                            /* No_padding */0,
                                                            /* Formatting_lit */Block.__(17, [
                                                                /* Break */Block.__(0, [
                                                                    "@ ",
                                                                    1,
                                                                    0
                                                                  ]),
                                                                /* String_literal */Block.__(11, [
                                                                    "have the same hash value.",
                                                                    /* Formatting_lit */Block.__(17, [
                                                                        /* Break */Block.__(0, [
                                                                            "@ ",
                                                                            1,
                                                                            0
                                                                          ]),
                                                                        /* String_literal */Block.__(11, [
                                                                            "Change one of them.",
                                                                            /* End_of_format */0
                                                                          ])
                                                                      ])
                                                                  ])
                                                              ])
                                                          ])
                                                      ])
                                                  ])
                                              ])
                                          ])
                                      ])
                                  ])
                              ]),
                            "In this program,@ variant constructors@ `%s and `%s@ have the same hash value.@ Change one of them."
                          ]), param[1], param[2])];
        } else {
          return /* None */0;
        }
      }));

var Subtype = Caml_exceptions.create("Ocaml_typedtree_test.Ctype.Subtype");

var Cannot_expand = Caml_exceptions.create("Ocaml_typedtree_test.Ctype.Cannot_expand");

var Recursive_abbrev = Caml_exceptions.create("Ocaml_typedtree_test.Ctype.Recursive_abbrev");

var Unification_recursive_abbrev = Caml_exceptions.create("Ocaml_typedtree_test.Ctype.Unification_recursive_abbrev");

var current_level = [0];

var nongen_level = [0];

var global_level = [1];

var saved_level = [/* [] */0];

function init_def(level) {
  current_level[0] = level;
  nongen_level[0] = level;
  return /* () */0;
}

function begin_def() {
  saved_level[0] = /* :: */[
    /* tuple */[
      current_level[0],
      nongen_level[0]
    ],
    saved_level[0]
  ];
  current_level[0] = current_level[0] + 1 | 0;
  nongen_level[0] = current_level[0];
  return /* () */0;
}

function begin_class_def() {
  saved_level[0] = /* :: */[
    /* tuple */[
      current_level[0],
      nongen_level[0]
    ],
    saved_level[0]
  ];
  current_level[0] = current_level[0] + 1 | 0;
  return /* () */0;
}

function raise_nongen_level() {
  saved_level[0] = /* :: */[
    /* tuple */[
      current_level[0],
      nongen_level[0]
    ],
    saved_level[0]
  ];
  nongen_level[0] = current_level[0];
  return /* () */0;
}

function end_def() {
  var match = List.hd(saved_level[0]);
  saved_level[0] = List.tl(saved_level[0]);
  current_level[0] = match[0];
  nongen_level[0] = match[1];
  return /* () */0;
}

function reset_global_level() {
  global_level[0] = current_level[0] + 1 | 0;
  return /* () */0;
}

function increase_global_level() {
  var gl = global_level[0];
  global_level[0] = current_level[0];
  return gl;
}

function is_object_type(path) {
  var name;
  switch (path.tag | 0) {
    case 0 : 
        name = path[0][/* name */1];
        break;
    case 1 : 
        name = path[1];
        break;
    case 2 : 
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "ctype.ml",
                149,
                23
              ]
            ];
    
  }
  return +(Caml_string.get(name, 0) === /* "#" */35);
}

var trace_gadt_instances = [/* false */0];

function check_trace_gadt_instances(env) {
  if (!trace_gadt_instances[0] && env[/* local_constraints */11]) {
    trace_gadt_instances[0] = /* true */1;
    cleanup_abbrev(/* () */0);
    return /* true */1;
  } else {
    return /* false */0;
  }
}

function reset_trace_gadt_instances(b) {
  if (b) {
    trace_gadt_instances[0] = /* false */0;
    return /* () */0;
  } else {
    return 0;
  }
}

function wrap_trace_gadt_instances(env, f, x) {
  var b = check_trace_gadt_instances(env);
  var y = Curry._1(f, x);
  reset_trace_gadt_instances(b);
  return y;
}

var simple_abbrevs = [/* Mnil */0];

function proper_abbrevs(path, tl, abbrev) {
  if (tl !== /* [] */0 || trace_gadt_instances[0] || principal[0] || is_object_type(path)) {
    return abbrev;
  } else {
    return simple_abbrevs;
  }
}

function newvar(name, _) {
  return newty2(current_level[0], /* Tvar */Block.__(0, [name]));
}

function newobj(fields) {
  return newty2(current_level[0], /* Tobject */Block.__(4, [
                fields,
                [/* None */0]
              ]));
}

function newconstr(path, tyl) {
  return newty2(current_level[0], /* Tconstr */Block.__(3, [
                path,
                tyl,
                [/* Mnil */0]
              ]));
}

var none$2 = newty2(current_level[0], /* Ttuple */Block.__(2, [/* [] */0]));

function equal$3(param, param$1) {
  if (param[0] === param$1[0]) {
    return +(param[1] === param$1[1]);
  } else {
    return /* false */0;
  }
}

function hash$1(param) {
  return param[0][/* id */2] + Caml_int32.imul(93, param[1][/* id */2]) | 0;
}

var TypePairs = Hashtbl.Make(/* module */[
      /* equal */equal$3,
      /* hash */hash$1
    ]);

var umode = [/* Expression */0];

var generate_equations = [/* false */0];

var assume_injective = [/* false */0];

function set_mode_pattern(generate, injective, f) {
  var old_unification_mode = umode[0];
  var old_gen = generate_equations[0];
  var old_inj = assume_injective[0];
  try {
    umode[0] = /* Pattern */1;
    generate_equations[0] = generate;
    assume_injective[0] = injective;
    var ret = Curry._1(f, /* () */0);
    umode[0] = old_unification_mode;
    generate_equations[0] = old_gen;
    assume_injective[0] = old_inj;
    return ret;
  }
  catch (e){
    umode[0] = old_unification_mode;
    generate_equations[0] = old_gen;
    assume_injective[0] = old_inj;
    throw e;
  }
}

function in_current_module(param) {
  switch (param.tag | 0) {
    case 0 : 
        return /* true */1;
    case 1 : 
    case 2 : 
        return /* false */0;
    
  }
}

function in_pervasives(p) {
  if (in_current_module(p)) {
    try {
      find_type_full(p, initial_safe_string)[0];
      return /* true */1;
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        return /* false */0;
      } else {
        throw exn;
      }
    }
  } else {
    return /* false */0;
  }
}

function is_datatype(decl) {
  var match = decl[/* type_kind */2];
  if (typeof match === "number" && match === 0) {
    return /* false */0;
  } else {
    return /* true */1;
  }
}

function object_fields(ty) {
  var match = repr(ty)[/* desc */0];
  if (typeof match === "number") {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "ctype.ml",
            284,
            27
          ]
        ];
  } else if (match.tag === 4) {
    return match[0];
  } else {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "ctype.ml",
            284,
            27
          ]
        ];
  }
}

function flatten_fields(ty) {
  var flatten = function (_l, _ty) {
    while(true) {
      var ty = _ty;
      var l = _l;
      var ty$1 = repr(ty);
      var match = ty$1[/* desc */0];
      if (typeof match === "number") {
        return /* tuple */[
                l,
                ty$1
              ];
      } else if (match.tag === 5) {
        _ty = match[3];
        _l = /* :: */[
          /* tuple */[
            match[0],
            match[1],
            match[2]
          ],
          l
        ];
        continue ;
        
      } else {
        return /* tuple */[
                l,
                ty$1
              ];
      }
    };
  };
  var match = flatten(/* [] */0, ty);
  return /* tuple */[
          List.sort((function (param, param$1) {
                  return Caml_string.caml_string_compare(param[0], param$1[0]);
                }), match[0]),
          match[1]
        ];
}

function build_fields(level) {
  return (function (param, param$1) {
      return List.fold_right((function (param, ty2) {
                    return newty2(level, /* Tfield */Block.__(5, [
                                  param[0],
                                  param[1],
                                  param[2],
                                  ty2
                                ]));
                  }), param, param$1);
    });
}

function associate_fields(fields1, fields2) {
  var _p = /* [] */0;
  var _s = /* [] */0;
  var _s$prime = /* [] */0;
  var _param = /* tuple */[
    fields1,
    fields2
  ];
  while(true) {
    var param = _param;
    var s$prime = _s$prime;
    var s = _s;
    var p = _p;
    var l = param[0];
    if (param[1]) {
      if (l) {
        var l$prime = param[1];
        var r$prime = l$prime[1];
        var match = l$prime[0];
        var t$prime = match[2];
        var k$prime = match[1];
        var n$prime = match[0];
        var r = l[1];
        var match$1 = l[0];
        var t = match$1[2];
        var k = match$1[1];
        var n = match$1[0];
        if (Caml_obj.caml_equal(n, n$prime)) {
          _param = /* tuple */[
            r,
            r$prime
          ];
          _p = /* :: */[
            /* tuple */[
              n,
              k,
              t,
              k$prime,
              t$prime
            ],
            p
          ];
          continue ;
          
        } else if (Caml_obj.caml_lessthan(n, n$prime)) {
          _param = /* tuple */[
            r,
            l$prime
          ];
          _s = /* :: */[
            /* tuple */[
              n,
              k,
              t
            ],
            s
          ];
          continue ;
          
        } else {
          _param = /* tuple */[
            l,
            r$prime
          ];
          _s$prime = /* :: */[
            /* tuple */[
              n$prime,
              k$prime,
              t$prime
            ],
            s$prime
          ];
          continue ;
          
        }
      } else {
        return /* tuple */[
                List.rev(p),
                List.rev(s),
                Pervasives.$at(List.rev(s$prime), param[1])
              ];
      }
    } else {
      return /* tuple */[
              List.rev(p),
              Pervasives.$at(List.rev(s), l),
              List.rev(s$prime)
            ];
    }
  };
}

function object_row(_ty) {
  while(true) {
    var ty = _ty;
    var ty$1 = repr(ty);
    var match = ty$1[/* desc */0];
    if (typeof match === "number") {
      return ty$1;
    } else {
      switch (match.tag | 0) {
        case 4 : 
            _ty = match[0];
            continue ;
            case 5 : 
            _ty = match[3];
            continue ;
            default:
          return ty$1;
      }
    }
  };
}

function opened_object(ty) {
  var match = object_row(ty)[/* desc */0];
  if (typeof match === "number") {
    return /* false */0;
  } else {
    switch (match.tag | 0) {
      case 0 : 
      case 3 : 
      case 9 : 
          return /* true */1;
      default:
        return /* false */0;
    }
  }
}

function concrete_object(ty) {
  var match = object_row(ty)[/* desc */0];
  if (typeof match === "number" || match.tag) {
    return /* true */1;
  } else {
    return /* false */0;
  }
}

function close_object(ty) {
  var match = repr(ty)[/* desc */0];
  if (typeof match === "number") {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "ctype.ml",
            351,
            25
          ]
        ];
  } else if (match.tag === 4) {
    var _ty = match[0];
    while(true) {
      var ty$1 = _ty;
      var ty$2 = repr(ty$1);
      var match$1 = ty$2[/* desc */0];
      if (typeof match$1 === "number") {
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "ctype.ml",
                347,
                30
              ]
            ];
      } else {
        switch (match$1.tag | 0) {
          case 0 : 
              return link_type(ty$2, newty2(ty$2[/* level */1], /* Tnil */0));
          case 5 : 
              _ty = match$1[3];
              continue ;
              default:
            throw [
                  Caml_builtin_exceptions.assert_failure,
                  [
                    "ctype.ml",
                    347,
                    30
                  ]
                ];
        }
      }
    };
  } else {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "ctype.ml",
            351,
            25
          ]
        ];
  }
}

function row_variable(ty) {
  var match = repr(ty)[/* desc */0];
  if (typeof match === "number") {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "ctype.ml",
            365,
            23
          ]
        ];
  } else if (match.tag === 4) {
    var _ty = match[0];
    while(true) {
      var ty$1 = _ty;
      var ty$2 = repr(ty$1);
      var match$1 = ty$2[/* desc */0];
      if (typeof match$1 === "number") {
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "ctype.ml",
                361,
                30
              ]
            ];
      } else {
        switch (match$1.tag | 0) {
          case 0 : 
              return ty$2;
          case 5 : 
              _ty = match$1[3];
              continue ;
              default:
            throw [
                  Caml_builtin_exceptions.assert_failure,
                  [
                    "ctype.ml",
                    361,
                    30
                  ]
                ];
        }
      }
    };
  } else {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "ctype.ml",
            365,
            23
          ]
        ];
  }
}

function set_object_name(id, rv, params, ty) {
  var match = repr(ty)[/* desc */0];
  if (typeof match === "number") {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "ctype.ml",
            375,
            6
          ]
        ];
  } else if (match.tag === 4) {
    return set_name(match[1], /* Some */[/* tuple */[
                  /* Pident */Block.__(0, [id]),
                  /* :: */[
                    rv,
                    params
                  ]
                ]]);
  } else {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "ctype.ml",
            375,
            6
          ]
        ];
  }
}

function hide_private_methods(ty) {
  var match = repr(ty)[/* desc */0];
  if (typeof match === "number") {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "ctype.ml",
            397,
            6
          ]
        ];
  } else if (match.tag === 4) {
    match[1][0] = /* None */0;
    var match$1 = flatten_fields(match[0]);
    return List.iter((function (param) {
                  var match = field_kind_repr(param[1]);
                  if (typeof match === "number") {
                    return /* () */0;
                  } else {
                    return set_kind(match[0], /* Fabsent */1);
                  }
                }), match$1[0]);
  } else {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "ctype.ml",
            397,
            6
          ]
        ];
  }
}

function signature_of_class_type(_param) {
  while(true) {
    var param = _param;
    switch (param.tag | 0) {
      case 1 : 
          return param[0];
      case 0 : 
      case 2 : 
          _param = param[2];
          continue ;
          
    }
  };
}

function class_type_arity(_param) {
  while(true) {
    var param = _param;
    switch (param.tag | 0) {
      case 0 : 
          _param = param[2];
          continue ;
          case 1 : 
          return 0;
      case 2 : 
          return 1 + class_type_arity(param[2]) | 0;
      
    }
  };
}

function sort_row_fields(param) {
  return List.sort((function (param, param$1) {
                return Caml_string.caml_string_compare(param[0], param$1[0]);
              }), param);
}

function merge_row_fields(fi1, fi2) {
  var exit = 0;
  var exit$1 = 0;
  if (fi1) {
    if (fi2) {
      if (fi1[1]) {
        exit$1 = 2;
      } else if (List.mem_assoc(fi1[0][0], fi2)) {
        exit$1 = 2;
      } else {
        return /* tuple */[
                fi1,
                fi2,
                /* [] */0
              ];
      }
    } else {
      return /* tuple */[
              fi1,
              fi2,
              /* [] */0
            ];
    }
  } else {
    return /* tuple */[
            fi1,
            fi2,
            /* [] */0
          ];
  }
  if (exit$1 === 2) {
    if (fi2[1]) {
      exit = 1;
    } else if (List.mem_assoc(fi2[0][0], fi1)) {
      exit = 1;
    } else {
      return /* tuple */[
              fi1,
              fi2,
              /* [] */0
            ];
    }
  }
  if (exit === 1) {
    var _r1 = /* [] */0;
    var _r2 = /* [] */0;
    var _pairs = /* [] */0;
    var _fi1 = sort_row_fields(fi1);
    var _fi2 = sort_row_fields(fi2);
    while(true) {
      var fi2$1 = _fi2;
      var fi1$1 = _fi1;
      var pairs = _pairs;
      var r2 = _r2;
      var r1 = _r1;
      if (fi1$1) {
        if (fi2$1) {
          var fi2$prime = fi2$1[1];
          var p2 = fi2$1[0];
          var l2 = p2[0];
          var fi1$prime = fi1$1[1];
          var p1 = fi1$1[0];
          var l1 = p1[0];
          if (Caml_obj.caml_equal(l1, l2)) {
            _fi2 = fi2$prime;
            _fi1 = fi1$prime;
            _pairs = /* :: */[
              /* tuple */[
                l1,
                p1[1],
                p2[1]
              ],
              pairs
            ];
            continue ;
            
          } else if (Caml_obj.caml_lessthan(l1, l2)) {
            _fi1 = fi1$prime;
            _r1 = /* :: */[
              p1,
              r1
            ];
            continue ;
            
          } else {
            _fi2 = fi2$prime;
            _r2 = /* :: */[
              p2,
              r2
            ];
            continue ;
            
          }
        } else {
          return /* tuple */[
                  List.rev_append(r1, fi1$1),
                  List.rev(r2),
                  pairs
                ];
        }
      } else {
        return /* tuple */[
                List.rev(r1),
                List.rev_append(r2, fi2$1),
                pairs
              ];
      }
    };
  }
  
}

function filter_row_fields(erase, param) {
  if (param) {
    var p = param[0];
    var fi = filter_row_fields(erase, param[1]);
    var match = row_field_repr_aux(/* [] */0, p[1]);
    if (typeof match === "number") {
      return fi;
    } else if (match.tag) {
      if (match[2] !== 0) {
        return /* :: */[
                p,
                fi
              ];
      } else if (erase) {
        set_row_field(match[3], /* Rabsent */0);
        return fi;
      } else {
        return /* :: */[
                p,
                fi
              ];
      }
    } else {
      return /* :: */[
              p,
              fi
            ];
    }
  } else {
    return /* [] */0;
  }
}

var Non_closed0 = Caml_exceptions.create("Ocaml_typedtree_test.Ctype.Non_closed0");

function closed_schema_rec(_ty) {
  while(true) {
    var ty = _ty;
    var ty$1 = repr(ty);
    if (ty$1[/* level */1] >= 0) {
      var level = ty$1[/* level */1];
      ty$1[/* level */1] = pivot_level - level | 0;
      var match = ty$1[/* desc */0];
      if (typeof match === "number") {
        return iter_type_expr(closed_schema_rec, ty$1);
      } else {
        switch (match.tag | 0) {
          case 0 : 
              if (level !== 100000000) {
                throw Non_closed0;
              } else {
                return iter_type_expr(closed_schema_rec, ty$1);
              }
              break;
          case 5 : 
              if (!field_kind_repr(match[1])) {
                closed_schema_rec(match[2]);
              }
              _ty = match[3];
              continue ;
              case 8 : 
              var row = row_repr_aux(/* [] */0, match[0]);
              iter_row(closed_schema_rec, row);
              if (static_row(row)) {
                return 0;
              } else {
                _ty = row[/* row_more */1];
                continue ;
                
              }
              break;
          default:
            return iter_type_expr(closed_schema_rec, ty$1);
        }
      }
    } else {
      return 0;
    }
  };
}

function closed_schema(ty) {
  try {
    closed_schema_rec(ty);
    unmark_type(ty);
    return /* true */1;
  }
  catch (exn){
    if (exn === Non_closed0) {
      unmark_type(ty);
      return /* false */0;
    } else {
      throw exn;
    }
  }
}

var Non_closed = Caml_exceptions.create("Ocaml_typedtree_test.Ctype.Non_closed");

var free_variables = [/* [] */0];

var really_closed = [/* None */0];

function free_vars_rec(_real, _ty) {
  while(true) {
    var ty = _ty;
    var real = _real;
    var ty$1 = repr(ty);
    if (ty$1[/* level */1] >= 0) {
      ty$1[/* level */1] = pivot_level - ty$1[/* level */1] | 0;
      var match = ty$1[/* desc */0];
      var match$1 = really_closed[0];
      var exit = 0;
      if (typeof match === "number") {
        exit = 1;
      } else {
        switch (match.tag | 0) {
          case 0 : 
              free_variables[0] = /* :: */[
                /* tuple */[
                  ty$1,
                  real
                ],
                free_variables[0]
              ];
              return /* () */0;
          case 3 : 
              if (match$1) {
                try {
                  var match$2 = find_type_expansion(match[0], match$1[0]);
                  if (repr(match$2[1])[/* level */1] !== 100000000) {
                    free_variables[0] = /* :: */[
                      /* tuple */[
                        ty$1,
                        real
                      ],
                      free_variables[0]
                    ];
                  }
                  
                }
                catch (exn){
                  if (exn !== Caml_builtin_exceptions.not_found) {
                    throw exn;
                  }
                  
                }
                return List.iter((function (param) {
                              return free_vars_rec(/* true */1, param);
                            }), match[1]);
              } else {
                exit = 1;
              }
              break;
          case 4 : 
              _ty = match[0];
              _real = /* false */0;
              continue ;
              case 5 : 
              free_vars_rec(/* true */1, match[2]);
              _ty = match[3];
              _real = /* false */0;
              continue ;
              case 8 : 
              var row = row_repr_aux(/* [] */0, match[0]);
              iter_row((function (param) {
                      return free_vars_rec(/* true */1, param);
                    }), row);
              if (static_row(row)) {
                return 0;
              } else {
                _ty = row[/* row_more */1];
                _real = /* false */0;
                continue ;
                
              }
              break;
          default:
            exit = 1;
        }
      }
      if (exit === 1) {
        return iter_type_expr((function (param) {
                      return free_vars_rec(/* true */1, param);
                    }), ty$1);
      }
      
    } else {
      return 0;
    }
  };
}

function free_vars$1(env, ty) {
  free_variables[0] = /* [] */0;
  really_closed[0] = env;
  free_vars_rec(/* true */1, ty);
  var res = free_variables[0];
  free_variables[0] = /* [] */0;
  really_closed[0] = /* None */0;
  return res;
}

function free_variables$1(env, ty) {
  var tl = List.map((function (prim) {
          return prim[0];
        }), free_vars$1(env, ty));
  unmark_type(ty);
  return tl;
}

function closed_type(ty) {
  var match = free_vars$1(/* None */0, ty);
  if (match) {
    var match$1 = match[0];
    throw [
          Non_closed,
          match$1[0],
          match$1[1]
        ];
  } else {
    return /* () */0;
  }
}

function closed_parameterized_type(params, ty) {
  List.iter(mark_type, params);
  var ok;
  try {
    closed_type(ty);
    ok = /* true */1;
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === Non_closed) {
      ok = /* false */0;
    } else {
      throw exn;
    }
  }
  List.iter(unmark_type, params);
  unmark_type(ty);
  return ok;
}

function closed_type_decl(decl) {
  try {
    List.iter(mark_type, decl[/* type_params */0]);
    var match = decl[/* type_kind */2];
    if (typeof match === "number") {
      +(match === 0);
    } else if (match.tag) {
      List.iter((function (param) {
              if (param[/* cd_res */2]) {
                return /* () */0;
              } else {
                return List.iter(closed_type, param[/* cd_args */1]);
              }
            }), match[0]);
    } else {
      List.iter((function (l) {
              return closed_type(l[/* ld_type */2]);
            }), match[0]);
    }
    var match$1 = decl[/* type_manifest */4];
    if (match$1) {
      closed_type(match$1[0]);
    }
    Curry._2(newrecord$1[/* it_type_declaration */3], newrecord$1, decl);
    return /* None */0;
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === Non_closed) {
      Curry._2(newrecord$1[/* it_type_declaration */3], newrecord$1, decl);
      return /* Some */[exn[1]];
    } else {
      throw exn;
    }
  }
}

function closed_extension_constructor(ext) {
  try {
    List.iter(mark_type, ext[/* ext_type_params */1]);
    var match = ext[/* ext_ret_type */3];
    if (!match) {
      List.iter(closed_type, ext[/* ext_args */2]);
    }
    unmark_extension_constructor(ext);
    return /* None */0;
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === Non_closed) {
      unmark_extension_constructor(ext);
      return /* Some */[exn[1]];
    } else {
      throw exn;
    }
  }
}

var CCFailure = Caml_exceptions.create("Ocaml_typedtree_test.Ctype.CCFailure");

function closed_class(params, sign) {
  var ty = object_fields(repr(sign[/* csig_self */0]));
  var match = flatten_fields(ty);
  var fields = match[0];
  List.iter(mark_type, params);
  mark_type(match[1]);
  List.iter((function (param) {
          if (param[0] === dummy_method) {
            return mark_type(param[2]);
          } else {
            return 0;
          }
        }), fields);
  try {
    mark_type_node(repr(sign[/* csig_self */0]));
    List.iter((function (param) {
            var ty = param[2];
            if (field_kind_repr(param[1])) {
              return 0;
            } else {
              try {
                return closed_type(ty);
              }
              catch (raw_exn){
                var exn = Js_exn.internalToOCamlException(raw_exn);
                if (exn[0] === Non_closed) {
                  throw [
                        CCFailure,
                        /* CC_Method */Block.__(0, [
                            exn[1],
                            exn[2],
                            param[0],
                            ty
                          ])
                      ];
                } else {
                  throw exn;
                }
              }
            }
          }), fields);
    iter_type_expr(mark_type, repr(sign[/* csig_self */0]));
    List.iter(unmark_type, params);
    unmark_class_signature(sign);
    return /* None */0;
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === CCFailure) {
      iter_type_expr(mark_type, repr(sign[/* csig_self */0]));
      List.iter(unmark_type, params);
      unmark_class_signature(sign);
      return /* Some */[exn[1]];
    } else {
      throw exn;
    }
  }
}

function duplicate_type(ty) {
  return type_expr(identity, ty);
}

function duplicate_class_type(ty) {
  var s = identity;
  var cty = ty;
  var cty$1 = class_type(s, cty);
  cleanup_types(/* () */0);
  return cty$1;
}

function iter_generalize(tyl, ty) {
  var ty$1 = repr(ty);
  if (ty$1[/* level */1] > current_level[0] && ty$1[/* level */1] !== 100000000) {
    set_level(ty$1, 100000000);
    var match = ty$1[/* desc */0];
    if (typeof match !== "number") {
      if (match.tag === 3) {
        iter_abbrev((function (param) {
                return iter_generalize(tyl, param);
              }), match[2][0]);
      }
      
    }
    return iter_type_expr((function (param) {
                  return iter_generalize(tyl, param);
                }), ty$1);
  } else {
    tyl[0] = /* :: */[
      ty$1,
      tyl[0]
    ];
    return /* () */0;
  }
}

function iter_generalize$1(tyl, ty) {
  simple_abbrevs[0] = /* Mnil */0;
  return iter_generalize(tyl, ty);
}

function generalize(ty) {
  return iter_generalize$1([/* [] */0], ty);
}

function generalize_structure(var_level, ty) {
  var ty$1 = repr(ty);
  if (ty$1[/* level */1] !== 100000000) {
    if (is_Tvar(ty$1) && ty$1[/* level */1] > var_level) {
      return set_level(ty$1, var_level);
    } else {
      var match = ty$1[/* desc */0];
      var $js;
      $js = typeof match === "number" || match.tag !== 3 ? /* true */1 : 1 - is_object_type(match[0]) && (match[2][0] = /* Mnil */0, /* true */1);
      if (ty$1[/* level */1] > current_level[0] && $js) {
        set_level(ty$1, 100000000);
        return iter_type_expr((function (param) {
                      return generalize_structure(var_level, param);
                    }), ty$1);
      } else {
        return 0;
      }
    }
  } else {
    return 0;
  }
}

function generalize_structure$1(var_level, ty) {
  simple_abbrevs[0] = /* Mnil */0;
  return generalize_structure(var_level, ty);
}

function generalize_spine(_ty) {
  while(true) {
    var ty = _ty;
    var ty$1 = repr(ty);
    if (ty$1[/* level */1] < current_level[0] || ty$1[/* level */1] === 100000000) {
      return /* () */0;
    } else {
      var match = ty$1[/* desc */0];
      if (typeof match === "number") {
        return /* () */0;
      } else {
        switch (match.tag | 0) {
          case 1 : 
              set_level(ty$1, 100000000);
              generalize_spine(match[1]);
              _ty = match[2];
              continue ;
              case 2 : 
              set_level(ty$1, 100000000);
              return List.iter(generalize_spine, match[0]);
          case 3 : 
              if (is_object_type(match[0])) {
                return /* () */0;
              } else {
                set_level(ty$1, 100000000);
                match[2][0] = /* Mnil */0;
                return List.iter(generalize_spine, match[1]);
              }
          case 10 : 
              set_level(ty$1, 100000000);
              _ty = match[0];
              continue ;
              case 11 : 
              set_level(ty$1, 100000000);
              return List.iter(generalize_spine, match[2]);
          default:
            return /* () */0;
        }
      }
    }
  };
}

var forward_try_expand_once = [(function (_, _$1) {
      throw Cannot_expand;
    })];

function get_level(env, p) {
  try {
    var match = find_type_full(p, env)[0][/* type_newtype_level */6];
    if (match) {
      return match[0][0];
    } else {
      return binding_time(p);
    }
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return binding_time(p);
    } else {
      throw exn;
    }
  }
}

function normalize_package_path(env, _p) {
  while(true) {
    var p = _p;
    var t;
    try {
      t = find_modtype(p, env)[/* mtd_type */0];
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        t = /* None */0;
      } else {
        throw exn;
      }
    }
    if (t) {
      var match = t[0];
      if (match.tag) {
        return p;
      } else {
        _p = match[0];
        continue ;
        
      }
    } else {
      return p;
    }
  };
}

function update_level(env, level, _ty) {
  while(true) {
    var ty = _ty;
    var ty$1 = repr(ty);
    if (ty$1[/* level */1] > level) {
      var match = gadt_instance_level(env, ty$1);
      if (match) {
        if (level < match[0]) {
          throw [
                Unify,
                /* :: */[
                  /* tuple */[
                    ty$1,
                    newty2(level, /* Tvar */Block.__(0, [/* None */0]))
                  ],
                  /* [] */0
                ]
              ];
        }
        
      }
      var match$1 = ty$1[/* desc */0];
      var exit = 0;
      if (typeof match$1 === "number") {
        exit = 1;
      } else {
        switch (match$1.tag | 0) {
          case 3 : 
              var p = match$1[0];
              if (level < get_level(env, p)) {
                try {
                  link_type(ty$1, Curry._2(forward_try_expand_once[0], env, ty$1));
                  return update_level(env, level, ty$1);
                }
                catch (exn){
                  if (exn === Cannot_expand) {
                    if (level < get_level(env, p)) {
                      throw [
                            Unify,
                            /* :: */[
                              /* tuple */[
                                ty$1,
                                newty2(level, /* Tvar */Block.__(0, [/* None */0]))
                              ],
                              /* [] */0
                            ]
                          ];
                    }
                    return iter_type_expr((function (param) {
                                  return update_level(env, level, param);
                                }), ty$1);
                  } else {
                    throw exn;
                  }
                }
              } else {
                exit = 1;
              }
              break;
          case 4 : 
              var nm = match$1[1];
              var match$2 = nm[/* contents */0];
              if (match$2) {
                if (level < get_level(env, match$2[0][0])) {
                  set_name(nm, /* None */0);
                  _ty = ty$1;
                  continue ;
                  
                } else {
                  exit = 1;
                }
              } else {
                exit = 1;
              }
              break;
          case 5 : 
              var ty1 = match$1[2];
              if (match$1[0] === dummy_method && repr(ty1)[/* level */1] > level) {
                throw [
                      Unify,
                      /* :: */[
                        /* tuple */[
                          ty1,
                          newty2(level, /* Tvar */Block.__(0, [/* None */0]))
                        ],
                        /* [] */0
                      ]
                    ];
              } else {
                exit = 1;
              }
              break;
          case 8 : 
              var row = row_repr_aux(/* [] */0, match$1[0]);
              var match$3 = row[/* row_name */5];
              if (match$3) {
                if (level < get_level(env, match$3[0][0])) {
                  log_type(ty$1);
                  var newrecord = row.slice();
                  ty$1[/* desc */0] = /* Tvariant */Block.__(8, [(newrecord[/* row_name */5] = /* None */0, newrecord)]);
                }
                
              }
              set_level(ty$1, level);
              return iter_type_expr((function (param) {
                            return update_level(env, level, param);
                          }), ty$1);
          case 11 : 
              var p$1 = match$1[0];
              if (level < get_level(env, p$1)) {
                var p$prime = normalize_package_path(env, p$1);
                if (same(p$1, p$prime)) {
                  throw [
                        Unify,
                        /* :: */[
                          /* tuple */[
                            ty$1,
                            newty2(level, /* Tvar */Block.__(0, [/* None */0]))
                          ],
                          /* [] */0
                        ]
                      ];
                }
                log_type(ty$1);
                ty$1[/* desc */0] = /* Tpackage */Block.__(11, [
                    p$prime,
                    match$1[1],
                    match$1[2]
                  ]);
                _ty = ty$1;
                continue ;
                
              } else {
                exit = 1;
              }
              break;
          default:
            exit = 1;
        }
      }
      if (exit === 1) {
        set_level(ty$1, level);
        return iter_type_expr((function (param) {
                      return update_level(env, level, param);
                    }), ty$1);
      }
      
    } else {
      return 0;
    }
  };
}

function generalize_contravariant(env) {
  if (principal[0]) {
    return generalize_structure$1;
  } else {
    return (function (param, param$1) {
        return update_level(env, param, param$1);
      });
  }
}

function generalize_expansive(env, var_level, _ty) {
  while(true) {
    var ty = _ty;
    var ty$1 = repr(ty);
    if (ty$1[/* level */1] !== 100000000) {
      if (ty$1[/* level */1] > var_level) {
        set_level(ty$1, 100000000);
        var match = ty$1[/* desc */0];
        if (typeof match === "number") {
          return iter_type_expr((function (param) {
                        return generalize_expansive(env, var_level, param);
                      }), ty$1);
        } else {
          switch (match.tag | 0) {
            case 1 : 
                Curry._2(generalize_contravariant(env), var_level, match[1]);
                _ty = match[2];
                continue ;
                case 3 : 
                var tyl = match[1];
                var variance;
                try {
                  variance = find_type_full(match[0], env)[0][/* type_variance */5];
                }
                catch (exn){
                  if (exn === Caml_builtin_exceptions.not_found) {
                    variance = List.map((function () {
                            return Types_003[/* may_inv */3];
                          }), tyl);
                  } else {
                    throw exn;
                  }
                }
                match[2][0] = /* Mnil */0;
                return List.iter2((function (v, t) {
                              if (Curry._2(Types_003[/* mem */8], /* May_weak */2, v)) {
                                return Curry._2(generalize_contravariant(env), var_level, t);
                              } else {
                                return generalize_expansive(env, var_level, t);
                              }
                            }), variance, tyl);
            case 11 : 
                return List.iter(Curry._1(generalize_contravariant(env), var_level), match[2]);
            default:
              return iter_type_expr((function (param) {
                            return generalize_expansive(env, var_level, param);
                          }), ty$1);
          }
        }
      } else {
        return 0;
      }
    } else {
      return 0;
    }
  };
}

function generalize_expansive$1(env, ty) {
  simple_abbrevs[0] = /* Mnil */0;
  try {
    return generalize_expansive(env, nongen_level[0], ty);
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === Unify) {
      var tr = exn[1];
      if (tr) {
        if (tr[1]) {
          throw exn;
        } else {
          throw [
                Unify,
                /* :: */[
                  /* tuple */[
                    ty,
                    tr[0][1]
                  ],
                  tr
                ]
              ];
        }
      } else {
        throw exn;
      }
    } else {
      throw exn;
    }
  }
}

function generalize_structure$2(ty) {
  return generalize_structure$1(current_level[0], ty);
}

function limited_generalize(ty0, ty) {
  var ty0$1 = repr(ty0);
  var graph = Hashtbl.create(/* None */0, 17);
  var idx = [0];
  var roots = [/* [] */0];
  var inverse = function (pty, ty) {
    var ty$1 = repr(ty);
    if (ty$1[/* level */1] > current_level[0] || ty$1[/* level */1] === 100000000) {
      idx[0] = idx[0] - 1 | 0;
      Hashtbl.add(graph, idx[0], /* tuple */[
            ty$1,
            [pty]
          ]);
      if (ty$1[/* level */1] === 100000000 || ty$1 === ty0$1) {
        roots[0] = /* :: */[
          ty$1,
          roots[0]
        ];
      }
      set_level(ty$1, idx[0]);
      var partial_arg = /* :: */[
        ty$1,
        /* [] */0
      ];
      return iter_type_expr((function (param) {
                    return inverse(partial_arg, param);
                  }), ty$1);
    } else if (ty$1[/* level */1] < 0) {
      var match = Hashtbl.find(graph, ty$1[/* level */1]);
      var parents = match[1];
      parents[0] = Pervasives.$at(pty, parents[0]);
      return /* () */0;
    } else {
      return 0;
    }
  };
  var generalize_parents = function (ty) {
    var idx = ty[/* level */1];
    if (idx !== 100000000) {
      set_level(ty, 100000000);
      List.iter(generalize_parents, Hashtbl.find(graph, idx)[1][0]);
      var match = ty[/* desc */0];
      if (typeof match === "number") {
        return /* () */0;
      } else if (match.tag === 8) {
        var more = row_more(match[0]);
        var lv = more[/* level */1];
        if ((lv < 0 || lv > current_level[0]) && lv !== 100000000) {
          return set_level(more, 100000000);
        } else {
          return 0;
        }
      } else {
        return /* () */0;
      }
    } else {
      return 0;
    }
  };
  inverse(/* [] */0, ty);
  if (ty0$1[/* level */1] < 0) {
    iter_type_expr((function (param) {
            return inverse(/* [] */0, param);
          }), ty0$1);
  }
  List.iter(generalize_parents, roots[0]);
  return Hashtbl.iter((function (_, param) {
                var ty = param[0];
                if (ty[/* level */1] !== 100000000) {
                  return set_level(ty, current_level[0]);
                } else {
                  return 0;
                }
              }), graph);
}

function inv_type(hash, pty, ty) {
  var ty$1 = repr(ty);
  try {
    var inv = Curry._2(TypeHash[/* find */6], hash, ty$1);
    inv[/* inv_parents */1] = Pervasives.$at(pty, inv[/* inv_parents */1]);
    return /* () */0;
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      var inv$1 = /* record */[
        /* inv_type */ty$1,
        /* inv_parents */pty
      ];
      Curry._3(TypeHash[/* add */4], hash, ty$1, inv$1);
      var partial_arg = /* :: */[
        inv$1,
        /* [] */0
      ];
      return iter_type_expr((function (param) {
                    return inv_type(hash, partial_arg, param);
                  }), ty$1);
    } else {
      throw exn;
    }
  }
}

function compute_univars(ty) {
  var inverted = Curry._1(TypeHash[/* create */0], 17);
  inv_type(inverted, /* [] */0, ty);
  var node_univars = Curry._1(TypeHash[/* create */0], 17);
  var add_univar = function (univ, inv) {
    var match = inv[/* inv_type */0][/* desc */0];
    var exit = 0;
    if (typeof match === "number") {
      exit = 1;
    } else if (match.tag === 10) {
      if (List.memq(univ, List.map(repr, match[1]))) {
        return /* () */0;
      } else {
        exit = 1;
      }
    } else {
      exit = 1;
    }
    if (exit === 1) {
      try {
        var univs = Curry._2(TypeHash[/* find */6], node_univars, inv[/* inv_type */0]);
        if (mem$3(univ, univs[0])) {
          return 0;
        } else {
          univs[0] = add$3(univ, univs[0]);
          return List.iter((function (param) {
                        return add_univar(univ, param);
                      }), inv[/* inv_parents */1]);
        }
      }
      catch (exn){
        if (exn === Caml_builtin_exceptions.not_found) {
          Curry._3(TypeHash[/* add */4], node_univars, inv[/* inv_type */0], [singleton$1(univ)]);
          return List.iter((function (param) {
                        return add_univar(univ, param);
                      }), inv[/* inv_parents */1]);
        } else {
          throw exn;
        }
      }
    }
    
  };
  Curry._2(TypeHash[/* iter */10], (function (ty, inv) {
          if (is_Tunivar(ty)) {
            return add_univar(ty, inv);
          } else {
            return 0;
          }
        }), inverted);
  return (function (ty) {
      try {
        return Curry._2(TypeHash[/* find */6], node_univars, ty)[0];
      }
      catch (exn){
        if (exn === Caml_builtin_exceptions.not_found) {
          return /* Empty */0;
        } else {
          throw exn;
        }
      }
    });
}

function find_repr(p1, _param) {
  while(true) {
    var param = _param;
    if (typeof param === "number") {
      return /* None */0;
    } else if (param.tag) {
      var rem = param[0][/* contents */0];
      _param = rem;
      continue ;
      
    } else if (param[0] !== 0) {
      if (same(p1, param[1])) {
        return /* Some */[param[2]];
      } else {
        _param = param[4];
        continue ;
        
      }
    } else {
      _param = param[4];
      continue ;
      
    }
  };
}

var abbreviations = [[/* Mnil */0]];

function copy(env, partial, keep_names, ty) {
  var copy$1 = function (param) {
    return copy(env, partial, keep_names, param);
  };
  var ty$1 = repr(ty);
  var match = ty$1[/* desc */0];
  var exit = 0;
  if (typeof match === "number") {
    exit = 1;
  } else if (match.tag === 7) {
    return match[0];
  } else {
    exit = 1;
  }
  if (exit === 1) {
    if (ty$1[/* level */1] !== 100000000 && partial === /* None */0) {
      return ty$1;
    } else {
      var forget;
      if (ty$1[/* level */1] === 100000000) {
        forget = 100000000;
      } else if (partial) {
        var match$1 = partial[0];
        var param = Curry._1(match$1[0], ty$1);
        forget = (
          param ? /* false */0 : /* true */1
        ) ? (
            match$1[1] ? ty$1[/* level */1] : current_level[0]
          ) : 100000000;
      } else {
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "ctype.ml",
                984,
                16
              ]
            ];
      }
      if (forget !== 100000000) {
        return newty2(forget, /* Tvar */Block.__(0, [/* None */0]));
      } else {
        var desc = ty$1[/* desc */0];
        save_desc(ty$1, desc);
        var t = newvar(/* None */0, /* () */0);
        if (env) {
          var env$1 = env[0];
          if (env$1[/* local_constraints */11]) {
            var match$2 = gadt_instance_level(env$1, ty$1);
            if (match$2) {
              add_gadt_instances(env$1, match$2[0], /* :: */[
                    t,
                    /* [] */0
                  ]);
            }
            
          }
          
        }
        ty$1[/* desc */0] = /* Tsubst */Block.__(7, [t]);
        var $js;
        if (typeof desc === "number") {
          $js = copy_type_desc(keep_names, copy$1, desc);
        } else {
          switch (desc.tag | 0) {
            case 3 : 
                var tl = desc[1];
                var p = desc[0];
                var abbrevs = proper_abbrevs(p, tl, abbreviations[0]);
                var match$3 = find_repr(p, abbrevs[0]);
                var exit$1 = 0;
                if (match$3) {
                  var ty$2 = match$3[0];
                  if (repr(ty$2) !== t) {
                    $js = /* Tlink */Block.__(6, [ty$2]);
                  } else {
                    exit$1 = 2;
                  }
                } else {
                  exit$1 = 2;
                }
                if (exit$1 === 2) {
                  var abbrev = abbreviations[0][0];
                  var $js$1;
                  $js$1 = typeof abbrev === "number" || abbrev.tag ? abbrev : /* Mlink */Block.__(1, [abbreviations[0]]);
                  $js = /* Tconstr */Block.__(3, [
                      p,
                      List.map(copy$1, tl),
                      [$js$1]
                    ]);
                }
                break;
            case 4 : 
                $js = partial !== /* None */0 ? /* Tobject */Block.__(4, [
                      copy$1(desc[0]),
                      [/* None */0]
                    ]) : copy_type_desc(keep_names, copy$1, desc);
                break;
            case 5 : 
                var match$4 = field_kind_repr(desc[1]);
                if (typeof match$4 === "number") {
                  $js = match$4 !== 0 ? /* Tlink */Block.__(6, [copy$1(desc[3])]) : copy_type_desc(/* None */0, copy$1, desc);
                } else {
                  dup_kind(match$4[0]);
                  $js = copy_type_desc(/* None */0, copy$1, desc);
                }
                break;
            case 8 : 
                var row = row_repr_aux(/* [] */0, desc[0]);
                var more = repr(row[/* row_more */1]);
                var match$5 = more[/* desc */0];
                var exit$2 = 0;
                if (typeof match$5 === "number") {
                  exit$2 = 2;
                } else if (match$5.tag === 7) {
                  var match$6 = match$5[0][/* desc */0];
                  if (typeof match$6 === "number") {
                    exit$2 = 2;
                  } else if (match$6.tag === 2) {
                    var match$7 = match$6[0];
                    if (match$7) {
                      var match$8 = match$7[1];
                      if (match$8) {
                        if (match$8[1]) {
                          exit$2 = 2;
                        } else {
                          var ty2 = match$8[0];
                          ty$1[/* desc */0] = /* Tsubst */Block.__(7, [ty2]);
                          $js = /* Tlink */Block.__(6, [ty2]);
                        }
                      } else {
                        exit$2 = 2;
                      }
                    } else {
                      exit$2 = 2;
                    }
                  } else {
                    exit$2 = 2;
                  }
                } else {
                  exit$2 = 2;
                }
                if (exit$2 === 2) {
                  var keep = +(more[/* level */1] !== 100000000);
                  var match$9 = more[/* desc */0];
                  var more$prime;
                  var exit$3 = 0;
                  if (typeof match$9 === "number") {
                    if (match$9) {
                      throw [
                            Caml_builtin_exceptions.assert_failure,
                            [
                              "ctype.ml",
                              1047,
                              24
                            ]
                          ];
                    } else {
                      exit$3 = 3;
                    }
                  } else {
                    switch (match$9.tag | 0) {
                      case 3 : 
                          exit$3 = 3;
                          break;
                      case 7 : 
                          more$prime = match$9[0];
                          break;
                      case 0 : 
                      case 9 : 
                          exit$3 = 4;
                          break;
                      default:
                        throw [
                              Caml_builtin_exceptions.assert_failure,
                              [
                                "ctype.ml",
                                1047,
                                24
                              ]
                            ];
                    }
                  }
                  switch (exit$3) {
                    case 3 : 
                        if (keep) {
                          save_desc(more, more[/* desc */0]);
                        }
                        more$prime = copy$1(more);
                        break;
                    case 4 : 
                        save_desc(more, more[/* desc */0]);
                        more$prime = keep ? more : newty2(current_level[0], more[/* desc */0]);
                        break;
                    
                  }
                  var match$10 = repr(more$prime);
                  var match$11 = match$10[/* desc */0];
                  var row$1;
                  if (typeof match$11 === "number") {
                    row$1 = row;
                  } else if (match$11.tag === 3) {
                    if (row[/* row_fixed */4]) {
                      row$1 = row;
                    } else {
                      var newrecord = row.slice();
                      newrecord[/* row_fixed */4] = /* true */1;
                      row$1 = newrecord;
                    }
                  } else {
                    row$1 = row;
                  }
                  var match$12;
                  if (partial) {
                    var match$13 = partial[0];
                    if (match$13[1] !== 0) {
                      match$12 = /* tuple */[
                        more$prime,
                        row$1
                      ];
                    } else {
                      var more$prime$1;
                      if (more[/* id */2] !== more$prime[/* id */2]) {
                        more$prime$1 = more$prime;
                      } else {
                        var lv = keep ? more[/* level */1] : current_level[0];
                        more$prime$1 = newty2(lv, /* Tvar */Block.__(0, [/* None */0]));
                      }
                      var not_reither = function (param) {
                        var match = row_field_repr_aux(/* [] */0, param[1]);
                        if (typeof match === "number" || !match.tag) {
                          return /* true */1;
                        } else {
                          return /* false */0;
                        }
                      };
                      var param$1 = Curry._1(match$13[0], ty$1);
                      match$12 = row$1[/* row_closed */3] && !row$1[/* row_fixed */4] && (
                        param$1 ? /* false */0 : /* true */1
                      ) && !List.for_all(not_reither, row$1[/* row_fields */0]) ? /* tuple */[
                          more$prime$1,
                          /* record */[
                            /* row_fields */List.filter(not_reither)(row$1[/* row_fields */0]),
                            /* row_more */more$prime$1,
                            /* row_bound : () */0,
                            /* row_closed : false */0,
                            /* row_fixed : false */0,
                            /* row_name : None */0
                          ]
                        ] : /* tuple */[
                          more$prime$1,
                          row$1
                        ];
                    }
                  } else {
                    match$12 = /* tuple */[
                      more$prime,
                      row$1
                    ];
                  }
                  var more$prime$2 = match$12[0];
                  more[/* desc */0] = /* Tsubst */Block.__(7, [newty2(100000000, /* Ttuple */Block.__(2, [/* :: */[
                                more$prime$2,
                                /* :: */[
                                  t,
                                  /* [] */0
                                ]
                              ]]))]);
                  $js = /* Tvariant */Block.__(8, [copy_row(copy$1, /* true */1, match$12[1], keep, more$prime$2)]);
                }
                break;
            default:
              $js = copy_type_desc(keep_names, copy$1, desc);
          }
        }
        t[/* desc */0] = $js;
        return t;
      }
    }
  }
  
}

function simple_copy(t) {
  return copy(/* None */0, /* None */0, /* None */0, t);
}

function gadt_env(env) {
  if (env[/* local_constraints */11]) {
    return /* Some */[env];
  } else {
    return /* None */0;
  }
}

function instance(partial, env, sch) {
  var env$1 = gadt_env(env);
  var partial$1 = partial ? /* Some */[/* tuple */[
        compute_univars(sch),
        partial[0]
      ]] : /* None */0;
  var ty = copy(env$1, partial$1, /* None */0, sch);
  cleanup_types(/* () */0);
  return ty;
}

function instance_def(sch) {
  var ty = copy(/* None */0, /* None */0, /* None */0, sch);
  cleanup_types(/* () */0);
  return ty;
}

function instance_list(env, schl) {
  var env$1 = gadt_env(env);
  var tyl = List.map((function (t) {
          return copy(env$1, /* None */0, /* None */0, t);
        }), schl);
  cleanup_types(/* () */0);
  return tyl;
}

var reified_var_counter = [/* Empty */0];

function get_new_abstract_name(s) {
  var index;
  try {
    index = find(s, reified_var_counter[0]) + 1 | 0;
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      index = 0;
    } else {
      throw exn;
    }
  }
  reified_var_counter[0] = add$1(s, index, reified_var_counter[0]);
  return Curry._2(Printf.sprintf(/* Format */[
                  /* String */Block.__(2, [
                      /* No_padding */0,
                      /* Char_literal */Block.__(12, [
                          /* "#" */35,
                          /* Int */Block.__(4, [
                              /* Int_d */0,
                              /* No_padding */0,
                              /* No_precision */0,
                              /* End_of_format */0
                            ])
                        ])
                    ]),
                  "%s#%d"
                ]), s, index);
}

function new_declaration(newtype, manifest) {
  return /* record */[
          /* type_params : [] */0,
          /* type_arity */0,
          /* type_kind : Type_abstract */0,
          /* type_private : Public */1,
          /* type_manifest */manifest,
          /* type_variance : [] */0,
          /* type_newtype_level */newtype,
          /* type_loc */none,
          /* type_attributes : [] */0
        ];
}

function instance_constructor(in_pattern, cstr) {
  if (in_pattern) {
    var match = in_pattern[0];
    var newtype_lev = match[1];
    var env = match[0];
    var $$process = function (existential) {
      var decl = new_declaration(/* Some */[/* tuple */[
              newtype_lev,
              newtype_lev
            ]], /* None */0);
      var match = repr(existential);
      var match$1 = match[/* desc */0];
      var name;
      if (typeof match$1 === "number") {
        name = "ex";
      } else if (match$1.tag) {
        name = "ex";
      } else {
        var match$2 = match$1[0];
        name = match$2 ? match$2[0] : "ex";
      }
      var match$3 = enter_type(get_new_abstract_name(name), decl, env[0]);
      env[0] = match$3[1];
      var to_unify = newty2(current_level[0], /* Tconstr */Block.__(3, [
              /* Pident */Block.__(0, [match$3[0]]),
              /* [] */0,
              [/* Mnil */0]
            ]));
      var tv = copy(/* None */0, /* None */0, /* None */0, existential);
      if (!is_Tvar(tv)) {
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "ctype.ml",
                1170,
                8
              ]
            ];
      }
      return link_type(tv, to_unify);
    };
    List.iter($$process, cstr[/* cstr_existentials */2]);
  }
  var ty_res = copy(/* None */0, /* None */0, /* None */0, cstr[/* cstr_res */1]);
  var ty_args = List.map(simple_copy, cstr[/* cstr_args */3]);
  cleanup_types(/* () */0);
  return /* tuple */[
          ty_args,
          ty_res
        ];
}

function instance_parameterized_type(keep_names, sch_args, sch) {
  var ty_args = List.map((function (t) {
          return copy(/* None */0, /* None */0, keep_names, t);
        }), sch_args);
  var ty = copy(/* None */0, /* None */0, /* None */0, sch);
  cleanup_types(/* () */0);
  return /* tuple */[
          ty_args,
          ty
        ];
}

function instance_declaration(decl) {
  var match = decl[/* type_kind */2];
  var $js;
  $js = typeof match === "number" ? (
      match ? /* Type_open */1 : /* Type_abstract */0
    ) : (
      match.tag ? /* Type_variant */Block.__(1, [List.map((function (c) {
                    return /* record */[
                            /* cd_id */c[/* cd_id */0],
                            /* cd_args */List.map(simple_copy, c[/* cd_args */1]),
                            /* cd_res */may_map(simple_copy, c[/* cd_res */2]),
                            /* cd_loc */c[/* cd_loc */3],
                            /* cd_attributes */c[/* cd_attributes */4]
                          ];
                  }), match[0])]) : /* Type_record */Block.__(0, [
            List.map((function (l) {
                    return /* record */[
                            /* ld_id */l[/* ld_id */0],
                            /* ld_mutable */l[/* ld_mutable */1],
                            /* ld_type */copy(/* None */0, /* None */0, /* None */0, l[/* ld_type */2]),
                            /* ld_loc */l[/* ld_loc */3],
                            /* ld_attributes */l[/* ld_attributes */4]
                          ];
                  }), match[0]),
            match[1]
          ])
    );
  var decl_000 = /* type_params */List.map(simple_copy, decl[/* type_params */0]);
  var decl_001 = /* type_arity */decl[/* type_arity */1];
  var decl_003 = /* type_private */decl[/* type_private */3];
  var decl_004 = /* type_manifest */may_map(simple_copy, decl[/* type_manifest */4]);
  var decl_005 = /* type_variance */decl[/* type_variance */5];
  var decl_006 = /* type_newtype_level */decl[/* type_newtype_level */6];
  var decl_007 = /* type_loc */decl[/* type_loc */7];
  var decl_008 = /* type_attributes */decl[/* type_attributes */8];
  var decl$1 = /* record */[
    decl_000,
    decl_001,
    /* type_kind */$js,
    decl_003,
    decl_004,
    decl_005,
    decl_006,
    decl_007,
    decl_008
  ];
  cleanup_types(/* () */0);
  return decl$1;
}

function instance_class(params, cty) {
  var copy_class_type = function (param) {
    switch (param.tag | 0) {
      case 0 : 
          return /* Cty_constr */Block.__(0, [
                    param[0],
                    List.map(simple_copy, param[1]),
                    copy_class_type(param[2])
                  ]);
      case 1 : 
          var sign = param[0];
          return /* Cty_signature */Block.__(1, [/* record */[
                      /* csig_self */copy(/* None */0, /* None */0, /* None */0, sign[/* csig_self */0]),
                      /* csig_vars */map((function (param) {
                              return /* tuple */[
                                      param[0],
                                      param[1],
                                      copy(/* None */0, /* None */0, /* None */0, param[2])
                                    ];
                            }), sign[/* csig_vars */1]),
                      /* csig_concr */sign[/* csig_concr */2],
                      /* csig_inher */List.map((function (param) {
                              return /* tuple */[
                                      param[0],
                                      List.map(simple_copy, param[1])
                                    ];
                            }), sign[/* csig_inher */3])
                    ]]);
      case 2 : 
          return /* Cty_arrow */Block.__(2, [
                    param[0],
                    copy(/* None */0, /* None */0, /* None */0, param[1]),
                    copy_class_type(param[2])
                  ]);
      
    }
  };
  var params$prime = List.map(simple_copy, params);
  var cty$prime = copy_class_type(cty);
  cleanup_types(/* () */0);
  return /* tuple */[
          params$prime,
          cty$prime
        ];
}

function diff_list(l1, l2) {
  if (l1 === l2) {
    return /* [] */0;
  } else if (l1) {
    return /* :: */[
            l1[0],
            diff_list(l1[1], l2)
          ];
  } else {
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "Ctype.diff_list"
        ];
  }
}

function conflicts(free, bound) {
  var bound$1 = List.map(repr, bound);
  return exists((function (t) {
                return List.memq(repr(t), bound$1);
              }), free);
}

var delayed_copy = [/* [] */0];

function copy_sep(fixed, free, bound, visited, ty) {
  var ty$1 = repr(ty);
  var univars = Curry._1(free, ty$1);
  if (univars ? /* false */0 : /* true */1) {
    if (ty$1[/* level */1] !== 100000000) {
      return ty$1;
    } else {
      var t = newvar(/* None */0, /* () */0);
      delayed_copy[0] = /* :: */[
        Block.__(246, [(function () {
                t[/* desc */0] = /* Tlink */Block.__(6, [copy(/* None */0, /* None */0, /* None */0, ty$1)]);
                return /* () */0;
              })]),
        delayed_copy[0]
      ];
      return t;
    }
  } else {
    try {
      var match = List.assq(ty$1, visited);
      var dl = is_Tunivar(ty$1) ? /* [] */0 : diff_list(bound, match[1]);
      if (dl !== /* [] */0 && conflicts(univars, dl)) {
        throw Caml_builtin_exceptions.not_found;
      }
      return match[0];
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        var t$1 = newvar(/* None */0, /* () */0);
        var match$1 = ty$1[/* desc */0];
        var visited$1;
        var exit = 0;
        if (typeof match$1 === "number") {
          visited$1 = visited;
        } else {
          switch (match$1.tag | 0) {
            case 1 : 
            case 2 : 
            case 3 : 
            case 4 : 
            case 8 : 
            case 11 : 
                exit = 1;
                break;
            default:
              visited$1 = visited;
          }
        }
        if (exit === 1) {
          visited$1 = /* :: */[
            /* tuple */[
              ty$1,
              /* tuple */[
                t$1,
                bound
              ]
            ],
            visited
          ];
        }
        var copy_rec = function (param) {
          return copy_sep(fixed, free, bound, visited$1, param);
        };
        var match$2 = ty$1[/* desc */0];
        var $js;
        if (typeof match$2 === "number") {
          $js = copy_type_desc(/* None */0, copy_rec, ty$1[/* desc */0]);
        } else {
          switch (match$2.tag | 0) {
            case 8 : 
                var row = row_repr_aux(/* [] */0, match$2[0]);
                var more = repr(row[/* row_more */1]);
                var keep = is_Tvar(more) && +(more[/* level */1] !== 100000000);
                var more$prime = copy_rec(more);
                var fixed$prime = fixed && is_Tvar(repr(more$prime));
                var row$1 = copy_row(copy_rec, fixed$prime, row, keep, more$prime);
                $js = /* Tvariant */Block.__(8, [row$1]);
                break;
            case 10 : 
                var tl = List.map(repr, match$2[1]);
                var tl$prime = List.map((function (t) {
                        return newty2(current_level[0], t[/* desc */0]);
                      }), tl);
                var bound$1 = Pervasives.$at(tl, bound);
                var visited$2 = Pervasives.$at(List.map2((function (ty, t) {
                            return /* tuple */[
                                    ty,
                                    /* tuple */[
                                      t,
                                      bound$1
                                    ]
                                  ];
                          }), tl, tl$prime), visited$1);
                $js = /* Tpoly */Block.__(10, [
                    copy_sep(fixed, free, bound$1, visited$2, match$2[0]),
                    tl$prime
                  ]);
                break;
            default:
              $js = copy_type_desc(/* None */0, copy_rec, ty$1[/* desc */0]);
          }
        }
        t$1[/* desc */0] = $js;
        return t$1;
      } else {
        throw exn;
      }
    }
  }
}

function instance_poly($staropt$star, fixed, univars, sch) {
  var keep_names = $staropt$star ? $staropt$star[0] : /* false */0;
  var univars$1 = List.map(repr, univars);
  var copy_var = function (ty) {
    var match = ty[/* desc */0];
    if (typeof match === "number") {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "ctype.ml",
              1307,
              11
            ]
          ];
    } else if (match.tag === 9) {
      if (keep_names) {
        return newty2(current_level[0], /* Tvar */Block.__(0, [match[0]]));
      } else {
        return newvar(/* None */0, /* () */0);
      }
    } else {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "ctype.ml",
              1307,
              11
            ]
          ];
    }
  };
  var vars = List.map(copy_var, univars$1);
  var pairs = List.map2((function (u, v) {
          return /* tuple */[
                  u,
                  /* tuple */[
                    v,
                    /* [] */0
                  ]
                ];
        }), univars$1, vars);
  delayed_copy[0] = /* [] */0;
  var ty = copy_sep(fixed, compute_univars(sch), /* [] */0, pairs, sch);
  List.iter((function (prim) {
          var tag = prim.tag | 0;
          if (tag === 250) {
            return prim[0];
          } else if (tag === 246) {
            return CamlinternalLazy.force_lazy_block(prim);
          } else {
            return prim;
          }
        }), delayed_copy[0]);
  delayed_copy[0] = /* [] */0;
  cleanup_types(/* () */0);
  return /* tuple */[
          vars,
          ty
        ];
}

function instance_label(fixed, lbl) {
  var ty_res = copy(/* None */0, /* None */0, /* None */0, lbl[/* lbl_res */1]);
  var ty = repr(lbl[/* lbl_arg */2]);
  var match = ty[/* desc */0];
  var match$1;
  var exit = 0;
  if (typeof match === "number" || match.tag !== 10) {
    exit = 1;
  } else {
    match$1 = instance_poly(/* None */0, fixed, match[1], match[0]);
  }
  if (exit === 1) {
    match$1 = /* tuple */[
      /* [] */0,
      copy(/* None */0, /* None */0, /* None */0, lbl[/* lbl_arg */2])
    ];
  }
  cleanup_types(/* () */0);
  return /* tuple */[
          match$1[0],
          match$1[1],
          ty_res
        ];
}

var unify$prime = [(function (_, _$1, _$2) {
      throw [
            Unify,
            /* [] */0
          ];
    })];

function subst(env, level, priv, abbrev, ty, params, args, body) {
  if (List.length(params) !== List.length(args)) {
    throw [
          Unify,
          /* [] */0
        ];
  }
  var old_level = current_level[0];
  current_level[0] = level;
  try {
    var body0 = newvar(/* None */0, /* () */0);
    if (ty) {
      var ty$1 = ty[0];
      var match = ty$1[/* desc */0];
      if (typeof match === "number") {
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "ctype.ml",
                1347,
                8
              ]
            ];
      } else if (match.tag === 3) {
        var path = match[0];
        var abbrev$1 = proper_abbrevs(path, match[1], abbrev);
        memorize_abbrev(abbrev$1, priv, path, ty$1, body0);
      } else {
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "ctype.ml",
                1347,
                8
              ]
            ];
      }
    }
    abbreviations[0] = abbrev;
    var match$1 = instance_parameterized_type(/* None */0, params, body);
    var body$prime = match$1[1];
    abbreviations[0] = [/* Mnil */0];
    Curry._3(unify$prime[0], env, body0, body$prime);
    List.iter2(Curry._1(unify$prime[0], env), match$1[0], args);
    current_level[0] = old_level;
    return body$prime;
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === Unify) {
      current_level[0] = old_level;
      throw exn;
    } else {
      throw exn;
    }
  }
}

var previous_env = [empty];

function check_abbrev_env(env) {
  if (env !== previous_env[0]) {
    cleanup_abbrev(/* () */0);
    previous_env[0] = env;
    return /* () */0;
  } else {
    return 0;
  }
}

function expand_abbrev_gen(kind, find_type_expansion, env, ty) {
  check_abbrev_env(env);
  var match = ty[/* desc */0];
  if (typeof match === "number") {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "ctype.ml",
            1456,
            6
          ]
        ];
  } else if (match.tag === 3) {
    var abbrev = match[2];
    var args = match[1];
    var path = match[0];
    var level = ty[/* level */1];
    var lookup_abbrev = proper_abbrevs(path, args, abbrev);
    var match$1 = find_expans(kind, path, lookup_abbrev[0]);
    if (match$1) {
      var ty$1 = match$1[0];
      if (level !== 100000000) {
        try {
          update_level(env, level, ty$1);
        }
        catch (raw_exn){
          var exn = Js_exn.internalToOCamlException(raw_exn);
          if (exn[0] !== Unify) {
            throw exn;
          }
          
        }
      }
      return ty$1;
    } else {
      var match$2;
      try {
        match$2 = Curry._2(find_type_expansion, path, env);
      }
      catch (exn$1){
        if (exn$1 === Caml_builtin_exceptions.not_found) {
          throw Cannot_expand;
        } else {
          throw exn$1;
        }
      }
      var ty$prime = subst(env, level, kind, abbrev, /* Some */[ty], match$2[0], args, match$2[1]);
      var ty$2 = repr(ty$prime);
      var match$3 = ty$2[/* desc */0];
      if (typeof match$3 !== "number") {
        if (match$3.tag === 8) {
          var row = match$3[0];
          if (static_row(row)) {
            var newrecord = row.slice();
            ty$2[/* desc */0] = /* Tvariant */Block.__(8, [(newrecord[/* row_name */5] = /* Some */[/* tuple */[
                      path,
                      args
                    ]], newrecord)]);
          }
          
        }
        
      }
      if (trace_gadt_instances[0]) {
        var match$4 = Pervasives.max(match$2[2], gadt_instance_level(env, ty));
        if (match$4) {
          var lv = match$4[0];
          if (level < lv) {
            throw [
                  Unify,
                  /* :: */[
                    /* tuple */[
                      ty,
                      newty2(level, /* Tvar */Block.__(0, [/* None */0]))
                    ],
                    /* [] */0
                  ]
                ];
          }
          add_gadt_instances(env, lv, /* :: */[
                ty,
                /* :: */[
                  ty$prime,
                  /* [] */0
                ]
              ]);
        }
        
      }
      return ty$prime;
    }
  } else {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "ctype.ml",
            1456,
            6
          ]
        ];
  }
}

function expand_abbrev(ty) {
  return (function (param) {
      return expand_abbrev_gen(/* Public */1, find_type_expansion, ty, param);
    });
}

function expand_head_once(env, ty) {
  try {
    return expand_abbrev(env)(repr(ty));
  }
  catch (exn){
    if (exn === Cannot_expand) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "ctype.ml",
              1464,
              56
            ]
          ];
    } else {
      throw exn;
    }
  }
}

function safe_abbrev(env, ty) {
  var snap = snapshot(/* () */0);
  try {
    expand_abbrev(env)(ty);
    return /* true */1;
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn === Cannot_expand) {
      backtrack(snap);
      return /* false */0;
    } else if (exn[0] === Unify) {
      backtrack(snap);
      return /* false */0;
    } else {
      throw exn;
    }
  }
}

function try_expand_once(env, ty) {
  var ty$1 = repr(ty);
  var match = ty$1[/* desc */0];
  if (typeof match === "number") {
    throw Cannot_expand;
  } else if (match.tag === 3) {
    return repr(expand_abbrev(env)(ty$1));
  } else {
    throw Cannot_expand;
  }
}

function try_expand_safe(env, ty) {
  var snap = snapshot(/* () */0);
  try {
    return try_expand_once(env, ty);
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === Unify) {
      backtrack(snap);
      throw Cannot_expand;
    } else {
      throw exn;
    }
  }
}

function try_expand_head(try_once, env, ty) {
  var ty$prime = Curry._2(try_once, env, ty);
  try {
    return try_expand_head(try_once, env, ty$prime);
  }
  catch (exn){
    if (exn === Cannot_expand) {
      return ty$prime;
    } else {
      throw exn;
    }
  }
}

function try_expand_head$1(try_once, env, ty) {
  var ty$prime = try_expand_head(try_once, env, ty);
  var match = gadt_instance_level(env, ty$prime);
  if (match) {
    add_gadt_instance_chain(env, match[0], ty);
  }
  return ty$prime;
}

function expand_head_unif(env, ty) {
  try {
    return try_expand_head$1(try_expand_once, env, ty);
  }
  catch (exn){
    if (exn === Cannot_expand) {
      return repr(ty);
    } else {
      throw exn;
    }
  }
}

function expand_head(env, ty) {
  try {
    return try_expand_head$1(try_expand_safe, env, ty);
  }
  catch (exn){
    if (exn === Cannot_expand) {
      return repr(ty);
    } else {
      throw exn;
    }
  }
}

forward_try_expand_once[0] = try_expand_safe;

function extract_concrete_typedecl(env, ty) {
  var ty$1 = repr(ty);
  var match = ty$1[/* desc */0];
  if (typeof match === "number") {
    throw Caml_builtin_exceptions.not_found;
  } else if (match.tag === 3) {
    var p = match[0];
    var decl = find_type_full(p, env)[0];
    if (decl[/* type_kind */2] !== /* Type_abstract */0) {
      return /* tuple */[
              p,
              p,
              decl
            ];
    } else {
      var ty$2;
      try {
        ty$2 = try_expand_once(env, ty$1);
      }
      catch (exn){
        if (exn === Cannot_expand) {
          throw Caml_builtin_exceptions.not_found;
        } else {
          throw exn;
        }
      }
      var match$1 = extract_concrete_typedecl(env, ty$2);
      return /* tuple */[
              p,
              match$1[1],
              match$1[2]
            ];
    }
  } else {
    throw Caml_builtin_exceptions.not_found;
  }
}

function expand_abbrev_opt(param, param$1) {
  return expand_abbrev_gen(/* Private */0, find_type_expansion_opt, param, param$1);
}

function try_expand_once_opt(env, ty) {
  var ty$1 = repr(ty);
  var match = ty$1[/* desc */0];
  if (typeof match === "number") {
    throw Cannot_expand;
  } else if (match.tag === 3) {
    return repr(expand_abbrev_opt(env, ty$1));
  } else {
    throw Cannot_expand;
  }
}

function try_expand_head_opt(env, ty) {
  var ty$prime = try_expand_once_opt(env, ty);
  try {
    return try_expand_head_opt(env, ty$prime);
  }
  catch (exn){
    if (exn === Cannot_expand) {
      return ty$prime;
    } else {
      throw exn;
    }
  }
}

function expand_head_opt(env, ty) {
  var snap = snapshot(/* () */0);
  try {
    return try_expand_head_opt(env, ty);
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn === Cannot_expand) {
      backtrack(snap);
      return repr(ty);
    } else if (exn[0] === Unify) {
      backtrack(snap);
      return repr(ty);
    } else {
      throw exn;
    }
  }
}

function enforce_constraints(env, ty) {
  var match = ty[/* desc */0];
  if (typeof match === "number") {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "ctype.ml",
            1574,
            6
          ]
        ];
  } else if (match.tag === 3) {
    var level = ty[/* level */1];
    try {
      var decl = find_type_full(match[0], env)[0];
      subst(env, level, /* Public */1, [/* Mnil */0], /* None */0, decl[/* type_params */0], match[1], newty2(level, /* Tvar */Block.__(0, [/* None */0])));
      return /* () */0;
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        return /* () */0;
      } else {
        throw exn;
      }
    }
  } else {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "ctype.ml",
            1574,
            6
          ]
        ];
  }
}

function full_expand(env, ty) {
  var ty$1 = repr(expand_head(env, ty));
  var match = ty$1[/* desc */0];
  if (typeof match === "number") {
    return ty$1;
  } else if (match.tag === 4) {
    var match$1 = match[1][/* contents */0];
    if (match$1) {
      var match$2 = match$1[0][1];
      if (match$2 && is_Tvar(repr(match$2[0]))) {
        return newty2(ty$1[/* level */1], /* Tobject */Block.__(4, [
                      match[0],
                      [/* None */0]
                    ]));
      } else {
        return ty$1;
      }
    } else {
      return ty$1;
    }
  } else {
    return ty$1;
  }
}

function generic_abbrev(env, path) {
  try {
    var match = find_type_expansion(path, env);
    return +(repr(match[1])[/* level */1] === 100000000);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return /* false */0;
    } else {
      throw exn;
    }
  }
}

function generic_private_abbrev(env, path) {
  try {
    var match = find_type_full(path, env)[0];
    var match$1 = match[/* type_kind */2];
    if (typeof match$1 === "number") {
      if (match$1 !== 0) {
        return /* false */0;
      } else if (match[/* type_private */3] !== 0) {
        return /* false */0;
      } else {
        var match$2 = match[/* type_manifest */4];
        if (match$2) {
          return +(repr(match$2[0])[/* level */1] === 100000000);
        } else {
          return /* false */0;
        }
      }
    } else {
      return /* false */0;
    }
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return /* false */0;
    } else {
      throw exn;
    }
  }
}

function is_contractive(env, ty) {
  var match = repr(ty)[/* desc */0];
  if (typeof match === "number") {
    return /* true */1;
  } else if (match.tag === 3) {
    var p = match[0];
    if (in_pervasives(p)) {
      return /* true */1;
    } else {
      try {
        return is_datatype(find_type_full(p, env)[0]);
      }
      catch (exn){
        if (exn === Caml_builtin_exceptions.not_found) {
          return /* false */0;
        } else {
          throw exn;
        }
      }
    }
  } else {
    return /* true */1;
  }
}

var Occur = Caml_exceptions.create("Ocaml_typedtree_test.Ctype.Occur");

function occur_rec(env, visited, ty0, ty) {
  if (ty === ty0) {
    throw Occur;
  }
  var occur_ok = recursive_types[0] && is_contractive(env, ty);
  var match = ty[/* desc */0];
  var exit = 0;
  if (typeof match === "number") {
    exit = 1;
  } else {
    switch (match.tag | 0) {
      case 3 : 
          try {
            if (occur_ok || List.memq(ty, visited)) {
              throw Occur;
            }
            var partial_arg = /* :: */[
              ty,
              visited
            ];
            return iter_type_expr((function (param) {
                          return occur_rec(env, partial_arg, ty0, param);
                        }), ty);
          }
          catch (exn){
            if (exn === Occur) {
              try {
                var ty$prime = try_expand_head$1(try_expand_once, env, ty);
                if (ty$prime === ty0 || List.memq(ty$prime, visited)) {
                  throw Occur;
                }
                var match$1 = ty$prime[/* desc */0];
                var exit$1 = 0;
                if (typeof match$1 === "number") {
                  exit$1 = 2;
                } else {
                  switch (match$1.tag | 0) {
                    case 4 : 
                    case 8 : 
                        return /* () */0;
                    default:
                      exit$1 = 2;
                  }
                }
                if (exit$1 === 2) {
                  if (recursive_types[0] && is_contractive(env, ty$prime)) {
                    return 0;
                  } else {
                    var partial_arg$1 = /* :: */[
                      ty$prime,
                      visited
                    ];
                    return iter_type_expr((function (param) {
                                  return occur_rec(env, partial_arg$1, ty0, param);
                                }), ty$prime);
                  }
                }
                
              }
              catch (exn$1){
                if (exn$1 === Cannot_expand) {
                  if (occur_ok) {
                    return 0;
                  } else {
                    throw Occur;
                  }
                } else {
                  throw exn$1;
                }
              }
            } else {
              throw exn;
            }
          }
          break;
      case 4 : 
      case 8 : 
          return /* () */0;
      default:
        exit = 1;
    }
  }
  if (exit === 1) {
    if (occur_ok) {
      return 0;
    } else {
      return iter_type_expr((function (param) {
                    return occur_rec(env, visited, ty0, param);
                  }), ty);
    }
  }
  
}

var type_changed = [/* false */0];

function merge(r, b) {
  if (b) {
    r[0] = /* true */1;
    return /* () */0;
  } else {
    return 0;
  }
}

function occur(env, ty0, ty) {
  var old = type_changed[0];
  try {
    while(type_changed[0] = /* false */0, occur_rec(env, /* [] */0, ty0, ty), type_changed[0]) {
      
    };
    return merge(type_changed, old);
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    merge(type_changed, old);
    throw exn === Occur ? [
            Unify,
            /* [] */0
          ] : exn;
  }
}

function occur_in(env, ty0, t) {
  try {
    occur(env, ty0, t);
    return /* false */0;
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === Unify) {
      return /* true */1;
    } else {
      throw exn;
    }
  }
}

function unify_univar(t1, t2, _param) {
  while(true) {
    var param = _param;
    if (param) {
      var match = param[0];
      var find_univ = function (t, cl) {
        try {
          var match = List.find((function (param) {
                  return +(t === repr(param[0]));
                }), cl);
          return /* Some */[match[1]];
        }
        catch (exn){
          if (exn === Caml_builtin_exceptions.not_found) {
            return /* None */0;
          } else {
            throw exn;
          }
        }
      };
      var match$1 = find_univ(t1, match[0]);
      var match$2 = find_univ(t2, match[1]);
      if (match$1) {
        var r1 = match$1[0];
        var match$3 = r1[/* contents */0];
        if (match$3) {
          if (match$2) {
            if (t2 === repr(match$3[0])) {
              return /* () */0;
            } else {
              throw [
                    Unify,
                    /* [] */0
                  ];
            }
          } else {
            throw [
                  Unify,
                  /* [] */0
                ];
          }
        } else if (match$2) {
          var r2 = match$2[0];
          var match$4 = r2[/* contents */0];
          if (match$4) {
            throw [
                  Unify,
                  /* [] */0
                ];
          } else {
            set_univar(r1, t2);
            return set_univar(r2, t1);
          }
        } else {
          throw [
                Unify,
                /* [] */0
              ];
        }
      } else if (match$2) {
        throw [
              Unify,
              /* [] */0
            ];
      } else {
        _param = param[1];
        continue ;
        
      }
    } else {
      throw [
            Unify,
            /* [] */0
          ];
    }
  };
}

function occur_univar(env, ty) {
  var visited = [/* Empty */0];
  var occur_rec = function (_bound, _ty) {
    while(true) {
      var ty = _ty;
      var bound = _bound;
      var ty$1 = repr(ty);
      var $js;
      if (bound ? /* false */0 : /* true */1) {
        ty$1[/* level */1] = pivot_level - ty$1[/* level */1] | 0;
        $js = /* true */1;
      } else {
        try {
          var bound$prime = find$1(ty$1, visited[0]);
          if (exists((function(bound){
                return function (x) {
                  return 1 - mem$3(x, bound);
                }
                }(bound)), bound$prime)) {
            visited[0] = add$4(ty$1, inter$2(bound, bound$prime), visited[0]);
            $js = /* true */1;
          } else {
            $js = /* false */0;
          }
        }
        catch (exn){
          if (exn === Caml_builtin_exceptions.not_found) {
            visited[0] = add$4(ty$1, bound, visited[0]);
            $js = /* true */1;
          } else {
            throw exn;
          }
        }
      }
      if (ty$1[/* level */1] >= 0 && $js) {
        var match = ty$1[/* desc */0];
        if (typeof match === "number") {
          return iter_type_expr((function(bound){
                    return function (param) {
                      return occur_rec(bound, param);
                    }
                    }(bound)), ty$1);
        } else {
          switch (match.tag | 0) {
            case 3 : 
                var tl = match[1];
                if (tl) {
                  try {
                    var td = find_type_full(match[0], env)[0];
                    return List.iter2((function(bound){
                              return function (t, v) {
                                if (Curry._2(Types_003[/* mem */8], /* May_pos */0, v) || Curry._2(Types_003[/* mem */8], /* May_neg */1, v)) {
                                  return occur_rec(bound, t);
                                } else {
                                  return 0;
                                }
                              }
                              }(bound)), tl, td[/* type_variance */5]);
                  }
                  catch (exn$1){
                    if (exn$1 === Caml_builtin_exceptions.not_found) {
                      return List.iter((function(bound){
                                return function (param) {
                                  return occur_rec(bound, param);
                                }
                                }(bound)), tl);
                    } else {
                      throw exn$1;
                    }
                  }
                } else {
                  return /* () */0;
                }
                break;
            case 9 : 
                if (mem$3(ty$1, bound)) {
                  return 0;
                } else {
                  throw [
                        Unify,
                        /* :: */[
                          /* tuple */[
                            ty$1,
                            newty2(100000000, /* Tvar */Block.__(0, [/* None */0]))
                          ],
                          /* [] */0
                        ]
                      ];
                }
                break;
            case 10 : 
                var bound$1 = List.fold_right(add$3, List.map(repr, match[1]), bound);
                _ty = match[0];
                _bound = bound$1;
                continue ;
                default:
              return iter_type_expr((function(bound){
                        return function (param) {
                          return occur_rec(bound, param);
                        }
                        }(bound)), ty$1);
          }
        }
      } else {
        return 0;
      }
    };
  };
  try {
    occur_rec(/* Empty */0, ty);
    return unmark_type(ty);
  }
  catch (exn){
    unmark_type(ty);
    throw exn;
  }
}

function add_univars(param, param$1) {
  return List.fold_left((function (s, param) {
                return add$3(repr(param[0]), s);
              }), param, param$1);
}

function get_univar_family(univar_pairs, univars) {
  if (univars) {
    var insert = function (s, param) {
      var cl2 = param[1];
      if (cl2 && List.exists((function (param) {
                return mem$3(repr(param[0]), s);
              }), param[0])) {
        return add_univars(s, cl2);
      } else {
        return s;
      }
    };
    var s = List.fold_right(add$3, univars, /* Empty */0);
    return List.fold_left(insert, s, univar_pairs);
  } else {
    return /* Empty */0;
  }
}

function univars_escape(env, univar_pairs, vl, ty) {
  var family = get_univar_family(univar_pairs, vl);
  var visited = [/* Empty */0];
  var occur = function (_t) {
    while(true) {
      var t = _t;
      var t$1 = repr(t);
      if (mem$3(t$1, visited[0])) {
        return /* () */0;
      } else {
        visited[0] = add$3(t$1, visited[0]);
        var match = t$1[/* desc */0];
        if (typeof match === "number") {
          return iter_type_expr(occur, t$1);
        } else {
          switch (match.tag | 0) {
            case 3 : 
                var tl = match[1];
                if (tl) {
                  try {
                    var td = find_type_full(match[0], env)[0];
                    return List.iter2((function (t, v) {
                                  if (Curry._2(Types_003[/* mem */8], /* May_pos */0, v) || Curry._2(Types_003[/* mem */8], /* May_neg */1, v)) {
                                    return occur(t);
                                  } else {
                                    return 0;
                                  }
                                }), tl, td[/* type_variance */5]);
                  }
                  catch (exn){
                    if (exn === Caml_builtin_exceptions.not_found) {
                      return List.iter(occur, tl);
                    } else {
                      throw exn;
                    }
                  }
                } else {
                  return /* () */0;
                }
                break;
            case 9 : 
                if (mem$3(t$1, family)) {
                  throw Occur;
                } else {
                  return 0;
                }
                break;
            case 10 : 
                if (List.exists((function (t) {
                          return mem$3(repr(t), family);
                        }), match[1])) {
                  return /* () */0;
                } else {
                  _t = match[0];
                  continue ;
                  
                }
                break;
            default:
              return iter_type_expr(occur, t$1);
          }
        }
      }
    };
  };
  try {
    occur(ty);
    return /* false */0;
  }
  catch (exn){
    if (exn === Occur) {
      return /* true */1;
    } else {
      throw exn;
    }
  }
}

function enter_poly(env, univar_pairs, t1, tl1, t2, tl2, f) {
  var old_univars = univar_pairs[0];
  var known_univars = List.fold_left((function (s, param) {
          return add_univars(s, param[0]);
        }), /* Empty */0, old_univars);
  var tl1$1 = List.map(repr, tl1);
  var tl2$1 = List.map(repr, tl2);
  if (List.exists((function (t) {
            return mem$3(t, known_univars);
          }), tl1$1) && univars_escape(env, old_univars, tl1$1, newty2(current_level[0], /* Tpoly */Block.__(10, [
                t2,
                tl2$1
              ]))) || List.exists((function (t) {
            return mem$3(t, known_univars);
          }), tl2$1) && univars_escape(env, old_univars, tl2$1, newty2(current_level[0], /* Tpoly */Block.__(10, [
                t1,
                tl1$1
              ])))) {
    throw [
          Unify,
          /* [] */0
        ];
  }
  var cl1 = List.map((function (t) {
          return /* tuple */[
                  t,
                  [/* None */0]
                ];
        }), tl1$1);
  var cl2 = List.map((function (t) {
          return /* tuple */[
                  t,
                  [/* None */0]
                ];
        }), tl2$1);
  univar_pairs[0] = /* :: */[
    /* tuple */[
      cl1,
      cl2
    ],
    /* :: */[
      /* tuple */[
        cl2,
        cl1
      ],
      old_univars
    ]
  ];
  try {
    var res = Curry._2(f, t1, t2);
    univar_pairs[0] = old_univars;
    return res;
  }
  catch (exn){
    univar_pairs[0] = old_univars;
    throw exn;
  }
}

var univar_pairs = [/* [] */0];

function has_cached_expansion(p, _abbrev) {
  while(true) {
    var abbrev = _abbrev;
    if (typeof abbrev === "number") {
      return /* false */0;
    } else if (abbrev.tag) {
      _abbrev = abbrev[0][0];
      continue ;
      
    } else if (same(p, abbrev[1])) {
      return /* true */1;
    } else {
      _abbrev = abbrev[4];
      continue ;
      
    }
  };
}

function expand_trace(env, trace) {
  return List.fold_right((function (param, rem) {
                var t2 = param[1];
                var t1 = param[0];
                return /* :: */[
                        /* tuple */[
                          repr(t1),
                          full_expand(env, t1)
                        ],
                        /* :: */[
                          /* tuple */[
                            repr(t2),
                            full_expand(env, t2)
                          ],
                          rem
                        ]
                      ];
              }), trace, /* [] */0);
}

function mkvariant(fields, closed) {
  return newty2(100000000, /* Tvariant */Block.__(8, [/* record */[
                  /* row_fields */fields,
                  /* row_more */newvar(/* None */0, /* () */0),
                  /* row_bound : () */0,
                  /* row_closed */closed,
                  /* row_fixed : false */0,
                  /* row_name : None */0
                ]]));
}

var rigid_variants = [/* false */0];

function deep_occur(t0, ty) {
  var occur_rec = function (ty) {
    var ty$1 = repr(ty);
    if (ty$1[/* level */1] >= 0) {
      if (ty$1 === t0) {
        throw Occur;
      }
      ty$1[/* level */1] = pivot_level - ty$1[/* level */1] | 0;
      return iter_type_expr(occur_rec, ty$1);
    } else {
      return 0;
    }
  };
  try {
    occur_rec(ty);
    unmark_type(ty);
    return /* false */0;
  }
  catch (exn){
    if (exn === Occur) {
      unmark_type(ty);
      return /* true */1;
    } else {
      throw exn;
    }
  }
}

var newtype_level = [/* None */0];

function get_newtype_level() {
  var match = newtype_level[0];
  if (match) {
    return match[0];
  } else {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "ctype.ml",
            1949,
            12
          ]
        ];
  }
}

function reify(env, t) {
  var newtype_level = get_newtype_level(/* () */0);
  var create_fresh_constr = function (lev, name) {
    var decl = new_declaration(/* Some */[/* tuple */[
            newtype_level,
            newtype_level
          ]], /* None */0);
    var name$1 = get_new_abstract_name(name);
    var match = enter_type(name$1, decl, env[0]);
    var t = newty2(lev, /* Tconstr */Block.__(3, [
            /* Pident */Block.__(0, [match[0]]),
            /* [] */0,
            [/* Mnil */0]
          ]));
    env[0] = match[1];
    return t;
  };
  var visited = [/* Empty */0];
  var iterator = function (ty) {
    var ty$1 = repr(ty);
    if (mem$3(ty$1, visited[0])) {
      return /* () */0;
    } else {
      visited[0] = add$3(ty$1, visited[0]);
      var match = ty$1[/* desc */0];
      if (typeof match === "number") {
        return iter_type_expr(iterator, ty$1);
      } else {
        switch (match.tag | 0) {
          case 0 : 
              var o = match[0];
              var name = o ? o[0] : "ex";
              var t = create_fresh_constr(ty$1[/* level */1], name);
              return link_type(ty$1, t);
          case 3 : 
              if (is_object_type(match[0])) {
                return iter_type_expr(iterator, full_expand(env[0], ty$1));
              } else {
                return iter_type_expr(iterator, ty$1);
              }
          case 8 : 
              var r = row_repr_aux(/* [] */0, match[0]);
              if (!static_row(r)) {
                if (r[/* row_fixed */4]) {
                  iterator(row_more(r));
                } else {
                  var m = r[/* row_more */1];
                  var match$1 = m[/* desc */0];
                  if (typeof match$1 === "number") {
                    throw [
                          Caml_builtin_exceptions.assert_failure,
                          [
                            "ctype.ml",
                            1987,
                            19
                          ]
                        ];
                  } else if (match$1.tag) {
                    throw [
                          Caml_builtin_exceptions.assert_failure,
                          [
                            "ctype.ml",
                            1987,
                            19
                          ]
                        ];
                  } else {
                    var o$1 = match$1[0];
                    var name$1 = o$1 ? o$1[0] : "ex";
                    var t$1 = create_fresh_constr(m[/* level */1], name$1);
                    var row_002 = /* row_bound */r[/* row_bound */2];
                    var row_003 = /* row_closed */r[/* row_closed */3];
                    var row_005 = /* row_name */r[/* row_name */5];
                    var row = /* record */[
                      /* row_fields : [] */0,
                      /* row_more */t$1,
                      row_002,
                      row_003,
                      /* row_fixed : true */1,
                      row_005
                    ];
                    link_type(m, newty2(m[/* level */1], /* Tvariant */Block.__(8, [row])));
                  }
                }
              }
              return iter_row(iterator, r);
          default:
            return iter_type_expr(iterator, ty$1);
        }
      }
    }
  };
  return iterator(t);
}

function is_newtype(env, p) {
  try {
    var decl = find_type_full(p, env)[0];
    if (decl[/* type_newtype_level */6] !== /* None */0 && !decl[/* type_kind */2]) {
      return +(decl[/* type_private */3] === /* Public */1);
    } else {
      return /* false */0;
    }
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return /* false */0;
    } else {
      throw exn;
    }
  }
}

function non_aliasable(p, decl) {
  if (in_current_module(p)) {
    return +(decl[/* type_newtype_level */6] === /* None */0);
  } else {
    return /* false */0;
  }
}

function expands_to_datatype(env, ty) {
  var ty$1 = repr(ty);
  var match = ty$1[/* desc */0];
  if (typeof match === "number") {
    return /* false */0;
  } else if (match.tag === 3) {
    try {
      if (is_datatype(find_type_full(match[0], env)[0])) {
        return /* true */1;
      } else {
        return expands_to_datatype(env, try_expand_once(env, ty$1));
      }
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        return /* false */0;
      } else if (exn === Cannot_expand) {
        return /* false */0;
      } else {
        throw exn;
      }
    }
  } else {
    return /* false */0;
  }
}

function mcomp(type_pairs, env, _t1, _t2) {
  while(true) {
    var t2 = _t2;
    var t1 = _t1;
    if (t1 === t2) {
      return /* () */0;
    } else {
      var t1$1 = repr(t1);
      var t2$1 = repr(t2);
      if (t1$1 === t2$1) {
        return /* () */0;
      } else {
        var match = t1$1[/* desc */0];
        var match$1 = t2$1[/* desc */0];
        var exit = 0;
        var exit$1 = 0;
        if (typeof match === "number") {
          exit$1 = 2;
        } else {
          switch (match.tag | 0) {
            case 0 : 
                return /* () */0;
            case 3 : 
                if (match[1]) {
                  exit$1 = 2;
                } else if (typeof match$1 === "number") {
                  exit = 1;
                } else {
                  switch (match$1.tag | 0) {
                    case 0 : 
                        exit$1 = 2;
                        break;
                    case 3 : 
                        if (match$1[1]) {
                          exit = 1;
                        } else if (same(match[0], match$1[0])) {
                          return /* () */0;
                        } else {
                          exit = 1;
                        }
                        break;
                    default:
                      exit = 1;
                  }
                }
                break;
            default:
              exit$1 = 2;
          }
        }
        if (exit$1 === 2) {
          if (typeof match$1 === "number") {
            exit = 1;
          } else if (match$1.tag) {
            exit = 1;
          } else {
            return /* () */0;
          }
        }
        if (exit === 1) {
          var t1$prime = expand_head_opt(env, t1$1);
          var t2$prime = expand_head_opt(env, t2$1);
          var t1$prime$1 = repr(t1$prime);
          var t2$prime$1 = repr(t2$prime);
          if (t1$prime$1 === t2$prime$1) {
            return /* () */0;
          } else {
            try {
              return Curry._2(TypePairs[/* find */6], type_pairs, /* tuple */[
                          t1$prime$1,
                          t2$prime$1
                        ]);
            }
            catch (exn){
              if (exn === Caml_builtin_exceptions.not_found) {
                Curry._3(TypePairs[/* add */4], type_pairs, /* tuple */[
                      t1$prime$1,
                      t2$prime$1
                    ], /* () */0);
                var match$2 = t1$prime$1[/* desc */0];
                var match$3 = t2$prime$1[/* desc */0];
                var exit$2 = 0;
                var p;
                var exit$3 = 0;
                if (typeof match$2 === "number") {
                  if (typeof match$3 === "number") {
                    if (match$3) {
                      throw [
                            Unify,
                            /* [] */0
                          ];
                    } else {
                      return /* () */0;
                    }
                  } else if (match$3.tag === 3) {
                    exit$3 = 3;
                  } else {
                    throw [
                          Unify,
                          /* [] */0
                        ];
                  }
                } else {
                  switch (match$2.tag | 0) {
                    case 0 : 
                        if (typeof match$3 === "number") {
                          throw [
                                Unify,
                                /* [] */0
                              ];
                        } else {
                          switch (match$3.tag | 0) {
                            case 0 : 
                                throw [
                                      Caml_builtin_exceptions.assert_failure,
                                      [
                                        "ctype.ml",
                                        2051,
                                        30
                                      ]
                                    ];
                            case 3 : 
                                exit$3 = 3;
                                break;
                            default:
                              throw [
                                    Unify,
                                    /* [] */0
                                  ];
                          }
                        }
                        break;
                    case 1 : 
                        var l1 = match$2[0];
                        if (typeof match$3 === "number") {
                          throw [
                                Unify,
                                /* [] */0
                              ];
                        } else {
                          switch (match$3.tag | 0) {
                            case 1 : 
                                var l2 = match$3[0];
                                if (l1 === l2 || !(is_optional(l1) || is_optional(l2))) {
                                  mcomp(type_pairs, env, match$2[1], match$3[1]);
                                  _t2 = match$3[2];
                                  _t1 = match$2[2];
                                  continue ;
                                  
                                } else {
                                  throw [
                                        Unify,
                                        /* [] */0
                                      ];
                                }
                                break;
                            case 3 : 
                                exit$3 = 3;
                                break;
                            default:
                              throw [
                                    Unify,
                                    /* [] */0
                                  ];
                          }
                        }
                        break;
                    case 2 : 
                        if (typeof match$3 === "number") {
                          throw [
                                Unify,
                                /* [] */0
                              ];
                        } else {
                          switch (match$3.tag | 0) {
                            case 2 : 
                                return mcomp_list(type_pairs, env, match$2[0], match$3[0]);
                            case 3 : 
                                exit$3 = 3;
                                break;
                            default:
                              throw [
                                    Unify,
                                    /* [] */0
                                  ];
                          }
                        }
                        break;
                    case 3 : 
                        var p1 = match$2[0];
                        if (typeof match$3 === "number") {
                          p = p1;
                          exit$2 = 2;
                        } else if (match$3.tag === 3) {
                          var type_pairs$1 = type_pairs;
                          var env$1 = env;
                          var p1$1 = p1;
                          var p2 = match$3[0];
                          var tl1 = match$2[1];
                          var tl2 = match$3[1];
                          try {
                            var decl = find_type_full(p1$1, env$1)[0];
                            var decl$prime = find_type_full(p2, env$1)[0];
                            if (same(p1$1, p2)) {
                              var inj;
                              try {
                                inj = List.map(Curry._1(Types_003[/* mem */8], /* Inj */3), find_type_full(p1$1, env$1)[0][/* type_variance */5]);
                              }
                              catch (exn$1){
                                if (exn$1 === Caml_builtin_exceptions.not_found) {
                                  inj = List.map((function () {
                                          return /* false */0;
                                        }), tl1);
                                } else {
                                  throw exn$1;
                                }
                              }
                              return List.iter2((function(type_pairs$1,env$1){
                                        return function (i, param) {
                                          if (i) {
                                            return mcomp(type_pairs$1, env$1, param[0], param[1]);
                                          } else {
                                            return 0;
                                          }
                                        }
                                        }(type_pairs$1,env$1)), inj, List.combine(tl1, tl2));
                            } else if (non_aliasable(p1$1, decl) && non_aliasable(p2, decl$prime)) {
                              throw [
                                    Unify,
                                    /* [] */0
                                  ];
                            } else {
                              var match$4 = decl[/* type_kind */2];
                              var match$5 = decl$prime[/* type_kind */2];
                              var exit$4 = 0;
                              if (typeof match$4 === "number") {
                                if (match$4) {
                                  if (typeof match$5 === "number") {
                                    if (match$5 !== 0) {
                                      return mcomp_list(type_pairs$1, env$1, tl1, tl2);
                                    } else {
                                      exit$4 = 1;
                                    }
                                  } else {
                                    throw [
                                          Unify,
                                          /* [] */0
                                        ];
                                  }
                                } else {
                                  var exit$5 = 0;
                                  if (typeof match$5 === "number") {
                                    if (match$5 !== 0) {
                                      exit$5 = 2;
                                    } else {
                                      return /* () */0;
                                    }
                                  } else {
                                    exit$5 = 2;
                                  }
                                  if (exit$5 === 2) {
                                    if (non_aliasable(p1$1, decl)) {
                                      exit$4 = 1;
                                    } else {
                                      return /* () */0;
                                    }
                                  }
                                  
                                }
                              } else if (match$4.tag) {
                                if (typeof match$5 === "number") {
                                  if (match$5) {
                                    throw [
                                          Unify,
                                          /* [] */0
                                        ];
                                  } else {
                                    exit$4 = 1;
                                  }
                                } else if (match$5.tag) {
                                  mcomp_list(type_pairs$1, env$1, tl1, tl2);
                                  var type_pairs$2 = type_pairs$1;
                                  var env$2 = env$1;
                                  var xs = match$4[0];
                                  var ys = match$5[0];
                                  var _x = xs;
                                  var _y = ys;
                                  while(true) {
                                    var y = _y;
                                    var x = _x;
                                    if (x) {
                                      if (y) {
                                        var c2 = y[0];
                                        var c1 = x[0];
                                        mcomp_type_option(type_pairs$2, env$2, c1[/* cd_res */2], c2[/* cd_res */2]);
                                        mcomp_list(type_pairs$2, env$2, c1[/* cd_args */1], c2[/* cd_args */1]);
                                        if (c1[/* cd_id */0][/* name */1] === c2[/* cd_id */0][/* name */1]) {
                                          _y = y[1];
                                          _x = x[1];
                                          continue ;
                                          
                                        } else {
                                          throw [
                                                Unify,
                                                /* [] */0
                                              ];
                                        }
                                      } else {
                                        throw [
                                              Unify,
                                              /* [] */0
                                            ];
                                      }
                                    } else if (y) {
                                      throw [
                                            Unify,
                                            /* [] */0
                                          ];
                                    } else {
                                      return /* () */0;
                                    }
                                  };
                                } else {
                                  throw [
                                        Unify,
                                        /* [] */0
                                      ];
                                }
                              } else if (typeof match$5 === "number") {
                                if (match$5) {
                                  throw [
                                        Unify,
                                        /* [] */0
                                      ];
                                } else {
                                  exit$4 = 1;
                                }
                              } else if (match$5.tag) {
                                throw [
                                      Unify,
                                      /* [] */0
                                    ];
                              } else if (Caml_obj.caml_equal(match$4[1], match$5[1])) {
                                mcomp_list(type_pairs$1, env$1, tl1, tl2);
                                return mcomp_record_description(type_pairs$1, env$1)(match$4[0], match$5[0]);
                              } else {
                                throw [
                                      Unify,
                                      /* [] */0
                                    ];
                              }
                              if (exit$4 === 1) {
                                if (typeof match$5 === "number") {
                                  if (match$5 !== 0) {
                                    throw [
                                          Unify,
                                          /* [] */0
                                        ];
                                  } else if (non_aliasable(p2, decl$prime)) {
                                    throw [
                                          Unify,
                                          /* [] */0
                                        ];
                                  } else {
                                    return /* () */0;
                                  }
                                } else {
                                  throw [
                                        Unify,
                                        /* [] */0
                                      ];
                                }
                              }
                              
                            }
                          }
                          catch (exn$2){
                            if (exn$2 === Caml_builtin_exceptions.not_found) {
                              return /* () */0;
                            } else {
                              throw exn$2;
                            }
                          }
                        } else {
                          p = p1;
                          exit$2 = 2;
                        }
                        break;
                    case 4 : 
                        if (typeof match$3 === "number") {
                          throw [
                                Unify,
                                /* [] */0
                              ];
                        } else {
                          switch (match$3.tag | 0) {
                            case 3 : 
                                exit$3 = 3;
                                break;
                            case 4 : 
                                return mcomp_fields(type_pairs, env, match$2[0], match$3[0]);
                            default:
                              throw [
                                    Unify,
                                    /* [] */0
                                  ];
                          }
                        }
                        break;
                    case 5 : 
                        if (typeof match$3 === "number") {
                          throw [
                                Unify,
                                /* [] */0
                              ];
                        } else {
                          switch (match$3.tag | 0) {
                            case 3 : 
                                exit$3 = 3;
                                break;
                            case 5 : 
                                return mcomp_fields(type_pairs, env, t1$prime$1, t2$prime$1);
                            default:
                              throw [
                                    Unify,
                                    /* [] */0
                                  ];
                          }
                        }
                        break;
                    case 6 : 
                    case 7 : 
                        exit$3 = 3;
                        break;
                    case 8 : 
                        if (typeof match$3 === "number") {
                          throw [
                                Unify,
                                /* [] */0
                              ];
                        } else {
                          switch (match$3.tag | 0) {
                            case 3 : 
                                exit$3 = 3;
                                break;
                            case 8 : 
                                var type_pairs$3 = type_pairs;
                                var env$3 = env;
                                var row1 = match$2[0];
                                var row2 = match$3[0];
                                var row1$1 = row_repr_aux(/* [] */0, row1);
                                var row2$1 = row_repr_aux(/* [] */0, row2);
                                var match$6 = merge_row_fields(row1$1[/* row_fields */0], row2$1[/* row_fields */0]);
                                var cannot_erase = function (param) {
                                  var match = row_field_repr_aux(/* [] */0, param[1]);
                                  if (typeof match === "number" || match.tag) {
                                    return /* false */0;
                                  } else {
                                    return /* true */1;
                                  }
                                };
                                if (row1$1[/* row_closed */3] && List.exists(cannot_erase, match$6[1]) || row2$1[/* row_closed */3] && List.exists(cannot_erase, match$6[0])) {
                                  throw [
                                        Unify,
                                        /* [] */0
                                      ];
                                }
                                return List.iter((function(type_pairs$3,env$3){
                                          return function (param) {
                                            var match = row_field_repr_aux(/* [] */0, param[1]);
                                            var match$1 = row_field_repr_aux(/* [] */0, param[2]);
                                            var exit = 0;
                                            var exit$1 = 0;
                                            if (typeof match === "number") {
                                              exit$1 = 2;
                                            } else if (match.tag) {
                                              var exit$2 = 0;
                                              if (match[0] !== 0) {
                                                exit$2 = 3;
                                              } else if (typeof match$1 === "number") {
                                                exit$2 = 3;
                                              } else if (match$1.tag) {
                                                exit$2 = 3;
                                              } else {
                                                var match$2 = match$1[0];
                                                if (match$2) {
                                                  var t2 = match$2[0];
                                                  return List.iter((function (param) {
                                                                return mcomp(type_pairs$3, env$3, t2, param);
                                                              }), match[1]);
                                                } else {
                                                  exit$2 = 3;
                                                }
                                              }
                                              if (exit$2 === 3) {
                                                if (match[1]) {
                                                  exit$1 = 2;
                                                } else {
                                                  exit = 1;
                                                }
                                              }
                                              
                                            } else {
                                              var match$3 = match[0];
                                              if (match$3) {
                                                var t1 = match$3[0];
                                                if (typeof match$1 === "number") {
                                                  throw [
                                                        Unify,
                                                        /* [] */0
                                                      ];
                                                } else if (match$1.tag) {
                                                  if (match$1[0] !== 0) {
                                                    throw [
                                                          Unify,
                                                          /* [] */0
                                                        ];
                                                  } else {
                                                    return List.iter((function (param) {
                                                                  return mcomp(type_pairs$3, env$3, t1, param);
                                                                }), match$1[1]);
                                                  }
                                                } else {
                                                  var match$4 = match$1[0];
                                                  if (match$4) {
                                                    return mcomp(type_pairs$3, env$3, t1, match$4[0]);
                                                  } else {
                                                    throw [
                                                          Unify,
                                                          /* [] */0
                                                        ];
                                                  }
                                                }
                                              } else if (typeof match$1 === "number") {
                                                throw [
                                                      Unify,
                                                      /* [] */0
                                                    ];
                                              } else if (match$1.tag) {
                                                if (match$1[1]) {
                                                  throw [
                                                        Unify,
                                                        /* [] */0
                                                      ];
                                                } else {
                                                  return /* () */0;
                                                }
                                              } else if (match$1[0]) {
                                                throw [
                                                      Unify,
                                                      /* [] */0
                                                    ];
                                              } else {
                                                return /* () */0;
                                              }
                                            }
                                            if (exit$1 === 2) {
                                              if (typeof match$1 === "number") {
                                                return /* () */0;
                                              } else if (match$1.tag) {
                                                return /* () */0;
                                              } else if (match$1[0]) {
                                                exit = 1;
                                              } else {
                                                throw [
                                                      Unify,
                                                      /* [] */0
                                                    ];
                                              }
                                            }
                                            if (exit === 1) {
                                              var exit$3 = 0;
                                              if (typeof match === "number") {
                                                exit$3 = 2;
                                              } else if (match[0] !== 0) {
                                                exit$3 = 2;
                                              } else {
                                                return /* () */0;
                                              }
                                              if (exit$3 === 2) {
                                                if (typeof match$1 === "number") {
                                                  return /* () */0;
                                                } else if (match$1.tag) {
                                                  return /* () */0;
                                                } else if (match$1[0]) {
                                                  throw [
                                                        Unify,
                                                        /* [] */0
                                                      ];
                                                } else {
                                                  return /* () */0;
                                                }
                                              }
                                              
                                            }
                                            
                                          }
                                          }(type_pairs$3,env$3)), match$6[2]);
                            default:
                              throw [
                                    Unify,
                                    /* [] */0
                                  ];
                          }
                        }
                        break;
                    case 9 : 
                        if (typeof match$3 === "number") {
                          throw [
                                Unify,
                                /* [] */0
                              ];
                        } else {
                          switch (match$3.tag | 0) {
                            case 3 : 
                                exit$3 = 3;
                                break;
                            case 9 : 
                                return unify_univar(t1$prime$1, t2$prime$1, univar_pairs[0]);
                            default:
                              throw [
                                    Unify,
                                    /* [] */0
                                  ];
                          }
                        }
                        break;
                    case 10 : 
                        var tl1$1 = match$2[1];
                        var t1$2 = match$2[0];
                        var exit$6 = 0;
                        if (tl1$1) {
                          exit$6 = 4;
                        } else if (typeof match$3 === "number") {
                          throw [
                                Unify,
                                /* [] */0
                              ];
                        } else {
                          switch (match$3.tag | 0) {
                            case 3 : 
                                exit$3 = 3;
                                break;
                            case 10 : 
                                if (match$3[1]) {
                                  exit$6 = 4;
                                } else {
                                  _t2 = match$3[0];
                                  _t1 = t1$2;
                                  continue ;
                                  
                                }
                                break;
                            default:
                              throw [
                                    Unify,
                                    /* [] */0
                                  ];
                          }
                        }
                        if (exit$6 === 4) {
                          if (typeof match$3 === "number") {
                            throw [
                                  Unify,
                                  /* [] */0
                                ];
                          } else {
                            switch (match$3.tag | 0) {
                              case 3 : 
                                  exit$3 = 3;
                                  break;
                              case 10 : 
                                  return enter_poly(env, univar_pairs, t1$2, tl1$1, match$3[0], match$3[1], (function (param, param$1) {
                                                return mcomp(type_pairs, env, param, param$1);
                                              }));
                              default:
                                throw [
                                      Unify,
                                      /* [] */0
                                    ];
                            }
                          }
                        }
                        break;
                    case 11 : 
                        if (typeof match$3 === "number") {
                          throw [
                                Unify,
                                /* [] */0
                              ];
                        } else {
                          switch (match$3.tag | 0) {
                            case 3 : 
                                exit$3 = 3;
                                break;
                            case 11 : 
                                return /* () */0;
                            default:
                              throw [
                                    Unify,
                                    /* [] */0
                                  ];
                          }
                        }
                        break;
                    
                  }
                }
                if (exit$3 === 3) {
                  if (typeof match$3 === "number") {
                    throw [
                          Unify,
                          /* [] */0
                        ];
                  } else if (match$3.tag === 3) {
                    p = match$3[0];
                    exit$2 = 2;
                  } else {
                    throw [
                          Unify,
                          /* [] */0
                        ];
                  }
                }
                if (exit$2 === 2) {
                  try {
                    var decl$1 = find_type_full(p, env)[0];
                    if (non_aliasable(p, decl$1) || is_datatype(decl$1)) {
                      throw [
                            Unify,
                            /* [] */0
                          ];
                    } else {
                      return 0;
                    }
                  }
                  catch (exn$3){
                    if (exn$3 === Caml_builtin_exceptions.not_found) {
                      return /* () */0;
                    } else {
                      throw exn$3;
                    }
                  }
                }
                
              } else {
                throw exn;
              }
            }
          }
        }
        
      }
    }
  };
}

function mcomp_list(type_pairs, env, tl1, tl2) {
  if (List.length(tl1) !== List.length(tl2)) {
    throw [
          Unify,
          /* [] */0
        ];
  }
  return List.iter2((function (param, param$1) {
                return mcomp(type_pairs, env, param, param$1);
              }), tl1, tl2);
}

function mcomp_fields(type_pairs, env, ty1, ty2) {
  if (!(concrete_object(ty1) && concrete_object(ty2))) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "ctype.ml",
            2096,
            59
          ]
        ];
  }
  var match = flatten_fields(ty2);
  var match$1 = flatten_fields(ty1);
  var match$2 = associate_fields(match$1[0], match[0]);
  mcomp(type_pairs, env, match$1[1], match[1]);
  if (match$2[1] !== /* [] */0 && object_row(ty1)[/* desc */0] === /* Tnil */0 || match$2[2] !== /* [] */0 && object_row(ty2)[/* desc */0] === /* Tnil */0) {
    throw [
          Unify,
          /* [] */0
        ];
  }
  return List.iter((function (param) {
                mcomp_kind(param[1], param[3]);
                return mcomp(type_pairs, env, param[2], param[4]);
              }), match$2[0]);
}

function mcomp_kind(k1, k2) {
  var k1$1 = field_kind_repr(k1);
  var k2$1 = field_kind_repr(k2);
  if (typeof k1$1 === "number") {
    if (k1$1 !== 0) {
      throw [
            Unify,
            /* [] */0
          ];
    } else if (typeof k2$1 === "number") {
      if (k2$1 !== 0) {
        throw [
              Unify,
              /* [] */0
            ];
      } else {
        return /* () */0;
      }
    } else {
      throw [
            Unify,
            /* [] */0
          ];
    }
  } else if (typeof k2$1 === "number") {
    throw [
          Unify,
          /* [] */0
        ];
  } else {
    return /* () */0;
  }
}

function mcomp_type_option(type_pairs, env, t, t$prime) {
  if (t) {
    if (t$prime) {
      return mcomp(type_pairs, env, t[0], t$prime[0]);
    } else {
      throw [
            Unify,
            /* [] */0
          ];
    }
  } else if (t$prime) {
    throw [
          Unify,
          /* [] */0
        ];
  } else {
    return /* () */0;
  }
}

function mcomp_record_description(type_pairs, env) {
  var iter = function (_x, _y) {
    while(true) {
      var y = _y;
      var x = _x;
      if (x) {
        if (y) {
          var l2 = y[0];
          var l1 = x[0];
          mcomp(type_pairs, env, l1[/* ld_type */2], l2[/* ld_type */2]);
          if (l1[/* ld_id */0][/* name */1] === l2[/* ld_id */0][/* name */1] && Caml_obj.caml_equal(l1[/* ld_mutable */1], l2[/* ld_mutable */1])) {
            _y = y[1];
            _x = x[1];
            continue ;
            
          } else {
            throw [
                  Unify,
                  /* [] */0
                ];
          }
        } else {
          throw [
                Unify,
                /* [] */0
              ];
        }
      } else if (y) {
        throw [
              Unify,
              /* [] */0
            ];
      } else {
        return /* () */0;
      }
    };
  };
  return iter;
}

function mcomp$1(env, t1, t2) {
  return mcomp(Curry._1(TypePairs[/* create */0], 4), env, t1, t2);
}

function find_lowest_level(ty) {
  var lowest = [100000000];
  var find = function (ty) {
    var ty$1 = repr(ty);
    if (ty$1[/* level */1] >= 0) {
      if (ty$1[/* level */1] < lowest[0]) {
        lowest[0] = ty$1[/* level */1];
      }
      ty$1[/* level */1] = pivot_level - ty$1[/* level */1] | 0;
      return iter_type_expr(find, ty$1);
    } else {
      return 0;
    }
  };
  find(ty);
  unmark_type(ty);
  return lowest[0];
}

function find_newtype_level(env, path) {
  try {
    var match = find_type_full(path, env)[0][/* type_newtype_level */6];
    if (match) {
      return match[0];
    } else {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "ctype.ml",
              2227,
              12
            ]
          ];
    }
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "ctype.ml",
              2228,
              20
            ]
          ];
    } else {
      throw exn;
    }
  }
}

function add_gadt_equation(env, source, destination) {
  var destination$1 = duplicate_type(destination);
  var source_lev = find_newtype_level(env[0], /* Pident */Block.__(0, [source]));
  var decl = new_declaration(/* Some */[source_lev], /* Some */[destination$1]);
  var newtype_level = get_newtype_level(/* () */0);
  env[0] = add_local_constraint(source, decl, newtype_level, env[0]);
  return cleanup_abbrev(/* () */0);
}

var unify_eq_set = Curry._1(TypePairs[/* create */0], 11);

function order_type_pair(t1, t2) {
  if (t1[/* id */2] <= t2[/* id */2]) {
    return /* tuple */[
            t1,
            t2
          ];
  } else {
    return /* tuple */[
            t2,
            t1
          ];
  }
}

function add_type_equality(t1, t2) {
  return Curry._3(TypePairs[/* add */4], unify_eq_set, order_type_pair(t1, t2), /* () */0);
}

function eq_package_path(env, p1, p2) {
  if (same(p1, p2)) {
    return /* true */1;
  } else {
    return same(normalize_package_path(env, p1), normalize_package_path(env, p2));
  }
}

var nondep_type$prime = [(function (_, _$1, _$2) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "ctype.ml",
              2250,
              37
            ]
          ];
    })];

var package_subtype = [(function (_, _$1, _$2, _$3, _$4, _$5, _$6) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "ctype.ml",
              2251,
              48
            ]
          ];
    })];

function concat_longident(lid1, param) {
  switch (param.tag | 0) {
    case 0 : 
        return /* Ldot */Block.__(1, [
                  lid1,
                  param[0]
                ]);
    case 1 : 
        return /* Ldot */Block.__(1, [
                  concat_longident(lid1, param[0]),
                  param[1]
                ]);
    case 2 : 
        return /* Lapply */Block.__(2, [
                  concat_longident(lid1, param[0]),
                  param[1]
                ]);
    
  }
}

function nondep_instance(env, level, id, ty) {
  var ty$1 = Curry._3(nondep_type$prime[0], env, id, ty);
  if (level === 100000000) {
    return duplicate_type(ty$1);
  } else {
    var old = current_level[0];
    current_level[0] = level;
    var ty$2 = instance(/* None */0, env, ty$1);
    current_level[0] = old;
    return ty$2;
  }
}

function complete_type_list($staropt$star, env, nl1, lv2, mty2, nl2, tl2) {
  var allow_absent = $staropt$star ? $staropt$star[0] : /* false */0;
  var id2 = create("Pkg");
  var env$prime = add_module$1(/* None */0, id2, mty2, env);
  var complete = function (_nl1, ntl2) {
    while(true) {
      var nl1 = _nl1;
      if (nl1) {
        var nl = nl1[1];
        var n = nl1[0];
        var exit = 0;
        if (ntl2) {
          var nt2 = ntl2[0];
          var n2 = nt2[0];
          if (Caml_obj.caml_greaterequal(n, n2)) {
            return /* :: */[
                    nt2,
                    complete(Caml_obj.caml_equal(n, n2) ? nl : nl1, ntl2[1])
                  ];
          } else {
            exit = 1;
          }
        } else {
          exit = 1;
        }
        if (exit === 1) {
          try {
            var match = lookup_type$1(concat_longident(/* Lident */Block.__(0, ["Pkg"]), n), env$prime);
            var decl = match[1];
            if (decl[/* type_arity */1] !== 0) {
              throw Pervasives.Exit;
            } else {
              var match$1 = decl[/* type_kind */2];
              if (typeof match$1 === "number") {
                if (match$1 !== 0) {
                  throw Pervasives.Exit;
                } else if (decl[/* type_private */3] !== 0) {
                  var match$2 = decl[/* type_manifest */4];
                  if (match$2) {
                    return /* :: */[
                            /* tuple */[
                              n,
                              nondep_instance(env$prime, lv2, id2, match$2[0])
                            ],
                            complete(nl, ntl2)
                          ];
                  } else if (allow_absent) {
                    return complete(nl, ntl2);
                  } else {
                    throw Pervasives.Exit;
                  }
                } else {
                  throw Pervasives.Exit;
                }
              } else {
                throw Pervasives.Exit;
              }
            }
          }
          catch (exn){
            if (exn === Caml_builtin_exceptions.not_found) {
              if (allow_absent) {
                _nl1 = nl;
                continue ;
                
              } else if (exn === Pervasives.Exit) {
                throw Caml_builtin_exceptions.not_found;
              } else {
                throw exn;
              }
            } else if (exn === Pervasives.Exit) {
              throw Caml_builtin_exceptions.not_found;
            } else {
              throw exn;
            }
          }
        }
        
      } else {
        return ntl2;
      }
    };
  };
  return complete(nl1, List.combine(nl2, tl2));
}

function unify_package(env, unify_list, _, p1, n1, tl1, lv2, p2, n2, tl2) {
  var ntl2 = complete_type_list(/* None */0, env, n1, lv2, /* Mty_ident */Block.__(0, [p2]), n2, tl2);
  var ntl1 = complete_type_list(/* None */0, env, n2, lv2, /* Mty_ident */Block.__(0, [p1]), n1, tl1);
  Curry._2(unify_list, List.map((function (prim) {
              return prim[1];
            }), ntl1), List.map((function (prim) {
              return prim[1];
            }), ntl2));
  if (eq_package_path(env, p1, p2) || Curry._7(package_subtype[0], env, p1, n1, tl1, p2, n2, tl2) && Curry._7(package_subtype[0], env, p2, n2, tl2, p1, n1, tl1)) {
    return /* () */0;
  } else {
    throw Caml_builtin_exceptions.not_found;
  }
}

function unify_eq(_, t1, t2) {
  if (t1 === t2) {
    return /* true */1;
  } else {
    var match = umode[0];
    if (match !== 0) {
      try {
        Curry._2(TypePairs[/* find */6], unify_eq_set, order_type_pair(t1, t2));
        return /* true */1;
      }
      catch (exn){
        if (exn === Caml_builtin_exceptions.not_found) {
          return /* false */0;
        } else {
          throw exn;
        }
      }
    } else {
      return /* false */0;
    }
  }
}

function unify(env, t1, t2) {
  if (t1 === t2) {
    return /* () */0;
  } else {
    var t1$1 = repr(t1);
    var t2$1 = repr(t2);
    if (unify_eq(env[0], t1$1, t2$1)) {
      return /* () */0;
    } else {
      var reset_tracing = check_trace_gadt_instances(env[0]);
      try {
        type_changed[0] = /* true */1;
        var match = t1$1[/* desc */0];
        var match$1 = t2$1[/* desc */0];
        var exit = 0;
        if (typeof match === "number") {
          exit = 1;
        } else {
          switch (match.tag | 0) {
            case 0 : 
                var exit$1 = 0;
                if (typeof match$1 === "number" || !(match$1.tag === 3 && deep_occur(t1$1, t2$1))) {
                  exit$1 = 2;
                } else {
                  unify2(env, t1$1, t2$1);
                }
                if (exit$1 === 2) {
                  occur(env[0], t1$1, t2$1);
                  occur_univar(env[0], t2$1);
                  link_type(t1$1, t2$1);
                  update_level(env[0], t1$1[/* level */1], t2$1);
                }
                break;
            case 3 : 
                var p1 = match[0];
                if (typeof match$1 === "number") {
                  unify2(env, t1$1, t2$1);
                } else {
                  switch (match$1.tag | 0) {
                    case 0 : 
                        if (deep_occur(t2$1, t1$1)) {
                          unify2(env, t1$1, t2$1);
                        } else {
                          exit = 1;
                        }
                        break;
                    case 3 : 
                        if (match[1]) {
                          unify2(env, t1$1, t2$1);
                        } else if (match$1[1]) {
                          unify2(env, t1$1, t2$1);
                        } else {
                          var p2 = match$1[0];
                          if (same(p1, p2) && !(has_cached_expansion(p1, match[2][0]) || has_cached_expansion(p2, match$1[2][0]))) {
                            update_level(env[0], t1$1[/* level */1], t2$1);
                            link_type(t1$1, t2$1);
                          } else if (env[0][/* local_constraints */11] && is_newtype(env[0], p1) && is_newtype(env[0], p2)) {
                            try {
                              if (Caml_obj.caml_lessthan(find_newtype_level(env[0], p1), find_newtype_level(env[0], p2))) {
                                unify(env, t1$1, try_expand_once(env[0], t2$1));
                              } else {
                                unify(env, try_expand_once(env[0], t1$1), t2$1);
                              }
                            }
                            catch (exn){
                              if (exn === Cannot_expand) {
                                unify2(env, t1$1, t2$1);
                              } else {
                                throw exn;
                              }
                            }
                          } else {
                            unify2(env, t1$1, t2$1);
                          }
                        }
                        break;
                    default:
                      unify2(env, t1$1, t2$1);
                  }
                }
                break;
            case 9 : 
                if (typeof match$1 === "number") {
                  unify2(env, t1$1, t2$1);
                } else {
                  switch (match$1.tag | 0) {
                    case 0 : 
                        exit = 1;
                        break;
                    case 9 : 
                        unify_univar(t1$1, t2$1, univar_pairs[0]);
                        update_level(env[0], t1$1[/* level */1], t2$1);
                        link_type(t1$1, t2$1);
                        break;
                    default:
                      unify2(env, t1$1, t2$1);
                  }
                }
                break;
            default:
              exit = 1;
          }
        }
        if (exit === 1) {
          if (typeof match$1 === "number" || match$1.tag) {
            unify2(env, t1$1, t2$1);
          } else {
            occur(env[0], t2$1, t1$1);
            occur_univar(env[0], t1$1);
            link_type(t2$1, t1$1);
            update_level(env[0], t2$1[/* level */1], t1$1);
          }
        }
        return reset_trace_gadt_instances(reset_tracing);
      }
      catch (raw_exn){
        var exn$1 = Js_exn.internalToOCamlException(raw_exn);
        if (exn$1[0] === Unify) {
          reset_trace_gadt_instances(reset_tracing);
          throw [
                Unify,
                /* :: */[
                  /* tuple */[
                    t1$1,
                    t2$1
                  ],
                  exn$1[1]
                ]
              ];
        } else {
          throw exn$1;
        }
      }
    }
  }
}

function unify3(env, t1, t1$prime, t2, t2$prime) {
  var d1 = t1$prime[/* desc */0];
  var d2 = t2$prime[/* desc */0];
  var create_recursion = +(t2 !== t2$prime) && deep_occur(t1$prime, t2);
  var exit = 0;
  var exit$1 = 0;
  if (typeof d1 === "number") {
    exit$1 = 2;
  } else {
    switch (d1.tag | 0) {
      case 0 : 
          occur(env[0], t1$prime, t2);
          occur_univar(env[0], t2);
          return link_type(t1$prime, t2);
      case 5 : 
          if (typeof d2 === "number") {
            exit = 1;
          } else {
            switch (d2.tag | 0) {
              case 0 : 
                  exit$1 = 2;
                  break;
              case 5 : 
                  return unify_fields(env, t1$prime, t2$prime);
              default:
                exit = 1;
            }
          }
          break;
      case 9 : 
          if (typeof d2 === "number") {
            exit = 1;
          } else {
            switch (d2.tag | 0) {
              case 0 : 
                  exit$1 = 2;
                  break;
              case 9 : 
                  unify_univar(t1$prime, t2$prime, univar_pairs[0]);
                  return link_type(t1$prime, t2$prime);
              default:
                exit = 1;
            }
          }
          break;
      default:
        exit$1 = 2;
    }
  }
  if (exit$1 === 2) {
    if (typeof d2 === "number") {
      exit = 1;
    } else if (d2.tag) {
      exit = 1;
    } else {
      occur(env[0], t2$prime, t1);
      occur_univar(env[0], t1);
      return link_type(t2$prime, t1);
    }
  }
  if (exit === 1) {
    var match = umode[0];
    if (match !== 0) {
      add_type_equality(t1$prime, t2$prime);
    } else {
      occur(env[0], t1$prime, t2$prime);
      link_type(t1$prime, t2);
    }
    try {
      var exit$2 = 0;
      var f;
      var kind;
      var rem;
      var exit$3 = 0;
      var exit$4 = 0;
      if (typeof d1 === "number") {
        if (d1) {
          exit$4 = 5;
        } else if (typeof d2 === "number") {
          if (d2 !== 0) {
            throw [
                  Unify,
                  /* [] */0
                ];
          }
          
        } else {
          switch (d2.tag | 0) {
            case 3 : 
                exit$4 = 5;
                break;
            case 5 : 
                f = d2[0];
                kind = d2[1];
                rem = d2[3];
                exit$2 = 3;
                break;
            default:
              throw [
                    Unify,
                    /* [] */0
                  ];
          }
        }
      } else {
        switch (d1.tag | 0) {
          case 1 : 
              var l1 = d1[0];
              if (typeof d2 === "number") {
                throw [
                      Unify,
                      /* [] */0
                    ];
              } else {
                switch (d2.tag | 0) {
                  case 1 : 
                      var l2 = d2[0];
                      if (l1 === l2 || classic[0] && !(is_optional(l1) || is_optional(l2))) {
                        unify(env, d1[1], d2[1]);
                        unify(env, d1[2], d2[2]);
                        var match$1 = commu_repr(d1[3]);
                        var match$2 = commu_repr(d2[3]);
                        if (typeof match$1 === "number") {
                          if (typeof match$2 === "number") {
                            
                          } else {
                            set_commu(match$2[0], match$1);
                          }
                        } else {
                          set_commu(match$1[0], match$2);
                        }
                      } else {
                        throw [
                              Unify,
                              /* [] */0
                            ];
                      }
                      break;
                  case 3 : 
                      exit$4 = 5;
                      break;
                  default:
                    throw [
                          Unify,
                          /* [] */0
                        ];
                }
              }
              break;
          case 2 : 
              if (typeof d2 === "number") {
                throw [
                      Unify,
                      /* [] */0
                    ];
              } else {
                switch (d2.tag | 0) {
                  case 2 : 
                      unify_list(env, d1[0], d2[0]);
                      break;
                  case 3 : 
                      exit$4 = 5;
                      break;
                  default:
                    throw [
                          Unify,
                          /* [] */0
                        ];
                }
              }
              break;
          case 3 : 
              var p1 = d1[0];
              var exit$5 = 0;
              if (typeof d2 === "number") {
                exit$5 = 6;
              } else if (d2.tag === 3) {
                var tl2 = d2[1];
                var tl1 = d1[1];
                if (same(p1, d2[0])) {
                  if (umode[0] === /* Expression */0 || !generate_equations[0]) {
                    unify_list(env, tl1, tl2);
                  } else if (assume_injective[0]) {
                    set_mode_pattern(/* true */1, /* false */0, (function () {
                            return unify_list(env, tl1, tl2);
                          }));
                  } else {
                    var partial_arg = env[0];
                    if (in_current_module(p1) || List.exists((function (param) {
                              return expands_to_datatype(partial_arg, param);
                            }), /* :: */[
                            t1$prime,
                            /* :: */[
                              t1,
                              /* :: */[
                                t2,
                                /* [] */0
                              ]
                            ]
                          ])) {
                      unify_list(env, tl1, tl2);
                    } else {
                      var inj;
                      try {
                        inj = List.map(Curry._1(Types_003[/* mem */8], /* Inj */3), find_type_full(p1, env[0])[0][/* type_variance */5]);
                      }
                      catch (exn){
                        if (exn === Caml_builtin_exceptions.not_found) {
                          inj = List.map((function () {
                                  return /* false */0;
                                }), tl1);
                        } else {
                          throw exn;
                        }
                      }
                      List.iter2((function (i, param) {
                              var t2 = param[1];
                              var t1 = param[0];
                              if (i) {
                                return unify(env, t1, t2);
                              } else {
                                return set_mode_pattern(/* false */0, /* false */0, (function () {
                                              var snap = snapshot(/* () */0);
                                              try {
                                                return unify(env, t1, t2);
                                              }
                                              catch (raw_exn){
                                                var exn = Js_exn.internalToOCamlException(raw_exn);
                                                if (exn[0] === Unify) {
                                                  backtrack(snap);
                                                  reify(env, t1);
                                                  return reify(env, t2);
                                                } else {
                                                  throw exn;
                                                }
                                              }
                                            }));
                              }
                            }), inj, List.combine(tl1, tl2));
                    }
                  }
                } else {
                  exit$5 = 6;
                }
              } else {
                exit$5 = 6;
              }
              if (exit$5 === 6) {
                switch (p1.tag | 0) {
                  case 0 : 
                      if (d1[1]) {
                        exit$4 = 5;
                      } else {
                        var p = p1[0];
                        var exit$6 = 0;
                        if (typeof d2 === "number") {
                          exit$6 = 7;
                        } else if (d2.tag === 3) {
                          var path$prime = d2[0];
                          switch (path$prime.tag | 0) {
                            case 0 : 
                                if (d2[1]) {
                                  exit$6 = 7;
                                } else if (is_newtype(env[0], p1) && is_newtype(env[0], path$prime) && generate_equations[0]) {
                                  var match$3 = Caml_obj.caml_greaterthan(find_newtype_level(env[0], p1), find_newtype_level(env[0], path$prime)) ? /* tuple */[
                                      p,
                                      t2$prime
                                    ] : /* tuple */[
                                      path$prime[0],
                                      t1$prime
                                    ];
                                  add_gadt_equation(env, match$3[0], match$3[1]);
                                } else {
                                  exit$6 = 7;
                                }
                                break;
                            case 1 : 
                            case 2 : 
                                exit$6 = 7;
                                break;
                            
                          }
                        } else {
                          exit$6 = 7;
                        }
                        if (exit$6 === 7) {
                          if (is_newtype(env[0], p1) && generate_equations[0]) {
                            reify(env, t2$prime);
                            add_gadt_equation(env, p, t2$prime);
                          } else {
                            exit$4 = 5;
                          }
                        }
                        
                      }
                      break;
                  case 1 : 
                  case 2 : 
                      exit$4 = 5;
                      break;
                  
                }
              }
              break;
          case 4 : 
              var nm1 = d1[1];
              if (typeof d2 === "number") {
                throw [
                      Unify,
                      /* [] */0
                    ];
              } else {
                switch (d2.tag | 0) {
                  case 3 : 
                      exit$4 = 5;
                      break;
                  case 4 : 
                      unify_fields(env, d1[0], d2[0]);
                      var match$4 = repr(t2$prime)[/* desc */0];
                      if (typeof match$4 !== "number") {
                        if (match$4.tag === 4) {
                          var nm2 = match$4[1];
                          var match$5 = nm2[/* contents */0];
                          if (match$5) {
                            var match$6 = match$5[0][1];
                            if (match$6) {
                              var match$7 = repr(match$6[0])[/* desc */0];
                              var $js;
                              if (typeof match$7 === "number") {
                                $js = match$7 ? /* false */0 : /* true */1;
                              } else {
                                switch (match$7.tag | 0) {
                                  case 0 : 
                                  case 9 : 
                                      $js = /* true */1;
                                      break;
                                  default:
                                    $js = /* false */0;
                                }
                              }
                              if (!$js) {
                                set_name(nm2, nm1[0]);
                              }
                              
                            } else {
                              set_name(nm2, nm1[0]);
                            }
                          } else {
                            set_name(nm2, nm1[0]);
                          }
                        }
                        
                      }
                      break;
                  default:
                    throw [
                          Unify,
                          /* [] */0
                        ];
                }
              }
              break;
          case 5 : 
              if (typeof d2 === "number") {
                if (d2) {
                  throw [
                        Unify,
                        /* [] */0
                      ];
                } else {
                  f = d1[0];
                  kind = d1[1];
                  rem = d1[3];
                  exit$2 = 3;
                }
              } else if (d2.tag === 3) {
                exit$4 = 5;
              } else {
                throw [
                      Unify,
                      /* [] */0
                    ];
              }
              break;
          case 8 : 
              var row1 = d1[0];
              if (typeof d2 === "number") {
                throw [
                      Unify,
                      /* [] */0
                    ];
              } else {
                switch (d2.tag | 0) {
                  case 3 : 
                      exit$4 = 5;
                      break;
                  case 8 : 
                      var row2 = d2[0];
                      if (umode[0]) {
                        var snap = snapshot(/* () */0);
                        try {
                          unify_row(env, row1, row2);
                        }
                        catch (raw_exn){
                          var exn$1 = Js_exn.internalToOCamlException(raw_exn);
                          if (exn$1[0] === Unify) {
                            backtrack(snap);
                            reify(env, t1$prime);
                            reify(env, t2$prime);
                            if (generate_equations[0]) {
                              mcomp$1(env[0], t1$prime, t2$prime);
                            }
                            
                          } else {
                            throw exn$1;
                          }
                        }
                      } else {
                        unify_row(env, row1, row2);
                      }
                      break;
                  default:
                    throw [
                          Unify,
                          /* [] */0
                        ];
                }
              }
              break;
          case 10 : 
              var tl1$1 = d1[1];
              var t1$1 = d1[0];
              var exit$7 = 0;
              if (tl1$1) {
                exit$7 = 6;
              } else if (typeof d2 === "number") {
                throw [
                      Unify,
                      /* [] */0
                    ];
              } else {
                switch (d2.tag | 0) {
                  case 3 : 
                      exit$4 = 5;
                      break;
                  case 10 : 
                      if (d2[1]) {
                        exit$7 = 6;
                      } else {
                        unify(env, t1$1, d2[0]);
                      }
                      break;
                  default:
                    throw [
                          Unify,
                          /* [] */0
                        ];
                }
              }
              if (exit$7 === 6) {
                if (typeof d2 === "number") {
                  throw [
                        Unify,
                        /* [] */0
                      ];
                } else {
                  switch (d2.tag | 0) {
                    case 3 : 
                        exit$4 = 5;
                        break;
                    case 10 : 
                        enter_poly(env[0], univar_pairs, t1$1, tl1$1, d2[0], d2[1], (function (param, param$1) {
                                return unify(env, param, param$1);
                              }));
                        break;
                    default:
                      throw [
                            Unify,
                            /* [] */0
                          ];
                  }
                }
              }
              break;
          case 11 : 
              var tl1$2 = d1[2];
              if (typeof d2 === "number") {
                throw [
                      Unify,
                      /* [] */0
                    ];
              } else {
                switch (d2.tag | 0) {
                  case 3 : 
                      exit$4 = 5;
                      break;
                  case 11 : 
                      var tl2$1 = d2[2];
                      try {
                        unify_package(env[0], (function (param, param$1) {
                                return unify_list(env, param, param$1);
                              }), t1[/* level */1], d1[0], d1[1], tl1$2, t2[/* level */1], d2[0], d2[1], tl2$1);
                      }
                      catch (exn$2){
                        if (exn$2 === Caml_builtin_exceptions.not_found) {
                          if (!umode[0]) {
                            throw [
                                  Unify,
                                  /* [] */0
                                ];
                          }
                          List.iter((function (param) {
                                  return reify(env, param);
                                }), Pervasives.$at(tl1$2, tl2$1));
                        } else {
                          throw exn$2;
                        }
                      }
                      break;
                  default:
                    throw [
                          Unify,
                          /* [] */0
                        ];
                }
              }
              break;
          default:
            exit$4 = 5;
        }
      }
      if (exit$4 === 5) {
        if (typeof d2 === "number") {
          exit$3 = 4;
        } else if (d2.tag === 3) {
          var path = d2[0];
          switch (path.tag | 0) {
            case 0 : 
                if (d2[1] || !(is_newtype(env[0], path) && generate_equations[0])) {
                  exit$2 = 2;
                } else {
                  reify(env, t1$prime);
                  add_gadt_equation(env, path[0], t1$prime);
                }
                break;
            case 1 : 
            case 2 : 
                exit$2 = 2;
                break;
            
          }
        } else {
          exit$3 = 4;
        }
      }
      if (exit$3 === 4) {
        if (typeof d1 === "number") {
          throw [
                Unify,
                /* [] */0
              ];
        } else if (d1.tag === 3) {
          exit$2 = 2;
        } else {
          throw [
                Unify,
                /* [] */0
              ];
        }
      }
      switch (exit$2) {
        case 2 : 
            if (umode[0] === /* Pattern */1) {
              reify(env, t1$prime);
              reify(env, t2$prime);
              if (generate_equations[0]) {
                mcomp$1(env[0], t1$prime, t2$prime);
              }
              
            } else {
              throw [
                    Unify,
                    /* [] */0
                  ];
            }
            break;
        case 3 : 
            var match$8 = field_kind_repr(kind);
            if (typeof match$8 === "number") {
              throw [
                    Unify,
                    /* [] */0
                  ];
            } else if (f !== dummy_method) {
              set_kind(match$8[0], /* Fabsent */1);
              if (d2) {
                unify(env, newty2(rem[/* level */1], /* Tnil */0), rem);
              } else {
                unify(env, rem, t2$prime);
              }
            } else {
              throw [
                    Unify,
                    /* [] */0
                  ];
            }
            break;
        
      }
      if (create_recursion) {
        var match$9 = t2[/* desc */0];
        if (typeof match$9 === "number") {
          return /* () */0;
        } else if (match$9.tag === 3) {
          forget_abbrev(match$9[2], match$9[0]);
          var t2$prime$prime = expand_head_unif(env[0], t2);
          if (closed_parameterized_type(match$9[1], t2$prime$prime)) {
            return 0;
          } else {
            return link_type(repr(t2), repr(t2$prime));
          }
        } else {
          return /* () */0;
        }
      } else {
        return 0;
      }
    }
    catch (raw_exn$1){
      var exn$3 = Js_exn.internalToOCamlException(raw_exn$1);
      if (exn$3[0] === Unify) {
        t1$prime[/* desc */0] = d1;
        throw [
              Unify,
              exn$3[1]
            ];
      } else {
        throw exn$3;
      }
    }
  }
  
}

function unify2(env, t1, t2) {
  var expand_both = function (_t1$prime$prime, _t2$prime$prime) {
    while(true) {
      var t2$prime$prime = _t2$prime$prime;
      var t1$prime$prime = _t1$prime$prime;
      var t1$prime = expand_head_unif(env[0], t1);
      var t2$prime = expand_head_unif(env[0], t2);
      if (unify_eq(env[0], t1$prime, t1$prime$prime) && unify_eq(env[0], t2$prime, t2$prime$prime)) {
        return /* tuple */[
                t1$prime,
                t2$prime
              ];
      } else {
        _t2$prime$prime = t2$prime;
        _t1$prime$prime = t1$prime;
        continue ;
        
      }
    };
  };
  var match = expand_both(t1, t2);
  var t2$prime = match[1];
  var t1$prime = match[0];
  var lv = Pervasives.min(t1$prime[/* level */1], t2$prime[/* level */1]);
  update_level(env[0], lv, t2);
  update_level(env[0], lv, t1);
  if (unify_eq(env[0], t1$prime, t2$prime)) {
    return /* () */0;
  } else {
    var t1$1 = repr(t1);
    var t2$1 = repr(t2);
    if (trace_gadt_instances[0]) {
      var ilevel = function (t) {
        var match = gadt_instance_level(env[0], t);
        if (match) {
          return match[0];
        } else {
          return 0;
        }
      };
      var lv1 = ilevel(t1$1);
      var lv2 = ilevel(t2$1);
      if (lv1 > lv2) {
        add_gadt_instance_chain(env[0], lv1, t2$1);
      } else if (lv2 > lv1) {
        add_gadt_instance_chain(env[0], lv2, t1$1);
      }
      
    }
    var match$1;
    if (principal[0] && (find_lowest_level(t1$prime) < lv || find_lowest_level(t2$prime) < lv)) {
      var match$2 = t1$1[/* desc */0];
      var $js;
      $js = typeof match$2 === "number" || !(match$2.tag === 3 && !match$2[1]) ? t1$1 : t1$prime;
      var match$3 = t2$1[/* desc */0];
      var $js$1;
      $js$1 = typeof match$3 === "number" || !(match$3.tag === 3 && !match$3[1]) ? t2$1 : t2$prime;
      match$1 = /* tuple */[
        $js,
        $js$1
      ];
    } else {
      match$1 = /* tuple */[
        t1$1,
        t2$1
      ];
    }
    var t2$2 = match$1[1];
    var t1$2 = match$1[0];
    if (unify_eq(env[0], t1$2, t1$prime) || !unify_eq(env[0], t2$2, t2$prime)) {
      return unify3(env, t1$2, t1$prime, t2$2, t2$prime);
    } else {
      try {
        return unify3(env, t2$2, t2$prime, t1$2, t1$prime);
      }
      catch (raw_exn){
        var exn = Js_exn.internalToOCamlException(raw_exn);
        if (exn[0] === Unify) {
          throw [
                Unify,
                List.map((function (param) {
                        return /* tuple */[
                                param[1],
                                param[0]
                              ];
                      }), exn[1])
              ];
        } else {
          throw exn;
        }
      }
    }
  }
}

function make_rowvar(level, use1, rest1, use2, rest2) {
  var set_name = function (ty, name) {
    var match = ty[/* desc */0];
    if (typeof match === "number" || !(!match.tag && !match[0])) {
      return /* () */0;
    } else {
      log_type(ty);
      ty[/* desc */0] = /* Tvar */Block.__(0, [name]);
      return /* () */0;
    }
  };
  var match = rest1[/* desc */0];
  var match$1 = rest2[/* desc */0];
  var name;
  var exit = 0;
  if (typeof match === "number") {
    exit = 1;
  } else if (match.tag) {
    exit = 1;
  } else {
    var name1 = match[0];
    if (name1) {
      var exit$1 = 0;
      if (typeof match$1 === "number") {
        exit$1 = 2;
      } else if (match$1.tag) {
        exit$1 = 2;
      } else {
        var name2 = match$1[0];
        if (name2) {
          name = rest1[/* level */1] <= rest2[/* level */1] ? name1 : name2;
        } else {
          exit$1 = 2;
        }
      }
      if (exit$1 === 2) {
        if (use2) {
          set_name(rest2, name1);
        }
        name = name1;
      }
      
    } else {
      exit = 1;
    }
  }
  if (exit === 1) {
    if (typeof match$1 === "number") {
      name = /* None */0;
    } else if (match$1.tag) {
      name = /* None */0;
    } else {
      var name$1 = match$1[0];
      if (name$1) {
        if (use1) {
          set_name(rest2, name$1);
        }
        name = name$1;
      } else {
        name = /* None */0;
      }
    }
  }
  if (use1) {
    return rest1;
  } else if (use2) {
    return rest2;
  } else {
    return newty2(level, /* Tvar */Block.__(0, [name]));
  }
}

function unify_kind(k1, k2) {
  var k1$1 = field_kind_repr(k1);
  var k2$1 = field_kind_repr(k2);
  if (k1$1 === k2$1) {
    return /* () */0;
  } else {
    var exit = 0;
    if (typeof k1$1 === "number") {
      if (k1$1 !== 0) {
        exit = 1;
      } else if (typeof k2$1 === "number") {
        if (k2$1 !== 0) {
          exit = 1;
        } else {
          return /* () */0;
        }
      } else {
        return set_kind(k2$1[0], k1$1);
      }
    } else {
      var r = k1$1[0];
      if (typeof k2$1 === "number") {
        if (k2$1 !== 0) {
          exit = 1;
        } else {
          return set_kind(r, k2$1);
        }
      } else {
        return set_kind(r, k2$1);
      }
    }
    if (exit === 1) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "ctype.ml",
              2624,
              37
            ]
          ];
    }
    
  }
}

function unify_fields(env, ty1, ty2) {
  var match = flatten_fields(ty1);
  var rest1 = match[1];
  var match$1 = flatten_fields(ty2);
  var rest2 = match$1[1];
  var match$2 = associate_fields(match[0], match$1[0]);
  var miss2 = match$2[2];
  var miss1 = match$2[1];
  var l1 = repr(ty1)[/* level */1];
  var l2 = repr(ty2)[/* level */1];
  var va = make_rowvar(Pervasives.min(l1, l2), +(miss2 === /* [] */0), rest1, +(miss1 === /* [] */0), rest2);
  var d1 = rest1[/* desc */0];
  var d2 = rest2[/* desc */0];
  try {
    unify(env, build_fields(l1)(miss1, va), rest2);
    unify(env, rest1, build_fields(l2)(miss2, va));
    return List.iter((function (param) {
                  var t2 = param[4];
                  var k2 = param[3];
                  var t1 = param[2];
                  var k1 = param[1];
                  var n = param[0];
                  unify_kind(k1, k2);
                  try {
                    if (trace_gadt_instances[0]) {
                      update_level(env[0], va[/* level */1], t1);
                    }
                    return unify(env, t1, t2);
                  }
                  catch (raw_exn){
                    var exn = Js_exn.internalToOCamlException(raw_exn);
                    if (exn[0] === Unify) {
                      var desc_003 = newty2(current_level[0], /* Tnil */0);
                      var desc = /* Tfield */Block.__(5, [
                          n,
                          k1,
                          t1,
                          desc_003
                        ]);
                      var desc_003$1 = newty2(current_level[0], /* Tnil */0);
                      var desc$1 = /* Tfield */Block.__(5, [
                          n,
                          k2,
                          t2,
                          desc_003$1
                        ]);
                      throw [
                            Unify,
                            /* :: */[
                              /* tuple */[
                                newty2(current_level[0], desc),
                                newty2(current_level[0], desc$1)
                              ],
                              exn[1]
                            ]
                          ];
                    } else {
                      throw exn;
                    }
                  }
                }), match$2[0]);
  }
  catch (exn){
    log_type(rest1);
    rest1[/* desc */0] = d1;
    log_type(rest2);
    rest2[/* desc */0] = d2;
    throw exn;
  }
}

function unify_row(env, row1, row2) {
  var row1$1 = row_repr_aux(/* [] */0, row1);
  var row2$1 = row_repr_aux(/* [] */0, row2);
  var rm1 = row_more(row1$1);
  var rm2 = row_more(row2$1);
  if (unify_eq(env[0], rm1, rm2)) {
    return /* () */0;
  } else {
    var match = merge_row_fields(row1$1[/* row_fields */0], row2$1[/* row_fields */0]);
    var pairs = match[2];
    var r2 = match[1];
    var r1 = match[0];
    if (r1 !== /* [] */0 && r2 !== /* [] */0) {
      var ht = Hashtbl.create(/* None */0, List.length(r1));
      List.iter((function (param) {
              var l = param[0];
              return Hashtbl.add(ht, hash_variant(l), l);
            }), r1);
      List.iter((function (param) {
              var l = param[0];
              try {
                throw [
                      Tags,
                      l,
                      Hashtbl.find(ht, hash_variant(l))
                    ];
              }
              catch (exn){
                if (exn === Caml_builtin_exceptions.not_found) {
                  return /* () */0;
                } else {
                  throw exn;
                }
              }
            }), r2);
    }
    var fixed1 = row_fixed(row1$1);
    var fixed2 = row_fixed(row2$1);
    var more = fixed1 ? rm1 : (
        fixed2 ? rm2 : newty2(Pervasives.min(rm1[/* level */1], rm2[/* level */1]), /* Tvar */Block.__(0, [/* None */0]))
      );
    var fixed = fixed1 || fixed2;
    var closed = row1$1[/* row_closed */3] || row2$1[/* row_closed */3];
    var keep = function ($$switch) {
      return List.for_all((function (param) {
                    var match = Curry._2($$switch, param[1], param[2]);
                    if (row_field_repr_aux(/* [] */0, match[0])) {
                      return +(row_field_repr_aux(/* [] */0, match[1]) !== /* Rabsent */0);
                    } else {
                      return /* true */1;
                    }
                  }), pairs);
    };
    var empty = function (fields) {
      return List.for_all((function (param) {
                    return +(row_field_repr_aux(/* [] */0, param[1]) === /* Rabsent */0);
                  }), fields);
    };
    if (closed && (empty(r1) || row2$1[/* row_closed */3]) && (empty(r2) || row1$1[/* row_closed */3]) && List.for_all((function (param) {
              if (row_field_repr_aux(/* [] */0, param[1])) {
                return +(row_field_repr_aux(/* [] */0, param[2]) === /* Rabsent */0);
              } else {
                return /* true */1;
              }
            }), pairs)) {
      throw [
            Unify,
            /* :: */[
              /* tuple */[
                mkvariant(/* [] */0, /* true */1),
                mkvariant(/* [] */0, /* true */1)
              ],
              /* [] */0
            ]
          ];
    }
    var name = row1$1[/* row_name */5] !== /* None */0 && (row1$1[/* row_closed */3] || empty(r2)) && (!row2$1[/* row_closed */3] || keep((function (f1, f2) {
              return /* tuple */[
                      f1,
                      f2
                    ];
            })) && empty(r1)) ? row1$1[/* row_name */5] : (
        row2$1[/* row_name */5] !== /* None */0 && (row2$1[/* row_closed */3] || empty(r1)) && (!row1$1[/* row_closed */3] || keep((function (f1, f2) {
                  return /* tuple */[
                          f2,
                          f1
                        ];
                })) && empty(r2)) ? row2$1[/* row_name */5] : /* None */0
      );
    var row0 = /* record */[
      /* row_fields : [] */0,
      /* row_more */more,
      /* row_bound : () */0,
      /* row_closed */closed,
      /* row_fixed */fixed,
      /* row_name */name
    ];
    var set_more = function (row, rest) {
      var rest$1 = closed ? filter_row_fields(row[/* row_closed */3], rest) : rest;
      if (rest$1 !== /* [] */0 && (row[/* row_closed */3] || row_fixed(row)) || closed && row_fixed(row) && !row[/* row_closed */3]) {
        var t1 = mkvariant(/* [] */0, /* true */1);
        var t2 = mkvariant(rest$1, /* false */0);
        throw [
              Unify,
              /* :: */[
                row === row1$1 ? /* tuple */[
                    t1,
                    t2
                  ] : /* tuple */[
                    t2,
                    t1
                  ],
                /* [] */0
              ]
            ];
      }
      var rm = row_more(row);
      if (!(trace_gadt_instances[0] && rm[/* desc */0] === /* Tnil */0)) {
        if (trace_gadt_instances[0]) {
          update_level(env[0], rm[/* level */1], newty2(100000000, /* Tvariant */Block.__(8, [row])));
        }
        
      }
      if (row_fixed(row)) {
        if (more === rm) {
          return /* () */0;
        } else if (is_Tvar(rm)) {
          return link_type(rm, more);
        } else {
          return unify(env, rm, more);
        }
      } else {
        var newrecord = row0.slice();
        var ty = newty2(100000000, /* Tvariant */Block.__(8, [(newrecord[/* row_fields */0] = rest$1, newrecord)]));
        update_level(env[0], rm[/* level */1], ty);
        return link_type(rm, ty);
      }
    };
    var md1 = rm1[/* desc */0];
    var md2 = rm2[/* desc */0];
    try {
      set_more(row2$1, r1);
      set_more(row1$1, r2);
      return List.iter((function (param) {
                    var f2 = param[2];
                    var f1 = param[1];
                    var l = param[0];
                    try {
                      var env$1 = env;
                      var fixed1$1 = fixed1;
                      var fixed2$1 = fixed2;
                      var more$1 = more;
                      var _f1 = f1;
                      var _f2 = f2;
                      while(true) {
                        var f2$1 = _f2;
                        var f1$1 = _f1;
                        var f1$2 = row_field_repr_aux(/* [] */0, f1$1);
                        var f2$2 = row_field_repr_aux(/* [] */0, f2$1);
                        if (f1$2 === f2$2) {
                          return /* () */0;
                        } else if (typeof f1$2 === "number") {
                          if (typeof f2$2 === "number") {
                            return /* () */0;
                          } else if (f2$2.tag) {
                            if (f2$2[2] !== 0) {
                              throw [
                                    Unify,
                                    /* [] */0
                                  ];
                            } else if (fixed2$1) {
                              throw [
                                    Unify,
                                    /* [] */0
                                  ];
                            } else {
                              return set_row_field(f2$2[3], f1$2);
                            }
                          } else {
                            throw [
                                  Unify,
                                  /* [] */0
                                ];
                          }
                        } else if (f1$2.tag) {
                          var c1 = f1$2[0];
                          var m1 = f1$2[2];
                          var tl1 = f1$2[1];
                          var e1 = f1$2[3];
                          if (typeof f2$2 === "number") {
                            if (m1 !== 0) {
                              throw [
                                    Unify,
                                    /* [] */0
                                  ];
                            } else if (fixed1$1) {
                              throw [
                                    Unify,
                                    /* [] */0
                                  ];
                            } else {
                              return set_row_field(f1$2[3], f2$2);
                            }
                          } else if (f2$2.tag) {
                            var e2 = f2$2[3];
                            if (e1 === e2) {
                              return /* () */0;
                            } else {
                              var m2 = f2$2[2];
                              var tl2 = f2$2[1];
                              var c2 = f2$2[0];
                              var match = Pervasives.$at(tl1, tl2);
                              var $js;
                              if (match) {
                                var t1 = match[0];
                                if (c1 || c2) {
                                  throw [
                                        Unify,
                                        /* [] */0
                                      ];
                                }
                                List.iter((function(t1){
                                    return function (param) {
                                      return unify(env$1, t1, param);
                                    }
                                    }(t1)), match[1]);
                                $js = +(e1[0] !== /* None */0 || e2[0] !== /* None */0);
                              } else {
                                $js = /* false */0;
                              }
                              var redo = (m1 || m2 || fixed1$1 || fixed2$1 || rigid_variants[0] && +(List.length(tl1) === 1 || List.length(tl2) === 1)) && $js;
                              if (redo) {
                                _f2 = f2$2;
                                _f1 = f1$2;
                                continue ;
                                
                              } else {
                                var tl1$1 = List.map(repr, tl1);
                                var tl2$1 = List.map(repr, tl2);
                                var remq = function (tl, _param) {
                                  while(true) {
                                    var param = _param;
                                    if (param) {
                                      var tl$prime = param[1];
                                      var ty = param[0];
                                      if (List.memq(ty, tl)) {
                                        _param = tl$prime;
                                        continue ;
                                        
                                      } else {
                                        return /* :: */[
                                                ty,
                                                remq(tl, tl$prime)
                                              ];
                                      }
                                    } else {
                                      return /* [] */0;
                                    }
                                  };
                                };
                                var tl2$prime = remq(tl2$1, tl1$1);
                                var tl1$prime = remq(tl1$1, tl2$1);
                                var partial_arg = repr(more$1)[/* level */1];
                                var partial_arg$1 = env$1[0];
                                List.iter((function(partial_arg,partial_arg$1){
                                    return function (param) {
                                      return update_level(partial_arg$1, partial_arg, param);
                                    }
                                    }(partial_arg,partial_arg$1)), Pervasives.$at(tl1$prime, tl2$prime));
                                var e = [/* None */0];
                                var f1$prime_000 = c1 || c2;
                                var f1$prime_002 = m1 || m2;
                                var f1$prime = /* Reither */Block.__(1, [
                                    f1$prime_000,
                                    tl1$prime,
                                    f1$prime_002,
                                    e
                                  ]);
                                var f2$prime_000 = c1 || c2;
                                var f2$prime_002 = m1 || m2;
                                var f2$prime = /* Reither */Block.__(1, [
                                    f2$prime_000,
                                    tl2$prime,
                                    f2$prime_002,
                                    e
                                  ]);
                                set_row_field(e1, f1$prime);
                                return set_row_field(e2, f2$prime);
                              }
                            }
                          } else if (c1 !== 0) {
                            if (f1$2[1]) {
                              throw [
                                    Unify,
                                    /* [] */0
                                  ];
                            } else if (f2$2[0]) {
                              throw [
                                    Unify,
                                    /* [] */0
                                  ];
                            } else if (fixed1$1) {
                              throw [
                                    Unify,
                                    /* [] */0
                                  ];
                            } else {
                              return set_row_field(f1$2[3], f2$2);
                            }
                          } else {
                            var match$1 = f2$2[0];
                            if (match$1) {
                              if (fixed1$1) {
                                throw [
                                      Unify,
                                      /* [] */0
                                    ];
                              } else {
                                var t2 = match$1[0];
                                var e1$1 = f1$2[3];
                                set_row_field(e1$1, f2$2);
                                update_level(env$1[0], repr(more$1)[/* level */1], t2);
                                try {
                                  return List.iter((function(t2){
                                            return function (t1) {
                                              return unify(env$1, t1, t2);
                                            }
                                            }(t2)), f1$2[1]);
                                }
                                catch (exn){
                                  e1$1[0] = /* None */0;
                                  throw exn;
                                }
                              }
                            } else {
                              throw [
                                    Unify,
                                    /* [] */0
                                  ];
                            }
                          }
                        } else {
                          var match$2 = f1$2[0];
                          if (match$2) {
                            var t1$1 = match$2[0];
                            if (typeof f2$2 === "number") {
                              throw [
                                    Unify,
                                    /* [] */0
                                  ];
                            } else if (f2$2.tag) {
                              if (f2$2[0] !== 0) {
                                throw [
                                      Unify,
                                      /* [] */0
                                    ];
                              } else if (fixed2$1) {
                                throw [
                                      Unify,
                                      /* [] */0
                                    ];
                              } else {
                                var e2$1 = f2$2[3];
                                set_row_field(e2$1, f1$2);
                                update_level(env$1[0], repr(more$1)[/* level */1], t1$1);
                                try {
                                  return List.iter((function(t1$1){
                                            return function (param) {
                                              return unify(env$1, t1$1, param);
                                            }
                                            }(t1$1)), f2$2[1]);
                                }
                                catch (exn$1){
                                  e2$1[0] = /* None */0;
                                  throw exn$1;
                                }
                              }
                            } else {
                              var match$3 = f2$2[0];
                              if (match$3) {
                                return unify(env$1, t1$1, match$3[0]);
                              } else {
                                throw [
                                      Unify,
                                      /* [] */0
                                    ];
                              }
                            }
                          } else if (typeof f2$2 === "number") {
                            throw [
                                  Unify,
                                  /* [] */0
                                ];
                          } else if (f2$2.tag) {
                            if (f2$2[0] !== 0) {
                              if (f2$2[1]) {
                                throw [
                                      Unify,
                                      /* [] */0
                                    ];
                              } else if (fixed2$1) {
                                throw [
                                      Unify,
                                      /* [] */0
                                    ];
                              } else {
                                return set_row_field(f2$2[3], f1$2);
                              }
                            } else {
                              throw [
                                    Unify,
                                    /* [] */0
                                  ];
                            }
                          } else if (f2$2[0]) {
                            throw [
                                  Unify,
                                  /* [] */0
                                ];
                          } else {
                            return /* () */0;
                          }
                        }
                      };
                    }
                    catch (raw_exn){
                      var exn$2 = Js_exn.internalToOCamlException(raw_exn);
                      if (exn$2[0] === Unify) {
                        throw [
                              Unify,
                              /* :: */[
                                /* tuple */[
                                  mkvariant(/* :: */[
                                        /* tuple */[
                                          l,
                                          f1
                                        ],
                                        /* [] */0
                                      ], /* true */1),
                                  mkvariant(/* :: */[
                                        /* tuple */[
                                          l,
                                          f2
                                        ],
                                        /* [] */0
                                      ], /* true */1)
                                ],
                                exn$2[1]
                              ]
                            ];
                      } else {
                        throw exn$2;
                      }
                    }
                  }), pairs);
    }
    catch (exn){
      log_type(rm1);
      rm1[/* desc */0] = md1;
      log_type(rm2);
      rm2[/* desc */0] = md2;
      throw exn;
    }
  }
}

function unify_list(env, tl1, tl2) {
  if (List.length(tl1) !== List.length(tl2)) {
    throw [
          Unify,
          /* [] */0
        ];
  }
  return List.iter2((function (param, param$1) {
                return unify(env, param, param$1);
              }), tl1, tl2);
}

function unify$1(env, ty1, ty2) {
  try {
    return unify(env, ty1, ty2);
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === Unify) {
      throw [
            Unify,
            expand_trace(env[0], exn[1])
          ];
    } else if (exn === Recursive_abbrev) {
      throw [
            Unification_recursive_abbrev,
            expand_trace(env[0], /* :: */[
                  /* tuple */[
                    ty1,
                    ty2
                  ],
                  /* [] */0
                ])
          ];
    } else {
      throw exn;
    }
  }
}

function unify_var(env, t1, t2) {
  var t1$1 = repr(t1);
  var t2$1 = repr(t2);
  if (t1$1 === t2$1) {
    return /* () */0;
  } else {
    var match = t1$1[/* desc */0];
    if (typeof match === "number") {
      return unify$1([env], t1$1, t2$1);
    } else if (match.tag) {
      return unify$1([env], t1$1, t2$1);
    } else {
      var reset_tracing = check_trace_gadt_instances(env);
      try {
        occur(env, t1$1, t2$1);
        update_level(env, t1$1[/* level */1], t2$1);
        link_type(t1$1, t2$1);
        return reset_trace_gadt_instances(reset_tracing);
      }
      catch (raw_exn){
        var exn = Js_exn.internalToOCamlException(raw_exn);
        if (exn[0] === Unify) {
          reset_trace_gadt_instances(reset_tracing);
          var expanded_trace = expand_trace(env, /* :: */[
                /* tuple */[
                  t1$1,
                  t2$1
                ],
                exn[1]
              ]);
          throw [
                Unify,
                expanded_trace
              ];
        } else {
          throw exn;
        }
      }
    }
  }
}

unify$prime[0] = unify_var;

function unify_pairs(env, ty1, ty2, pairs) {
  univar_pairs[0] = pairs;
  return unify$1(env, ty1, ty2);
}

function unify$2(env, ty1, ty2) {
  return unify_pairs([env], ty1, ty2, /* [] */0);
}

function expand_head_trace(env, t) {
  var reset_tracing = check_trace_gadt_instances(env);
  var t$1 = expand_head_unif(env, t);
  reset_trace_gadt_instances(reset_tracing);
  return t$1;
}

function filter_arrow(env, t, l) {
  var t$1 = expand_head_trace(env, t);
  var match = t$1[/* desc */0];
  if (typeof match === "number") {
    throw [
          Unify,
          /* [] */0
        ];
  } else {
    switch (match.tag | 0) {
      case 0 : 
          var lv = t$1[/* level */1];
          var t1 = newty2(lv, /* Tvar */Block.__(0, [/* None */0]));
          var t2 = newty2(lv, /* Tvar */Block.__(0, [/* None */0]));
          var t$prime = newty2(lv, /* Tarrow */Block.__(1, [
                  l,
                  t1,
                  t2,
                  /* Cok */0
                ]));
          link_type(t$1, t$prime);
          return /* tuple */[
                  t1,
                  t2
                ];
      case 1 : 
          var l$prime = match[0];
          if (l === l$prime || classic[0] && l === "" && !is_optional(l$prime)) {
            return /* tuple */[
                    match[1],
                    match[2]
                  ];
          } else {
            throw [
                  Unify,
                  /* [] */0
                ];
          }
          break;
      default:
        throw [
              Unify,
              /* [] */0
            ];
    }
  }
}

function filter_method_field(env, name, priv, _ty) {
  while(true) {
    var ty = _ty;
    var ty$1 = expand_head_trace(env, ty);
    var match = ty$1[/* desc */0];
    if (typeof match === "number") {
      throw [
            Unify,
            /* [] */0
          ];
    } else {
      switch (match.tag | 0) {
        case 0 : 
            var level = ty$1[/* level */1];
            var ty1 = newty2(level, /* Tvar */Block.__(0, [/* None */0]));
            var ty2 = newty2(level, /* Tvar */Block.__(0, [/* None */0]));
            var ty$prime = newty2(level, /* Tfield */Block.__(5, [
                    name,
                    priv !== 0 ? /* Fpresent */0 : /* Fvar */[[/* None */0]],
                    ty1,
                    ty2
                  ]));
            link_type(ty$1, ty$prime);
            return ty1;
        case 5 : 
            var kind = field_kind_repr(match[1]);
            if (match[0] === name && kind !== /* Fabsent */1) {
              if (priv === /* Public */1) {
                unify_kind(kind, /* Fpresent */0);
              }
              return match[2];
            } else {
              _ty = match[3];
              continue ;
              
            }
            break;
        default:
          throw [
                Unify,
                /* [] */0
              ];
      }
    }
  };
}

function filter_method(env, name, priv, ty) {
  var ty$1 = expand_head_trace(env, ty);
  var match = ty$1[/* desc */0];
  if (typeof match === "number") {
    throw [
          Unify,
          /* [] */0
        ];
  } else {
    switch (match.tag | 0) {
      case 0 : 
          var ty1 = newvar(/* None */0, /* () */0);
          var ty$prime = newobj(ty1);
          update_level(env, ty$1[/* level */1], ty$prime);
          link_type(ty$1, ty$prime);
          return filter_method_field(env, name, priv, ty1);
      case 4 : 
          return filter_method_field(env, name, priv, match[0]);
      default:
        throw [
              Unify,
              /* [] */0
            ];
    }
  }
}

function filter_self_method(env, lab, priv, meths, ty) {
  var ty$prime = filter_method(env, lab, priv, ty);
  try {
    return find(lab, meths[0]);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      var pair_000 = create(lab);
      var pair = /* tuple */[
        pair_000,
        ty$prime
      ];
      meths[0] = add$1(lab, pair, meths[0]);
      return pair;
    } else {
      throw exn;
    }
  }
}

function moregen_occur(env, level, ty) {
  var occur = function (ty) {
    var ty$1 = repr(ty);
    if (ty$1[/* level */1] > level) {
      if (is_Tvar(ty$1) && ty$1[/* level */1] >= 99999999) {
        throw Occur;
      }
      ty$1[/* level */1] = pivot_level - ty$1[/* level */1] | 0;
      var match = ty$1[/* desc */0];
      if (typeof match === "number") {
        return iter_type_expr(occur, ty$1);
      } else if (match.tag === 8) {
        var row = match[0];
        if (static_row(row)) {
          return iter_row(occur, row);
        } else {
          return iter_type_expr(occur, ty$1);
        }
      } else {
        return iter_type_expr(occur, ty$1);
      }
    } else {
      return 0;
    }
  };
  try {
    occur(ty);
    unmark_type(ty);
  }
  catch (exn){
    if (exn === Occur) {
      unmark_type(ty);
      throw [
            Unify,
            /* [] */0
          ];
    } else {
      throw exn;
    }
  }
  occur_univar(env, ty);
  return update_level(env, level, ty);
}

function may_instantiate(inst_nongen, t1) {
  if (inst_nongen) {
    return +(t1[/* level */1] !== 99999999);
  } else {
    return +(t1[/* level */1] === 100000000);
  }
}

function moregen(inst_nongen, type_pairs, env, t1, t2) {
  if (t1 === t2) {
    return /* () */0;
  } else {
    var t1$1 = repr(t1);
    var t2$1 = repr(t2);
    if (t1$1 === t2$1) {
      return /* () */0;
    } else {
      try {
        var match = t1$1[/* desc */0];
        var match$1 = t2$1[/* desc */0];
        var exit = 0;
        if (typeof match === "number") {
          exit = 1;
        } else {
          switch (match.tag | 0) {
            case 0 : 
                if (may_instantiate(inst_nongen, t1$1)) {
                  moregen_occur(env, t1$1[/* level */1], t2$1);
                  occur(env, t1$1, t2$1);
                  return link_type(t1$1, t2$1);
                } else {
                  exit = 1;
                }
                break;
            case 3 : 
                if (match[1]) {
                  exit = 1;
                } else if (typeof match$1 === "number") {
                  exit = 1;
                } else if (match$1.tag === 3) {
                  if (match$1[1]) {
                    exit = 1;
                  } else if (same(match[0], match$1[0])) {
                    return /* () */0;
                  } else {
                    exit = 1;
                  }
                } else {
                  exit = 1;
                }
                break;
            default:
              exit = 1;
          }
        }
        if (exit === 1) {
          var t1$prime = expand_head(env, t1$1);
          var t2$prime = expand_head(env, t2$1);
          var t1$prime$1 = repr(t1$prime);
          var t2$prime$1 = repr(t2$prime);
          if (t1$prime$1 === t2$prime$1) {
            return /* () */0;
          } else {
            try {
              return Curry._2(TypePairs[/* find */6], type_pairs, /* tuple */[
                          t1$prime$1,
                          t2$prime$1
                        ]);
            }
            catch (exn){
              if (exn === Caml_builtin_exceptions.not_found) {
                Curry._3(TypePairs[/* add */4], type_pairs, /* tuple */[
                      t1$prime$1,
                      t2$prime$1
                    ], /* () */0);
                var match$2 = t1$prime$1[/* desc */0];
                var match$3 = t2$prime$1[/* desc */0];
                if (typeof match$2 === "number") {
                  if (typeof match$3 === "number") {
                    return /* () */0;
                  } else {
                    throw [
                          Unify,
                          /* [] */0
                        ];
                  }
                } else {
                  switch (match$2.tag | 0) {
                    case 0 : 
                        if (may_instantiate(inst_nongen, t1$prime$1)) {
                          moregen_occur(env, t1$prime$1[/* level */1], t2$1);
                          return link_type(t1$prime$1, t2$1);
                        } else {
                          throw [
                                Unify,
                                /* [] */0
                              ];
                        }
                        break;
                    case 1 : 
                        if (typeof match$3 === "number") {
                          throw [
                                Unify,
                                /* [] */0
                              ];
                        } else if (match$3.tag === 1) {
                          var l2 = match$3[0];
                          var l1 = match$2[0];
                          if (l1 === l2 || classic[0] && !(is_optional(l1) || is_optional(l2))) {
                            moregen(inst_nongen, type_pairs, env, match$2[1], match$3[1]);
                            return moregen(inst_nongen, type_pairs, env, match$2[2], match$3[2]);
                          } else {
                            throw [
                                  Unify,
                                  /* [] */0
                                ];
                          }
                        } else {
                          throw [
                                Unify,
                                /* [] */0
                              ];
                        }
                        break;
                    case 2 : 
                        if (typeof match$3 === "number") {
                          throw [
                                Unify,
                                /* [] */0
                              ];
                        } else if (match$3.tag === 2) {
                          return moregen_list(inst_nongen, type_pairs, env, match$2[0], match$3[0]);
                        } else {
                          throw [
                                Unify,
                                /* [] */0
                              ];
                        }
                        break;
                    case 3 : 
                        if (typeof match$3 === "number") {
                          throw [
                                Unify,
                                /* [] */0
                              ];
                        } else if (match$3.tag === 3) {
                          if (same(match$2[0], match$3[0])) {
                            return moregen_list(inst_nongen, type_pairs, env, match$2[1], match$3[1]);
                          } else {
                            throw [
                                  Unify,
                                  /* [] */0
                                ];
                          }
                        } else {
                          throw [
                                Unify,
                                /* [] */0
                              ];
                        }
                        break;
                    case 4 : 
                        if (typeof match$3 === "number") {
                          throw [
                                Unify,
                                /* [] */0
                              ];
                        } else if (match$3.tag === 4) {
                          return moregen_fields(inst_nongen, type_pairs, env, match$2[0], match$3[0]);
                        } else {
                          throw [
                                Unify,
                                /* [] */0
                              ];
                        }
                        break;
                    case 5 : 
                        if (typeof match$3 === "number") {
                          throw [
                                Unify,
                                /* [] */0
                              ];
                        } else if (match$3.tag === 5) {
                          return moregen_fields(inst_nongen, type_pairs, env, t1$prime$1, t2$prime$1);
                        } else {
                          throw [
                                Unify,
                                /* [] */0
                              ];
                        }
                        break;
                    case 6 : 
                    case 7 : 
                        throw [
                              Unify,
                              /* [] */0
                            ];
                    case 8 : 
                        if (typeof match$3 === "number") {
                          throw [
                                Unify,
                                /* [] */0
                              ];
                        } else if (match$3.tag === 8) {
                          var inst_nongen$1 = inst_nongen;
                          var type_pairs$1 = type_pairs;
                          var env$1 = env;
                          var row1 = match$2[0];
                          var row2 = match$3[0];
                          var row1$1 = row_repr_aux(/* [] */0, row1);
                          var row2$1 = row_repr_aux(/* [] */0, row2);
                          var rm1 = repr(row1$1[/* row_more */1]);
                          var rm2 = repr(row2$1[/* row_more */1]);
                          if (rm1 === rm2) {
                            return /* () */0;
                          } else {
                            var may_inst = is_Tvar(rm1) && may_instantiate(inst_nongen$1, rm1) || +(rm1[/* desc */0] === /* Tnil */0);
                            var match$4 = merge_row_fields(row1$1[/* row_fields */0], row2$1[/* row_fields */0]);
                            var r2 = match$4[1];
                            var r1 = match$4[0];
                            var match$5 = row2$1[/* row_closed */3] ? /* tuple */[
                                filter_row_fields(may_inst, r1),
                                filter_row_fields(/* false */0, r2)
                              ] : /* tuple */[
                                r1,
                                r2
                              ];
                            var r2$1 = match$5[1];
                            if (match$5[0] !== /* [] */0 || row1$1[/* row_closed */3] && (!row2$1[/* row_closed */3] || r2$1 !== /* [] */0)) {
                              throw [
                                    Unify,
                                    /* [] */0
                                  ];
                            }
                            var match$6 = rm1[/* desc */0];
                            var match$7 = rm2[/* desc */0];
                            var exit$1 = 0;
                            if (typeof match$6 === "number") {
                              exit$1 = 1;
                            } else if (match$6.tag === 9) {
                              if (typeof match$7 === "number") {
                                throw [
                                      Unify,
                                      /* [] */0
                                    ];
                              } else if (match$7.tag === 9) {
                                unify_univar(rm1, rm2, univar_pairs[0]);
                              } else {
                                throw [
                                      Unify,
                                      /* [] */0
                                    ];
                              }
                            } else {
                              exit$1 = 1;
                            }
                            if (exit$1 === 1) {
                              if (typeof match$7 === "number") {
                                if (!static_row(row1$1)) {
                                  if (may_inst) {
                                    var newrecord = row2$1.slice();
                                    var ext = newty2(100000000, /* Tvariant */Block.__(8, [(newrecord[/* row_fields */0] = r2$1, newrecord)]));
                                    moregen_occur(env$1, rm1[/* level */1], ext);
                                    link_type(rm1, ext);
                                  } else if (typeof match$6 === "number") {
                                    throw [
                                          Unify,
                                          /* [] */0
                                        ];
                                  } else if (match$6.tag === 3) {
                                    if (typeof match$7 === "number") {
                                      throw [
                                            Unify,
                                            /* [] */0
                                          ];
                                    } else if (match$7.tag === 3) {
                                      moregen(inst_nongen$1, type_pairs$1, env$1, rm1, rm2);
                                    } else {
                                      throw [
                                            Unify,
                                            /* [] */0
                                          ];
                                    }
                                  } else {
                                    throw [
                                          Unify,
                                          /* [] */0
                                        ];
                                  }
                                }
                                
                              } else if (match$7.tag === 9) {
                                throw [
                                      Unify,
                                      /* [] */0
                                    ];
                              } else if (!static_row(row1$1)) {
                                if (may_inst) {
                                  var newrecord = row2$1.slice();
                                  var ext = newty2(100000000, /* Tvariant */Block.__(8, [(newrecord[/* row_fields */0] = r2$1, newrecord)]));
                                  moregen_occur(env$1, rm1[/* level */1], ext);
                                  link_type(rm1, ext);
                                } else if (typeof match$6 === "number") {
                                  throw [
                                        Unify,
                                        /* [] */0
                                      ];
                                } else if (match$6.tag === 3) {
                                  if (typeof match$7 === "number") {
                                    throw [
                                          Unify,
                                          /* [] */0
                                        ];
                                  } else if (match$7.tag === 3) {
                                    moregen(inst_nongen$1, type_pairs$1, env$1, rm1, rm2);
                                  } else {
                                    throw [
                                          Unify,
                                          /* [] */0
                                        ];
                                  }
                                } else {
                                  throw [
                                        Unify,
                                        /* [] */0
                                      ];
                                }
                              }
                              
                            }
                            return List.iter((function (param) {
                                          var f1 = row_field_repr_aux(/* [] */0, param[1]);
                                          var f2 = row_field_repr_aux(/* [] */0, param[2]);
                                          if (f1 === f2) {
                                            return /* () */0;
                                          } else if (typeof f1 === "number") {
                                            if (typeof f2 === "number") {
                                              return /* () */0;
                                            } else {
                                              throw [
                                                    Unify,
                                                    /* [] */0
                                                  ];
                                            }
                                          } else if (f1.tag) {
                                            var c1 = f1[0];
                                            var exit = 0;
                                            if (c1 !== 0) {
                                              if (f1[1]) {
                                                exit = 1;
                                              } else if (typeof f2 === "number") {
                                                exit = 1;
                                              } else if (f2.tag) {
                                                exit = 1;
                                              } else if (f2[0]) {
                                                throw [
                                                      Unify,
                                                      /* [] */0
                                                    ];
                                              } else if (may_inst) {
                                                return set_row_field(f1[3], f2);
                                              } else {
                                                throw [
                                                      Unify,
                                                      /* [] */0
                                                    ];
                                              }
                                            } else if (typeof f2 === "number") {
                                              exit = 1;
                                            } else if (f2.tag) {
                                              exit = 1;
                                            } else {
                                              var match = f2[0];
                                              if (match) {
                                                if (may_inst) {
                                                  var t2 = match[0];
                                                  set_row_field(f1[3], f2);
                                                  return List.iter((function (t1) {
                                                                return moregen(inst_nongen$1, type_pairs$1, env$1, t1, t2);
                                                              }), f1[1]);
                                                } else {
                                                  throw [
                                                        Unify,
                                                        /* [] */0
                                                      ];
                                                }
                                              } else {
                                                throw [
                                                      Unify,
                                                      /* [] */0
                                                    ];
                                              }
                                            }
                                            if (exit === 1) {
                                              var e1 = f1[3];
                                              var tl1 = f1[1];
                                              if (typeof f2 === "number") {
                                                if (may_inst) {
                                                  return set_row_field(e1, f2);
                                                } else {
                                                  throw [
                                                        Unify,
                                                        /* [] */0
                                                      ];
                                                }
                                              } else if (f2.tag) {
                                                var e2 = f2[3];
                                                if (e1 !== e2) {
                                                  var tl2 = f2[1];
                                                  var c2 = f2[0];
                                                  if (c1 && !c2) {
                                                    throw [
                                                          Unify,
                                                          /* [] */0
                                                        ];
                                                  }
                                                  set_row_field(e1, /* Reither */Block.__(1, [
                                                          c2,
                                                          /* [] */0,
                                                          f2[2],
                                                          e2
                                                        ]));
                                                  if (List.length(tl1) === List.length(tl2)) {
                                                    return List.iter2((function (param, param$1) {
                                                                  return moregen(inst_nongen$1, type_pairs$1, env$1, param, param$1);
                                                                }), tl1, tl2);
                                                  } else if (tl2) {
                                                    var t2$1 = tl2[0];
                                                    return List.iter((function (t1) {
                                                                  return moregen(inst_nongen$1, type_pairs$1, env$1, t1, t2$1);
                                                                }), tl1);
                                                  } else if (tl1 !== /* [] */0) {
                                                    throw [
                                                          Unify,
                                                          /* [] */0
                                                        ];
                                                  } else {
                                                    return 0;
                                                  }
                                                } else {
                                                  return 0;
                                                }
                                              } else {
                                                throw [
                                                      Unify,
                                                      /* [] */0
                                                    ];
                                              }
                                            }
                                            
                                          } else {
                                            var match$1 = f1[0];
                                            if (match$1) {
                                              if (typeof f2 === "number") {
                                                throw [
                                                      Unify,
                                                      /* [] */0
                                                    ];
                                              } else if (f2.tag) {
                                                throw [
                                                      Unify,
                                                      /* [] */0
                                                    ];
                                              } else {
                                                var match$2 = f2[0];
                                                if (match$2) {
                                                  return moregen(inst_nongen$1, type_pairs$1, env$1, match$1[0], match$2[0]);
                                                } else {
                                                  throw [
                                                        Unify,
                                                        /* [] */0
                                                      ];
                                                }
                                              }
                                            } else if (typeof f2 === "number") {
                                              throw [
                                                    Unify,
                                                    /* [] */0
                                                  ];
                                            } else if (f2.tag) {
                                              throw [
                                                    Unify,
                                                    /* [] */0
                                                  ];
                                            } else if (f2[0]) {
                                              throw [
                                                    Unify,
                                                    /* [] */0
                                                  ];
                                            } else {
                                              return /* () */0;
                                            }
                                          }
                                        }), match$4[2]);
                          }
                        } else {
                          throw [
                                Unify,
                                /* [] */0
                              ];
                        }
                        break;
                    case 9 : 
                        if (typeof match$3 === "number") {
                          throw [
                                Unify,
                                /* [] */0
                              ];
                        } else if (match$3.tag === 9) {
                          return unify_univar(t1$prime$1, t2$prime$1, univar_pairs[0]);
                        } else {
                          throw [
                                Unify,
                                /* [] */0
                              ];
                        }
                        break;
                    case 10 : 
                        var tl1 = match$2[1];
                        var t1$2 = match$2[0];
                        var exit$2 = 0;
                        if (tl1) {
                          exit$2 = 2;
                        } else if (typeof match$3 === "number") {
                          throw [
                                Unify,
                                /* [] */0
                              ];
                        } else if (match$3.tag === 10) {
                          if (match$3[1]) {
                            exit$2 = 2;
                          } else {
                            return moregen(inst_nongen, type_pairs, env, t1$2, match$3[0]);
                          }
                        } else {
                          throw [
                                Unify,
                                /* [] */0
                              ];
                        }
                        if (exit$2 === 2) {
                          if (typeof match$3 === "number") {
                            throw [
                                  Unify,
                                  /* [] */0
                                ];
                          } else if (match$3.tag === 10) {
                            return enter_poly(env, univar_pairs, t1$2, tl1, match$3[0], match$3[1], (function (param, param$1) {
                                          return moregen(inst_nongen, type_pairs, env, param, param$1);
                                        }));
                          } else {
                            throw [
                                  Unify,
                                  /* [] */0
                                ];
                          }
                        }
                        break;
                    case 11 : 
                        if (typeof match$3 === "number") {
                          throw [
                                Unify,
                                /* [] */0
                              ];
                        } else if (match$3.tag === 11) {
                          try {
                            return unify_package(env, (function (param, param$1) {
                                          return moregen_list(inst_nongen, type_pairs, env, param, param$1);
                                        }), t1$prime$1[/* level */1], match$2[0], match$2[1], match$2[2], t2$prime$1[/* level */1], match$3[0], match$3[1], match$3[2]);
                          }
                          catch (exn$1){
                            if (exn$1 === Caml_builtin_exceptions.not_found) {
                              throw [
                                    Unify,
                                    /* [] */0
                                  ];
                            } else {
                              throw exn$1;
                            }
                          }
                        } else {
                          throw [
                                Unify,
                                /* [] */0
                              ];
                        }
                        break;
                    
                  }
                }
              } else {
                throw exn;
              }
            }
          }
        }
        
      }
      catch (raw_exn){
        var exn$2 = Js_exn.internalToOCamlException(raw_exn);
        if (exn$2[0] === Unify) {
          throw [
                Unify,
                /* :: */[
                  /* tuple */[
                    t1$1,
                    t2$1
                  ],
                  exn$2[1]
                ]
              ];
        } else {
          throw exn$2;
        }
      }
    }
  }
}

function moregen_list(inst_nongen, type_pairs, env, tl1, tl2) {
  if (List.length(tl1) !== List.length(tl2)) {
    throw [
          Unify,
          /* [] */0
        ];
  }
  return List.iter2((function (param, param$1) {
                return moregen(inst_nongen, type_pairs, env, param, param$1);
              }), tl1, tl2);
}

function moregen_fields(inst_nongen, type_pairs, env, ty1, ty2) {
  var match = flatten_fields(ty1);
  var match$1 = flatten_fields(ty2);
  var rest2 = match$1[1];
  var match$2 = associate_fields(match[0], match$1[0]);
  if (match$2[1] !== /* [] */0) {
    throw [
          Unify,
          /* [] */0
        ];
  }
  moregen(inst_nongen, type_pairs, env, match[1], build_fields(repr(ty2)[/* level */1])(match$2[2], rest2));
  return List.iter((function (param) {
                var t2 = param[4];
                var k2 = param[3];
                var t1 = param[2];
                var k1 = param[1];
                var n = param[0];
                moregen_kind(k1, k2);
                try {
                  return moregen(inst_nongen, type_pairs, env, t1, t2);
                }
                catch (raw_exn){
                  var exn = Js_exn.internalToOCamlException(raw_exn);
                  if (exn[0] === Unify) {
                    throw [
                          Unify,
                          /* :: */[
                            /* tuple */[
                              newty2(current_level[0], /* Tfield */Block.__(5, [
                                      n,
                                      k1,
                                      t1,
                                      rest2
                                    ])),
                              newty2(current_level[0], /* Tfield */Block.__(5, [
                                      n,
                                      k2,
                                      t2,
                                      rest2
                                    ]))
                            ],
                            exn[1]
                          ]
                        ];
                  } else {
                    throw exn;
                  }
                }
              }), match$2[0]);
}

function moregen_kind(k1, k2) {
  var k1$1 = field_kind_repr(k1);
  var k2$1 = field_kind_repr(k2);
  if (k1$1 === k2$1) {
    return /* () */0;
  } else if (typeof k1$1 === "number") {
    if (k1$1 !== 0) {
      throw [
            Unify,
            /* [] */0
          ];
    } else if (typeof k2$1 === "number") {
      if (k2$1 !== 0) {
        throw [
              Unify,
              /* [] */0
            ];
      } else {
        return /* () */0;
      }
    } else {
      throw [
            Unify,
            /* [] */0
          ];
    }
  } else {
    var r = k1$1[0];
    if (typeof k2$1 === "number") {
      if (k2$1 !== 0) {
        throw [
              Unify,
              /* [] */0
            ];
      } else {
        return set_kind(r, k2$1);
      }
    } else {
      return set_kind(r, k2$1);
    }
  }
}

function moregen$1(inst_nongen, type_pairs, env, patt, subj) {
  univar_pairs[0] = /* [] */0;
  return moregen(inst_nongen, type_pairs, env, patt, subj);
}

function moregeneral(env, inst_nongen, pat_sch, subj_sch) {
  var old_level = current_level[0];
  current_level[0] = 99999999;
  var subj = duplicate_type(instance(/* None */0, env, subj_sch));
  current_level[0] = 100000000;
  var patt = instance(/* None */0, env, pat_sch);
  var res;
  try {
    moregen$1(inst_nongen, Curry._1(TypePairs[/* create */0], 13), env, patt, subj);
    res = /* true */1;
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === Unify) {
      res = /* false */0;
    } else {
      throw exn;
    }
  }
  current_level[0] = old_level;
  return res;
}

function rigidify_rec(vars, _ty) {
  while(true) {
    var ty = _ty;
    var ty$1 = repr(ty);
    if (ty$1[/* level */1] >= 0) {
      ty$1[/* level */1] = pivot_level - ty$1[/* level */1] | 0;
      var match = ty$1[/* desc */0];
      if (typeof match === "number") {
        return iter_type_expr((function (param) {
                      return rigidify_rec(vars, param);
                    }), ty$1);
      } else {
        switch (match.tag | 0) {
          case 0 : 
              if (List.memq(ty$1, vars[0])) {
                return 0;
              } else {
                vars[0] = /* :: */[
                  ty$1,
                  vars[0]
                ];
                return /* () */0;
              }
          case 8 : 
              var row = row_repr_aux(/* [] */0, match[0]);
              var more = repr(row[/* row_more */1]);
              if (is_Tvar(more) && !row_fixed(row)) {
                var more$prime = newty2(more[/* level */1], more[/* desc */0]);
                var row$prime_002 = /* row_bound */row[/* row_bound */2];
                var row$prime_003 = /* row_closed */row[/* row_closed */3];
                var row$prime_005 = /* row_name */row[/* row_name */5];
                var row$prime = /* record */[
                  /* row_fields : [] */0,
                  /* row_more */more$prime,
                  row$prime_002,
                  row$prime_003,
                  /* row_fixed : true */1,
                  row$prime_005
                ];
                link_type(more, newty2(ty$1[/* level */1], /* Tvariant */Block.__(8, [row$prime])));
              }
              iter_row((function (param) {
                      return rigidify_rec(vars, param);
                    }), row);
              if (static_row(row)) {
                return 0;
              } else {
                _ty = row_more(row);
                continue ;
                
              }
              break;
          default:
            return iter_type_expr((function (param) {
                          return rigidify_rec(vars, param);
                        }), ty$1);
        }
      }
    } else {
      return 0;
    }
  };
}

function rigidify(ty) {
  var vars = [/* [] */0];
  rigidify_rec(vars, ty);
  unmark_type(ty);
  return vars[0];
}

function all_distinct_vars(env, vars) {
  var tyl = [/* [] */0];
  return List.for_all((function (ty) {
                var ty$1 = expand_head(env, ty);
                if (List.memq(ty$1, tyl[0])) {
                  return /* false */0;
                } else {
                  tyl[0] = /* :: */[
                    ty$1,
                    tyl[0]
                  ];
                  return is_Tvar(ty$1);
                }
              }), vars);
}

function matches(env, ty, ty$prime) {
  var snap = snapshot(/* () */0);
  var vars = rigidify(ty);
  cleanup_abbrev(/* () */0);
  var ok;
  try {
    unify$2(env, ty, ty$prime);
    ok = all_distinct_vars(env, vars);
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === Unify) {
      ok = /* false */0;
    } else {
      throw exn;
    }
  }
  backtrack(snap);
  return ok;
}

function expand_head_rigid(env, ty) {
  var old = rigid_variants[0];
  rigid_variants[0] = /* true */1;
  var ty$prime = expand_head(env, ty);
  rigid_variants[0] = old;
  return ty$prime;
}

function normalize_subst(subst) {
  if (List.exists((function (param) {
            var match = param[0][/* desc */0];
            var exit = 0;
            if (typeof match === "number") {
              exit = 1;
            } else if (match.tag === 6) {
              return /* true */1;
            } else {
              exit = 1;
            }
            if (exit === 1) {
              var match$1 = param[1][/* desc */0];
              return typeof match$1 === "number" || match$1.tag !== 6 ? /* false */0 : /* true */1;
            }
            
          }), subst[0])) {
    subst[0] = List.map((function (param) {
            return /* tuple */[
                    repr(param[0]),
                    repr(param[1])
                  ];
          }), subst[0]);
    return /* () */0;
  } else {
    return 0;
  }
}

function eqtype(rename, type_pairs, subst, env, t1, t2) {
  if (t1 === t2) {
    return /* () */0;
  } else {
    var t1$1 = repr(t1);
    var t2$1 = repr(t2);
    if (t1$1 === t2$1) {
      return /* () */0;
    } else {
      try {
        var match = t1$1[/* desc */0];
        var match$1 = t2$1[/* desc */0];
        var exit = 0;
        if (typeof match === "number") {
          exit = 1;
        } else {
          switch (match.tag | 0) {
            case 0 : 
                if (typeof match$1 === "number") {
                  exit = 1;
                } else if (match$1.tag) {
                  exit = 1;
                } else if (rename) {
                  try {
                    normalize_subst(subst);
                    if (List.assq(t1$1, subst[0]) !== t2$1) {
                      throw [
                            Unify,
                            /* [] */0
                          ];
                    } else {
                      return 0;
                    }
                  }
                  catch (exn){
                    if (exn === Caml_builtin_exceptions.not_found) {
                      if (List.exists((function (param) {
                                return +(param[1] === t2$1);
                              }), subst[0])) {
                        throw [
                              Unify,
                              /* [] */0
                            ];
                      }
                      subst[0] = /* :: */[
                        /* tuple */[
                          t1$1,
                          t2$1
                        ],
                        subst[0]
                      ];
                      return /* () */0;
                    } else {
                      throw exn;
                    }
                  }
                } else {
                  exit = 1;
                }
                break;
            case 3 : 
                if (match[1]) {
                  exit = 1;
                } else if (typeof match$1 === "number") {
                  exit = 1;
                } else if (match$1.tag === 3) {
                  if (match$1[1]) {
                    exit = 1;
                  } else if (same(match[0], match$1[0])) {
                    return /* () */0;
                  } else {
                    exit = 1;
                  }
                } else {
                  exit = 1;
                }
                break;
            default:
              exit = 1;
          }
        }
        if (exit === 1) {
          var t1$prime = expand_head_rigid(env, t1$1);
          var t2$prime = expand_head_rigid(env, t2$1);
          var t1$prime$1 = repr(t1$prime);
          var t2$prime$1 = repr(t2$prime);
          if (t1$prime$1 === t2$prime$1) {
            return /* () */0;
          } else {
            try {
              return Curry._2(TypePairs[/* find */6], type_pairs, /* tuple */[
                          t1$prime$1,
                          t2$prime$1
                        ]);
            }
            catch (exn$1){
              if (exn$1 === Caml_builtin_exceptions.not_found) {
                Curry._3(TypePairs[/* add */4], type_pairs, /* tuple */[
                      t1$prime$1,
                      t2$prime$1
                    ], /* () */0);
                var match$2 = t1$prime$1[/* desc */0];
                var match$3 = t2$prime$1[/* desc */0];
                if (typeof match$2 === "number") {
                  if (typeof match$3 === "number") {
                    return /* () */0;
                  } else {
                    throw [
                          Unify,
                          /* [] */0
                        ];
                  }
                } else {
                  switch (match$2.tag | 0) {
                    case 0 : 
                        if (typeof match$3 === "number") {
                          throw [
                                Unify,
                                /* [] */0
                              ];
                        } else if (match$3.tag) {
                          throw [
                                Unify,
                                /* [] */0
                              ];
                        } else if (rename) {
                          try {
                            normalize_subst(subst);
                            if (List.assq(t1$prime$1, subst[0]) !== t2$prime$1) {
                              throw [
                                    Unify,
                                    /* [] */0
                                  ];
                            } else {
                              return 0;
                            }
                          }
                          catch (exn$2){
                            if (exn$2 === Caml_builtin_exceptions.not_found) {
                              if (List.exists((function (param) {
                                        return +(param[1] === t2$prime$1);
                                      }), subst[0])) {
                                throw [
                                      Unify,
                                      /* [] */0
                                    ];
                              }
                              subst[0] = /* :: */[
                                /* tuple */[
                                  t1$prime$1,
                                  t2$prime$1
                                ],
                                subst[0]
                              ];
                              return /* () */0;
                            } else {
                              throw exn$2;
                            }
                          }
                        } else {
                          throw [
                                Unify,
                                /* [] */0
                              ];
                        }
                        break;
                    case 1 : 
                        if (typeof match$3 === "number") {
                          throw [
                                Unify,
                                /* [] */0
                              ];
                        } else if (match$3.tag === 1) {
                          var l2 = match$3[0];
                          var l1 = match$2[0];
                          if (l1 === l2 || classic[0] && !(is_optional(l1) || is_optional(l2))) {
                            eqtype(rename, type_pairs, subst, env, match$2[1], match$3[1]);
                            return eqtype(rename, type_pairs, subst, env, match$2[2], match$3[2]);
                          } else {
                            throw [
                                  Unify,
                                  /* [] */0
                                ];
                          }
                        } else {
                          throw [
                                Unify,
                                /* [] */0
                              ];
                        }
                        break;
                    case 2 : 
                        if (typeof match$3 === "number") {
                          throw [
                                Unify,
                                /* [] */0
                              ];
                        } else if (match$3.tag === 2) {
                          return eqtype_list(rename, type_pairs, subst, env, match$2[0], match$3[0]);
                        } else {
                          throw [
                                Unify,
                                /* [] */0
                              ];
                        }
                        break;
                    case 3 : 
                        if (typeof match$3 === "number") {
                          throw [
                                Unify,
                                /* [] */0
                              ];
                        } else if (match$3.tag === 3) {
                          if (same(match$2[0], match$3[0])) {
                            return eqtype_list(rename, type_pairs, subst, env, match$2[1], match$3[1]);
                          } else {
                            throw [
                                  Unify,
                                  /* [] */0
                                ];
                          }
                        } else {
                          throw [
                                Unify,
                                /* [] */0
                              ];
                        }
                        break;
                    case 4 : 
                        if (typeof match$3 === "number") {
                          throw [
                                Unify,
                                /* [] */0
                              ];
                        } else if (match$3.tag === 4) {
                          return eqtype_fields(rename, type_pairs, subst, env, match$2[0], match$3[0]);
                        } else {
                          throw [
                                Unify,
                                /* [] */0
                              ];
                        }
                        break;
                    case 5 : 
                        if (typeof match$3 === "number") {
                          throw [
                                Unify,
                                /* [] */0
                              ];
                        } else if (match$3.tag === 5) {
                          return eqtype_fields(rename, type_pairs, subst, env, t1$prime$1, t2$prime$1);
                        } else {
                          throw [
                                Unify,
                                /* [] */0
                              ];
                        }
                        break;
                    case 6 : 
                    case 7 : 
                        throw [
                              Unify,
                              /* [] */0
                            ];
                    case 8 : 
                        if (typeof match$3 === "number") {
                          throw [
                                Unify,
                                /* [] */0
                              ];
                        } else if (match$3.tag === 8) {
                          var rename$1 = rename;
                          var type_pairs$1 = type_pairs;
                          var subst$1 = subst;
                          var env$1 = env;
                          var row1 = match$2[0];
                          var _row2 = match$3[0];
                          while(true) {
                            var row2 = _row2;
                            var match$4 = expand_head_rigid(env$1, row_more(row2));
                            var match$5 = match$4[/* desc */0];
                            var exit$1 = 0;
                            if (typeof match$5 === "number") {
                              exit$1 = 1;
                            } else if (match$5.tag === 8) {
                              _row2 = match$5[0];
                              continue ;
                              
                            } else {
                              exit$1 = 1;
                            }
                            if (exit$1 === 1) {
                              var row1$1 = row_repr_aux(/* [] */0, row1);
                              var row2$1 = row_repr_aux(/* [] */0, row2);
                              var match$6 = merge_row_fields(row1$1[/* row_fields */0], row2$1[/* row_fields */0]);
                              var r2 = match$6[1];
                              var r1 = match$6[0];
                              if (Caml_obj.caml_notequal(row1$1[/* row_closed */3], row2$1[/* row_closed */3]) || !row1$1[/* row_closed */3] && (r1 !== /* [] */0 || r2 !== /* [] */0) || filter_row_fields(/* false */0, Pervasives.$at(r1, r2)) !== /* [] */0) {
                                throw [
                                      Unify,
                                      /* [] */0
                                    ];
                              }
                              if (!static_row(row1$1)) {
                                eqtype(rename$1, type_pairs$1, subst$1, env$1, row1$1[/* row_more */1], row2$1[/* row_more */1]);
                              }
                              return List.iter((function (param) {
                                            var match = row_field_repr_aux(/* [] */0, param[1]);
                                            var match$1 = row_field_repr_aux(/* [] */0, param[2]);
                                            if (typeof match === "number") {
                                              if (typeof match$1 === "number") {
                                                return /* () */0;
                                              } else {
                                                throw [
                                                      Unify,
                                                      /* [] */0
                                                    ];
                                              }
                                            } else if (match.tag) {
                                              if (match[0] !== 0) {
                                                if (match[1]) {
                                                  throw [
                                                        Unify,
                                                        /* [] */0
                                                      ];
                                                } else if (typeof match$1 === "number") {
                                                  throw [
                                                        Unify,
                                                        /* [] */0
                                                      ];
                                                } else if (match$1.tag) {
                                                  if (match$1[0] !== 0) {
                                                    if (match$1[1]) {
                                                      throw [
                                                            Unify,
                                                            /* [] */0
                                                          ];
                                                    } else {
                                                      return /* () */0;
                                                    }
                                                  } else {
                                                    throw [
                                                          Unify,
                                                          /* [] */0
                                                        ];
                                                  }
                                                } else {
                                                  throw [
                                                        Unify,
                                                        /* [] */0
                                                      ];
                                                }
                                              } else {
                                                var match$2 = match[1];
                                                if (match$2) {
                                                  var tl1 = match$2[1];
                                                  var t1 = match$2[0];
                                                  if (typeof match$1 === "number") {
                                                    throw [
                                                          Unify,
                                                          /* [] */0
                                                        ];
                                                  } else if (match$1.tag) {
                                                    if (match$1[0] !== 0) {
                                                      throw [
                                                            Unify,
                                                            /* [] */0
                                                          ];
                                                    } else {
                                                      var match$3 = match$1[1];
                                                      if (match$3) {
                                                        var tl2 = match$3[1];
                                                        var t2 = match$3[0];
                                                        eqtype(rename$1, type_pairs$1, subst$1, env$1, t1, t2);
                                                        if (List.length(tl1) === List.length(tl2)) {
                                                          return List.iter2((function (param, param$1) {
                                                                        return eqtype(rename$1, type_pairs$1, subst$1, env$1, param, param$1);
                                                                      }), tl1, tl2);
                                                        } else {
                                                          List.iter((function (param) {
                                                                  return eqtype(rename$1, type_pairs$1, subst$1, env$1, t1, param);
                                                                }), tl2);
                                                          return List.iter((function (t1) {
                                                                        return eqtype(rename$1, type_pairs$1, subst$1, env$1, t1, t2);
                                                                      }), tl1);
                                                        }
                                                      } else {
                                                        throw [
                                                              Unify,
                                                              /* [] */0
                                                            ];
                                                      }
                                                    }
                                                  } else {
                                                    throw [
                                                          Unify,
                                                          /* [] */0
                                                        ];
                                                  }
                                                } else {
                                                  throw [
                                                        Unify,
                                                        /* [] */0
                                                      ];
                                                }
                                              }
                                            } else {
                                              var match$4 = match[0];
                                              if (match$4) {
                                                if (typeof match$1 === "number") {
                                                  throw [
                                                        Unify,
                                                        /* [] */0
                                                      ];
                                                } else if (match$1.tag) {
                                                  throw [
                                                        Unify,
                                                        /* [] */0
                                                      ];
                                                } else {
                                                  var match$5 = match$1[0];
                                                  if (match$5) {
                                                    return eqtype(rename$1, type_pairs$1, subst$1, env$1, match$4[0], match$5[0]);
                                                  } else {
                                                    throw [
                                                          Unify,
                                                          /* [] */0
                                                        ];
                                                  }
                                                }
                                              } else if (typeof match$1 === "number") {
                                                throw [
                                                      Unify,
                                                      /* [] */0
                                                    ];
                                              } else if (match$1.tag) {
                                                throw [
                                                      Unify,
                                                      /* [] */0
                                                    ];
                                              } else if (match$1[0]) {
                                                throw [
                                                      Unify,
                                                      /* [] */0
                                                    ];
                                              } else {
                                                return /* () */0;
                                              }
                                            }
                                          }), match$6[2]);
                            }
                            
                          };
                        } else {
                          throw [
                                Unify,
                                /* [] */0
                              ];
                        }
                        break;
                    case 9 : 
                        if (typeof match$3 === "number") {
                          throw [
                                Unify,
                                /* [] */0
                              ];
                        } else if (match$3.tag === 9) {
                          return unify_univar(t1$prime$1, t2$prime$1, univar_pairs[0]);
                        } else {
                          throw [
                                Unify,
                                /* [] */0
                              ];
                        }
                        break;
                    case 10 : 
                        var tl1 = match$2[1];
                        var t1$2 = match$2[0];
                        var exit$2 = 0;
                        if (tl1) {
                          exit$2 = 2;
                        } else if (typeof match$3 === "number") {
                          throw [
                                Unify,
                                /* [] */0
                              ];
                        } else if (match$3.tag === 10) {
                          if (match$3[1]) {
                            exit$2 = 2;
                          } else {
                            return eqtype(rename, type_pairs, subst, env, t1$2, match$3[0]);
                          }
                        } else {
                          throw [
                                Unify,
                                /* [] */0
                              ];
                        }
                        if (exit$2 === 2) {
                          if (typeof match$3 === "number") {
                            throw [
                                  Unify,
                                  /* [] */0
                                ];
                          } else if (match$3.tag === 10) {
                            return enter_poly(env, univar_pairs, t1$2, tl1, match$3[0], match$3[1], (function (param, param$1) {
                                          return eqtype(rename, type_pairs, subst, env, param, param$1);
                                        }));
                          } else {
                            throw [
                                  Unify,
                                  /* [] */0
                                ];
                          }
                        }
                        break;
                    case 11 : 
                        if (typeof match$3 === "number") {
                          throw [
                                Unify,
                                /* [] */0
                              ];
                        } else if (match$3.tag === 11) {
                          try {
                            return unify_package(env, (function (param, param$1) {
                                          return eqtype_list(rename, type_pairs, subst, env, param, param$1);
                                        }), t1$prime$1[/* level */1], match$2[0], match$2[1], match$2[2], t2$prime$1[/* level */1], match$3[0], match$3[1], match$3[2]);
                          }
                          catch (exn$3){
                            if (exn$3 === Caml_builtin_exceptions.not_found) {
                              throw [
                                    Unify,
                                    /* [] */0
                                  ];
                            } else {
                              throw exn$3;
                            }
                          }
                        } else {
                          throw [
                                Unify,
                                /* [] */0
                              ];
                        }
                        break;
                    
                  }
                }
              } else {
                throw exn$1;
              }
            }
          }
        }
        
      }
      catch (raw_exn){
        var exn$4 = Js_exn.internalToOCamlException(raw_exn);
        if (exn$4[0] === Unify) {
          throw [
                Unify,
                /* :: */[
                  /* tuple */[
                    t1$1,
                    t2$1
                  ],
                  exn$4[1]
                ]
              ];
        } else {
          throw exn$4;
        }
      }
    }
  }
}

function eqtype_list(rename, type_pairs, subst, env, tl1, tl2) {
  if (List.length(tl1) !== List.length(tl2)) {
    throw [
          Unify,
          /* [] */0
        ];
  }
  return List.iter2((function (param, param$1) {
                return eqtype(rename, type_pairs, subst, env, param, param$1);
              }), tl1, tl2);
}

function eqtype_fields(rename, type_pairs, subst, env, ty1, _ty2) {
  while(true) {
    var ty2 = _ty2;
    var match = flatten_fields(ty1);
    var rest1 = match[1];
    var match$1 = flatten_fields(ty2);
    var rest2 = match$1[1];
    var same_row = +(rest1 === rest2) || Curry._2(TypePairs[/* mem */9], type_pairs, /* tuple */[
          rest1,
          rest2
        ]) || rename && List.mem(/* tuple */[
          rest1,
          rest2
        ], subst[0]);
    if (same_row) {
      return /* () */0;
    } else {
      var match$2 = expand_head_rigid(env, rest2);
      var match$3 = match$2[/* desc */0];
      var exit = 0;
      if (typeof match$3 === "number") {
        exit = 1;
      } else if (match$3.tag === 4) {
        _ty2 = match$3[0];
        continue ;
        
      } else {
        exit = 1;
      }
      if (exit === 1) {
        var match$4 = associate_fields(match[0], match$1[0]);
        eqtype(rename, type_pairs, subst, env, rest1, rest2);
        if (match$4[1] !== /* [] */0 || match$4[2] !== /* [] */0) {
          throw [
                Unify,
                /* [] */0
              ];
        }
        return List.iter((function(rest2){
                  return function (param) {
                    var t2 = param[4];
                    var k2 = param[3];
                    var t1 = param[2];
                    var k1 = param[1];
                    var n = param[0];
                    eqtype_kind(k1, k2);
                    try {
                      return eqtype(rename, type_pairs, subst, env, t1, t2);
                    }
                    catch (raw_exn){
                      var exn = Js_exn.internalToOCamlException(raw_exn);
                      if (exn[0] === Unify) {
                        throw [
                              Unify,
                              /* :: */[
                                /* tuple */[
                                  newty2(current_level[0], /* Tfield */Block.__(5, [
                                          n,
                                          k1,
                                          t1,
                                          rest2
                                        ])),
                                  newty2(current_level[0], /* Tfield */Block.__(5, [
                                          n,
                                          k2,
                                          t2,
                                          rest2
                                        ]))
                                ],
                                exn[1]
                              ]
                            ];
                      } else {
                        throw exn;
                      }
                    }
                  }
                  }(rest2)), match$4[0]);
      }
      
    }
  };
}

function eqtype_kind(k1, k2) {
  var k1$1 = field_kind_repr(k1);
  var k2$1 = field_kind_repr(k2);
  if (typeof k1$1 === "number") {
    if (k1$1 !== 0) {
      throw [
            Unify,
            /* [] */0
          ];
    } else if (typeof k2$1 === "number") {
      if (k2$1 !== 0) {
        throw [
              Unify,
              /* [] */0
            ];
      } else {
        return /* () */0;
      }
    } else {
      throw [
            Unify,
            /* [] */0
          ];
    }
  } else if (typeof k2$1 === "number") {
    throw [
          Unify,
          /* [] */0
        ];
  } else {
    return /* () */0;
  }
}

function equal$4(env, rename, tyl1, tyl2) {
  try {
    univar_pairs[0] = /* [] */0;
    eqtype_list(rename, Curry._1(TypePairs[/* create */0], 11), [/* [] */0], env, tyl1, tyl2);
    return /* true */1;
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === Unify) {
      return /* false */0;
    } else {
      throw exn;
    }
  }
}

function eqtype$1(rename, type_pairs, subst, env, t1, t2) {
  univar_pairs[0] = /* [] */0;
  return eqtype(rename, type_pairs, subst, env, t1, t2);
}

var Failure = Caml_exceptions.create("Ocaml_typedtree_test.Ctype.Failure");

function moregen_clty(trace, type_pairs, env, cty1, cty2) {
  try {
    var exit = 0;
    switch (cty1.tag | 0) {
      case 0 : 
          return moregen_clty(/* true */1, type_pairs, env, cty1[2], cty2);
      case 1 : 
          var sign1 = cty1[0];
          switch (cty2.tag | 0) {
            case 0 : 
                exit = 1;
                break;
            case 1 : 
                var sign2 = cty2[0];
                var ty1 = object_fields(repr(sign1[/* csig_self */0]));
                var ty2 = object_fields(repr(sign2[/* csig_self */0]));
                var match = flatten_fields(ty1);
                var match$1 = flatten_fields(ty2);
                var match$2 = associate_fields(match[0], match$1[0]);
                List.iter((function (param) {
                        try {
                          return moregen$1(/* true */1, type_pairs, env, param[2], param[4]);
                        }
                        catch (raw_exn){
                          var exn = Js_exn.internalToOCamlException(raw_exn);
                          if (exn[0] === Unify) {
                            throw [
                                  Failure,
                                  /* :: */[
                                    /* CM_Meth_type_mismatch */Block.__(5, [
                                        param[0],
                                        env,
                                        expand_trace(env, exn[1])
                                      ]),
                                    /* [] */0
                                  ]
                                ];
                          } else {
                            throw exn;
                          }
                        }
                      }), match$2[0]);
                return iter$1((function (lab, param) {
                              var match = find(lab, sign1[/* csig_vars */1]);
                              try {
                                return moregen$1(/* true */1, type_pairs, env, match[2], param[2]);
                              }
                              catch (raw_exn){
                                var exn = Js_exn.internalToOCamlException(raw_exn);
                                if (exn[0] === Unify) {
                                  throw [
                                        Failure,
                                        /* :: */[
                                          /* CM_Val_type_mismatch */Block.__(4, [
                                              lab,
                                              env,
                                              expand_trace(env, exn[1])
                                            ]),
                                          /* [] */0
                                        ]
                                      ];
                                } else {
                                  throw exn;
                                }
                              }
                            }), sign2[/* csig_vars */1]);
            case 2 : 
                throw [
                      Failure,
                      /* [] */0
                    ];
            
          }
          break;
      case 2 : 
          switch (cty2.tag | 0) {
            case 0 : 
                exit = 1;
                break;
            case 1 : 
                throw [
                      Failure,
                      /* [] */0
                    ];
            case 2 : 
                if (cty1[0] === cty2[0]) {
                  try {
                    moregen$1(/* true */1, type_pairs, env, cty1[1], cty2[1]);
                  }
                  catch (raw_exn){
                    var exn = Js_exn.internalToOCamlException(raw_exn);
                    if (exn[0] === Unify) {
                      throw [
                            Failure,
                            /* :: */[
                              /* CM_Parameter_mismatch */Block.__(3, [
                                  env,
                                  expand_trace(env, exn[1])
                                ]),
                              /* [] */0
                            ]
                          ];
                    } else {
                      throw exn;
                    }
                  }
                  return moregen_clty(/* false */0, type_pairs, env, cty1[2], cty2[2]);
                } else {
                  throw [
                        Failure,
                        /* [] */0
                      ];
                }
                break;
            
          }
          break;
      
    }
    if (exit === 1) {
      return moregen_clty(/* true */1, type_pairs, env, cty1, cty2[2]);
    }
    
  }
  catch (raw_exn$1){
    var exn$1 = Js_exn.internalToOCamlException(raw_exn$1);
    if (exn$1[0] === Failure) {
      var error = exn$1[1];
      if (trace || error === /* [] */0) {
        throw [
              Failure,
              /* :: */[
                /* CM_Class_type_mismatch */Block.__(2, [
                    env,
                    cty1,
                    cty2
                  ]),
                error
              ]
            ];
      } else {
        throw exn$1;
      }
    } else {
      throw exn$1;
    }
  }
}

function match_class_types($staropt$star, env, pat_sch, subj_sch) {
  var trace = $staropt$star ? $staropt$star[0] : /* true */1;
  var type_pairs = Curry._1(TypePairs[/* create */0], 53);
  var old_level = current_level[0];
  current_level[0] = 99999999;
  var match = instance_class(/* [] */0, subj_sch);
  var subj = duplicate_class_type(match[1]);
  current_level[0] = 100000000;
  var match$1 = instance_class(/* [] */0, pat_sch);
  var patt = match$1[1];
  var sign1 = signature_of_class_type(patt);
  var sign2 = signature_of_class_type(subj);
  var t1 = repr(sign1[/* csig_self */0]);
  var t2 = repr(sign2[/* csig_self */0]);
  Curry._3(TypePairs[/* add */4], type_pairs, /* tuple */[
        t1,
        t2
      ], /* () */0);
  var match$2 = flatten_fields(object_fields(t1));
  var match$3 = flatten_fields(object_fields(t2));
  var match$4 = associate_fields(match$2[0], match$3[0]);
  var error = List.fold_right((function (param, err) {
          var lab = param[0];
          var k = field_kind_repr(param[1]);
          var err$1 = typeof k === "number" ? /* :: */[
              /* CM_Hide_public */Block.__(10, [lab]),
              err
            ] : (set_kind(k[0], /* Fabsent */1), err);
          if (mem$2(lab, sign1[/* csig_concr */2])) {
            return err$1;
          } else {
            return /* :: */[
                    /* CM_Hide_virtual */Block.__(11, [
                        "method",
                        lab
                      ]),
                    err$1
                  ];
          }
        }), match$4[1], /* [] */0);
  var missing_method = List.map((function (param) {
          return param[0];
        }), match$4[2]);
  var error$1 = Pervasives.$at(List.map((function (m) {
              return /* CM_Missing_method */Block.__(9, [m]);
            }), missing_method), error);
  moregen$1(/* true */1, type_pairs, env, match$2[1], match$3[1]);
  var error$2 = List.fold_right((function (param, err) {
          try {
            moregen_kind(param[1], param[3]);
            return err;
          }
          catch (raw_exn){
            var exn = Js_exn.internalToOCamlException(raw_exn);
            if (exn[0] === Unify) {
              return /* :: */[
                      /* CM_Public_method */Block.__(12, [param[0]]),
                      err
                    ];
            } else {
              throw exn;
            }
          }
        }), match$4[0], error$1);
  var error$3 = fold((function (lab, param, err) {
          try {
            var match = find(lab, sign1[/* csig_vars */1]);
            if (param[0] === /* Mutable */1 && match[0] !== /* Mutable */1) {
              return /* :: */[
                      /* CM_Non_mutable_value */Block.__(6, [lab]),
                      err
                    ];
            } else if (param[1] === /* Concrete */1 && match[1] !== /* Concrete */1) {
              return /* :: */[
                      /* CM_Non_concrete_value */Block.__(7, [lab]),
                      err
                    ];
            } else {
              return err;
            }
          }
          catch (exn){
            if (exn === Caml_builtin_exceptions.not_found) {
              return /* :: */[
                      /* CM_Missing_value */Block.__(8, [lab]),
                      err
                    ];
            } else {
              throw exn;
            }
          }
        }), sign2[/* csig_vars */1], error$2);
  var error$4 = fold((function (lab, param, err) {
          if (param[1] === /* Virtual */0 && !mem(lab, sign2[/* csig_vars */1])) {
            return /* :: */[
                    /* CM_Hide_virtual */Block.__(11, [
                        "instance variable",
                        lab
                      ]),
                    err
                  ];
          } else {
            return err;
          }
        }), sign1[/* csig_vars */1], error$3);
  var error$5 = List.fold_right((function (e, l) {
          if (List.mem(e, missing_method)) {
            return l;
          } else {
            return /* :: */[
                    /* CM_Virtual_method */Block.__(14, [e]),
                    l
                  ];
          }
        }), elements_aux(/* [] */0, diff(sign2[/* csig_concr */2], sign1[/* csig_concr */2])), error$4);
  var res;
  if (error$5) {
    res = /* :: */[
      /* CM_Class_type_mismatch */Block.__(2, [
          env,
          patt,
          subj
        ]),
      error$5
    ];
  } else {
    try {
      moregen_clty(trace, type_pairs, env, patt, subj);
      res = /* [] */0;
    }
    catch (raw_exn){
      var exn = Js_exn.internalToOCamlException(raw_exn);
      if (exn[0] === Failure) {
        res = exn[1];
      } else {
        throw exn;
      }
    }
  }
  current_level[0] = old_level;
  return res;
}

function equal_clty(trace, type_pairs, subst, env, cty1, cty2) {
  try {
    var exit = 0;
    switch (cty1.tag | 0) {
      case 0 : 
          var cty1$1 = cty1[2];
          var exit$1 = 0;
          switch (cty2.tag | 0) {
            case 0 : 
                return equal_clty(/* true */1, type_pairs, subst, env, cty1$1, cty2[2]);
            case 1 : 
            case 2 : 
                exit$1 = 3;
                break;
            
          }
          if (exit$1 === 3) {
            return equal_clty(/* true */1, type_pairs, subst, env, cty1$1, cty2);
          }
          break;
      case 1 : 
          var sign1 = cty1[0];
          switch (cty2.tag | 0) {
            case 0 : 
                exit = 1;
                break;
            case 1 : 
                var sign2 = cty2[0];
                var ty1 = object_fields(repr(sign1[/* csig_self */0]));
                var ty2 = object_fields(repr(sign2[/* csig_self */0]));
                var match = flatten_fields(ty1);
                var match$1 = flatten_fields(ty2);
                var match$2 = associate_fields(match[0], match$1[0]);
                List.iter((function (param) {
                        try {
                          return eqtype$1(/* true */1, type_pairs, subst, env, param[2], param[4]);
                        }
                        catch (raw_exn){
                          var exn = Js_exn.internalToOCamlException(raw_exn);
                          if (exn[0] === Unify) {
                            throw [
                                  Failure,
                                  /* :: */[
                                    /* CM_Meth_type_mismatch */Block.__(5, [
                                        param[0],
                                        env,
                                        expand_trace(env, exn[1])
                                      ]),
                                    /* [] */0
                                  ]
                                ];
                          } else {
                            throw exn;
                          }
                        }
                      }), match$2[0]);
                return iter$1((function (lab, param) {
                              var match = find(lab, sign1[/* csig_vars */1]);
                              try {
                                return eqtype$1(/* true */1, type_pairs, subst, env, match[2], param[2]);
                              }
                              catch (raw_exn){
                                var exn = Js_exn.internalToOCamlException(raw_exn);
                                if (exn[0] === Unify) {
                                  throw [
                                        Failure,
                                        /* :: */[
                                          /* CM_Val_type_mismatch */Block.__(4, [
                                              lab,
                                              env,
                                              expand_trace(env, exn[1])
                                            ]),
                                          /* [] */0
                                        ]
                                      ];
                                } else {
                                  throw exn;
                                }
                              }
                            }), sign2[/* csig_vars */1]);
            case 2 : 
                exit = 2;
                break;
            
          }
          break;
      case 2 : 
          switch (cty2.tag | 0) {
            case 0 : 
                exit = 1;
                break;
            case 1 : 
                exit = 2;
                break;
            case 2 : 
                if (cty1[0] === cty2[0]) {
                  try {
                    eqtype$1(/* true */1, type_pairs, subst, env, cty1[1], cty2[1]);
                  }
                  catch (raw_exn){
                    var exn = Js_exn.internalToOCamlException(raw_exn);
                    if (exn[0] === Unify) {
                      throw [
                            Failure,
                            /* :: */[
                              /* CM_Parameter_mismatch */Block.__(3, [
                                  env,
                                  expand_trace(env, exn[1])
                                ]),
                              /* [] */0
                            ]
                          ];
                    } else {
                      throw exn;
                    }
                  }
                  return equal_clty(/* false */0, type_pairs, subst, env, cty1[2], cty2[2]);
                } else {
                  exit = 2;
                }
                break;
            
          }
          break;
      
    }
    switch (exit) {
      case 1 : 
          return equal_clty(/* true */1, type_pairs, subst, env, cty1, cty2[2]);
      case 2 : 
          throw [
                Failure,
                trace ? /* [] */0 : /* :: */[
                    /* CM_Class_type_mismatch */Block.__(2, [
                        env,
                        cty1,
                        cty2
                      ]),
                    /* [] */0
                  ]
              ];
      
    }
  }
  catch (raw_exn$1){
    var exn$1 = Js_exn.internalToOCamlException(raw_exn$1);
    if (exn$1[0] === Failure) {
      if (trace) {
        throw [
              Failure,
              /* :: */[
                /* CM_Class_type_mismatch */Block.__(2, [
                    env,
                    cty1,
                    cty2
                  ]),
                exn$1[1]
              ]
            ];
      } else {
        throw exn$1;
      }
    } else {
      throw exn$1;
    }
  }
}

function match_class_declarations(env, patt_params, patt_type, subj_params, subj_type) {
  var type_pairs = Curry._1(TypePairs[/* create */0], 53);
  var subst = [/* [] */0];
  var sign1 = signature_of_class_type(patt_type);
  var sign2 = signature_of_class_type(subj_type);
  var t1 = repr(sign1[/* csig_self */0]);
  var t2 = repr(sign2[/* csig_self */0]);
  Curry._3(TypePairs[/* add */4], type_pairs, /* tuple */[
        t1,
        t2
      ], /* () */0);
  var match = flatten_fields(object_fields(t1));
  var match$1 = flatten_fields(object_fields(t2));
  var match$2 = associate_fields(match[0], match$1[0]);
  var error = List.fold_right((function (param, err) {
          var lab = param[0];
          var k = field_kind_repr(param[1]);
          var err$1 = typeof k === "number" ? /* :: */[
              /* CM_Hide_public */Block.__(10, [lab]),
              err
            ] : err;
          if (mem$2(lab, sign1[/* csig_concr */2])) {
            return err$1;
          } else {
            return /* :: */[
                    /* CM_Hide_virtual */Block.__(11, [
                        "method",
                        lab
                      ]),
                    err$1
                  ];
          }
        }), match$2[1], /* [] */0);
  var missing_method = List.map((function (param) {
          return param[0];
        }), match$2[2]);
  var error$1 = Pervasives.$at(List.map((function (m) {
              return /* CM_Missing_method */Block.__(9, [m]);
            }), missing_method), error);
  eqtype$1(/* true */1, type_pairs, subst, env, match[1], match$1[1]);
  var error$2 = List.fold_right((function (param, err) {
          var lab = param[0];
          var k1 = field_kind_repr(param[1]);
          var k2 = field_kind_repr(param[3]);
          var exit = 0;
          if (typeof k1 === "number") {
            if (k1 !== 0) {
              exit = 1;
            } else if (typeof k2 === "number") {
              if (k2 !== 0) {
                exit = 1;
              } else {
                return err;
              }
            } else {
              return /* :: */[
                      /* CM_Public_method */Block.__(12, [lab]),
                      err
                    ];
            }
          } else if (typeof k2 === "number") {
            if (k2 !== 0) {
              exit = 1;
            } else {
              return /* :: */[
                      /* CM_Private_method */Block.__(13, [lab]),
                      err
                    ];
            }
          } else {
            return err;
          }
          if (exit === 1) {
            throw [
                  Caml_builtin_exceptions.assert_failure,
                  [
                    "ctype.ml",
                    3600,
                    34
                  ]
                ];
          }
          
        }), match$2[0], error$1);
  var error$3 = fold((function (lab, param, err) {
          try {
            var match = find(lab, sign1[/* csig_vars */1]);
            if (param[0] === /* Mutable */1 && match[0] !== /* Mutable */1) {
              return /* :: */[
                      /* CM_Non_mutable_value */Block.__(6, [lab]),
                      err
                    ];
            } else if (param[1] === /* Concrete */1 && match[1] !== /* Concrete */1) {
              return /* :: */[
                      /* CM_Non_concrete_value */Block.__(7, [lab]),
                      err
                    ];
            } else {
              return err;
            }
          }
          catch (exn){
            if (exn === Caml_builtin_exceptions.not_found) {
              return /* :: */[
                      /* CM_Missing_value */Block.__(8, [lab]),
                      err
                    ];
            } else {
              throw exn;
            }
          }
        }), sign2[/* csig_vars */1], error$2);
  var error$4 = fold((function (lab, param, err) {
          if (param[1] === /* Virtual */0 && !mem(lab, sign2[/* csig_vars */1])) {
            return /* :: */[
                    /* CM_Hide_virtual */Block.__(11, [
                        "instance variable",
                        lab
                      ]),
                    err
                  ];
          } else {
            return err;
          }
        }), sign1[/* csig_vars */1], error$3);
  var error$5 = List.fold_right((function (e, l) {
          if (List.mem(e, missing_method)) {
            return l;
          } else {
            return /* :: */[
                    /* CM_Virtual_method */Block.__(14, [e]),
                    l
                  ];
          }
        }), elements_aux(/* [] */0, diff(sign2[/* csig_concr */2], sign1[/* csig_concr */2])), error$4);
  if (error$5) {
    return error$5;
  } else {
    try {
      var lp = List.length(patt_params);
      var ls = List.length(subj_params);
      if (lp !== ls) {
        throw [
              Failure,
              /* :: */[
                /* CM_Parameter_arity_mismatch */Block.__(0, [
                    lp,
                    ls
                  ]),
                /* [] */0
              ]
            ];
      }
      List.iter2((function (p, s) {
              try {
                return eqtype$1(/* true */1, type_pairs, subst, env, p, s);
              }
              catch (raw_exn){
                var exn = Js_exn.internalToOCamlException(raw_exn);
                if (exn[0] === Unify) {
                  throw [
                        Failure,
                        /* :: */[
                          /* CM_Type_parameter_mismatch */Block.__(1, [
                              env,
                              expand_trace(env, exn[1])
                            ]),
                          /* [] */0
                        ]
                      ];
                } else {
                  throw exn;
                }
              }
            }), patt_params, subj_params);
      equal_clty(/* false */0, type_pairs, subst, env, /* Cty_signature */Block.__(1, [sign1]), /* Cty_signature */Block.__(1, [sign2]));
      var clty_params = function (param, param$1) {
        return List.fold_right((function (ty, cty) {
                      return /* Cty_arrow */Block.__(2, [
                                "*",
                                ty,
                                cty
                              ]);
                    }), param, param$1);
      };
      return match_class_types(/* Some */[/* false */0], env, clty_params(patt_params, patt_type), clty_params(subj_params, subj_type));
    }
    catch (raw_exn){
      var exn = Js_exn.internalToOCamlException(raw_exn);
      if (exn[0] === Failure) {
        return exn[1];
      } else {
        throw exn;
      }
    }
  }
}

var warn = [/* false */0];

function pred_expand(n) {
  if (n % 2 === 0 && n > 0) {
    return n - 1 | 0;
  } else {
    return n;
  }
}

function pred_enlarge(n) {
  if (n % 2 === 1) {
    return n - 1 | 0;
  } else {
    return n;
  }
}

function collect(l) {
  return List.fold_left((function (c1, param) {
                return Pervasives.max(c1, param[1]);
              }), /* Unchanged */0, l);
}

function filter_visited(_l) {
  while(true) {
    var l = _l;
    if (l) {
      var match = l[0][/* desc */0];
      if (typeof match === "number") {
        _l = l[1];
        continue ;
        
      } else {
        switch (match.tag | 0) {
          case 4 : 
          case 8 : 
              return l;
          default:
            _l = l[1];
            continue ;
            
        }
      }
    } else {
      return /* [] */0;
    }
  };
}

function memq_warn(t, visited) {
  if (List.memq(t, visited)) {
    warn[0] = /* true */1;
    return /* true */1;
  } else {
    return /* false */0;
  }
}

function lid_of_path($staropt$star, param) {
  var sharp = $staropt$star ? $staropt$star[0] : "";
  switch (param.tag | 0) {
    case 0 : 
        return /* Lident */Block.__(0, [sharp + param[0][/* name */1]]);
    case 1 : 
        return /* Ldot */Block.__(1, [
                  lid_of_path(/* None */0, param[0]),
                  sharp + param[1]
                ]);
    case 2 : 
        return /* Lapply */Block.__(2, [
                  lid_of_path(/* Some */[sharp], param[0]),
                  lid_of_path(/* None */0, param[1])
                ]);
    
  }
}

function find_cltype_for_path(env, p) {
  var match = lookup_type$1(lid_of_path(/* Some */["#"], p), env);
  var cl_abbr = match[1];
  var match$1 = cl_abbr[/* type_manifest */4];
  if (match$1) {
    var ty = match$1[0];
    var match$2 = repr(ty)[/* desc */0];
    if (typeof match$2 === "number") {
      throw Caml_builtin_exceptions.not_found;
    } else if (match$2.tag === 4) {
      var match$3 = match$2[1][/* contents */0];
      if (match$3) {
        if (same(p, match$3[0][0])) {
          return /* tuple */[
                  cl_abbr,
                  ty
                ];
        } else {
          throw Caml_builtin_exceptions.not_found;
        }
      } else {
        throw Caml_builtin_exceptions.not_found;
      }
    } else {
      throw Caml_builtin_exceptions.not_found;
    }
  } else {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "ctype.ml",
            3707,
            12
          ]
        ];
  }
}

function has_constr_row$prime(env, t) {
  return has_constr_row(expand_abbrev(env)(t));
}

function build_subtype(env, visited, loops, posi, level, t) {
  var t$1 = repr(t);
  var match = t$1[/* desc */0];
  if (typeof match === "number") {
    if (posi) {
      var v = newvar(/* None */0, /* () */0);
      return /* tuple */[
              v,
              /* Changed */2
            ];
    } else {
      warn[0] = /* true */1;
      return /* tuple */[
              t$1,
              /* Unchanged */0
            ];
    }
  } else {
    switch (match.tag | 0) {
      case 0 : 
          if (posi) {
            try {
              var t$prime = List.assq(t$1, loops);
              warn[0] = /* true */1;
              return /* tuple */[
                      t$prime,
                      /* Equiv */1
                    ];
            }
            catch (exn){
              if (exn === Caml_builtin_exceptions.not_found) {
                return /* tuple */[
                        t$1,
                        /* Unchanged */0
                      ];
              } else {
                throw exn;
              }
            }
          } else {
            return /* tuple */[
                    t$1,
                    /* Unchanged */0
                  ];
          }
          break;
      case 1 : 
          if (memq_warn(t$1, visited)) {
            return /* tuple */[
                    t$1,
                    /* Unchanged */0
                  ];
          } else {
            var visited$1 = /* :: */[
              t$1,
              visited
            ];
            var match$1 = build_subtype(env, visited$1, loops, 1 - posi, level, match[1]);
            var match$2 = build_subtype(env, visited$1, loops, posi, level, match[2]);
            var c = Pervasives.max(match$1[1], match$2[1]);
            if (Caml_obj.caml_greaterthan(c, /* Unchanged */0)) {
              return /* tuple */[
                      newty2(current_level[0], /* Tarrow */Block.__(1, [
                              match[0],
                              match$1[0],
                              match$2[0],
                              /* Cok */0
                            ])),
                      c
                    ];
            } else {
              return /* tuple */[
                      t$1,
                      /* Unchanged */0
                    ];
            }
          }
          break;
      case 2 : 
          if (memq_warn(t$1, visited)) {
            return /* tuple */[
                    t$1,
                    /* Unchanged */0
                  ];
          } else {
            var visited$2 = /* :: */[
              t$1,
              visited
            ];
            var tlist$prime = List.map((function (param) {
                    return build_subtype(env, visited$2, loops, posi, level, param);
                  }), match[0]);
            var c$1 = collect(tlist$prime);
            if (Caml_obj.caml_greaterthan(c$1, /* Unchanged */0)) {
              var desc = /* Ttuple */Block.__(2, [List.map((function (prim) {
                          return prim[0];
                        }), tlist$prime)]);
              return /* tuple */[
                      newty2(current_level[0], desc),
                      c$1
                    ];
            } else {
              return /* tuple */[
                      t$1,
                      /* Unchanged */0
                    ];
            }
          }
          break;
      case 3 : 
          var tl = match[1];
          var p = match[0];
          if (level > 0 && generic_abbrev(env, p) && safe_abbrev(env, t$1) && !has_constr_row$prime(env, t$1)) {
            var t$prime$1 = repr(expand_abbrev(env)(t$1));
            var level$prime = pred_expand(level);
            try {
              var match$3 = t$prime$1[/* desc */0];
              if (typeof match$3 === "number") {
                throw Caml_builtin_exceptions.not_found;
              } else if (match$3.tag === 4) {
                if (posi && !opened_object(t$prime$1)) {
                  var match$4 = find_cltype_for_path(env, p);
                  var ty = subst(env, current_level[0], /* Public */1, match[2], /* None */0, match$4[0][/* type_params */0], tl, match$4[1]);
                  var ty$1 = repr(ty);
                  var match$5 = ty$1[/* desc */0];
                  var match$6;
                  if (typeof match$5 === "number") {
                    throw Caml_builtin_exceptions.not_found;
                  } else if (match$5.tag === 4) {
                    var match$7 = match$5[1][/* contents */0];
                    if (match$7) {
                      var match$8 = match$7[0];
                      if (same(p, match$8[0])) {
                        match$6 = /* tuple */[
                          match$5[0],
                          match$8[1]
                        ];
                      } else {
                        throw Caml_builtin_exceptions.not_found;
                      }
                    } else {
                      throw Caml_builtin_exceptions.not_found;
                    }
                  } else {
                    throw Caml_builtin_exceptions.not_found;
                  }
                  var tl1 = match$6[1];
                  if (List.exists((function (param) {
                            return deep_occur(ty$1, param);
                          }), tl1)) {
                    throw Caml_builtin_exceptions.not_found;
                  }
                  ty$1[/* desc */0] = /* Tvar */Block.__(0, [/* None */0]);
                  var t$prime$prime = newvar(/* None */0, /* () */0);
                  var loops_000 = /* tuple */[
                    ty$1,
                    t$prime$prime
                  ];
                  var loops$1 = /* :: */[
                    loops_000,
                    loops
                  ];
                  var match$9 = build_subtype(env, /* :: */[
                        t$prime$1,
                        /* [] */0
                      ], loops$1, posi, pred_enlarge(level$prime), match$6[0]);
                  var ty1$prime = match$9[0];
                  if (!is_Tvar(t$prime$prime)) {
                    throw [
                          Caml_builtin_exceptions.assert_failure,
                          [
                            "ctype.ml",
                            3770,
                            10
                          ]
                        ];
                  }
                  var nm = Caml_obj.caml_greaterthan(match$9[1], /* Equiv */1) || deep_occur(ty$1, ty1$prime) ? /* None */0 : /* Some */[/* tuple */[
                        p,
                        tl1
                      ]];
                  t$prime$prime[/* desc */0] = /* Tobject */Block.__(4, [
                      ty1$prime,
                      [nm]
                    ]);
                  try {
                    unify_var(env, ty$1, t$1);
                  }
                  catch (raw_exn){
                    var exn$1 = Js_exn.internalToOCamlException(raw_exn);
                    if (exn$1[0] === Unify) {
                      throw [
                            Caml_builtin_exceptions.assert_failure,
                            [
                              "ctype.ml",
                              3774,
                              50
                            ]
                          ];
                    } else {
                      throw exn$1;
                    }
                  }
                  return /* tuple */[
                          t$prime$prime,
                          /* Changed */2
                        ];
                } else {
                  throw Caml_builtin_exceptions.not_found;
                }
              } else {
                throw Caml_builtin_exceptions.not_found;
              }
            }
            catch (exn$2){
              if (exn$2 === Caml_builtin_exceptions.not_found) {
                var match$10 = build_subtype(env, visited, loops, posi, level$prime, t$prime$1);
                var c$2 = match$10[1];
                if (Caml_obj.caml_greaterthan(c$2, /* Unchanged */0)) {
                  return /* tuple */[
                          match$10[0],
                          c$2
                        ];
                } else {
                  return /* tuple */[
                          t$1,
                          /* Unchanged */0
                        ];
                }
              } else {
                throw exn$2;
              }
            }
          } else if (memq_warn(t$1, visited)) {
            return /* tuple */[
                    t$1,
                    /* Unchanged */0
                  ];
          } else {
            var visited$3 = /* :: */[
              t$1,
              visited
            ];
            try {
              var decl = find_type_full(p, env)[0];
              if (level === 0 && generic_abbrev(env, p) && safe_abbrev(env, t$1) && !has_constr_row$prime(env, t$1)) {
                warn[0] = /* true */1;
              }
              var tl$prime = List.map2((function (v, t) {
                      var match = Curry._1(Types_003[/* get_upper */10], v);
                      var co = match[0];
                      if (match[1]) {
                        if (co) {
                          return /* tuple */[
                                  t,
                                  /* Unchanged */0
                                ];
                        } else {
                          return build_subtype(env, visited$3, loops, 1 - posi, level, t);
                        }
                      } else if (co) {
                        return build_subtype(env, visited$3, loops, posi, level, t);
                      } else {
                        return /* tuple */[
                                newvar(/* None */0, /* () */0),
                                /* Changed */2
                              ];
                      }
                    }), decl[/* type_variance */5], tl);
              var c$3 = collect(tl$prime);
              if (Caml_obj.caml_greaterthan(c$3, /* Unchanged */0)) {
                return /* tuple */[
                        newconstr(p, List.map((function (prim) {
                                    return prim[0];
                                  }), tl$prime)),
                        c$3
                      ];
              } else {
                return /* tuple */[
                        t$1,
                        /* Unchanged */0
                      ];
              }
            }
            catch (exn$3){
              if (exn$3 === Caml_builtin_exceptions.not_found) {
                return /* tuple */[
                        t$1,
                        /* Unchanged */0
                      ];
              } else {
                throw exn$3;
              }
            }
          }
          break;
      case 4 : 
          var t1 = match[0];
          if (memq_warn(t$1, visited) || opened_object(t1)) {
            return /* tuple */[
                    t$1,
                    /* Unchanged */0
                  ];
          } else {
            var level$prime$1 = pred_enlarge(level);
            var visited_001 = level$prime$1 < level ? /* [] */0 : filter_visited(visited);
            var visited$4 = /* :: */[
              t$1,
              visited_001
            ];
            var match$11 = build_subtype(env, visited$4, loops, posi, level$prime$1, t1);
            var c$4 = match$11[1];
            if (Caml_obj.caml_greaterthan(c$4, /* Unchanged */0)) {
              return /* tuple */[
                      newty2(current_level[0], /* Tobject */Block.__(4, [
                              match$11[0],
                              [/* None */0]
                            ])),
                      c$4
                    ];
            } else {
              return /* tuple */[
                      t$1,
                      /* Unchanged */0
                    ];
            }
          }
          break;
      case 5 : 
          var match$12 = build_subtype(env, visited, loops, posi, level, match[2]);
          var match$13 = build_subtype(env, visited, loops, posi, level, match[3]);
          var c$5 = Pervasives.max(match$12[1], match$13[1]);
          if (Caml_obj.caml_greaterthan(c$5, /* Unchanged */0)) {
            return /* tuple */[
                    newty2(current_level[0], /* Tfield */Block.__(5, [
                            match[0],
                            /* Fpresent */0,
                            match$12[0],
                            match$13[0]
                          ])),
                    c$5
                  ];
          } else {
            return /* tuple */[
                    t$1,
                    /* Unchanged */0
                  ];
          }
      case 6 : 
      case 7 : 
          throw [
                Caml_builtin_exceptions.assert_failure,
                [
                  "ctype.ml",
                  3865,
                  6
                ]
              ];
      case 8 : 
          var row = row_repr_aux(/* [] */0, match[0]);
          if (memq_warn(t$1, visited) || !static_row(row)) {
            return /* tuple */[
                    t$1,
                    /* Unchanged */0
                  ];
          } else {
            var level$prime$2 = pred_enlarge(level);
            var visited_001$1 = level$prime$2 < level ? /* [] */0 : filter_visited(visited);
            var visited$5 = /* :: */[
              t$1,
              visited_001$1
            ];
            var fields = filter_row_fields(/* false */0, row[/* row_fields */0]);
            var fields$1 = List.map((function (orig) {
                    var l = orig[0];
                    var match = row_field_repr_aux(/* [] */0, orig[1]);
                    if (typeof match === "number") {
                      throw [
                            Caml_builtin_exceptions.assert_failure,
                            [
                              "ctype.ml",
                              3832,
                              17
                            ]
                          ];
                    } else if (match.tag) {
                      throw [
                            Caml_builtin_exceptions.assert_failure,
                            [
                              "ctype.ml",
                              3832,
                              17
                            ]
                          ];
                    } else {
                      var match$1 = match[0];
                      if (match$1) {
                        var match$2 = build_subtype(env, visited$5, loops, posi, level$prime$2, match$1[0]);
                        var t$prime = match$2[0];
                        var f = posi && level > 0 ? /* Reither */Block.__(1, [
                              /* false */0,
                              /* :: */[
                                t$prime,
                                /* [] */0
                              ],
                              /* false */0,
                              [/* None */0]
                            ]) : /* Rpresent */Block.__(0, [/* Some */[t$prime]]);
                        return /* tuple */[
                                /* tuple */[
                                  l,
                                  f
                                ],
                                match$2[1]
                              ];
                      } else if (posi) {
                        return /* tuple */[
                                /* tuple */[
                                  l,
                                  /* Reither */Block.__(1, [
                                      /* true */1,
                                      /* [] */0,
                                      /* false */0,
                                      [/* None */0]
                                    ])
                                ],
                                /* Unchanged */0
                              ];
                      } else {
                        return /* tuple */[
                                orig,
                                /* Unchanged */0
                              ];
                      }
                    }
                  }), fields);
            var c$6 = collect(fields$1);
            var row_000 = /* row_fields */List.map((function (prim) {
                    return prim[0];
                  }), fields$1);
            var row_001 = /* row_more */newvar(/* None */0, /* () */0);
            var row_005 = /* row_name */Caml_obj.caml_greaterthan(c$6, /* Unchanged */0) ? /* None */0 : row[/* row_name */5];
            var row$1 = /* record */[
              row_000,
              row_001,
              /* row_bound : () */0,
              /* row_closed */posi,
              /* row_fixed : false */0,
              row_005
            ];
            return /* tuple */[
                    newty2(current_level[0], /* Tvariant */Block.__(8, [row$1])),
                    /* Changed */2
                  ];
          }
          break;
      case 10 : 
          var match$14 = build_subtype(env, visited, loops, posi, level, match[0]);
          var c$7 = match$14[1];
          if (Caml_obj.caml_greaterthan(c$7, /* Unchanged */0)) {
            return /* tuple */[
                    newty2(current_level[0], /* Tpoly */Block.__(10, [
                            match$14[0],
                            match[1]
                          ])),
                    c$7
                  ];
          } else {
            return /* tuple */[
                    t$1,
                    /* Unchanged */0
                  ];
          }
      case 9 : 
      case 11 : 
          return /* tuple */[
                  t$1,
                  /* Unchanged */0
                ];
      
    }
  }
}

function enlarge_type(env, ty) {
  warn[0] = /* false */0;
  var match = build_subtype(env, /* [] */0, /* [] */0, /* true */1, 4, ty);
  return /* tuple */[
          match[0],
          warn[0]
        ];
}

var subtypes = Curry._1(TypePairs[/* create */0], 17);

function subtype_error(env, trace) {
  throw [
        Subtype,
        expand_trace(env, List.rev(trace)),
        /* [] */0
      ];
}

function subtype_rec(env, _trace, _t1, _t2, _cstrs) {
  while(true) {
    var cstrs = _cstrs;
    var t2 = _t2;
    var t1 = _t1;
    var trace = _trace;
    var t1$1 = repr(t1);
    var t2$1 = repr(t2);
    if (t1$1 === t2$1) {
      return cstrs;
    } else {
      try {
        Curry._2(TypePairs[/* find */6], subtypes, /* tuple */[
              t1$1,
              t2$1
            ]);
        return cstrs;
      }
      catch (exn){
        if (exn === Caml_builtin_exceptions.not_found) {
          Curry._3(TypePairs[/* add */4], subtypes, /* tuple */[
                t1$1,
                t2$1
              ], /* () */0);
          var match = t1$1[/* desc */0];
          var match$1 = t2$1[/* desc */0];
          var exit = 0;
          var exit$1 = 0;
          var exit$2 = 0;
          var exit$3 = 0;
          var exit$4 = 0;
          if (typeof match === "number") {
            exit$4 = 6;
          } else {
            switch (match.tag | 0) {
              case 0 : 
                  exit = 2;
                  break;
              case 1 : 
                  var u1 = match[2];
                  var t1$2 = match[1];
                  var l1 = match[0];
                  if (typeof match$1 === "number") {
                    exit = 1;
                  } else {
                    switch (match$1.tag | 0) {
                      case 0 : 
                          exit$4 = 6;
                          break;
                      case 1 : 
                          var u2 = match$1[2];
                          var t2$2 = match$1[1];
                          var l2 = match$1[0];
                          if (l1 === l2 || classic[0] && !(is_optional(l1) || is_optional(l2))) {
                            var cstrs$1 = subtype_rec(env, /* :: */[
                                  /* tuple */[
                                    t2$2,
                                    t1$2
                                  ],
                                  trace
                                ], t2$2, t1$2, cstrs);
                            _cstrs = cstrs$1;
                            _t2 = u2;
                            _t1 = u1;
                            _trace = /* :: */[
                              /* tuple */[
                                u1,
                                u2
                              ],
                              trace
                            ];
                            continue ;
                            
                          } else {
                            exit = 1;
                          }
                          break;
                      case 3 : 
                          exit$2 = 4;
                          break;
                      default:
                        exit = 1;
                    }
                  }
                  break;
              case 2 : 
                  if (typeof match$1 === "number") {
                    exit = 1;
                  } else {
                    switch (match$1.tag | 0) {
                      case 0 : 
                          exit$4 = 6;
                          break;
                      case 2 : 
                          var env$1 = env;
                          var trace$1 = trace;
                          var tl1 = match[0];
                          var tl2 = match$1[0];
                          var cstrs$2 = cstrs;
                          if (List.length(tl1) !== List.length(tl2)) {
                            subtype_error(env$1, trace$1);
                          }
                          return List.fold_left2((function(env$1,trace$1){
                                    return function (cstrs, t1, t2) {
                                      return subtype_rec(env$1, /* :: */[
                                                  /* tuple */[
                                                    t1,
                                                    t2
                                                  ],
                                                  trace$1
                                                ], t1, t2, cstrs);
                                    }
                                    }(env$1,trace$1)), cstrs$2, tl1, tl2);
                      case 3 : 
                          exit$2 = 4;
                          break;
                      default:
                        exit = 1;
                    }
                  }
                  break;
              case 3 : 
                  if (match[1]) {
                    exit$4 = 6;
                  } else if (typeof match$1 === "number") {
                    exit$3 = 5;
                  } else {
                    switch (match$1.tag | 0) {
                      case 0 : 
                          exit$4 = 6;
                          break;
                      case 3 : 
                          if (match$1[1]) {
                            exit$3 = 5;
                          } else if (same(match[0], match$1[0])) {
                            return cstrs;
                          } else {
                            exit$3 = 5;
                          }
                          break;
                      default:
                        exit$3 = 5;
                    }
                  }
                  break;
              case 4 : 
                  var f1 = match[0];
                  if (typeof match$1 === "number") {
                    exit = 1;
                  } else {
                    switch (match$1.tag | 0) {
                      case 0 : 
                          exit$4 = 6;
                          break;
                      case 3 : 
                          exit$2 = 4;
                          break;
                      case 4 : 
                          var f2 = match$1[0];
                          if (is_Tvar(object_row(f1)) && is_Tvar(object_row(f2))) {
                            return /* :: */[
                                    /* tuple */[
                                      trace,
                                      t1$1,
                                      t2$1,
                                      univar_pairs[0]
                                    ],
                                    cstrs
                                  ];
                          } else {
                            var env$2 = env;
                            var trace$2 = trace;
                            var ty1 = f1;
                            var ty2 = f2;
                            var cstrs$3 = cstrs;
                            var match$2 = flatten_fields(ty1);
                            var rest1 = match$2[1];
                            var match$3 = flatten_fields(ty2);
                            var rest2 = match$3[1];
                            var match$4 = associate_fields(match$2[0], match$3[0]);
                            var miss2 = match$4[2];
                            var miss1 = match$4[1];
                            var cstrs$4 = rest2[/* desc */0] ? (
                                miss1 ? /* :: */[
                                    /* tuple */[
                                      trace$2,
                                      build_fields(repr(ty1)[/* level */1])(miss1, rest1),
                                      rest2,
                                      univar_pairs[0]
                                    ],
                                    cstrs$3
                                  ] : subtype_rec(env$2, /* :: */[
                                        /* tuple */[
                                          rest1,
                                          rest2
                                        ],
                                        trace$2
                                      ], rest1, rest2, cstrs$3)
                              ) : cstrs$3;
                            var cstrs$5 = miss2 ? /* :: */[
                                /* tuple */[
                                  trace$2,
                                  rest1,
                                  build_fields(repr(ty2)[/* level */1])(miss2, newvar(/* None */0, /* () */0)),
                                  univar_pairs[0]
                                ],
                                cstrs$4
                              ] : cstrs$4;
                            return List.fold_left((function(env$2,trace$2){
                                      return function (cstrs, param) {
                                        var t2 = param[4];
                                        var t1 = param[2];
                                        return subtype_rec(env$2, /* :: */[
                                                    /* tuple */[
                                                      t1,
                                                      t2
                                                    ],
                                                    trace$2
                                                  ], t1, t2, cstrs);
                                      }
                                      }(env$2,trace$2)), cstrs$5, match$4[0]);
                          }
                      default:
                        exit = 1;
                    }
                  }
                  break;
              case 8 : 
                  if (typeof match$1 === "number") {
                    exit = 1;
                  } else {
                    switch (match$1.tag | 0) {
                      case 0 : 
                          exit$4 = 6;
                          break;
                      case 3 : 
                          exit$2 = 4;
                          break;
                      case 8 : 
                          try {
                            var env$3 = env;
                            var trace$3 = trace;
                            var row1 = match[0];
                            var row2 = match$1[0];
                            var cstrs$6 = cstrs;
                            var row1$1 = row_repr_aux(/* [] */0, row1);
                            var row2$1 = row_repr_aux(/* [] */0, row2);
                            var match$5 = merge_row_fields(row1$1[/* row_fields */0], row2$1[/* row_fields */0]);
                            var pairs = match$5[2];
                            var r1 = match$5[0];
                            var more1 = repr(row1$1[/* row_more */1]);
                            var more2 = repr(row2$1[/* row_more */1]);
                            var match$6 = more1[/* desc */0];
                            var match$7 = more2[/* desc */0];
                            var exit$5 = 0;
                            if (typeof match$6 === "number") {
                              if (match$6) {
                                throw Pervasives.Exit;
                              } else {
                                exit$5 = 1;
                              }
                            } else {
                              switch (match$6.tag | 0) {
                                case 0 : 
                                    exit$5 = 1;
                                    break;
                                case 3 : 
                                    if (typeof match$7 === "number") {
                                      exit$5 = 1;
                                    } else if (match$7.tag === 3) {
                                      if (same(match$6[0], match$7[0])) {
                                        return subtype_rec(env$3, /* :: */[
                                                    /* tuple */[
                                                      more1,
                                                      more2
                                                    ],
                                                    trace$3
                                                  ], more1, more2, cstrs$6);
                                      } else {
                                        exit$5 = 1;
                                      }
                                    } else {
                                      exit$5 = 1;
                                    }
                                    break;
                                case 9 : 
                                    if (typeof match$7 === "number") {
                                      throw Pervasives.Exit;
                                    } else if (match$7.tag === 9) {
                                      if (Caml_obj.caml_equal(row1$1[/* row_closed */3], row2$1[/* row_closed */3]) && r1 === /* [] */0 && match$5[1] === /* [] */0) {
                                        var cstrs$7 = subtype_rec(env$3, /* :: */[
                                              /* tuple */[
                                                more1,
                                                more2
                                              ],
                                              trace$3
                                            ], more1, more2, cstrs$6);
                                        return List.fold_left((function(env$3,trace$3){
                                                  return function (cstrs, param) {
                                                    var match = row_field_repr_aux(/* [] */0, param[1]);
                                                    var match$1 = row_field_repr_aux(/* [] */0, param[2]);
                                                    var exit = 0;
                                                    var t1;
                                                    var t2;
                                                    if (typeof match === "number") {
                                                      if (typeof match$1 === "number") {
                                                        return cstrs;
                                                      } else {
                                                        throw Pervasives.Exit;
                                                      }
                                                    } else if (match.tag) {
                                                      if (match[0] !== 0) {
                                                        if (match[1]) {
                                                          throw Pervasives.Exit;
                                                        } else if (typeof match$1 === "number") {
                                                          throw Pervasives.Exit;
                                                        } else if (match$1.tag) {
                                                          if (match$1[0] !== 0) {
                                                            if (match$1[1]) {
                                                              throw Pervasives.Exit;
                                                            } else {
                                                              return cstrs;
                                                            }
                                                          } else {
                                                            throw Pervasives.Exit;
                                                          }
                                                        } else {
                                                          throw Pervasives.Exit;
                                                        }
                                                      } else {
                                                        var match$2 = match[1];
                                                        if (match$2) {
                                                          if (match$2[1]) {
                                                            throw Pervasives.Exit;
                                                          } else if (typeof match$1 === "number") {
                                                            throw Pervasives.Exit;
                                                          } else if (match$1.tag) {
                                                            if (match$1[0] !== 0) {
                                                              throw Pervasives.Exit;
                                                            } else {
                                                              var match$3 = match$1[1];
                                                              if (match$3) {
                                                                if (match$3[1]) {
                                                                  throw Pervasives.Exit;
                                                                } else {
                                                                  t1 = match$2[0];
                                                                  t2 = match$3[0];
                                                                  exit = 1;
                                                                }
                                                              } else {
                                                                throw Pervasives.Exit;
                                                              }
                                                            }
                                                          } else {
                                                            throw Pervasives.Exit;
                                                          }
                                                        } else {
                                                          throw Pervasives.Exit;
                                                        }
                                                      }
                                                    } else {
                                                      var match$4 = match[0];
                                                      if (match$4) {
                                                        if (typeof match$1 === "number") {
                                                          throw Pervasives.Exit;
                                                        } else if (match$1.tag) {
                                                          throw Pervasives.Exit;
                                                        } else {
                                                          var match$5 = match$1[0];
                                                          if (match$5) {
                                                            t1 = match$4[0];
                                                            t2 = match$5[0];
                                                            exit = 1;
                                                          } else {
                                                            throw Pervasives.Exit;
                                                          }
                                                        }
                                                      } else if (typeof match$1 === "number") {
                                                        throw Pervasives.Exit;
                                                      } else if (match$1.tag) {
                                                        throw Pervasives.Exit;
                                                      } else if (match$1[0]) {
                                                        throw Pervasives.Exit;
                                                      } else {
                                                        return cstrs;
                                                      }
                                                    }
                                                    if (exit === 1) {
                                                      return subtype_rec(env$3, /* :: */[
                                                                  /* tuple */[
                                                                    t1,
                                                                    t2
                                                                  ],
                                                                  trace$3
                                                                ], t1, t2, cstrs);
                                                    }
                                                    
                                                  }
                                                  }(env$3,trace$3)), cstrs$7, pairs);
                                      } else {
                                        throw Pervasives.Exit;
                                      }
                                    } else {
                                      throw Pervasives.Exit;
                                    }
                                    break;
                                default:
                                  throw Pervasives.Exit;
                              }
                            }
                            if (exit$5 === 1) {
                              var exit$6 = 0;
                              if (typeof match$7 === "number") {
                                if (match$7) {
                                  throw Pervasives.Exit;
                                } else {
                                  exit$6 = 2;
                                }
                              } else {
                                switch (match$7.tag | 0) {
                                  case 0 : 
                                  case 3 : 
                                      exit$6 = 2;
                                      break;
                                  default:
                                    throw Pervasives.Exit;
                                }
                              }
                              if (exit$6 === 2) {
                                if (row1$1[/* row_closed */3] && r1 === /* [] */0) {
                                  return List.fold_left((function(env$3,trace$3){
                                            return function (cstrs, param) {
                                              var match = row_field_repr_aux(/* [] */0, param[1]);
                                              var match$1 = row_field_repr_aux(/* [] */0, param[2]);
                                              var exit = 0;
                                              if (typeof match === "number") {
                                                return cstrs;
                                              } else if (match.tag) {
                                                if (match[0] !== 0) {
                                                  exit = 1;
                                                } else {
                                                  var match$2 = match[1];
                                                  if (match$2) {
                                                    var t1 = match$2[0];
                                                    if (typeof match$1 === "number") {
                                                      throw Pervasives.Exit;
                                                    } else if (match$1.tag) {
                                                      throw Pervasives.Exit;
                                                    } else {
                                                      var match$3 = match$1[0];
                                                      if (match$3) {
                                                        var t2 = match$3[0];
                                                        return subtype_rec(env$3, /* :: */[
                                                                    /* tuple */[
                                                                      t1,
                                                                      t2
                                                                    ],
                                                                    trace$3
                                                                  ], t1, t2, cstrs);
                                                      } else {
                                                        throw Pervasives.Exit;
                                                      }
                                                    }
                                                  } else {
                                                    throw Pervasives.Exit;
                                                  }
                                                }
                                              } else {
                                                var match$4 = match[0];
                                                if (match$4) {
                                                  var t1$1 = match$4[0];
                                                  if (typeof match$1 === "number") {
                                                    throw Pervasives.Exit;
                                                  } else if (match$1.tag) {
                                                    throw Pervasives.Exit;
                                                  } else {
                                                    var match$5 = match$1[0];
                                                    if (match$5) {
                                                      var t2$1 = match$5[0];
                                                      return subtype_rec(env$3, /* :: */[
                                                                  /* tuple */[
                                                                    t1$1,
                                                                    t2$1
                                                                  ],
                                                                  trace$3
                                                                ], t1$1, t2$1, cstrs);
                                                    } else {
                                                      throw Pervasives.Exit;
                                                    }
                                                  }
                                                } else {
                                                  exit = 1;
                                                }
                                              }
                                              if (exit === 1) {
                                                if (typeof match$1 === "number") {
                                                  throw Pervasives.Exit;
                                                } else if (match$1.tag) {
                                                  throw Pervasives.Exit;
                                                } else if (match$1[0]) {
                                                  throw Pervasives.Exit;
                                                } else {
                                                  return cstrs;
                                                }
                                              }
                                              
                                            }
                                            }(env$3,trace$3)), cstrs$6, pairs);
                                } else {
                                  throw Pervasives.Exit;
                                }
                              }
                              
                            }
                            
                          }
                          catch (exn$1){
                            if (exn$1 === Pervasives.Exit) {
                              return /* :: */[
                                      /* tuple */[
                                        trace,
                                        t1$1,
                                        t2$1,
                                        univar_pairs[0]
                                      ],
                                      cstrs
                                    ];
                            } else {
                              throw exn$1;
                            }
                          }
                          break;
                      default:
                        exit = 1;
                    }
                  }
                  break;
              case 10 : 
                  var tl1$1 = match[1];
                  var u1$1 = match[0];
                  var exit$7 = 0;
                  if (tl1$1) {
                    exit$7 = 7;
                  } else if (typeof match$1 === "number") {
                    exit = 1;
                  } else {
                    switch (match$1.tag | 0) {
                      case 0 : 
                          exit$4 = 6;
                          break;
                      case 3 : 
                          exit$2 = 4;
                          break;
                      case 10 : 
                          if (match$1[1]) {
                            exit$7 = 7;
                          } else {
                            _t2 = match$1[0];
                            _t1 = u1$1;
                            continue ;
                            
                          }
                          break;
                      default:
                        exit = 1;
                    }
                  }
                  if (exit$7 === 7) {
                    if (typeof match$1 === "number") {
                      exit = 1;
                    } else {
                      switch (match$1.tag | 0) {
                        case 0 : 
                            exit$4 = 6;
                            break;
                        case 3 : 
                            exit$2 = 4;
                            break;
                        case 10 : 
                            var tl2$1 = match$1[1];
                            var u2$1 = match$1[0];
                            if (tl2$1) {
                              try {
                                return enter_poly(env, univar_pairs, u1$1, tl1$1, u2$1, tl2$1, (function(trace,cstrs){
                                          return function (t1, t2) {
                                            return subtype_rec(env, trace, t1, t2, cstrs);
                                          }
                                          }(trace,cstrs)));
                              }
                              catch (raw_exn){
                                var exn$2 = Js_exn.internalToOCamlException(raw_exn);
                                if (exn$2[0] === Unify) {
                                  return /* :: */[
                                          /* tuple */[
                                            trace,
                                            t1$1,
                                            t2$1,
                                            univar_pairs[0]
                                          ],
                                          cstrs
                                        ];
                                } else {
                                  throw exn$2;
                                }
                              }
                            } else {
                              var match$8 = instance_poly(/* None */0, /* false */0, tl1$1, u1$1);
                              _t2 = u2$1;
                              _t1 = match$8[1];
                              continue ;
                              
                            }
                            break;
                        default:
                          exit = 1;
                      }
                    }
                  }
                  break;
              case 11 : 
                  var tl1$2 = match[2];
                  var nl1 = match[1];
                  var p1 = match[0];
                  if (typeof match$1 === "number") {
                    exit = 1;
                  } else {
                    switch (match$1.tag | 0) {
                      case 0 : 
                          exit$4 = 6;
                          break;
                      case 3 : 
                          exit$2 = 4;
                          break;
                      case 11 : 
                          var tl2$2 = match$1[2];
                          var nl2 = match$1[1];
                          var p2 = match$1[0];
                          try {
                            var ntl1 = complete_type_list(/* None */0, env, nl2, t1$1[/* level */1], /* Mty_ident */Block.__(0, [p1]), nl1, tl1$2);
                            var ntl2 = complete_type_list(/* Some */[/* true */1], env, nl1, t2$1[/* level */1], /* Mty_ident */Block.__(0, [p2]), nl2, tl2$2);
                            var cstrs$prime = List.map((function(trace,ntl1){
                                return function (param) {
                                  return /* tuple */[
                                          trace,
                                          List.assoc(param[0], ntl1),
                                          param[1],
                                          univar_pairs[0]
                                        ];
                                }
                                }(trace,ntl1)), ntl2);
                            if (eq_package_path(env, p1, p2)) {
                              return Pervasives.$at(cstrs$prime, cstrs);
                            } else {
                              var snap = snapshot(/* () */0);
                              try {
                                List.iter((function (param) {
                                        return unify$2(env, param[1], param[2]);
                                      }), cstrs$prime);
                                if (Curry._7(package_subtype[0], env, p1, nl1, tl1$2, p2, nl2, tl2$2)) {
                                  backtrack(snap);
                                  return Pervasives.$at(cstrs$prime, cstrs);
                                } else {
                                  throw [
                                        Unify,
                                        /* [] */0
                                      ];
                                }
                              }
                              catch (raw_exn$1){
                                var exn$3 = Js_exn.internalToOCamlException(raw_exn$1);
                                if (exn$3[0] === Unify) {
                                  backtrack(snap);
                                  throw Caml_builtin_exceptions.not_found;
                                } else {
                                  throw exn$3;
                                }
                              }
                            }
                          }
                          catch (exn$4){
                            if (exn$4 === Caml_builtin_exceptions.not_found) {
                              return /* :: */[
                                      /* tuple */[
                                        trace,
                                        t1$1,
                                        t2$1,
                                        univar_pairs[0]
                                      ],
                                      cstrs
                                    ];
                            } else {
                              throw exn$4;
                            }
                          }
                          break;
                      default:
                        exit = 1;
                    }
                  }
                  break;
              default:
                exit$4 = 6;
            }
          }
          if (exit$4 === 6) {
            if (typeof match$1 === "number" || match$1.tag) {
              exit$3 = 5;
            } else {
              exit = 2;
            }
          }
          if (exit$3 === 5) {
            if (typeof match === "number") {
              exit$2 = 4;
            } else if (match.tag === 3) {
              if (generic_abbrev(env, match[0]) && safe_abbrev(env, t1$1)) {
                _t2 = t2$1;
                _t1 = expand_abbrev(env)(t1$1);
                continue ;
                
              } else {
                exit$2 = 4;
              }
            } else {
              exit$2 = 4;
            }
          }
          if (exit$2 === 4) {
            if (typeof match$1 === "number") {
              exit$1 = 3;
            } else if (match$1.tag === 3) {
              if (generic_abbrev(env, match$1[0]) && safe_abbrev(env, t2$1)) {
                _t2 = expand_abbrev(env)(t2$1);
                _t1 = t1$1;
                continue ;
                
              } else {
                exit$1 = 3;
              }
            } else {
              exit$1 = 3;
            }
          }
          if (exit$1 === 3) {
            if (typeof match === "number") {
              exit = 1;
            } else if (match.tag === 3) {
              var p1$1 = match[0];
              var exit$8 = 0;
              if (typeof match$1 === "number") {
                exit$8 = 4;
              } else if (match$1.tag === 3) {
                if (same(p1$1, match$1[0])) {
                  try {
                    var decl = find_type_full(p1$1, env)[0];
                    return List.fold_left2((function(trace){
                              return function (cstrs, v, param) {
                                var t2 = param[1];
                                var t1 = param[0];
                                var match = Curry._1(Types_003[/* get_upper */10], v);
                                var cn = match[1];
                                if (match[0]) {
                                  if (cn) {
                                    return /* :: */[
                                            /* tuple */[
                                              trace,
                                              newty2(t1[/* level */1], /* Ttuple */Block.__(2, [/* :: */[
                                                        t1,
                                                        /* [] */0
                                                      ]])),
                                              newty2(t2[/* level */1], /* Ttuple */Block.__(2, [/* :: */[
                                                        t2,
                                                        /* [] */0
                                                      ]])),
                                              univar_pairs[0]
                                            ],
                                            cstrs
                                          ];
                                  } else {
                                    return subtype_rec(env, /* :: */[
                                                /* tuple */[
                                                  t1,
                                                  t2
                                                ],
                                                trace
                                              ], t1, t2, cstrs);
                                  }
                                } else if (cn) {
                                  return subtype_rec(env, /* :: */[
                                              /* tuple */[
                                                t2,
                                                t1
                                              ],
                                              trace
                                            ], t2, t1, cstrs);
                                } else {
                                  return cstrs;
                                }
                              }
                              }(trace)), cstrs, decl[/* type_variance */5], List.combine(match[1], match$1[1]));
                  }
                  catch (exn$5){
                    if (exn$5 === Caml_builtin_exceptions.not_found) {
                      return /* :: */[
                              /* tuple */[
                                trace,
                                t1$1,
                                t2$1,
                                univar_pairs[0]
                              ],
                              cstrs
                            ];
                    } else {
                      throw exn$5;
                    }
                  }
                } else {
                  exit$8 = 4;
                }
              } else {
                exit$8 = 4;
              }
              if (exit$8 === 4) {
                if (generic_private_abbrev(env, p1$1)) {
                  _t2 = t2$1;
                  _t1 = expand_abbrev_opt(env, t1$1);
                  continue ;
                  
                } else {
                  exit = 1;
                }
              }
              
            } else {
              exit = 1;
            }
          }
          switch (exit) {
            case 1 : 
            case 2 : 
                return /* :: */[
                        /* tuple */[
                          trace,
                          t1$1,
                          t2$1,
                          univar_pairs[0]
                        ],
                        cstrs
                      ];
            
          }
        } else {
          throw exn;
        }
      }
    }
  };
}

function subtype(env, ty1, ty2) {
  Curry._1(TypePairs[/* clear */1], subtypes);
  univar_pairs[0] = /* [] */0;
  var cstrs = subtype_rec(env, /* :: */[
        /* tuple */[
          ty1,
          ty2
        ],
        /* [] */0
      ], ty1, ty2, /* [] */0);
  Curry._1(TypePairs[/* clear */1], subtypes);
  return (function () {
      return List.iter((function (param) {
                    try {
                      return unify_pairs([env], param[1], param[2], param[3]);
                    }
                    catch (raw_exn){
                      var exn = Js_exn.internalToOCamlException(raw_exn);
                      if (exn[0] === Unify) {
                        throw [
                              Subtype,
                              expand_trace(env, List.rev(param[0])),
                              List.tl(List.tl(exn[1]))
                            ];
                      } else {
                        throw exn;
                      }
                    }
                  }), List.rev(cstrs));
    });
}

function unalias_object(ty) {
  var ty$1 = repr(ty);
  var match = ty$1[/* desc */0];
  if (typeof match === "number") {
    if (match) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "ctype.ml",
              4129,
              6
            ]
          ];
    } else {
      return newty2(ty$1[/* level */1], ty$1[/* desc */0]);
    }
  } else {
    switch (match.tag | 0) {
      case 0 : 
          return newty2(ty$1[/* level */1], ty$1[/* desc */0]);
      case 3 : 
          return newty2(ty$1[/* level */1], /* Tvar */Block.__(0, [/* None */0]));
      case 5 : 
          return newty2(ty$1[/* level */1], /* Tfield */Block.__(5, [
                        match[0],
                        match[1],
                        match[2],
                        unalias_object(match[3])
                      ]));
      case 9 : 
          return ty$1;
      default:
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "ctype.ml",
                4129,
                6
              ]
            ];
    }
  }
}

function unalias(ty) {
  var ty$1 = repr(ty);
  var match = ty$1[/* desc */0];
  if (typeof match === "number") {
    return newty2(ty$1[/* level */1], ty$1[/* desc */0]);
  } else {
    switch (match.tag | 0) {
      case 4 : 
          var ty$2 = match[0];
          return newty2(ty$2[/* level */1], /* Tobject */Block.__(4, [
                        unalias_object(ty$2),
                        match[1]
                      ]));
      case 8 : 
          var row = row_repr_aux(/* [] */0, match[0]);
          var more = row[/* row_more */1];
          var newrecord = row.slice();
          return newty2(ty$1[/* level */1], /* Tvariant */Block.__(8, [(newrecord[/* row_more */1] = newty2(more[/* level */1], more[/* desc */0]), newrecord)]));
      case 0 : 
      case 9 : 
          return ty$1;
      default:
        return newty2(ty$1[/* level */1], ty$1[/* desc */0]);
    }
  }
}

function arity(ty) {
  var match = repr(ty)[/* desc */0];
  if (typeof match === "number" || match.tag !== 1) {
    return 0;
  } else {
    return 1 + arity(match[2]) | 0;
  }
}

function cyclic_abbrev(env, id, ty) {
  var check_cycle = function (seen, ty) {
    var ty$1 = repr(ty);
    var match = ty$1[/* desc */0];
    if (typeof match === "number") {
      return /* false */0;
    } else if (match.tag === 3) {
      if (Caml_obj.caml_equal(match[0], /* Pident */Block.__(0, [id]))) {
        return /* true */1;
      } else if (List.memq(ty$1, seen)) {
        return /* true */1;
      } else {
        try {
          return check_cycle(/* :: */[
                      ty$1,
                      seen
                    ], expand_abbrev_opt(env, ty$1));
        }
        catch (raw_exn){
          var exn = Js_exn.internalToOCamlException(raw_exn);
          if (exn === Cannot_expand) {
            return /* false */0;
          } else if (exn[0] === Unify) {
            return /* true */1;
          } else {
            throw exn;
          }
        }
      }
    } else {
      return /* false */0;
    }
  };
  return check_cycle(/* [] */0, ty);
}

function normalize_type_rec(env, visited, ty) {
  var ty$1 = repr(ty);
  if (mem$3(ty$1, visited[0])) {
    return 0;
  } else {
    visited[0] = add$3(ty$1, visited[0]);
    var match = ty$1[/* desc */0];
    if (typeof match !== "number") {
      switch (match.tag | 0) {
        case 4 : 
            var nm = match[1];
            var match$1 = nm[0];
            if (match$1) {
              var match$2 = match$1[0];
              var match$3 = match$2[1];
              if (match$3) {
                var l = match$3[1];
                var v = match$3[0];
                var n = match$2[0];
                if (deep_occur(ty$1, newty2(100000000, /* Ttuple */Block.__(2, [l])))) {
                  set_name(nm, /* None */0);
                } else {
                  var v$prime = repr(v);
                  var match$4 = v$prime[/* desc */0];
                  var exit = 0;
                  if (typeof match$4 === "number") {
                    if (match$4) {
                      set_name(nm, /* None */0);
                    } else {
                      log_type(ty$1);
                      ty$1[/* desc */0] = /* Tconstr */Block.__(3, [
                          n,
                          l,
                          [/* Mnil */0]
                        ]);
                    }
                  } else {
                    switch (match$4.tag | 0) {
                      case 0 : 
                      case 9 : 
                          exit = 1;
                          break;
                      default:
                        set_name(nm, /* None */0);
                    }
                  }
                  if (exit === 1) {
                    if (v$prime !== v) {
                      set_name(nm, /* Some */[/* tuple */[
                              n,
                              /* :: */[
                                v$prime,
                                l
                              ]
                            ]]);
                    }
                    
                  }
                  
                }
              } else {
                fatal_error("Ctype.normalize_type_rec");
              }
            }
            var fi = repr(match[0]);
            if (fi[/* level */1] >= 0) {
              var match$5 = flatten_fields(fi);
              var fi$prime = build_fields(fi[/* level */1])(match$5[0], match$5[1]);
              log_type(ty$1);
              fi[/* desc */0] = fi$prime[/* desc */0];
            }
            break;
        case 8 : 
            var row = row_repr_aux(/* [] */0, match[0]);
            var fields = List.map((function (param) {
                    var f0 = param[1];
                    var f = row_field_repr_aux(/* [] */0, f0);
                    var $js;
                    if (typeof f === "number") {
                      $js = f;
                    } else if (f.tag) {
                      var match = f[1];
                      if (match) {
                        var tyl = match[1];
                        if (tyl) {
                          var tyl$prime = List.fold_left((function (tyl, ty) {
                                  if (List.exists((function (ty$prime) {
                                            return equal$4(env, /* false */0, /* :: */[
                                                        ty,
                                                        /* [] */0
                                                      ], /* :: */[
                                                        ty$prime,
                                                        /* [] */0
                                                      ]);
                                          }), tyl)) {
                                    return tyl;
                                  } else {
                                    return /* :: */[
                                            ty,
                                            tyl
                                          ];
                                  }
                                }), /* :: */[
                                match[0],
                                /* [] */0
                              ], tyl);
                          $js = f !== f0 || List.length(tyl$prime) < List.length(tyl) ? /* Reither */Block.__(1, [
                                f[0],
                                List.rev(tyl$prime),
                                f[2],
                                f[3]
                              ]) : f;
                        } else {
                          $js = f;
                        }
                      } else {
                        $js = f;
                      }
                    } else {
                      $js = f;
                    }
                    return /* tuple */[
                            param[0],
                            $js
                          ];
                  }), row[/* row_fields */0]);
            var fields$1 = List.sort((function (param, param$1) {
                    return Caml_string.caml_string_compare(param[0], param$1[0]);
                  }), List.filter((function (param) {
                          return +(param[1] !== /* Rabsent */0);
                        }))(fields));
            log_type(ty$1);
            var newrecord = row.slice();
            ty$1[/* desc */0] = /* Tvariant */Block.__(8, [(newrecord[/* row_fields */0] = fields$1, newrecord)]);
            break;
        default:
          
      }
    }
    return iter_type_expr((function (param) {
                  return normalize_type_rec(env, visited, param);
                }), ty$1);
  }
}

function normalize_type(env, ty) {
  return normalize_type_rec(env, [/* Empty */0], ty);
}

var nondep_hash = Curry._1(TypeHash[/* create */0], 47);

var nondep_variants = Curry._1(TypeHash[/* create */0], 17);

function clear_hash() {
  Curry._1(TypeHash[/* clear */1], nondep_hash);
  return Curry._1(TypeHash[/* clear */1], nondep_variants);
}

function nondep_type_rec(env, id, _ty) {
  while(true) {
    var ty = _ty;
    var match = ty[/* desc */0];
    var exit = 0;
    if (typeof match === "number") {
      exit = 1;
    } else {
      switch (match.tag | 0) {
        case 6 : 
            _ty = match[0];
            continue ;
            case 0 : 
        case 9 : 
            return ty;
        default:
          exit = 1;
      }
    }
    if (exit === 1) {
      try {
        return Curry._2(TypeHash[/* find */6], nondep_hash, ty);
      }
      catch (exn){
        if (exn === Caml_builtin_exceptions.not_found) {
          var ty$prime = newty2(100000000, /* Tvar */Block.__(0, [/* None */0]));
          Curry._3(TypeHash[/* add */4], nondep_hash, ty, ty$prime);
          var match$1 = ty[/* desc */0];
          var $js;
          var exit$1 = 0;
          if (typeof match$1 === "number") {
            exit$1 = 2;
          } else {
            switch (match$1.tag | 0) {
              case 3 : 
                  var p = match$1[0];
                  if (isfree(id, p)) {
                    try {
                      $js = /* Tlink */Block.__(6, [nondep_type_rec(env, id, expand_abbrev(env)(newty2(ty[/* level */1], ty[/* desc */0])))]);
                    }
                    catch (raw_exn){
                      var exn$1 = Js_exn.internalToOCamlException(raw_exn);
                      if (exn$1 === Cannot_expand) {
                        throw Caml_builtin_exceptions.not_found;
                      } else if (exn$1[0] === Unify) {
                        throw Caml_builtin_exceptions.not_found;
                      } else {
                        throw exn$1;
                      }
                    }
                  } else {
                    $js = /* Tconstr */Block.__(3, [
                        p,
                        List.map((function (param) {
                                return nondep_type_rec(env, id, param);
                              }), match$1[1]),
                        [/* Mnil */0]
                      ]);
                  }
                  break;
              case 4 : 
                  var match$2 = match$1[1][0];
                  var $js$1;
                  if (match$2) {
                    var match$3 = match$2[0];
                    var p$1 = match$3[0];
                    $js$1 = isfree(id, p$1) ? /* None */0 : /* Some */[/* tuple */[
                          p$1,
                          List.map((function (param) {
                                  return nondep_type_rec(env, id, param);
                                }), match$3[1])
                        ]];
                  } else {
                    $js$1 = /* None */0;
                  }
                  $js = /* Tobject */Block.__(4, [
                      nondep_type_rec(env, id, match$1[0]),
                      [$js$1]
                    ]);
                  break;
              case 8 : 
                  var row = row_repr_aux(/* [] */0, match$1[0]);
                  var more = repr(row[/* row_more */1]);
                  try {
                    var ty2 = Curry._2(TypeHash[/* find */6], nondep_variants, more);
                    Curry._3(TypeHash[/* add */4], nondep_hash, ty, ty2);
                    $js = /* Tlink */Block.__(6, [ty2]);
                  }
                  catch (exn$2){
                    if (exn$2 === Caml_builtin_exceptions.not_found) {
                      Curry._3(TypeHash[/* add */4], nondep_variants, more, ty$prime);
                      var $$static = static_row(row);
                      var more$prime = $$static ? newty2(100000000, /* Tnil */0) : more;
                      var row$1 = copy_row((function (param) {
                              return nondep_type_rec(env, id, param);
                            }), /* true */1, row, /* true */1, more$prime);
                      var match$4 = row$1[/* row_name */5];
                      if (match$4) {
                        if (isfree(id, match$4[0][0])) {
                          var newrecord = row$1.slice();
                          $js = /* Tvariant */Block.__(8, [(newrecord[/* row_name */5] = /* None */0, newrecord)]);
                        } else {
                          $js = /* Tvariant */Block.__(8, [row$1]);
                        }
                      } else {
                        $js = /* Tvariant */Block.__(8, [row$1]);
                      }
                    } else {
                      throw exn$2;
                    }
                  }
                  break;
              case 11 : 
                  var p$2 = match$1[0];
                  if (isfree(id, p$2)) {
                    var p$prime = normalize_package_path(env, p$2);
                    if (isfree(id, p$prime)) {
                      throw Caml_builtin_exceptions.not_found;
                    }
                    $js = /* Tpackage */Block.__(11, [
                        p$prime,
                        match$1[1],
                        List.map((function (param) {
                                return nondep_type_rec(env, id, param);
                              }), match$1[2])
                      ]);
                  } else {
                    exit$1 = 2;
                  }
                  break;
              default:
                exit$1 = 2;
            }
          }
          if (exit$1 === 2) {
            $js = copy_type_desc(/* None */0, (function (param) {
                    return nondep_type_rec(env, id, param);
                  }), ty[/* desc */0]);
          }
          ty$prime[/* desc */0] = $js;
          return ty$prime;
        } else {
          throw exn;
        }
      }
    }
    
  };
}

function nondep_type(env, id, ty) {
  try {
    var ty$prime = nondep_type_rec(env, id, ty);
    clear_hash(/* () */0);
    return ty$prime;
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      clear_hash(/* () */0);
      throw Caml_builtin_exceptions.not_found;
    } else {
      throw exn;
    }
  }
}

nondep_type$prime[0] = nondep_type;

function unroll_abbrev(id, tl, ty) {
  var ty$1 = repr(ty);
  var path = /* Pident */Block.__(0, [id]);
  if (is_Tvar(ty$1) || List.exists((function (param) {
            return deep_occur(ty$1, param);
          }), tl) || is_object_type(path)) {
    return ty$1;
  } else {
    var ty$prime = newty2(ty$1[/* level */1], ty$1[/* desc */0]);
    link_type(ty$1, newty2(ty$1[/* level */1], /* Tconstr */Block.__(3, [
                path,
                tl,
                [/* Mnil */0]
              ])));
    return ty$prime;
  }
}

function nondep_type_decl(env, mid, id, is_covariant, decl) {
  try {
    var params = List.map((function (param) {
            return nondep_type_rec(env, mid, param);
          }), decl[/* type_params */0]);
    var tk;
    try {
      var match = decl[/* type_kind */2];
      tk = typeof match === "number" ? (
          match ? /* Type_open */1 : /* Type_abstract */0
        ) : (
          match.tag ? /* Type_variant */Block.__(1, [List.map((function (c) {
                        return /* record */[
                                /* cd_id */c[/* cd_id */0],
                                /* cd_args */List.map((function (param) {
                                        return nondep_type_rec(env, mid, param);
                                      }), c[/* cd_args */1]),
                                /* cd_res */may_map((function (param) {
                                        return nondep_type_rec(env, mid, param);
                                      }), c[/* cd_res */2]),
                                /* cd_loc */c[/* cd_loc */3],
                                /* cd_attributes */c[/* cd_attributes */4]
                              ];
                      }), match[0])]) : /* Type_record */Block.__(0, [
                List.map((function (l) {
                        return /* record */[
                                /* ld_id */l[/* ld_id */0],
                                /* ld_mutable */l[/* ld_mutable */1],
                                /* ld_type */nondep_type_rec(env, mid, l[/* ld_type */2]),
                                /* ld_loc */l[/* ld_loc */3],
                                /* ld_attributes */l[/* ld_attributes */4]
                              ];
                      }), match[0]),
                match[1]
              ])
        );
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        if (is_covariant) {
          tk = /* Type_abstract */0;
        } else {
          throw exn;
        }
      } else {
        throw exn;
      }
    }
    var tm;
    try {
      var match$1 = decl[/* type_manifest */4];
      tm = match$1 ? /* Some */[unroll_abbrev(id, params, nondep_type_rec(env, mid, match$1[0]))] : /* None */0;
    }
    catch (exn$1){
      if (exn$1 === Caml_builtin_exceptions.not_found) {
        if (is_covariant) {
          tm = /* None */0;
        } else {
          throw exn$1;
        }
      } else {
        throw exn$1;
      }
    }
    clear_hash(/* () */0);
    var priv = tm && has_constr_row(tm[0]) ? /* Private */0 : decl[/* type_private */3];
    return /* record */[
            /* type_params */params,
            /* type_arity */decl[/* type_arity */1],
            /* type_kind */tk,
            /* type_private */priv,
            /* type_manifest */tm,
            /* type_variance */decl[/* type_variance */5],
            /* type_newtype_level : None */0,
            /* type_loc */decl[/* type_loc */7],
            /* type_attributes */decl[/* type_attributes */8]
          ];
  }
  catch (exn$2){
    if (exn$2 === Caml_builtin_exceptions.not_found) {
      clear_hash(/* () */0);
      throw Caml_builtin_exceptions.not_found;
    } else {
      throw exn$2;
    }
  }
}

function nondep_extension_constructor(env, mid, ext) {
  try {
    var match;
    if (isfree(mid, ext[/* ext_type_path */0])) {
      var ty = newty2(100000000, /* Tconstr */Block.__(3, [
              ext[/* ext_type_path */0],
              ext[/* ext_type_params */1],
              [/* Mnil */0]
            ]));
      var ty$prime = nondep_type_rec(env, mid, ty);
      var match$1 = repr(ty$prime)[/* desc */0];
      if (typeof match$1 === "number") {
        throw Caml_builtin_exceptions.not_found;
      } else if (match$1.tag === 3) {
        match = /* tuple */[
          match$1[0],
          match$1[1]
        ];
      } else {
        throw Caml_builtin_exceptions.not_found;
      }
    } else {
      var type_params = List.map((function (param) {
              return nondep_type_rec(env, mid, param);
            }), ext[/* ext_type_params */1]);
      match = /* tuple */[
        ext[/* ext_type_path */0],
        type_params
      ];
    }
    var args = List.map((function (param) {
            return nondep_type_rec(env, mid, param);
          }), ext[/* ext_args */2]);
    var ret_type = may_map((function (param) {
            return nondep_type_rec(env, mid, param);
          }), ext[/* ext_ret_type */3]);
    clear_hash(/* () */0);
    return /* record */[
            /* ext_type_path */match[0],
            /* ext_type_params */match[1],
            /* ext_args */args,
            /* ext_ret_type */ret_type,
            /* ext_private */ext[/* ext_private */4],
            /* ext_loc */ext[/* ext_loc */5],
            /* ext_attributes */ext[/* ext_attributes */6]
          ];
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      clear_hash(/* () */0);
      throw Caml_builtin_exceptions.not_found;
    } else {
      throw exn;
    }
  }
}

function nondep_class_signature(env, id, sign) {
  return /* record */[
          /* csig_self */nondep_type_rec(env, id, sign[/* csig_self */0]),
          /* csig_vars */map((function (param) {
                  return /* tuple */[
                          param[0],
                          param[1],
                          nondep_type_rec(env, id, param[2])
                        ];
                }), sign[/* csig_vars */1]),
          /* csig_concr */sign[/* csig_concr */2],
          /* csig_inher */List.map((function (param) {
                  return /* tuple */[
                          param[0],
                          List.map((function (param) {
                                  return nondep_type_rec(env, id, param);
                                }), param[1])
                        ];
                }), sign[/* csig_inher */3])
        ];
}

function nondep_class_type(env, id, _param) {
  while(true) {
    var param = _param;
    switch (param.tag | 0) {
      case 0 : 
          var cty = param[2];
          var p = param[0];
          if (isfree(id, p)) {
            _param = cty;
            continue ;
            
          } else {
            return /* Cty_constr */Block.__(0, [
                      p,
                      List.map((function (param) {
                              return nondep_type_rec(env, id, param);
                            }), param[1]),
                      nondep_class_type(env, id, cty)
                    ]);
          }
          break;
      case 1 : 
          return /* Cty_signature */Block.__(1, [nondep_class_signature(env, id, param[0])]);
      case 2 : 
          return /* Cty_arrow */Block.__(2, [
                    param[0],
                    nondep_type_rec(env, id, param[1]),
                    nondep_class_type(env, id, param[2])
                  ]);
      
    }
  };
}

function nondep_class_declaration(env, id, decl) {
  if (isfree(id, decl[/* cty_path */2])) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "ctype.ml",
            4449,
            2
          ]
        ];
  }
  var match = decl[/* cty_new */3];
  var decl$1 = /* record */[
    /* cty_params */List.map((function (param) {
            return nondep_type_rec(env, id, param);
          }), decl[/* cty_params */0]),
    /* cty_type */nondep_class_type(env, id, decl[/* cty_type */1]),
    /* cty_path */decl[/* cty_path */2],
    /* cty_new */match ? /* Some */[nondep_type_rec(env, id, match[0])] : /* None */0,
    /* cty_variance */decl[/* cty_variance */4],
    /* cty_loc */decl[/* cty_loc */5],
    /* cty_attributes */decl[/* cty_attributes */6]
  ];
  clear_hash(/* () */0);
  return decl$1;
}

function nondep_cltype_declaration(env, id, decl) {
  if (isfree(id, decl[/* clty_path */2])) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "ctype.ml",
            4468,
            2
          ]
        ];
  }
  var decl_000 = /* clty_params */List.map((function (param) {
          return nondep_type_rec(env, id, param);
        }), decl[/* clty_params */0]);
  var decl_001 = /* clty_type */nondep_class_type(env, id, decl[/* clty_type */1]);
  var decl_002 = /* clty_path */decl[/* clty_path */2];
  var decl_003 = /* clty_variance */decl[/* clty_variance */3];
  var decl_004 = /* clty_loc */decl[/* clty_loc */4];
  var decl_005 = /* clty_attributes */decl[/* clty_attributes */5];
  var decl$1 = /* record */[
    decl_000,
    decl_001,
    decl_002,
    decl_003,
    decl_004,
    decl_005
  ];
  clear_hash(/* () */0);
  return decl$1;
}

function collapse_conj(env, visited, ty) {
  var ty$1 = repr(ty);
  if (List.memq(ty$1, visited)) {
    return /* () */0;
  } else {
    var visited$1 = /* :: */[
      ty$1,
      visited
    ];
    var match = ty$1[/* desc */0];
    if (typeof match === "number") {
      return iter_type_expr((function (param) {
                    return collapse_conj(env, visited$1, param);
                  }), ty$1);
    } else if (match.tag === 8) {
      var row = row_repr_aux(/* [] */0, match[0]);
      List.iter((function (param) {
              var match = row_field_repr_aux(/* [] */0, param[1]);
              if (typeof match === "number") {
                return /* () */0;
              } else if (match.tag) {
                var match$1 = match[1];
                if (match$1) {
                  var tl = match$1[1];
                  if (tl) {
                    var t1 = match$1[0];
                    List.iter((function (param) {
                            return unify$2(env, t1, param);
                          }), tl);
                    return set_row_field(match[3], /* Reither */Block.__(1, [
                                  match[0],
                                  /* :: */[
                                    t1,
                                    /* [] */0
                                  ],
                                  match[2],
                                  [/* None */0]
                                ]));
                  } else {
                    return /* () */0;
                  }
                } else {
                  return /* () */0;
                }
              } else {
                return /* () */0;
              }
            }), row[/* row_fields */0]);
      return iter_row((function (param) {
                    return collapse_conj(env, visited$1, param);
                  }), row);
    } else {
      return iter_type_expr((function (param) {
                    return collapse_conj(env, visited$1, param);
                  }), ty$1);
    }
  }
}

function collapse_conj_params(env, params) {
  return List.iter((function (param) {
                return collapse_conj(env, /* [] */0, param);
              }), params);
}

function print_ident(ppf, param) {
  switch (param.tag | 0) {
    case 0 : 
        return Curry._4(Format.fprintf(ppf, /* Format */[
                        /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                /* "(" */40,
                                /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                        /* ")" */41,
                                        /* End_of_format */0
                                      ])])
                              ])]),
                        "%a(%a)"
                      ]), print_ident, param[0], print_ident, param[1]);
    case 1 : 
        print_ident(ppf, param[0]);
        Format.pp_print_char(ppf, /* "." */46);
        return Format.pp_print_string(ppf, param[1]);
    case 2 : 
        return Format.pp_print_string(ppf, param[0]);
    
  }
}

function parenthesized_ident(name) {
  if (List.mem(name, /* :: */[
          "or",
          /* :: */[
            "mod",
            /* :: */[
              "land",
              /* :: */[
                "lor",
                /* :: */[
                  "lxor",
                  /* :: */[
                    "lsl",
                    /* :: */[
                      "lsr",
                      /* :: */[
                        "asr",
                        /* [] */0
                      ]
                    ]
                  ]
                ]
              ]
            ]
          ]
        ])) {
    return /* true */1;
  } else {
    var match = Caml_string.get(name, 0);
    if (match >= 97) {
      if (match >= 223) {
        if (match !== 247) {
          return /* false */0;
        } else {
          return /* true */1;
        }
      } else if (match >= 123) {
        return /* true */1;
      } else {
        return /* false */0;
      }
    } else if (match >= 91) {
      if (match !== 95) {
        return /* true */1;
      } else {
        return /* false */0;
      }
    } else if (match >= 65) {
      return /* false */0;
    } else {
      return /* true */1;
    }
  }
}

function value_ident(ppf, name) {
  if (parenthesized_ident(name)) {
    return Curry._1(Format.fprintf(ppf, /* Format */[
                    /* String_literal */Block.__(11, [
                        "( ",
                        /* String */Block.__(2, [
                            /* No_padding */0,
                            /* String_literal */Block.__(11, [
                                " )",
                                /* End_of_format */0
                              ])
                          ])
                      ]),
                    "( %s )"
                  ]), name);
  } else {
    return Format.pp_print_string(ppf, name);
  }
}

function print_list(pr, sep, ppf, _param) {
  while(true) {
    var param = _param;
    if (param) {
      var l = param[1];
      var a = param[0];
      if (l) {
        Curry._2(pr, ppf, a);
        Curry._1(sep, ppf);
        _param = l;
        continue ;
        
      } else {
        return Curry._2(pr, ppf, a);
      }
    } else {
      return /* () */0;
    }
  };
}

function pr_present(param, param$1) {
  return print_list((function (ppf, s) {
                return Curry._1(Format.fprintf(ppf, /* Format */[
                                /* Char_literal */Block.__(12, [
                                    /* "`" */96,
                                    /* String */Block.__(2, [
                                        /* No_padding */0,
                                        /* End_of_format */0
                                      ])
                                  ]),
                                "`%s"
                              ]), s);
              }), (function (ppf) {
                return Format.fprintf(ppf, /* Format */[
                            /* Formatting_lit */Block.__(17, [
                                /* Break */Block.__(0, [
                                    "@ ",
                                    1,
                                    0
                                  ]),
                                /* End_of_format */0
                              ]),
                            "@ "
                          ]);
              }), param, param$1);
}

function pr_vars(param, param$1) {
  return print_list((function (ppf, s) {
                return Curry._1(Format.fprintf(ppf, /* Format */[
                                /* Char_literal */Block.__(12, [
                                    /* "'" */39,
                                    /* String */Block.__(2, [
                                        /* No_padding */0,
                                        /* End_of_format */0
                                      ])
                                  ]),
                                "'%s"
                              ]), s);
              }), (function (ppf) {
                return Format.fprintf(ppf, /* Format */[
                            /* Formatting_lit */Block.__(17, [
                                /* Break */Block.__(0, [
                                    "@ ",
                                    1,
                                    0
                                  ]),
                                /* End_of_format */0
                              ]),
                            "@ "
                          ]);
              }), param, param$1);
}

function print_out_type(ppf, ty) {
  if (typeof ty === "number") {
    return print_out_type_1(ppf, ty);
  } else {
    switch (ty.tag | 0) {
      case 0 : 
          return Curry._3(Format.fprintf(ppf, /* Format */[
                          /* Formatting_gen */Block.__(18, [
                              /* Open_box */Block.__(1, [/* Format */[
                                    /* End_of_format */0,
                                    ""
                                  ]]),
                              /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                      /* Break */Block.__(0, [
                                          "@ ",
                                          1,
                                          0
                                        ]),
                                      /* String_literal */Block.__(11, [
                                          "as '",
                                          /* String */Block.__(2, [
                                              /* No_padding */0,
                                              /* Formatting_lit */Block.__(17, [
                                                  /* Close_box */0,
                                                  /* End_of_format */0
                                                ])
                                            ])
                                        ])
                                    ])])
                            ]),
                          "@[%a@ as '%s@]"
                        ]), print_out_type, ty[0], ty[1]);
      case 12 : 
          return Curry._4(Format.fprintf(ppf, /* Format */[
                          /* Formatting_gen */Block.__(18, [
                              /* Open_box */Block.__(1, [/* Format */[
                                    /* String_literal */Block.__(11, [
                                        "<hov 2>",
                                        /* End_of_format */0
                                      ]),
                                    "<hov 2>"
                                  ]]),
                              /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                      /* "." */46,
                                      /* Formatting_lit */Block.__(17, [
                                          /* Break */Block.__(0, [
                                              "@ ",
                                              1,
                                              0
                                            ]),
                                          /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                  /* Close_box */0,
                                                  /* End_of_format */0
                                                ])])
                                        ])
                                    ])])
                            ]),
                          "@[<hov 2>%a.@ %a@]"
                        ]), pr_vars, ty[0], print_out_type, ty[1]);
      default:
        return print_out_type_1(ppf, ty);
    }
  }
}

function print_out_type_1(ppf, ty) {
  if (typeof ty === "number") {
    return print_out_type_2(ppf, ty);
  } else if (ty.tag === 1) {
    var lab = ty[0];
    Format.pp_open_box(ppf, 0);
    if (lab !== "") {
      Format.pp_print_string(ppf, lab);
      Format.pp_print_char(ppf, /* ":" */58);
    }
    print_out_type_2(ppf, ty[1]);
    Format.pp_print_string(ppf, " ->");
    Format.pp_print_space(ppf, /* () */0);
    print_out_type_1(ppf, ty[2]);
    return Format.pp_close_box(ppf, /* () */0);
  } else {
    return print_out_type_2(ppf, ty);
  }
}

function print_out_type_2(ppf, ty) {
  if (typeof ty === "number" || ty.tag !== 9) {
    return print_simple_out_type(ppf, ty);
  } else {
    return Curry._2(Format.fprintf(ppf, /* Format */[
                    /* Formatting_gen */Block.__(18, [
                        /* Open_box */Block.__(1, [/* Format */[
                              /* String_literal */Block.__(11, [
                                  "<0>",
                                  /* End_of_format */0
                                ]),
                              "<0>"
                            ]]),
                        /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                /* Close_box */0,
                                /* End_of_format */0
                              ])])
                      ]),
                    "@[<0>%a@]"
                  ]), (function (param, param$1) {
                  return print_typlist(print_simple_out_type, " *", param, param$1);
                }), ty[0]);
  }
}

function print_simple_out_type(ppf, ty) {
  var exit = 0;
  if (typeof ty === "number") {
    return /* () */0;
  } else {
    switch (ty.tag | 0) {
      case 2 : 
          return Curry._5(Format.fprintf(ppf, /* Format */[
                          /* Formatting_gen */Block.__(18, [
                              /* Open_box */Block.__(1, [/* Format */[
                                    /* End_of_format */0,
                                    ""
                                  ]]),
                              /* Alpha */Block.__(15, [/* String */Block.__(2, [
                                      /* No_padding */0,
                                      /* Char_literal */Block.__(12, [
                                          /* "#" */35,
                                          /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                  /* Close_box */0,
                                                  /* End_of_format */0
                                                ])])
                                        ])
                                    ])])
                            ]),
                          "@[%a%s#%a@]"
                        ]), print_typargs, ty[2], ty[0] ? "_" : "", print_ident, ty[1]);
      case 3 : 
          var id = ty[0];
          var exit$1 = 0;
          switch (id.tag | 0) {
            case 1 : 
                var match = id[0];
                switch (match.tag | 0) {
                  case 0 : 
                  case 1 : 
                      exit$1 = 2;
                      break;
                  case 2 : 
                      if (match[0] === "Js") {
                        var name = id[1];
                        var exit$2 = 0;
                        switch (name) {
                          case "fn" : 
                          case "meth" : 
                              exit$2 = 3;
                              break;
                          case "meth_callback" : 
                              var tyl = ty[1];
                              if (tyl) {
                                var match$1 = tyl[0];
                                if (typeof match$1 === "number") {
                                  exit$1 = 2;
                                } else if (match$1.tag === 11) {
                                  var match$2 = match$1[1];
                                  if (match$2.tag) {
                                    exit$1 = 2;
                                  } else {
                                    var match$3 = match$2[0];
                                    if (match$3) {
                                      if (match$3[1]) {
                                        exit$1 = 2;
                                      } else {
                                        var match$4 = tyl[1];
                                        if (match$4) {
                                          if (match$4[1]) {
                                            exit$1 = 2;
                                          } else {
                                            var match$5 = match$3[0];
                                            var variant = match$5[0];
                                            var make = function (tys, result) {
                                              if (tys) {
                                                var single = tys[0];
                                                var exit = 0;
                                                if (typeof single === "number") {
                                                  exit = 1;
                                                } else if (single.tag === 9) {
                                                  if (tys[1]) {
                                                    throw Caml_builtin_exceptions.not_found;
                                                  } else if (variant === "Arity_1") {
                                                    return /* Otyp_arrow */Block.__(1, [
                                                              "",
                                                              single,
                                                              result
                                                            ]);
                                                  } else {
                                                    return List.fold_right((function (x, acc) {
                                                                  return /* Otyp_arrow */Block.__(1, [
                                                                            "",
                                                                            x,
                                                                            acc
                                                                          ]);
                                                                }), single[0], result);
                                                  }
                                                } else {
                                                  exit = 1;
                                                }
                                                if (exit === 1) {
                                                  if (tys[1]) {
                                                    throw Caml_builtin_exceptions.not_found;
                                                  } else {
                                                    return /* Otyp_arrow */Block.__(1, [
                                                              "",
                                                              single,
                                                              result
                                                            ]);
                                                  }
                                                }
                                                
                                              } else {
                                                throw Caml_builtin_exceptions.not_found;
                                              }
                                            };
                                            var exit$3 = 0;
                                            var res;
                                            try {
                                              res = make(match$5[2], match$4[0]);
                                              exit$3 = 4;
                                            }
                                            catch (exn){
                                              Format.pp_open_box(ppf, 0);
                                              print_typargs(ppf, tyl);
                                              print_ident(ppf, id);
                                              return Format.pp_close_box(ppf, /* () */0);
                                            }
                                            if (exit$3 === 4) {
                                              return Curry._2(Format.fprintf(ppf, /* Format */[
                                                              /* Formatting_gen */Block.__(18, [
                                                                  /* Open_box */Block.__(1, [/* Format */[
                                                                        /* String_literal */Block.__(11, [
                                                                            "<0>",
                                                                            /* End_of_format */0
                                                                          ]),
                                                                        "<0>"
                                                                      ]]),
                                                                  /* Char_literal */Block.__(12, [
                                                                      /* "(" */40,
                                                                      /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                              /* Break */Block.__(0, [
                                                                                  "@ ",
                                                                                  1,
                                                                                  0
                                                                                ]),
                                                                              /* Char_literal */Block.__(12, [
                                                                                  /* "[" */91,
                                                                                  /* Formatting_lit */Block.__(17, [
                                                                                      /* Scan_indic */Block.__(2, [/* "b" */98]),
                                                                                      /* String_literal */Block.__(11, [
                                                                                          "s.this])",
                                                                                          /* Formatting_lit */Block.__(17, [
                                                                                              /* Close_box */0,
                                                                                              /* End_of_format */0
                                                                                            ])
                                                                                        ])
                                                                                    ])
                                                                                ])
                                                                            ])])
                                                                    ])
                                                                ]),
                                                              "@[<0>(%a@ [@bs.this])@]"
                                                            ]), print_out_type_1, res);
                                            }
                                            
                                          }
                                        } else {
                                          exit$1 = 2;
                                        }
                                      }
                                    } else {
                                      exit$1 = 2;
                                    }
                                  }
                                } else {
                                  exit$1 = 2;
                                }
                              } else {
                                exit$1 = 2;
                              }
                              break;
                          default:
                            exit$1 = 2;
                        }
                        if (exit$2 === 3) {
                          var tyl$1 = ty[1];
                          if (tyl$1) {
                            var match$6 = tyl$1[0];
                            if (typeof match$6 === "number") {
                              exit$1 = 2;
                            } else if (match$6.tag === 11) {
                              var match$7 = match$6[1];
                              if (match$7.tag) {
                                exit$1 = 2;
                              } else {
                                var match$8 = match$7[0];
                                if (match$8) {
                                  if (match$8[1]) {
                                    exit$1 = 2;
                                  } else {
                                    var match$9 = tyl$1[1];
                                    if (match$9) {
                                      if (match$9[1]) {
                                        exit$1 = 2;
                                      } else {
                                        var match$10 = match$8[0];
                                        var variant$1 = match$10[0];
                                        var make$1 = function (tys, result) {
                                          if (tys) {
                                            if (tys) {
                                              var single = tys[0];
                                              var exit = 0;
                                              if (typeof single === "number") {
                                                exit = 1;
                                              } else if (single.tag === 9) {
                                                if (tys[1]) {
                                                  throw Caml_builtin_exceptions.not_found;
                                                } else if (variant$1 === "Arity_1") {
                                                  return /* Otyp_arrow */Block.__(1, [
                                                            "",
                                                            single,
                                                            result
                                                          ]);
                                                } else {
                                                  return List.fold_right((function (x, acc) {
                                                                return /* Otyp_arrow */Block.__(1, [
                                                                          "",
                                                                          x,
                                                                          acc
                                                                        ]);
                                                              }), single[0], result);
                                                }
                                              } else {
                                                exit = 1;
                                              }
                                              if (exit === 1) {
                                                if (tys[1]) {
                                                  throw Caml_builtin_exceptions.not_found;
                                                } else {
                                                  return /* Otyp_arrow */Block.__(1, [
                                                            "",
                                                            single,
                                                            result
                                                          ]);
                                                }
                                              }
                                              
                                            } else {
                                              throw Caml_builtin_exceptions.not_found;
                                            }
                                          } else {
                                            return /* Otyp_arrow */Block.__(1, [
                                                      "",
                                                      /* Otyp_constr */Block.__(3, [
                                                          /* Oide_ident */Block.__(2, ["unit"]),
                                                          /* [] */0
                                                        ]),
                                                      result
                                                    ]);
                                          }
                                        };
                                        var exit$4 = 0;
                                        var res$1;
                                        try {
                                          res$1 = make$1(match$10[2], match$9[0]);
                                          exit$4 = 4;
                                        }
                                        catch (exn$1){
                                          Format.pp_open_box(ppf, 0);
                                          print_typargs(ppf, tyl$1);
                                          print_ident(ppf, id);
                                          return Format.pp_close_box(ppf, /* () */0);
                                        }
                                        if (exit$4 === 4) {
                                          switch (name) {
                                            case "fn" : 
                                                return Curry._2(Format.fprintf(ppf, /* Format */[
                                                                /* Formatting_gen */Block.__(18, [
                                                                    /* Open_box */Block.__(1, [/* Format */[
                                                                          /* String_literal */Block.__(11, [
                                                                              "<0>",
                                                                              /* End_of_format */0
                                                                            ]),
                                                                          "<0>"
                                                                        ]]),
                                                                    /* Char_literal */Block.__(12, [
                                                                        /* "(" */40,
                                                                        /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                                /* Break */Block.__(0, [
                                                                                    "@ ",
                                                                                    1,
                                                                                    0
                                                                                  ]),
                                                                                /* Char_literal */Block.__(12, [
                                                                                    /* "[" */91,
                                                                                    /* Formatting_lit */Block.__(17, [
                                                                                        /* Scan_indic */Block.__(2, [/* "b" */98]),
                                                                                        /* String_literal */Block.__(11, [
                                                                                            "s])",
                                                                                            /* Formatting_lit */Block.__(17, [
                                                                                                /* Close_box */0,
                                                                                                /* End_of_format */0
                                                                                              ])
                                                                                          ])
                                                                                      ])
                                                                                  ])
                                                                              ])])
                                                                      ])
                                                                  ]),
                                                                "@[<0>(%a@ [@bs])@]"
                                                              ]), print_out_type_1, res$1);
                                            case "meth" : 
                                                return Curry._2(Format.fprintf(ppf, /* Format */[
                                                                /* Formatting_gen */Block.__(18, [
                                                                    /* Open_box */Block.__(1, [/* Format */[
                                                                          /* String_literal */Block.__(11, [
                                                                              "<0>",
                                                                              /* End_of_format */0
                                                                            ]),
                                                                          "<0>"
                                                                        ]]),
                                                                    /* Char_literal */Block.__(12, [
                                                                        /* "(" */40,
                                                                        /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                                /* Break */Block.__(0, [
                                                                                    "@ ",
                                                                                    1,
                                                                                    0
                                                                                  ]),
                                                                                /* Char_literal */Block.__(12, [
                                                                                    /* "[" */91,
                                                                                    /* Formatting_lit */Block.__(17, [
                                                                                        /* Scan_indic */Block.__(2, [/* "b" */98]),
                                                                                        /* String_literal */Block.__(11, [
                                                                                            "s.meth])",
                                                                                            /* Formatting_lit */Block.__(17, [
                                                                                                /* Close_box */0,
                                                                                                /* End_of_format */0
                                                                                              ])
                                                                                          ])
                                                                                      ])
                                                                                  ])
                                                                              ])])
                                                                      ])
                                                                  ]),
                                                                "@[<0>(%a@ [@bs.meth])@]"
                                                              ]), print_out_type_1, res$1);
                                            default:
                                              throw [
                                                    Caml_builtin_exceptions.assert_failure,
                                                    [
                                                      "oprint.ml",
                                                      226,
                                                      17
                                                    ]
                                                  ];
                                          }
                                        }
                                        
                                      }
                                    } else {
                                      exit$1 = 2;
                                    }
                                  }
                                } else {
                                  exit$1 = 2;
                                }
                              }
                            } else {
                              exit$1 = 2;
                            }
                          } else {
                            exit$1 = 2;
                          }
                        }
                        
                      } else {
                        exit$1 = 2;
                      }
                      break;
                  
                }
                break;
            case 0 : 
            case 2 : 
                exit$1 = 2;
                break;
            
          }
          if (exit$1 === 2) {
            Format.pp_open_box(ppf, 0);
            print_typargs(ppf, ty[1]);
            print_ident(ppf, id);
            return Format.pp_close_box(ppf, /* () */0);
          }
          break;
      case 5 : 
          var rest = ty[1];
          return Curry._2(Format.fprintf(ppf, /* Format */[
                          /* Formatting_gen */Block.__(18, [
                              /* Open_box */Block.__(1, [/* Format */[
                                    /* String_literal */Block.__(11, [
                                        "<2>",
                                        /* End_of_format */0
                                      ]),
                                    "<2>"
                                  ]]),
                              /* String_literal */Block.__(11, [
                                  "< ",
                                  /* Alpha */Block.__(15, [/* String_literal */Block.__(11, [
                                          " >",
                                          /* Formatting_lit */Block.__(17, [
                                              /* Close_box */0,
                                              /* End_of_format */0
                                            ])
                                        ])])
                                ])
                            ]),
                          "@[<2>< %a >@]"
                        ]), (function (param, param$1) {
                        return print_fields(rest, param, param$1);
                      }), ty[0]);
      case 7 : 
          return Format.pp_print_string(ppf, ty[0]);
      case 10 : 
          return Curry._2(Format.fprintf(ppf, /* Format */[
                          /* Char_literal */Block.__(12, [
                              /* "'" */39,
                              /* String */Block.__(2, [
                                  /* No_padding */0,
                                  /* String */Block.__(2, [
                                      /* No_padding */0,
                                      /* End_of_format */0
                                    ])
                                ])
                            ]),
                          "'%s%s"
                        ]), ty[0] ? "_" : "", ty[1]);
      case 11 : 
          var tags = ty[3];
          var print_present = function (ppf, param) {
            if (param) {
              var l = param[0];
              if (l) {
                return Curry._2(Format.fprintf(ppf, /* Format */[
                                /* Formatting_lit */Block.__(17, [
                                    /* Break */Block.__(0, [
                                        "@;<1 -2>",
                                        1,
                                        -2
                                      ]),
                                    /* String_literal */Block.__(11, [
                                        "> ",
                                        /* Formatting_gen */Block.__(18, [
                                            /* Open_box */Block.__(1, [/* Format */[
                                                  /* String_literal */Block.__(11, [
                                                      "<hov>",
                                                      /* End_of_format */0
                                                    ]),
                                                  "<hov>"
                                                ]]),
                                            /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                    /* Close_box */0,
                                                    /* End_of_format */0
                                                  ])])
                                          ])
                                      ])
                                  ]),
                                "@;<1 -2>> @[<hov>%a@]"
                              ]), pr_present, l);
              } else {
                return /* () */0;
              }
            } else {
              return /* () */0;
            }
          };
          var print_fields$1 = function (ppf, param) {
            if (param.tag) {
              return Curry._4(Format.fprintf(ppf, /* Format */[
                              /* Formatting_gen */Block.__(18, [
                                  /* Open_box */Block.__(1, [/* Format */[
                                        /* End_of_format */0,
                                        ""
                                      ]]),
                                  /* Alpha */Block.__(15, [/* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                              /* Close_box */0,
                                              /* End_of_format */0
                                            ])])])
                                ]),
                              "@[%a%a@]"
                            ]), print_typargs, param[1], print_ident, param[0]);
            } else {
              return print_list(print_row_field, (function (ppf) {
                            return Format.fprintf(ppf, /* Format */[
                                        /* Formatting_lit */Block.__(17, [
                                            /* Break */Block.__(0, [
                                                "@;<1 -2>",
                                                1,
                                                -2
                                              ]),
                                            /* String_literal */Block.__(11, [
                                                "| ",
                                                /* End_of_format */0
                                              ])
                                          ]),
                                        "@;<1 -2>| "
                                      ]);
                          }), ppf, param[0]);
            }
          };
          return Curry._6(Format.fprintf(ppf, /* Format */[
                          /* String */Block.__(2, [
                              /* No_padding */0,
                              /* Char_literal */Block.__(12, [
                                  /* "[" */91,
                                  /* String */Block.__(2, [
                                      /* No_padding */0,
                                      /* Formatting_gen */Block.__(18, [
                                          /* Open_box */Block.__(1, [/* Format */[
                                                /* String_literal */Block.__(11, [
                                                    "<hv>",
                                                    /* End_of_format */0
                                                  ]),
                                                "<hv>"
                                              ]]),
                                          /* Formatting_gen */Block.__(18, [
                                              /* Open_box */Block.__(1, [/* Format */[
                                                    /* String_literal */Block.__(11, [
                                                        "<hv>",
                                                        /* End_of_format */0
                                                      ]),
                                                    "<hv>"
                                                  ]]),
                                              /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                      /* Close_box */0,
                                                      /* Alpha */Block.__(15, [/* String_literal */Block.__(11, [
                                                              " ]",
                                                              /* Formatting_lit */Block.__(17, [
                                                                  /* Close_box */0,
                                                                  /* End_of_format */0
                                                                ])
                                                            ])])
                                                    ])])
                                            ])
                                        ])
                                    ])
                                ])
                            ]),
                          "%s[%s@[<hv>@[<hv>%a@]%a ]@]"
                        ]), ty[0] ? "_" : "", ty[2] ? (
                        tags ? "< " : " "
                      ) : (
                        tags ? "? " : "> "
                      ), print_fields$1, ty[1], print_present, tags);
      case 0 : 
      case 1 : 
      case 9 : 
      case 12 : 
          exit = 1;
          break;
      case 13 : 
          Curry._1(Format.fprintf(ppf, /* Format */[
                    /* Formatting_gen */Block.__(18, [
                        /* Open_box */Block.__(1, [/* Format */[
                              /* String_literal */Block.__(11, [
                                  "<1>",
                                  /* End_of_format */0
                                ]),
                              "<1>"
                            ]]),
                        /* String_literal */Block.__(11, [
                            "(module ",
                            /* String */Block.__(2, [
                                /* No_padding */0,
                                /* End_of_format */0
                              ])
                          ])
                      ]),
                    "@[<1>(module %s"
                  ]), ty[0]);
          var first = [/* true */1];
          List.iter2((function (s, t) {
                  var sep = first[0] ? (first[0] = /* false */0, "with") : "and";
                  return Curry._4(Format.fprintf(ppf, /* Format */[
                                  /* Char_literal */Block.__(12, [
                                      /* " " */32,
                                      /* String */Block.__(2, [
                                          /* No_padding */0,
                                          /* String_literal */Block.__(11, [
                                              " type ",
                                              /* String */Block.__(2, [
                                                  /* No_padding */0,
                                                  /* String_literal */Block.__(11, [
                                                      " = ",
                                                      /* Alpha */Block.__(15, [/* End_of_format */0])
                                                    ])
                                                ])
                                            ])
                                        ])
                                    ]),
                                  " %s type %s = %a"
                                ]), sep, s, print_out_type, t);
                }), ty[1], ty[2]);
          return Format.fprintf(ppf, /* Format */[
                      /* Char_literal */Block.__(12, [
                          /* ")" */41,
                          /* Formatting_lit */Block.__(17, [
                              /* Close_box */0,
                              /* End_of_format */0
                            ])
                        ]),
                      ")@]"
                    ]);
      default:
        return /* () */0;
    }
  }
  if (exit === 1) {
    Format.pp_open_box(ppf, 1);
    Format.pp_print_char(ppf, /* "(" */40);
    print_out_type(ppf, ty);
    Format.pp_print_char(ppf, /* ")" */41);
    return Format.pp_close_box(ppf, /* () */0);
  }
  
}

function print_fields(rest, ppf, _param) {
  while(true) {
    var param = _param;
    if (param) {
      var l = param[1];
      var match = param[0];
      var t = match[1];
      var s = match[0];
      if (l) {
        return Curry._5(Format.fprintf(ppf, /* Format */[
                        /* String */Block.__(2, [
                            /* No_padding */0,
                            /* String_literal */Block.__(11, [
                                " : ",
                                /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                        /* ";" */59,
                                        /* Formatting_lit */Block.__(17, [
                                            /* Break */Block.__(0, [
                                                "@ ",
                                                1,
                                                0
                                              ]),
                                            /* Alpha */Block.__(15, [/* End_of_format */0])
                                          ])
                                      ])])
                              ])
                          ]),
                        "%s : %a;@ %a"
                      ]), s, print_out_type, t, (function (param, param$1) {
                      return print_fields(rest, param, param$1);
                    }), l);
      } else {
        Curry._3(Format.fprintf(ppf, /* Format */[
                  /* String */Block.__(2, [
                      /* No_padding */0,
                      /* String_literal */Block.__(11, [
                          " : ",
                          /* Alpha */Block.__(15, [/* End_of_format */0])
                        ])
                    ]),
                  "%s : %a"
                ]), s, print_out_type, t);
        if (rest) {
          Format.fprintf(ppf, /* Format */[
                /* Char_literal */Block.__(12, [
                    /* ";" */59,
                    /* Formatting_lit */Block.__(17, [
                        /* Break */Block.__(0, [
                            "@ ",
                            1,
                            0
                          ]),
                        /* End_of_format */0
                      ])
                  ]),
                ";@ "
              ]);
        }
        _param = /* [] */0;
        continue ;
        
      }
    } else if (rest) {
      return Curry._1(Format.fprintf(ppf, /* Format */[
                      /* String */Block.__(2, [
                          /* No_padding */0,
                          /* String_literal */Block.__(11, [
                              "..",
                              /* End_of_format */0
                            ])
                        ]),
                      "%s.."
                    ]), rest[0] ? "_" : "");
    } else {
      return /* () */0;
    }
  };
}

function print_row_field(ppf, param) {
  var tyl = param[2];
  var opt_amp = param[1];
  var pr_of = function (ppf) {
    if (opt_amp) {
      return Format.fprintf(ppf, /* Format */[
                  /* String_literal */Block.__(11, [
                      " of",
                      /* Formatting_lit */Block.__(17, [
                          /* Break */Block.__(0, [
                              "@ ",
                              1,
                              0
                            ]),
                          /* Char_literal */Block.__(12, [
                              /* "&" */38,
                              /* Formatting_lit */Block.__(17, [
                                  /* Break */Block.__(0, [
                                      "@ ",
                                      1,
                                      0
                                    ]),
                                  /* End_of_format */0
                                ])
                            ])
                        ])
                    ]),
                  " of@ &@ "
                ]);
    } else if (tyl !== /* [] */0) {
      return Format.fprintf(ppf, /* Format */[
                  /* String_literal */Block.__(11, [
                      " of",
                      /* Formatting_lit */Block.__(17, [
                          /* Break */Block.__(0, [
                              "@ ",
                              1,
                              0
                            ]),
                          /* End_of_format */0
                        ])
                    ]),
                  " of@ "
                ]);
    } else {
      return Format.fprintf(ppf, /* Format */[
                  /* End_of_format */0,
                  ""
                ]);
    }
  };
  return Curry._4(Format.fprintf(ppf, /* Format */[
                  /* Formatting_gen */Block.__(18, [
                      /* Open_box */Block.__(1, [/* Format */[
                            /* String_literal */Block.__(11, [
                                "<hv 2>",
                                /* End_of_format */0
                              ]),
                            "<hv 2>"
                          ]]),
                      /* Char_literal */Block.__(12, [
                          /* "`" */96,
                          /* String */Block.__(2, [
                              /* No_padding */0,
                              /* Theta */Block.__(16, [/* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                          /* Close_box */0,
                                          /* End_of_format */0
                                        ])])])
                            ])
                        ])
                    ]),
                  "@[<hv 2>`%s%t%a@]"
                ]), param[0], pr_of, (function (param, param$1) {
                return print_typlist(print_out_type, " &", param, param$1);
              }), tyl);
}

function print_typlist(print_elem, sep, ppf, _param) {
  while(true) {
    var param = _param;
    if (param) {
      var tyl = param[1];
      var ty = param[0];
      if (tyl) {
        Curry._2(print_elem, ppf, ty);
        Format.pp_print_string(ppf, sep);
        Format.pp_print_space(ppf, /* () */0);
        _param = tyl;
        continue ;
        
      } else {
        return Curry._2(print_elem, ppf, ty);
      }
    } else {
      return /* () */0;
    }
  };
}

function print_typargs(ppf, tyl) {
  if (tyl) {
    if (tyl[1]) {
      Format.pp_open_box(ppf, 1);
      Format.pp_print_char(ppf, /* "(" */40);
      print_typlist(print_out_type, ",", ppf, tyl);
      Format.pp_print_char(ppf, /* ")" */41);
      Format.pp_close_box(ppf, /* () */0);
      return Format.pp_print_space(ppf, /* () */0);
    } else {
      print_simple_out_type(ppf, tyl[0]);
      return Format.pp_print_space(ppf, /* () */0);
    }
  } else {
    return /* () */0;
  }
}

var out_type = [print_out_type];

function type_parameter(ppf, param) {
  var match = param[1];
  var ty = param[0];
  return Curry._2(Format.fprintf(ppf, /* Format */[
                  /* String */Block.__(2, [
                      /* No_padding */0,
                      /* String */Block.__(2, [
                          /* No_padding */0,
                          /* End_of_format */0
                        ])
                    ]),
                  "%s%s"
                ]), match[1] ? (
                match[0] ? "" : "-"
              ) : "+", ty === "_" ? ty : "'" + ty);
}

function print_out_class_params(ppf, tyl) {
  if (tyl) {
    return Curry._2(Format.fprintf(ppf, /* Format */[
                    /* Formatting_gen */Block.__(18, [
                        /* Open_box */Block.__(1, [/* Format */[
                              /* String_literal */Block.__(11, [
                                  "<1>",
                                  /* End_of_format */0
                                ]),
                              "<1>"
                            ]]),
                        /* Char_literal */Block.__(12, [
                            /* "[" */91,
                            /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                    /* "]" */93,
                                    /* Formatting_lit */Block.__(17, [
                                        /* Close_box */0,
                                        /* Formatting_lit */Block.__(17, [
                                            /* Break */Block.__(0, [
                                                "@ ",
                                                1,
                                                0
                                              ]),
                                            /* End_of_format */0
                                          ])
                                      ])
                                  ])])
                          ])
                      ]),
                    "@[<1>[%a]@]@ "
                  ]), (function (param, param$1) {
                  return print_list(type_parameter, (function (ppf) {
                                return Format.fprintf(ppf, /* Format */[
                                            /* String_literal */Block.__(11, [
                                                ", ",
                                                /* End_of_format */0
                                              ]),
                                            ", "
                                          ]);
                              }), param, param$1);
                }), tyl);
  } else {
    return /* () */0;
  }
}

function print_out_class_type(ppf, param) {
  switch (param.tag | 0) {
    case 0 : 
        var pr_tyl = function (ppf, tyl) {
          if (tyl) {
            var partial_arg = out_type[0];
            return Curry._2(Format.fprintf(ppf, /* Format */[
                            /* Formatting_gen */Block.__(18, [
                                /* Open_box */Block.__(1, [/* Format */[
                                      /* String_literal */Block.__(11, [
                                          "<1>",
                                          /* End_of_format */0
                                        ]),
                                      "<1>"
                                    ]]),
                                /* Char_literal */Block.__(12, [
                                    /* "[" */91,
                                    /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                            /* "]" */93,
                                            /* Formatting_lit */Block.__(17, [
                                                /* Close_box */0,
                                                /* Formatting_lit */Block.__(17, [
                                                    /* Break */Block.__(0, [
                                                        "@ ",
                                                        1,
                                                        0
                                                      ]),
                                                    /* End_of_format */0
                                                  ])
                                              ])
                                          ])])
                                  ])
                              ]),
                            "@[<1>[%a]@]@ "
                          ]), (function (param, param$1) {
                          return print_typlist(partial_arg, ",", param, param$1);
                        }), tyl);
          } else {
            return /* () */0;
          }
        };
        return Curry._4(Format.fprintf(ppf, /* Format */[
                        /* Formatting_gen */Block.__(18, [
                            /* Open_box */Block.__(1, [/* Format */[
                                  /* End_of_format */0,
                                  ""
                                ]]),
                            /* Alpha */Block.__(15, [/* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                        /* Close_box */0,
                                        /* End_of_format */0
                                      ])])])
                          ]),
                        "@[%a%a@]"
                      ]), pr_tyl, param[1], print_ident, param[0]);
    case 1 : 
        var lab = param[0];
        return Curry._5(Format.fprintf(ppf, /* Format */[
                        /* Formatting_gen */Block.__(18, [
                            /* Open_box */Block.__(1, [/* Format */[
                                  /* End_of_format */0,
                                  ""
                                ]]),
                            /* String */Block.__(2, [
                                /* No_padding */0,
                                /* Alpha */Block.__(15, [/* String_literal */Block.__(11, [
                                        " ->",
                                        /* Formatting_lit */Block.__(17, [
                                            /* Break */Block.__(0, [
                                                "@ ",
                                                1,
                                                0
                                              ]),
                                            /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                    /* Close_box */0,
                                                    /* End_of_format */0
                                                  ])])
                                          ])
                                      ])])
                              ])
                          ]),
                        "@[%s%a ->@ %a@]"
                      ]), lab !== "" ? lab + ":" : "", print_out_type_2, param[1], print_out_class_type, param[2]);
    case 2 : 
        var pr_param = function (ppf, param) {
          if (param) {
            return Curry._2(Format.fprintf(ppf, /* Format */[
                            /* Formatting_lit */Block.__(17, [
                                /* Break */Block.__(0, [
                                    "@ ",
                                    1,
                                    0
                                  ]),
                                /* Formatting_gen */Block.__(18, [
                                    /* Open_box */Block.__(1, [/* Format */[
                                          /* End_of_format */0,
                                          ""
                                        ]]),
                                    /* Char_literal */Block.__(12, [
                                        /* "(" */40,
                                        /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                                /* ")" */41,
                                                /* Formatting_lit */Block.__(17, [
                                                    /* Close_box */0,
                                                    /* End_of_format */0
                                                  ])
                                              ])])
                                      ])
                                  ])
                              ]),
                            "@ @[(%a)@]"
                          ]), out_type[0], param[0]);
          } else {
            return /* () */0;
          }
        };
        return Curry._4(Format.fprintf(ppf, /* Format */[
                        /* Formatting_gen */Block.__(18, [
                            /* Open_box */Block.__(1, [/* Format */[
                                  /* String_literal */Block.__(11, [
                                      "<hv 2>",
                                      /* End_of_format */0
                                    ]),
                                  "<hv 2>"
                                ]]),
                            /* Formatting_gen */Block.__(18, [
                                /* Open_box */Block.__(1, [/* Format */[
                                      /* String_literal */Block.__(11, [
                                          "<2>",
                                          /* End_of_format */0
                                        ]),
                                      "<2>"
                                    ]]),
                                /* String_literal */Block.__(11, [
                                    "object",
                                    /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                            /* Close_box */0,
                                            /* Formatting_lit */Block.__(17, [
                                                /* Break */Block.__(0, [
                                                    "@ ",
                                                    1,
                                                    0
                                                  ]),
                                                /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                        /* Break */Block.__(0, [
                                                            "@;<1 -2>",
                                                            1,
                                                            -2
                                                          ]),
                                                        /* String_literal */Block.__(11, [
                                                            "end",
                                                            /* Formatting_lit */Block.__(17, [
                                                                /* Close_box */0,
                                                                /* End_of_format */0
                                                              ])
                                                          ])
                                                      ])])
                                              ])
                                          ])])
                                  ])
                              ])
                          ]),
                        "@[<hv 2>@[<2>object%a@]@ %a@;<1 -2>end@]"
                      ]), pr_param, param[0], (function (param, param$1) {
                      return print_list(print_out_class_sig_item, (function (ppf) {
                                    return Format.fprintf(ppf, /* Format */[
                                                /* Formatting_lit */Block.__(17, [
                                                    /* Break */Block.__(0, [
                                                        "@ ",
                                                        1,
                                                        0
                                                      ]),
                                                    /* End_of_format */0
                                                  ]),
                                                "@ "
                                              ]);
                                  }), param, param$1);
                    }), param[1]);
    
  }
}

function print_out_class_sig_item(ppf, param) {
  switch (param.tag | 0) {
    case 0 : 
        return Curry._4(Format.fprintf(ppf, /* Format */[
                        /* Formatting_gen */Block.__(18, [
                            /* Open_box */Block.__(1, [/* Format */[
                                  /* String_literal */Block.__(11, [
                                      "<2>",
                                      /* End_of_format */0
                                    ]),
                                  "<2>"
                                ]]),
                            /* String_literal */Block.__(11, [
                                "constraint ",
                                /* Alpha */Block.__(15, [/* String_literal */Block.__(11, [
                                        " =",
                                        /* Formatting_lit */Block.__(17, [
                                            /* Break */Block.__(0, [
                                                "@ ",
                                                1,
                                                0
                                              ]),
                                            /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                    /* Close_box */0,
                                                    /* End_of_format */0
                                                  ])])
                                          ])
                                      ])])
                              ])
                          ]),
                        "@[<2>constraint %a =@ %a@]"
                      ]), out_type[0], param[0], out_type[0], param[1]);
    case 1 : 
        return Curry._5(Format.fprintf(ppf, /* Format */[
                        /* Formatting_gen */Block.__(18, [
                            /* Open_box */Block.__(1, [/* Format */[
                                  /* String_literal */Block.__(11, [
                                      "<2>",
                                      /* End_of_format */0
                                    ]),
                                  "<2>"
                                ]]),
                            /* String_literal */Block.__(11, [
                                "method ",
                                /* String */Block.__(2, [
                                    /* No_padding */0,
                                    /* String */Block.__(2, [
                                        /* No_padding */0,
                                        /* String */Block.__(2, [
                                            /* No_padding */0,
                                            /* String_literal */Block.__(11, [
                                                " :",
                                                /* Formatting_lit */Block.__(17, [
                                                    /* Break */Block.__(0, [
                                                        "@ ",
                                                        1,
                                                        0
                                                      ]),
                                                    /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                            /* Close_box */0,
                                                            /* End_of_format */0
                                                          ])])
                                                  ])
                                              ])
                                          ])
                                      ])
                                  ])
                              ])
                          ]),
                        "@[<2>method %s%s%s :@ %a@]"
                      ]), param[1] ? "private " : "", param[2] ? "virtual " : "", param[0], out_type[0], param[3]);
    case 2 : 
        return Curry._5(Format.fprintf(ppf, /* Format */[
                        /* Formatting_gen */Block.__(18, [
                            /* Open_box */Block.__(1, [/* Format */[
                                  /* String_literal */Block.__(11, [
                                      "<2>",
                                      /* End_of_format */0
                                    ]),
                                  "<2>"
                                ]]),
                            /* String_literal */Block.__(11, [
                                "val ",
                                /* String */Block.__(2, [
                                    /* No_padding */0,
                                    /* String */Block.__(2, [
                                        /* No_padding */0,
                                        /* String */Block.__(2, [
                                            /* No_padding */0,
                                            /* String_literal */Block.__(11, [
                                                " :",
                                                /* Formatting_lit */Block.__(17, [
                                                    /* Break */Block.__(0, [
                                                        "@ ",
                                                        1,
                                                        0
                                                      ]),
                                                    /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                            /* Close_box */0,
                                                            /* End_of_format */0
                                                          ])])
                                                  ])
                                              ])
                                          ])
                                      ])
                                  ])
                              ])
                          ]),
                        "@[<2>val %s%s%s :@ %a@]"
                      ]), param[1] ? "mutable " : "", param[2] ? "virtual " : "", param[0], out_type[0], param[3]);
    
  }
}

var out_class_type = [print_out_class_type];

var out_module_type = [(function () {
      throw [
            Caml_builtin_exceptions.failure,
            "Oprint.out_module_type"
          ];
    })];

var out_sig_item = [(function () {
      throw [
            Caml_builtin_exceptions.failure,
            "Oprint.out_sig_item"
          ];
    })];

var out_signature = [(function () {
      throw [
            Caml_builtin_exceptions.failure,
            "Oprint.out_signature"
          ];
    })];

var out_type_extension = [(function () {
      throw [
            Caml_builtin_exceptions.failure,
            "Oprint.out_type_extension"
          ];
    })];

function print_out_functor(ppf, m) {
  var exit = 0;
  if (typeof m === "number") {
    exit = 1;
  } else if (m.tag) {
    exit = 1;
  } else {
    var match = m[1];
    if (match) {
      return Curry._5(Format.fprintf(ppf, /* Format */[
                      /* Char_literal */Block.__(12, [
                          /* "(" */40,
                          /* String */Block.__(2, [
                              /* No_padding */0,
                              /* String_literal */Block.__(11, [
                                  " : ",
                                  /* Alpha */Block.__(15, [/* String_literal */Block.__(11, [
                                          ") ",
                                          /* Alpha */Block.__(15, [/* End_of_format */0])
                                        ])])
                                ])
                            ])
                        ]),
                      "(%s : %a) %a"
                    ]), m[0], print_out_module_type, match[0], print_out_functor, m[2]);
    } else {
      return Curry._2(Format.fprintf(ppf, /* Format */[
                      /* String_literal */Block.__(11, [
                          "() ",
                          /* Alpha */Block.__(15, [/* End_of_format */0])
                        ]),
                      "() %a"
                    ]), print_out_functor, m[2]);
    }
  }
  if (exit === 1) {
    return Curry._2(Format.fprintf(ppf, /* Format */[
                    /* String_literal */Block.__(11, [
                        "->",
                        /* Formatting_lit */Block.__(17, [
                            /* Break */Block.__(0, [
                                "@ ",
                                1,
                                0
                              ]),
                            /* Alpha */Block.__(15, [/* End_of_format */0])
                          ])
                      ]),
                    "->@ %a"
                  ]), print_out_module_type, m);
  }
  
}

function print_out_constr(ppf, param) {
  var ret_type_opt = param[2];
  var tyl = param[1];
  var name = param[0];
  if (ret_type_opt) {
    var ret_type = ret_type_opt[0];
    if (tyl) {
      return Curry._5(Format.fprintf(ppf, /* Format */[
                      /* Formatting_gen */Block.__(18, [
                          /* Open_box */Block.__(1, [/* Format */[
                                /* String_literal */Block.__(11, [
                                    "<2>",
                                    /* End_of_format */0
                                  ]),
                                "<2>"
                              ]]),
                          /* String */Block.__(2, [
                              /* No_padding */0,
                              /* String_literal */Block.__(11, [
                                  " :",
                                  /* Formatting_lit */Block.__(17, [
                                      /* Break */Block.__(0, [
                                          "@ ",
                                          1,
                                          0
                                        ]),
                                      /* Alpha */Block.__(15, [/* String_literal */Block.__(11, [
                                              " -> ",
                                              /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                      /* Close_box */0,
                                                      /* End_of_format */0
                                                    ])])
                                            ])])
                                    ])
                                ])
                            ])
                        ]),
                      "@[<2>%s :@ %a -> %a@]"
                    ]), name, (function (param, param$1) {
                    return print_typlist(print_simple_out_type, " *", param, param$1);
                  }), tyl, print_simple_out_type, ret_type);
    } else {
      return Curry._3(Format.fprintf(ppf, /* Format */[
                      /* Formatting_gen */Block.__(18, [
                          /* Open_box */Block.__(1, [/* Format */[
                                /* String_literal */Block.__(11, [
                                    "<2>",
                                    /* End_of_format */0
                                  ]),
                                "<2>"
                              ]]),
                          /* String */Block.__(2, [
                              /* No_padding */0,
                              /* String_literal */Block.__(11, [
                                  " :",
                                  /* Formatting_lit */Block.__(17, [
                                      /* Break */Block.__(0, [
                                          "@ ",
                                          1,
                                          0
                                        ]),
                                      /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                              /* Close_box */0,
                                              /* End_of_format */0
                                            ])])
                                    ])
                                ])
                            ])
                        ]),
                      "@[<2>%s :@ %a@]"
                    ]), name, print_simple_out_type, ret_type);
    }
  } else if (tyl) {
    return Curry._3(Format.fprintf(ppf, /* Format */[
                    /* Formatting_gen */Block.__(18, [
                        /* Open_box */Block.__(1, [/* Format */[
                              /* String_literal */Block.__(11, [
                                  "<2>",
                                  /* End_of_format */0
                                ]),
                              "<2>"
                            ]]),
                        /* String */Block.__(2, [
                            /* No_padding */0,
                            /* String_literal */Block.__(11, [
                                " of",
                                /* Formatting_lit */Block.__(17, [
                                    /* Break */Block.__(0, [
                                        "@ ",
                                        1,
                                        0
                                      ]),
                                    /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                            /* Close_box */0,
                                            /* End_of_format */0
                                          ])])
                                  ])
                              ])
                          ])
                      ]),
                    "@[<2>%s of@ %a@]"
                  ]), name, (function (param, param$1) {
                  return print_typlist(print_simple_out_type, " *", param, param$1);
                }), tyl);
  } else {
    return Format.pp_print_string(ppf, name);
  }
}

function print_out_signature(ppf, param) {
  if (param) {
    var item = param[0];
    var exit = 0;
    if (param[1]) {
      if (item.tag === 2) {
        if (item[1] !== 0) {
          exit = 1;
        } else {
          var ext = item[0];
          var gather_extensions = function (_acc, _items) {
            while(true) {
              var items = _items;
              var acc = _acc;
              if (items) {
                var match = items[0];
                if (match.tag === 2) {
                  if (match[1] !== 1) {
                    return /* tuple */[
                            List.rev(acc),
                            items
                          ];
                  } else {
                    var ext = match[0];
                    _items = items[1];
                    _acc = /* :: */[
                      /* tuple */[
                        ext[/* oext_name */0],
                        ext[/* oext_args */3],
                        ext[/* oext_ret_type */4]
                      ],
                      acc
                    ];
                    continue ;
                    
                  }
                } else {
                  return /* tuple */[
                          List.rev(acc),
                          items
                        ];
                }
              } else {
                return /* tuple */[
                        List.rev(acc),
                        items
                      ];
              }
            };
          };
          var match = gather_extensions(/* :: */[
                /* tuple */[
                  ext[/* oext_name */0],
                  ext[/* oext_args */3],
                  ext[/* oext_ret_type */4]
                ],
                /* [] */0
              ], param[1]);
          var te_000 = /* otyext_name */ext[/* oext_type_name */1];
          var te_001 = /* otyext_params */ext[/* oext_type_params */2];
          var te_002 = /* otyext_constructors */match[0];
          var te_003 = /* otyext_private */ext[/* oext_private */5];
          var te = /* record */[
            te_000,
            te_001,
            te_002,
            te_003
          ];
          return Curry._4(Format.fprintf(ppf, /* Format */[
                          /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                  /* Break */Block.__(0, [
                                      "@ ",
                                      1,
                                      0
                                    ]),
                                  /* Alpha */Block.__(15, [/* End_of_format */0])
                                ])]),
                          "%a@ %a"
                        ]), out_type_extension[0], te, print_out_signature, match[1]);
        }
      } else {
        exit = 1;
      }
    } else {
      return Curry._2(out_sig_item[0], ppf, item);
    }
    if (exit === 1) {
      return Curry._4(Format.fprintf(ppf, /* Format */[
                      /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                              /* Break */Block.__(0, [
                                  "@ ",
                                  1,
                                  0
                                ]),
                              /* Alpha */Block.__(15, [/* End_of_format */0])
                            ])]),
                      "%a@ %a"
                    ]), out_sig_item[0], item, print_out_signature, param[1]);
    }
    
  } else {
    return /* () */0;
  }
}

function print_out_module_type(ppf, t) {
  if (typeof t === "number") {
    return /* () */0;
  } else {
    switch (t.tag | 0) {
      case 0 : 
          return Curry._2(Format.fprintf(ppf, /* Format */[
                          /* Formatting_gen */Block.__(18, [
                              /* Open_box */Block.__(1, [/* Format */[
                                    /* String_literal */Block.__(11, [
                                        "<2>",
                                        /* End_of_format */0
                                      ]),
                                    "<2>"
                                  ]]),
                              /* String_literal */Block.__(11, [
                                  "functor",
                                  /* Formatting_lit */Block.__(17, [
                                      /* Break */Block.__(0, [
                                          "@ ",
                                          1,
                                          0
                                        ]),
                                      /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                              /* Close_box */0,
                                              /* End_of_format */0
                                            ])])
                                    ])
                                ])
                            ]),
                          "@[<2>functor@ %a@]"
                        ]), print_out_functor, t);
      case 1 : 
          return Curry._2(Format.fprintf(ppf, /* Format */[
                          /* Alpha */Block.__(15, [/* End_of_format */0]),
                          "%a"
                        ]), print_ident, t[0]);
      case 2 : 
          return Curry._2(Format.fprintf(ppf, /* Format */[
                          /* Formatting_gen */Block.__(18, [
                              /* Open_box */Block.__(1, [/* Format */[
                                    /* String_literal */Block.__(11, [
                                        "<hv 2>",
                                        /* End_of_format */0
                                      ]),
                                    "<hv 2>"
                                  ]]),
                              /* String_literal */Block.__(11, [
                                  "sig",
                                  /* Formatting_lit */Block.__(17, [
                                      /* Break */Block.__(0, [
                                          "@ ",
                                          1,
                                          0
                                        ]),
                                      /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                              /* Break */Block.__(0, [
                                                  "@;<1 -2>",
                                                  1,
                                                  -2
                                                ]),
                                              /* String_literal */Block.__(11, [
                                                  "end",
                                                  /* Formatting_lit */Block.__(17, [
                                                      /* Close_box */0,
                                                      /* End_of_format */0
                                                    ])
                                                ])
                                            ])])
                                    ])
                                ])
                            ]),
                          "@[<hv 2>sig@ %a@;<1 -2>end@]"
                        ]), out_signature[0], t[0]);
      case 3 : 
          return Curry._2(Format.fprintf(ppf, /* Format */[
                          /* String_literal */Block.__(11, [
                              "(module ",
                              /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                      /* ")" */41,
                                      /* End_of_format */0
                                    ])])
                            ]),
                          "(module %a)"
                        ]), print_ident, t[0]);
      
    }
  }
}

function print_out_label(ppf, param) {
  return Curry._4(Format.fprintf(ppf, /* Format */[
                  /* Formatting_gen */Block.__(18, [
                      /* Open_box */Block.__(1, [/* Format */[
                            /* String_literal */Block.__(11, [
                                "<2>",
                                /* End_of_format */0
                              ]),
                            "<2>"
                          ]]),
                      /* String */Block.__(2, [
                          /* No_padding */0,
                          /* String */Block.__(2, [
                              /* No_padding */0,
                              /* String_literal */Block.__(11, [
                                  " :",
                                  /* Formatting_lit */Block.__(17, [
                                      /* Break */Block.__(0, [
                                          "@ ",
                                          1,
                                          0
                                        ]),
                                      /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                              /* Close_box */0,
                                              /* Char_literal */Block.__(12, [
                                                  /* ";" */59,
                                                  /* End_of_format */0
                                                ])
                                            ])])
                                    ])
                                ])
                            ])
                        ])
                    ]),
                  "@[<2>%s%s :@ %a@];"
                ]), param[1] ? "mutable " : "", param[0], out_type[0], param[2]);
}

function print_out_sig_item(ppf, param) {
  switch (param.tag | 0) {
    case 0 : 
        return Curry._7(Format.fprintf(ppf, /* Format */[
                        /* Formatting_gen */Block.__(18, [
                            /* Open_box */Block.__(1, [/* Format */[
                                  /* String_literal */Block.__(11, [
                                      "<2>",
                                      /* End_of_format */0
                                    ]),
                                  "<2>"
                                ]]),
                            /* String */Block.__(2, [
                                /* No_padding */0,
                                /* String */Block.__(2, [
                                    /* No_padding */0,
                                    /* Formatting_lit */Block.__(17, [
                                        /* Break */Block.__(0, [
                                            "@ ",
                                            1,
                                            0
                                          ]),
                                        /* Alpha */Block.__(15, [/* String */Block.__(2, [
                                                /* No_padding */0,
                                                /* Formatting_lit */Block.__(17, [
                                                    /* Break */Block.__(0, [
                                                        "@ ",
                                                        1,
                                                        0
                                                      ]),
                                                    /* Char_literal */Block.__(12, [
                                                        /* ":" */58,
                                                        /* Formatting_lit */Block.__(17, [
                                                            /* Break */Block.__(0, [
                                                                "@ ",
                                                                1,
                                                                0
                                                              ]),
                                                            /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                    /* Close_box */0,
                                                                    /* End_of_format */0
                                                                  ])])
                                                          ])
                                                      ])
                                                  ])
                                              ])])
                                      ])
                                  ])
                              ])
                          ]),
                        "@[<2>%s%s@ %a%s@ :@ %a@]"
                      ]), param[4] === /* Orec_next */2 ? "and" : "class", param[0] ? " virtual" : "", print_out_class_params, param[2], param[1], out_class_type[0], param[3]);
    case 1 : 
        return Curry._7(Format.fprintf(ppf, /* Format */[
                        /* Formatting_gen */Block.__(18, [
                            /* Open_box */Block.__(1, [/* Format */[
                                  /* String_literal */Block.__(11, [
                                      "<2>",
                                      /* End_of_format */0
                                    ]),
                                  "<2>"
                                ]]),
                            /* String */Block.__(2, [
                                /* No_padding */0,
                                /* String */Block.__(2, [
                                    /* No_padding */0,
                                    /* Formatting_lit */Block.__(17, [
                                        /* Break */Block.__(0, [
                                            "@ ",
                                            1,
                                            0
                                          ]),
                                        /* Alpha */Block.__(15, [/* String */Block.__(2, [
                                                /* No_padding */0,
                                                /* Formatting_lit */Block.__(17, [
                                                    /* Break */Block.__(0, [
                                                        "@ ",
                                                        1,
                                                        0
                                                      ]),
                                                    /* Char_literal */Block.__(12, [
                                                        /* "=" */61,
                                                        /* Formatting_lit */Block.__(17, [
                                                            /* Break */Block.__(0, [
                                                                "@ ",
                                                                1,
                                                                0
                                                              ]),
                                                            /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                    /* Close_box */0,
                                                                    /* End_of_format */0
                                                                  ])])
                                                          ])
                                                      ])
                                                  ])
                                              ])])
                                      ])
                                  ])
                              ])
                          ]),
                        "@[<2>%s%s@ %a%s@ =@ %a@]"
                      ]), param[4] === /* Orec_next */2 ? "and" : "class type", param[0] ? " virtual" : "", print_out_class_params, param[2], param[1], out_class_type[0], param[3]);
    case 2 : 
        var ext = param[0];
        if (param[1] >= 2) {
          return Curry._2(Format.fprintf(ppf, /* Format */[
                          /* Formatting_gen */Block.__(18, [
                              /* Open_box */Block.__(1, [/* Format */[
                                    /* String_literal */Block.__(11, [
                                        "<2>",
                                        /* End_of_format */0
                                      ]),
                                    "<2>"
                                  ]]),
                              /* String_literal */Block.__(11, [
                                  "exception ",
                                  /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                          /* Close_box */0,
                                          /* End_of_format */0
                                        ])])
                                ])
                            ]),
                          "@[<2>exception %a@]"
                        ]), print_out_constr, /* tuple */[
                      ext[/* oext_name */0],
                      ext[/* oext_args */3],
                      ext[/* oext_ret_type */4]
                    ]);
        } else {
          var ppf$1 = ppf;
          var ext$1 = ext;
          var print_extended_type = function (ppf) {
            var print_type_parameter = function (ppf, ty) {
              return Curry._1(Format.fprintf(ppf, /* Format */[
                              /* String */Block.__(2, [
                                  /* No_padding */0,
                                  /* End_of_format */0
                                ]),
                              "%s"
                            ]), ty === "_" ? ty : "'" + ty);
            };
            var match = ext$1[/* oext_type_params */2];
            if (match) {
              if (match[1]) {
                return Curry._3(Format.fprintf(ppf, /* Format */[
                                /* Formatting_gen */Block.__(18, [
                                    /* Open_box */Block.__(1, [/* Format */[
                                          /* End_of_format */0,
                                          ""
                                        ]]),
                                    /* Char_literal */Block.__(12, [
                                        /* "(" */40,
                                        /* Formatting_gen */Block.__(18, [
                                            /* Open_box */Block.__(1, [/* Format */[
                                                  /* End_of_format */0,
                                                  ""
                                                ]]),
                                            /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                                    /* ")" */41,
                                                    /* Formatting_lit */Block.__(17, [
                                                        /* Close_box */0,
                                                        /* Formatting_lit */Block.__(17, [
                                                            /* Break */Block.__(0, [
                                                                "@ ",
                                                                1,
                                                                0
                                                              ]),
                                                            /* String */Block.__(2, [
                                                                /* No_padding */0,
                                                                /* Formatting_lit */Block.__(17, [
                                                                    /* Close_box */0,
                                                                    /* End_of_format */0
                                                                  ])
                                                              ])
                                                          ])
                                                      ])
                                                  ])])
                                          ])
                                      ])
                                  ]),
                                "@[(@[%a)@]@ %s@]"
                              ]), (function (param, param$1) {
                              return print_list(print_type_parameter, (function (ppf) {
                                            return Format.fprintf(ppf, /* Format */[
                                                        /* Char_literal */Block.__(12, [
                                                            /* "," */44,
                                                            /* Formatting_lit */Block.__(17, [
                                                                /* Break */Block.__(0, [
                                                                    "@ ",
                                                                    1,
                                                                    0
                                                                  ]),
                                                                /* End_of_format */0
                                                              ])
                                                          ]),
                                                        ",@ "
                                                      ]);
                                          }), param, param$1);
                            }), ext$1[/* oext_type_params */2], ext$1[/* oext_type_name */1]);
              } else {
                return Curry._3(Format.fprintf(ppf, /* Format */[
                                /* Formatting_gen */Block.__(18, [
                                    /* Open_box */Block.__(1, [/* Format */[
                                          /* End_of_format */0,
                                          ""
                                        ]]),
                                    /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                            /* Break */Block.__(0, [
                                                "@ ",
                                                1,
                                                0
                                              ]),
                                            /* String */Block.__(2, [
                                                /* No_padding */0,
                                                /* Formatting_lit */Block.__(17, [
                                                    /* Close_box */0,
                                                    /* End_of_format */0
                                                  ])
                                              ])
                                          ])])
                                  ]),
                                "@[%a@ %s@]"
                              ]), print_type_parameter, match[0], ext$1[/* oext_type_name */1]);
              }
            } else {
              return Curry._1(Format.fprintf(ppf, /* Format */[
                              /* String */Block.__(2, [
                                  /* No_padding */0,
                                  /* End_of_format */0
                                ]),
                              "%s"
                            ]), ext$1[/* oext_type_name */1]);
            }
          };
          return Curry._4(Format.fprintf(ppf$1, /* Format */[
                          /* Formatting_gen */Block.__(18, [
                              /* Open_box */Block.__(1, [/* Format */[
                                    /* String_literal */Block.__(11, [
                                        "<hv 2>",
                                        /* End_of_format */0
                                      ]),
                                    "<hv 2>"
                                  ]]),
                              /* String_literal */Block.__(11, [
                                  "type ",
                                  /* Theta */Block.__(16, [/* String_literal */Block.__(11, [
                                          " +=",
                                          /* String */Block.__(2, [
                                              /* No_padding */0,
                                              /* Formatting_lit */Block.__(17, [
                                                  /* Break */Block.__(0, [
                                                      "@;<1 2>",
                                                      1,
                                                      2
                                                    ]),
                                                  /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                          /* Close_box */0,
                                                          /* End_of_format */0
                                                        ])])
                                                ])
                                            ])
                                        ])])
                                ])
                            ]),
                          "@[<hv 2>type %t +=%s@;<1 2>%a@]"
                        ]), print_extended_type, ext$1[/* oext_private */5] ? "" : " private", print_out_constr, /* tuple */[
                      ext$1[/* oext_name */0],
                      ext$1[/* oext_args */3],
                      ext$1[/* oext_ret_type */4]
                    ]);
        }
    case 3 : 
        var mty = param[1];
        var name = param[0];
        if (typeof mty === "number") {
          return Curry._1(Format.fprintf(ppf, /* Format */[
                          /* Formatting_gen */Block.__(18, [
                              /* Open_box */Block.__(1, [/* Format */[
                                    /* String_literal */Block.__(11, [
                                        "<2>",
                                        /* End_of_format */0
                                      ]),
                                    "<2>"
                                  ]]),
                              /* String_literal */Block.__(11, [
                                  "module type ",
                                  /* String */Block.__(2, [
                                      /* No_padding */0,
                                      /* Formatting_lit */Block.__(17, [
                                          /* Close_box */0,
                                          /* End_of_format */0
                                        ])
                                    ])
                                ])
                            ]),
                          "@[<2>module type %s@]"
                        ]), name);
        } else {
          return Curry._3(Format.fprintf(ppf, /* Format */[
                          /* Formatting_gen */Block.__(18, [
                              /* Open_box */Block.__(1, [/* Format */[
                                    /* String_literal */Block.__(11, [
                                        "<2>",
                                        /* End_of_format */0
                                      ]),
                                    "<2>"
                                  ]]),
                              /* String_literal */Block.__(11, [
                                  "module type ",
                                  /* String */Block.__(2, [
                                      /* No_padding */0,
                                      /* String_literal */Block.__(11, [
                                          " =",
                                          /* Formatting_lit */Block.__(17, [
                                              /* Break */Block.__(0, [
                                                  "@ ",
                                                  1,
                                                  0
                                                ]),
                                              /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                      /* Close_box */0,
                                                      /* End_of_format */0
                                                    ])])
                                            ])
                                        ])
                                    ])
                                ])
                            ]),
                          "@[<2>module type %s =@ %a@]"
                        ]), name, out_module_type[0], mty);
        }
    case 4 : 
        var mty$1 = param[1];
        var name$1 = param[0];
        var exit = 0;
        if (typeof mty$1 === "number") {
          exit = 1;
        } else if (mty$1.tag === 3) {
          return Curry._3(Format.fprintf(ppf, /* Format */[
                          /* Formatting_gen */Block.__(18, [
                              /* Open_box */Block.__(1, [/* Format */[
                                    /* String_literal */Block.__(11, [
                                        "<2>",
                                        /* End_of_format */0
                                      ]),
                                    "<2>"
                                  ]]),
                              /* String_literal */Block.__(11, [
                                  "module ",
                                  /* String */Block.__(2, [
                                      /* No_padding */0,
                                      /* String_literal */Block.__(11, [
                                          " =",
                                          /* Formatting_lit */Block.__(17, [
                                              /* Break */Block.__(0, [
                                                  "@ ",
                                                  1,
                                                  0
                                                ]),
                                              /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                      /* Close_box */0,
                                                      /* End_of_format */0
                                                    ])])
                                            ])
                                        ])
                                    ])
                                ])
                            ]),
                          "@[<2>module %s =@ %a@]"
                        ]), name$1, print_ident, mty$1[0]);
        } else {
          exit = 1;
        }
        if (exit === 1) {
          var $js;
          switch (param[2]) {
            case 0 : 
                $js = "module";
                break;
            case 1 : 
                $js = "module rec";
                break;
            case 2 : 
                $js = "and";
                break;
            
          }
          return Curry._4(Format.fprintf(ppf, /* Format */[
                          /* Formatting_gen */Block.__(18, [
                              /* Open_box */Block.__(1, [/* Format */[
                                    /* String_literal */Block.__(11, [
                                        "<2>",
                                        /* End_of_format */0
                                      ]),
                                    "<2>"
                                  ]]),
                              /* String */Block.__(2, [
                                  /* No_padding */0,
                                  /* Char_literal */Block.__(12, [
                                      /* " " */32,
                                      /* String */Block.__(2, [
                                          /* No_padding */0,
                                          /* String_literal */Block.__(11, [
                                              " :",
                                              /* Formatting_lit */Block.__(17, [
                                                  /* Break */Block.__(0, [
                                                      "@ ",
                                                      1,
                                                      0
                                                    ]),
                                                  /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                          /* Close_box */0,
                                                          /* End_of_format */0
                                                        ])])
                                                ])
                                            ])
                                        ])
                                    ])
                                ])
                            ]),
                          "@[<2>%s %s :@ %a@]"
                        ]), $js, name$1, out_module_type[0], mty$1);
        }
        break;
    case 5 : 
        var $js$1;
        switch (param[1]) {
          case 0 : 
              $js$1 = "type nonrec";
              break;
          case 1 : 
              $js$1 = "type";
              break;
          case 2 : 
              $js$1 = "and";
              break;
          
        }
        var kwd = $js$1;
        var ppf$2 = ppf;
        var td = param[0];
        var print_constraints = function (ppf) {
          return List.iter((function (param) {
                        return Curry._4(Format.fprintf(ppf, /* Format */[
                                        /* Formatting_lit */Block.__(17, [
                                            /* Break */Block.__(0, [
                                                "@ ",
                                                1,
                                                0
                                              ]),
                                            /* Formatting_gen */Block.__(18, [
                                                /* Open_box */Block.__(1, [/* Format */[
                                                      /* String_literal */Block.__(11, [
                                                          "<2>",
                                                          /* End_of_format */0
                                                        ]),
                                                      "<2>"
                                                    ]]),
                                                /* String_literal */Block.__(11, [
                                                    "constraint ",
                                                    /* Alpha */Block.__(15, [/* String_literal */Block.__(11, [
                                                            " =",
                                                            /* Formatting_lit */Block.__(17, [
                                                                /* Break */Block.__(0, [
                                                                    "@ ",
                                                                    1,
                                                                    0
                                                                  ]),
                                                                /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                        /* Close_box */0,
                                                                        /* End_of_format */0
                                                                      ])])
                                                              ])
                                                          ])])
                                                  ])
                                              ])
                                          ]),
                                        "@ @[<2>constraint %a =@ %a@]"
                                      ]), out_type[0], param[0], out_type[0], param[1]);
                      }), td[/* otype_cstrs */4]);
        };
        var type_defined = function (ppf) {
          var match = td[/* otype_params */1];
          if (match) {
            if (match[1]) {
              return Curry._3(Format.fprintf(ppf, /* Format */[
                              /* Formatting_gen */Block.__(18, [
                                  /* Open_box */Block.__(1, [/* Format */[
                                        /* End_of_format */0,
                                        ""
                                      ]]),
                                  /* Char_literal */Block.__(12, [
                                      /* "(" */40,
                                      /* Formatting_gen */Block.__(18, [
                                          /* Open_box */Block.__(1, [/* Format */[
                                                /* End_of_format */0,
                                                ""
                                              ]]),
                                          /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                                  /* ")" */41,
                                                  /* Formatting_lit */Block.__(17, [
                                                      /* Close_box */0,
                                                      /* Formatting_lit */Block.__(17, [
                                                          /* Break */Block.__(0, [
                                                              "@ ",
                                                              1,
                                                              0
                                                            ]),
                                                          /* String */Block.__(2, [
                                                              /* No_padding */0,
                                                              /* Formatting_lit */Block.__(17, [
                                                                  /* Close_box */0,
                                                                  /* End_of_format */0
                                                                ])
                                                            ])
                                                        ])
                                                    ])
                                                ])])
                                        ])
                                    ])
                                ]),
                              "@[(@[%a)@]@ %s@]"
                            ]), (function (param, param$1) {
                            return print_list(type_parameter, (function (ppf) {
                                          return Format.fprintf(ppf, /* Format */[
                                                      /* Char_literal */Block.__(12, [
                                                          /* "," */44,
                                                          /* Formatting_lit */Block.__(17, [
                                                              /* Break */Block.__(0, [
                                                                  "@ ",
                                                                  1,
                                                                  0
                                                                ]),
                                                              /* End_of_format */0
                                                            ])
                                                        ]),
                                                      ",@ "
                                                    ]);
                                        }), param, param$1);
                          }), td[/* otype_params */1], td[/* otype_name */0]);
            } else {
              return Curry._3(Format.fprintf(ppf, /* Format */[
                              /* Formatting_gen */Block.__(18, [
                                  /* Open_box */Block.__(1, [/* Format */[
                                        /* End_of_format */0,
                                        ""
                                      ]]),
                                  /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                          /* Break */Block.__(0, [
                                              "@ ",
                                              1,
                                              0
                                            ]),
                                          /* String */Block.__(2, [
                                              /* No_padding */0,
                                              /* Formatting_lit */Block.__(17, [
                                                  /* Close_box */0,
                                                  /* End_of_format */0
                                                ])
                                            ])
                                        ])])
                                ]),
                              "@[%a@ %s@]"
                            ]), type_parameter, match[0], td[/* otype_name */0]);
            }
          } else {
            return Format.pp_print_string(ppf, td[/* otype_name */0]);
          }
        };
        var print_manifest = function (ppf, param) {
          if (typeof param === "number" || param.tag !== 4) {
            return /* () */0;
          } else {
            return Curry._2(Format.fprintf(ppf, /* Format */[
                            /* String_literal */Block.__(11, [
                                " =",
                                /* Formatting_lit */Block.__(17, [
                                    /* Break */Block.__(0, [
                                        "@ ",
                                        1,
                                        0
                                      ]),
                                    /* Alpha */Block.__(15, [/* End_of_format */0])
                                  ])
                              ]),
                            " =@ %a"
                          ]), out_type[0], param[0]);
          }
        };
        var print_name_params = function (ppf) {
          return Curry._4(Format.fprintf(ppf, /* Format */[
                          /* String */Block.__(2, [
                              /* No_padding */0,
                              /* Char_literal */Block.__(12, [
                                  /* " " */32,
                                  /* Theta */Block.__(16, [/* Alpha */Block.__(15, [/* End_of_format */0])])
                                ])
                            ]),
                          "%s %t%a"
                        ]), kwd, type_defined, print_manifest, td[/* otype_type */2]);
        };
        var match = td[/* otype_type */2];
        var ty;
        ty = typeof match === "number" || match.tag !== 4 ? td[/* otype_type */2] : match[1];
        var print_private = function (ppf, param) {
          if (param !== 0) {
            return /* () */0;
          } else {
            return Format.fprintf(ppf, /* Format */[
                        /* String_literal */Block.__(11, [
                            " private",
                            /* End_of_format */0
                          ]),
                        " private"
                      ]);
          }
        };
        var print_out_tkind = function (ppf, ty) {
          if (typeof ty === "number") {
            switch (ty) {
              case 0 : 
                  return /* () */0;
              case 1 : 
                  return Format.fprintf(ppf, /* Format */[
                              /* String_literal */Block.__(11, [
                                  " = ..",
                                  /* End_of_format */0
                                ]),
                              " = .."
                            ]);
              default:
                return Curry._4(Format.fprintf(ppf, /* Format */[
                                /* String_literal */Block.__(11, [
                                    " =",
                                    /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                            /* Break */Block.__(0, [
                                                "@;<1 2>",
                                                1,
                                                2
                                              ]),
                                            /* Alpha */Block.__(15, [/* End_of_format */0])
                                          ])])
                                  ]),
                                " =%a@;<1 2>%a"
                              ]), print_private, td[/* otype_private */3], out_type[0], ty);
            }
          } else {
            switch (ty.tag | 0) {
              case 6 : 
                  return Curry._4(Format.fprintf(ppf, /* Format */[
                                  /* String_literal */Block.__(11, [
                                      " =",
                                      /* Alpha */Block.__(15, [/* String_literal */Block.__(11, [
                                              " {",
                                              /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                      /* Break */Block.__(0, [
                                                          "@;<1 -2>",
                                                          1,
                                                          -2
                                                        ]),
                                                      /* Char_literal */Block.__(12, [
                                                          /* "}" */125,
                                                          /* End_of_format */0
                                                        ])
                                                    ])])
                                            ])])
                                    ]),
                                  " =%a {%a@;<1 -2>}"
                                ]), print_private, td[/* otype_private */3], (function (param, param$1) {
                                var pr = print_out_label;
                                var sep = function (ppf) {
                                  return Format.fprintf(ppf, /* Format */[
                                              /* Formatting_lit */Block.__(17, [
                                                  /* Break */Block.__(0, [
                                                      "@ ",
                                                      1,
                                                      0
                                                    ]),
                                                  /* End_of_format */0
                                                ]),
                                              "@ "
                                            ]);
                                };
                                var ppf = param;
                                var _param = param$1;
                                while(true) {
                                  var param$2 = _param;
                                  if (param$2) {
                                    Curry._1(sep, ppf);
                                    Curry._2(pr, ppf, param$2[0]);
                                    _param = param$2[1];
                                    continue ;
                                    
                                  } else {
                                    return /* () */0;
                                  }
                                };
                              }), ty[0]);
              case 8 : 
                  return Curry._4(Format.fprintf(ppf, /* Format */[
                                  /* String_literal */Block.__(11, [
                                      " =",
                                      /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                              /* Break */Block.__(0, [
                                                  "@;<1 2>",
                                                  1,
                                                  2
                                                ]),
                                              /* Alpha */Block.__(15, [/* End_of_format */0])
                                            ])])
                                    ]),
                                  " =%a@;<1 2>%a"
                                ]), print_private, td[/* otype_private */3], (function (param, param$1) {
                                return print_list(print_out_constr, (function (ppf) {
                                              return Format.fprintf(ppf, /* Format */[
                                                          /* Formatting_lit */Block.__(17, [
                                                              /* Break */Block.__(0, [
                                                                  "@ ",
                                                                  1,
                                                                  0
                                                                ]),
                                                              /* String_literal */Block.__(11, [
                                                                  "| ",
                                                                  /* End_of_format */0
                                                                ])
                                                            ]),
                                                          "@ | "
                                                        ]);
                                            }), param, param$1);
                              }), ty[0]);
              default:
                return Curry._4(Format.fprintf(ppf, /* Format */[
                                /* String_literal */Block.__(11, [
                                    " =",
                                    /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                            /* Break */Block.__(0, [
                                                "@;<1 2>",
                                                1,
                                                2
                                              ]),
                                            /* Alpha */Block.__(15, [/* End_of_format */0])
                                          ])])
                                  ]),
                                " =%a@;<1 2>%a"
                              ]), print_private, td[/* otype_private */3], out_type[0], ty);
            }
          }
        };
        return Curry._4(Format.fprintf(ppf$2, /* Format */[
                        /* Formatting_gen */Block.__(18, [
                            /* Open_box */Block.__(1, [/* Format */[
                                  /* String_literal */Block.__(11, [
                                      "<2>",
                                      /* End_of_format */0
                                    ]),
                                  "<2>"
                                ]]),
                            /* Formatting_gen */Block.__(18, [
                                /* Open_box */Block.__(1, [/* Format */[
                                      /* String_literal */Block.__(11, [
                                          "<hv 2>",
                                          /* End_of_format */0
                                        ]),
                                      "<hv 2>"
                                    ]]),
                                /* Theta */Block.__(16, [/* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                            /* Close_box */0,
                                            /* Theta */Block.__(16, [/* Formatting_lit */Block.__(17, [
                                                    /* Close_box */0,
                                                    /* End_of_format */0
                                                  ])])
                                          ])])])
                              ])
                          ]),
                        "@[<2>@[<hv 2>%t%a@]%t@]"
                      ]), print_name_params, print_out_tkind, ty, print_constraints);
    case 6 : 
        var prims = param[2];
        var kwd$1 = prims ? "external" : "val";
        var pr_prims = function (ppf, param) {
          if (param) {
            Curry._1(Format.fprintf(ppf, /* Format */[
                      /* Formatting_lit */Block.__(17, [
                          /* Break */Block.__(0, [
                              "@ ",
                              1,
                              0
                            ]),
                          /* String_literal */Block.__(11, [
                              "= \"",
                              /* String */Block.__(2, [
                                  /* No_padding */0,
                                  /* Char_literal */Block.__(12, [
                                      /* "\"" */34,
                                      /* End_of_format */0
                                    ])
                                ])
                            ])
                        ]),
                      "@ = \"%s\""
                    ]), param[0]);
            return List.iter((function (s) {
                          var len = s.length;
                          if (len >= 3 && Caml_string.get(s, 0) === /* "B" */66 && Caml_string.get(s, 1) === /* "S" */83 && Caml_string.get(s, 2) === /* ":" */58) {
                            return Format.fprintf(ppf, /* Format */[
                                        /* Formatting_lit */Block.__(17, [
                                            /* Break */Block.__(0, [
                                                "@ ",
                                                1,
                                                0
                                              ]),
                                            /* String_literal */Block.__(11, [
                                                "\"BS-EXTERNAL\"",
                                                /* End_of_format */0
                                              ])
                                          ]),
                                        "@ \"BS-EXTERNAL\""
                                      ]);
                          } else {
                            return Curry._1(Format.fprintf(ppf, /* Format */[
                                            /* Formatting_lit */Block.__(17, [
                                                /* Break */Block.__(0, [
                                                    "@ ",
                                                    1,
                                                    0
                                                  ]),
                                                /* Char_literal */Block.__(12, [
                                                    /* "\"" */34,
                                                    /* String */Block.__(2, [
                                                        /* No_padding */0,
                                                        /* Char_literal */Block.__(12, [
                                                            /* "\"" */34,
                                                            /* End_of_format */0
                                                          ])
                                                      ])
                                                  ])
                                              ]),
                                            "@ \"%s\""
                                          ]), s);
                          }
                        }), param[1]);
          } else {
            return /* () */0;
          }
        };
        return Curry._7(Format.fprintf(ppf, /* Format */[
                        /* Formatting_gen */Block.__(18, [
                            /* Open_box */Block.__(1, [/* Format */[
                                  /* String_literal */Block.__(11, [
                                      "<2>",
                                      /* End_of_format */0
                                    ]),
                                  "<2>"
                                ]]),
                            /* String */Block.__(2, [
                                /* No_padding */0,
                                /* Char_literal */Block.__(12, [
                                    /* " " */32,
                                    /* Alpha */Block.__(15, [/* String_literal */Block.__(11, [
                                            " :",
                                            /* Formatting_lit */Block.__(17, [
                                                /* Break */Block.__(0, [
                                                    "@ ",
                                                    1,
                                                    0
                                                  ]),
                                                /* Alpha */Block.__(15, [/* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                            /* Close_box */0,
                                                            /* End_of_format */0
                                                          ])])])
                                              ])
                                          ])])
                                  ])
                              ])
                          ]),
                        "@[<2>%s %a :@ %a%a@]"
                      ]), kwd$1, value_ident, param[0], out_type[0], param[1], pr_prims, prims);
    
  }
}

function print_out_type_extension(ppf, te) {
  var print_extended_type = function (ppf) {
    var print_type_parameter = function (ppf, ty) {
      return Curry._1(Format.fprintf(ppf, /* Format */[
                      /* String */Block.__(2, [
                          /* No_padding */0,
                          /* End_of_format */0
                        ]),
                      "%s"
                    ]), ty === "_" ? ty : "'" + ty);
    };
    var match = te[/* otyext_params */1];
    if (match) {
      if (match[1]) {
        return Curry._3(Format.fprintf(ppf, /* Format */[
                        /* Formatting_gen */Block.__(18, [
                            /* Open_box */Block.__(1, [/* Format */[
                                  /* End_of_format */0,
                                  ""
                                ]]),
                            /* Char_literal */Block.__(12, [
                                /* "(" */40,
                                /* Formatting_gen */Block.__(18, [
                                    /* Open_box */Block.__(1, [/* Format */[
                                          /* End_of_format */0,
                                          ""
                                        ]]),
                                    /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                            /* ")" */41,
                                            /* Formatting_lit */Block.__(17, [
                                                /* Close_box */0,
                                                /* Formatting_lit */Block.__(17, [
                                                    /* Break */Block.__(0, [
                                                        "@ ",
                                                        1,
                                                        0
                                                      ]),
                                                    /* String */Block.__(2, [
                                                        /* No_padding */0,
                                                        /* Formatting_lit */Block.__(17, [
                                                            /* Close_box */0,
                                                            /* End_of_format */0
                                                          ])
                                                      ])
                                                  ])
                                              ])
                                          ])])
                                  ])
                              ])
                          ]),
                        "@[(@[%a)@]@ %s@]"
                      ]), (function (param, param$1) {
                      return print_list(print_type_parameter, (function (ppf) {
                                    return Format.fprintf(ppf, /* Format */[
                                                /* Char_literal */Block.__(12, [
                                                    /* "," */44,
                                                    /* Formatting_lit */Block.__(17, [
                                                        /* Break */Block.__(0, [
                                                            "@ ",
                                                            1,
                                                            0
                                                          ]),
                                                        /* End_of_format */0
                                                      ])
                                                  ]),
                                                ",@ "
                                              ]);
                                  }), param, param$1);
                    }), te[/* otyext_params */1], te[/* otyext_name */0]);
      } else {
        return Curry._3(Format.fprintf(ppf, /* Format */[
                        /* Formatting_gen */Block.__(18, [
                            /* Open_box */Block.__(1, [/* Format */[
                                  /* End_of_format */0,
                                  ""
                                ]]),
                            /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                    /* Break */Block.__(0, [
                                        "@ ",
                                        1,
                                        0
                                      ]),
                                    /* String */Block.__(2, [
                                        /* No_padding */0,
                                        /* Formatting_lit */Block.__(17, [
                                            /* Close_box */0,
                                            /* End_of_format */0
                                          ])
                                      ])
                                  ])])
                          ]),
                        "@[%a@ %s@]"
                      ]), print_type_parameter, match[0], te[/* otyext_name */0]);
      }
    } else {
      return Curry._1(Format.fprintf(ppf, /* Format */[
                      /* String */Block.__(2, [
                          /* No_padding */0,
                          /* End_of_format */0
                        ]),
                      "%s"
                    ]), te[/* otyext_name */0]);
    }
  };
  return Curry._4(Format.fprintf(ppf, /* Format */[
                  /* Formatting_gen */Block.__(18, [
                      /* Open_box */Block.__(1, [/* Format */[
                            /* String_literal */Block.__(11, [
                                "<hv 2>",
                                /* End_of_format */0
                              ]),
                            "<hv 2>"
                          ]]),
                      /* String_literal */Block.__(11, [
                          "type ",
                          /* Theta */Block.__(16, [/* String_literal */Block.__(11, [
                                  " +=",
                                  /* String */Block.__(2, [
                                      /* No_padding */0,
                                      /* Formatting_lit */Block.__(17, [
                                          /* Break */Block.__(0, [
                                              "@;<1 2>",
                                              1,
                                              2
                                            ]),
                                          /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                  /* Close_box */0,
                                                  /* End_of_format */0
                                                ])])
                                        ])
                                    ])
                                ])])
                        ])
                    ]),
                  "@[<hv 2>type %t +=%s@;<1 2>%a@]"
                ]), print_extended_type, te[/* otyext_private */3] ? "" : " private", (function (param, param$1) {
                return print_list(print_out_constr, (function (ppf) {
                              return Format.fprintf(ppf, /* Format */[
                                          /* Formatting_lit */Block.__(17, [
                                              /* Break */Block.__(0, [
                                                  "@ ",
                                                  1,
                                                  0
                                                ]),
                                              /* String_literal */Block.__(11, [
                                                  "| ",
                                                  /* End_of_format */0
                                                ])
                                            ]),
                                          "@ | "
                                        ]);
                            }), param, param$1);
              }), te[/* otyext_constructors */2]);
}

out_module_type[0] = print_out_module_type;

out_signature[0] = print_out_signature;

out_sig_item[0] = print_out_sig_item;

out_type_extension[0] = print_out_type_extension;

function longident(ppf, param) {
  switch (param.tag | 0) {
    case 0 : 
        return Format.pp_print_string(ppf, param[0]);
    case 1 : 
        return Curry._3(Format.fprintf(ppf, /* Format */[
                        /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                /* "." */46,
                                /* String */Block.__(2, [
                                    /* No_padding */0,
                                    /* End_of_format */0
                                  ])
                              ])]),
                        "%a.%s"
                      ]), longident, param[0], param[1]);
    case 2 : 
        return Curry._4(Format.fprintf(ppf, /* Format */[
                        /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                /* "(" */40,
                                /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                        /* ")" */41,
                                        /* End_of_format */0
                                      ])])
                              ])]),
                        "%a(%a)"
                      ]), longident, param[0], longident, param[1]);
    
  }
}

var unique_names = [/* Empty */0];

function ident_name(id) {
  try {
    return find_same(id, unique_names[0]);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return id[/* name */1];
    } else {
      throw exn;
    }
  }
}

function add_unique(id) {
  try {
    find_same(id, unique_names[0]);
    return /* () */0;
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      unique_names[0] = add(id, unique_toplevel_name(id), unique_names[0]);
      return /* () */0;
    } else {
      throw exn;
    }
  }
}

function ident$3(ppf, id) {
  return Format.pp_print_string(ppf, ident_name(id));
}

var ident_pervasive = /* record */[
  /* stamp */0,
  /* name */"Pervasives",
  /* flags */1
];

function tree_of_path(param) {
  switch (param.tag | 0) {
    case 0 : 
        return /* Oide_ident */Block.__(2, [ident_name(param[0])]);
    case 1 : 
        var p = param[0];
        var exit = 0;
        switch (p.tag | 0) {
          case 0 : 
              if (Caml_obj.caml_equal(p[0], ident_pervasive)) {
                return /* Oide_ident */Block.__(2, [param[1]]);
              } else {
                exit = 1;
              }
              break;
          case 1 : 
          case 2 : 
              exit = 1;
              break;
          
        }
        if (exit === 1) {
          return /* Oide_dot */Block.__(1, [
                    tree_of_path(p),
                    param[1]
                  ]);
        }
        break;
    case 2 : 
        return /* Oide_apply */Block.__(0, [
                  tree_of_path(param[0]),
                  tree_of_path(param[1])
                ]);
    
  }
}

function path(ppf, param) {
  switch (param.tag | 0) {
    case 0 : 
        return Format.pp_print_string(ppf, ident_name(param[0]));
    case 1 : 
        var p = param[0];
        var exit = 0;
        switch (p.tag | 0) {
          case 0 : 
              if (Caml_obj.caml_equal(p[0], ident_pervasive)) {
                return Format.pp_print_string(ppf, param[1]);
              } else {
                exit = 1;
              }
              break;
          case 1 : 
          case 2 : 
              exit = 1;
              break;
          
        }
        if (exit === 1) {
          path(ppf, p);
          Format.pp_print_char(ppf, /* "." */46);
          return Format.pp_print_string(ppf, param[1]);
        }
        break;
    case 2 : 
        return Curry._4(Format.fprintf(ppf, /* Format */[
                        /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                /* "(" */40,
                                /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                        /* ")" */41,
                                        /* End_of_format */0
                                      ])])
                              ])]),
                        "%a(%a)"
                      ]), path, param[0], path, param[1]);
    
  }
}

function string_of_out_ident(param) {
  switch (param.tag | 0) {
    case 0 : 
        return $$String.concat("", /* :: */[
                    string_of_out_ident(param[0]),
                    /* :: */[
                      "(",
                      /* :: */[
                        string_of_out_ident(param[1]),
                        /* :: */[
                          ")",
                          /* [] */0
                        ]
                      ]
                    ]
                  ]);
    case 1 : 
        return $$String.concat(".", /* :: */[
                    string_of_out_ident(param[0]),
                    /* :: */[
                      param[1],
                      /* [] */0
                    ]
                  ]);
    case 2 : 
        return param[0];
    
  }
}

function string_of_path(p) {
  return string_of_out_ident(tree_of_path(p));
}

function tree_of_rec(param) {
  switch (param) {
    case 0 : 
        return /* Orec_not */0;
    case 1 : 
        return /* Orec_first */1;
    case 2 : 
        return /* Orec_next */2;
    
  }
}

function raw_list(pr, ppf, param) {
  if (param) {
    var l = param[1];
    return Curry._3(Format.fprintf(ppf, /* Format */[
                    /* Formatting_gen */Block.__(18, [
                        /* Open_box */Block.__(1, [/* Format */[
                              /* String_literal */Block.__(11, [
                                  "<1>",
                                  /* End_of_format */0
                                ]),
                              "<1>"
                            ]]),
                        /* Char_literal */Block.__(12, [
                            /* "[" */91,
                            /* Alpha */Block.__(15, [/* Theta */Block.__(16, [/* Char_literal */Block.__(12, [
                                        /* "]" */93,
                                        /* Formatting_lit */Block.__(17, [
                                            /* Close_box */0,
                                            /* End_of_format */0
                                          ])
                                      ])])])
                          ])
                      ]),
                    "@[<1>[%a%t]@]"
                  ]), pr, param[0], (function (ppf) {
                  return List.iter((function (x) {
                                return Curry._2(Format.fprintf(ppf, /* Format */[
                                                /* Char_literal */Block.__(12, [
                                                    /* ";" */59,
                                                    /* Formatting_lit */Block.__(17, [
                                                        /* Break */Block.__(0, [
                                                            "@,",
                                                            0,
                                                            0
                                                          ]),
                                                        /* Alpha */Block.__(15, [/* End_of_format */0])
                                                      ])
                                                  ]),
                                                ";@,%a"
                                              ]), pr, x);
                              }), l);
                }));
  } else {
    return Format.fprintf(ppf, /* Format */[
                /* String_literal */Block.__(11, [
                    "[]",
                    /* End_of_format */0
                  ]),
                "[]"
              ]);
  }
}

function safe_kind_repr(_v, _param) {
  while(true) {
    var param = _param;
    var v = _v;
    if (typeof param === "number") {
      if (param !== 0) {
        return "Fabsent";
      } else {
        return "Fpresent";
      }
    } else {
      var match = param[0][/* contents */0];
      if (match) {
        var k = match[0];
        if (List.memq(k, v)) {
          return "Fvar loop";
        } else {
          _param = k;
          _v = /* :: */[
            k,
            v
          ];
          continue ;
          
        }
      } else {
        return "Fvar None";
      }
    }
  };
}

function safe_commu_repr(_v, _param) {
  while(true) {
    var param = _param;
    var v = _v;
    if (typeof param === "number") {
      if (param !== 0) {
        return "Cunknown";
      } else {
        return "Cok";
      }
    } else {
      var r = param[0];
      if (List.memq(r, v)) {
        return "Clink loop";
      } else {
        _param = r[0];
        _v = /* :: */[
          r,
          v
        ];
        continue ;
        
      }
    }
  };
}

function safe_repr(_v, _t) {
  while(true) {
    var t = _t;
    var v = _v;
    var match = t[/* desc */0];
    if (typeof match === "number") {
      return t;
    } else if (match.tag === 6) {
      var t$1 = match[0];
      if (List.memq(t$1, v)) {
        return t;
      } else {
        _t = t$1;
        _v = /* :: */[
          t$1,
          v
        ];
        continue ;
        
      }
    } else {
      return t;
    }
  };
}

function list_of_memo(_param) {
  while(true) {
    var param = _param;
    if (typeof param === "number") {
      return /* [] */0;
    } else if (param.tag) {
      _param = param[0][0];
      continue ;
      
    } else {
      return /* :: */[
              param[1],
              list_of_memo(param[4])
            ];
    }
  };
}

function print_name(ppf, param) {
  if (param) {
    return Curry._1(Format.fprintf(ppf, /* Format */[
                    /* Char_literal */Block.__(12, [
                        /* "\"" */34,
                        /* String */Block.__(2, [
                            /* No_padding */0,
                            /* Char_literal */Block.__(12, [
                                /* "\"" */34,
                                /* End_of_format */0
                              ])
                          ])
                      ]),
                    "\"%s\""
                  ]), param[0]);
  } else {
    return Format.fprintf(ppf, /* Format */[
                /* String_literal */Block.__(11, [
                    "None",
                    /* End_of_format */0
                  ]),
                "None"
              ]);
  }
}

var visited = [/* [] */0];

function raw_type(ppf, ty) {
  var ty$1 = safe_repr(/* [] */0, ty);
  if (List.memq(ty$1, visited[0])) {
    return Curry._1(Format.fprintf(ppf, /* Format */[
                    /* String_literal */Block.__(11, [
                        "{id=",
                        /* Int */Block.__(4, [
                            /* Int_d */0,
                            /* No_padding */0,
                            /* No_precision */0,
                            /* Char_literal */Block.__(12, [
                                /* "}" */125,
                                /* End_of_format */0
                              ])
                          ])
                      ]),
                    "{id=%d}"
                  ]), ty$1[/* id */2]);
  } else {
    visited[0] = /* :: */[
      ty$1,
      visited[0]
    ];
    return Curry._4(Format.fprintf(ppf, /* Format */[
                    /* Formatting_gen */Block.__(18, [
                        /* Open_box */Block.__(1, [/* Format */[
                              /* String_literal */Block.__(11, [
                                  "<1>",
                                  /* End_of_format */0
                                ]),
                              "<1>"
                            ]]),
                        /* String_literal */Block.__(11, [
                            "{id=",
                            /* Int */Block.__(4, [
                                /* Int_d */0,
                                /* No_padding */0,
                                /* No_precision */0,
                                /* String_literal */Block.__(11, [
                                    ";level=",
                                    /* Int */Block.__(4, [
                                        /* Int_d */0,
                                        /* No_padding */0,
                                        /* No_precision */0,
                                        /* String_literal */Block.__(11, [
                                            ";desc=",
                                            /* Formatting_lit */Block.__(17, [
                                                /* Break */Block.__(0, [
                                                    "@,",
                                                    0,
                                                    0
                                                  ]),
                                                /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                                        /* "}" */125,
                                                        /* Formatting_lit */Block.__(17, [
                                                            /* Close_box */0,
                                                            /* End_of_format */0
                                                          ])
                                                      ])])
                                              ])
                                          ])
                                      ])
                                  ])
                              ])
                          ])
                      ]),
                    "@[<1>{id=%d;level=%d;desc=@,%a}@]"
                  ]), ty$1[/* id */2], ty$1[/* level */1], raw_type_desc, ty$1[/* desc */0]);
  }
}

function raw_type_list(tl) {
  return (function (param) {
      return raw_list(raw_type, tl, param);
    });
}

function raw_type_desc(ppf, param) {
  if (typeof param === "number") {
    return Format.fprintf(ppf, /* Format */[
                /* String_literal */Block.__(11, [
                    "Tnil",
                    /* End_of_format */0
                  ]),
                "Tnil"
              ]);
  } else {
    switch (param.tag | 0) {
      case 0 : 
          return Curry._2(Format.fprintf(ppf, /* Format */[
                          /* String_literal */Block.__(11, [
                              "Tvar ",
                              /* Alpha */Block.__(15, [/* End_of_format */0])
                            ]),
                          "Tvar %a"
                        ]), print_name, param[0]);
      case 1 : 
          return Curry._6(Format.fprintf(ppf, /* Format */[
                          /* Formatting_gen */Block.__(18, [
                              /* Open_box */Block.__(1, [/* Format */[
                                    /* String_literal */Block.__(11, [
                                        "<hov1>",
                                        /* End_of_format */0
                                      ]),
                                    "<hov1>"
                                  ]]),
                              /* String_literal */Block.__(11, [
                                  "Tarrow(",
                                  /* String */Block.__(2, [
                                      /* No_padding */0,
                                      /* Char_literal */Block.__(12, [
                                          /* "," */44,
                                          /* Formatting_lit */Block.__(17, [
                                              /* Break */Block.__(0, [
                                                  "@,",
                                                  0,
                                                  0
                                                ]),
                                              /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                                      /* "," */44,
                                                      /* Formatting_lit */Block.__(17, [
                                                          /* Break */Block.__(0, [
                                                              "@,",
                                                              0,
                                                              0
                                                            ]),
                                                          /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                                                  /* "," */44,
                                                                  /* Formatting_lit */Block.__(17, [
                                                                      /* Break */Block.__(0, [
                                                                          "@,",
                                                                          0,
                                                                          0
                                                                        ]),
                                                                      /* String */Block.__(2, [
                                                                          /* No_padding */0,
                                                                          /* Char_literal */Block.__(12, [
                                                                              /* ")" */41,
                                                                              /* Formatting_lit */Block.__(17, [
                                                                                  /* Close_box */0,
                                                                                  /* End_of_format */0
                                                                                ])
                                                                            ])
                                                                        ])
                                                                    ])
                                                                ])])
                                                        ])
                                                    ])])
                                            ])
                                        ])
                                    ])
                                ])
                            ]),
                          "@[<hov1>Tarrow(%s,@,%a,@,%a,@,%s)@]"
                        ]), param[0], raw_type, param[1], raw_type, param[2], safe_commu_repr(/* [] */0, param[3]));
      case 2 : 
          return Curry._2(Format.fprintf(ppf, /* Format */[
                          /* Formatting_gen */Block.__(18, [
                              /* Open_box */Block.__(1, [/* Format */[
                                    /* String_literal */Block.__(11, [
                                        "<1>",
                                        /* End_of_format */0
                                      ]),
                                    "<1>"
                                  ]]),
                              /* String_literal */Block.__(11, [
                                  "Ttuple",
                                  /* Formatting_lit */Block.__(17, [
                                      /* Break */Block.__(0, [
                                          "@,",
                                          0,
                                          0
                                        ]),
                                      /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                              /* Close_box */0,
                                              /* End_of_format */0
                                            ])])
                                    ])
                                ])
                            ]),
                          "@[<1>Ttuple@,%a@]"
                        ]), raw_type_list, param[0]);
      case 3 : 
          return Curry._6(Format.fprintf(ppf, /* Format */[
                          /* Formatting_gen */Block.__(18, [
                              /* Open_box */Block.__(1, [/* Format */[
                                    /* String_literal */Block.__(11, [
                                        "<hov1>",
                                        /* End_of_format */0
                                      ]),
                                    "<hov1>"
                                  ]]),
                              /* String_literal */Block.__(11, [
                                  "Tconstr(",
                                  /* Formatting_lit */Block.__(17, [
                                      /* Break */Block.__(0, [
                                          "@,",
                                          0,
                                          0
                                        ]),
                                      /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                              /* "," */44,
                                              /* Formatting_lit */Block.__(17, [
                                                  /* Break */Block.__(0, [
                                                      "@,",
                                                      0,
                                                      0
                                                    ]),
                                                  /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                                          /* "," */44,
                                                          /* Formatting_lit */Block.__(17, [
                                                              /* Break */Block.__(0, [
                                                                  "@,",
                                                                  0,
                                                                  0
                                                                ]),
                                                              /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                                                      /* ")" */41,
                                                                      /* Formatting_lit */Block.__(17, [
                                                                          /* Close_box */0,
                                                                          /* End_of_format */0
                                                                        ])
                                                                    ])])
                                                            ])
                                                        ])])
                                                ])
                                            ])])
                                    ])
                                ])
                            ]),
                          "@[<hov1>Tconstr(@,%a,@,%a,@,%a)@]"
                        ]), path, param[0], raw_type_list, param[1], (function (param, param$1) {
                        return raw_list(path, param, param$1);
                      }), list_of_memo(param[2][0]));
      case 4 : 
          var nm = param[1];
          return Curry._3(Format.fprintf(ppf, /* Format */[
                          /* Formatting_gen */Block.__(18, [
                              /* Open_box */Block.__(1, [/* Format */[
                                    /* String_literal */Block.__(11, [
                                        "<hov1>",
                                        /* End_of_format */0
                                      ]),
                                    "<hov1>"
                                  ]]),
                              /* String_literal */Block.__(11, [
                                  "Tobject(",
                                  /* Formatting_lit */Block.__(17, [
                                      /* Break */Block.__(0, [
                                          "@,",
                                          0,
                                          0
                                        ]),
                                      /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                              /* "," */44,
                                              /* Formatting_lit */Block.__(17, [
                                                  /* Break */Block.__(0, [
                                                      "@,",
                                                      0,
                                                      0
                                                    ]),
                                                  /* Formatting_gen */Block.__(18, [
                                                      /* Open_box */Block.__(1, [/* Format */[
                                                            /* String_literal */Block.__(11, [
                                                                "<1>",
                                                                /* End_of_format */0
                                                              ]),
                                                            "<1>"
                                                          ]]),
                                                      /* String_literal */Block.__(11, [
                                                          "ref",
                                                          /* Theta */Block.__(16, [/* Formatting_lit */Block.__(17, [
                                                                  /* Close_box */0,
                                                                  /* Char_literal */Block.__(12, [
                                                                      /* ")" */41,
                                                                      /* Formatting_lit */Block.__(17, [
                                                                          /* Close_box */0,
                                                                          /* End_of_format */0
                                                                        ])
                                                                    ])
                                                                ])])
                                                        ])
                                                    ])
                                                ])
                                            ])])
                                    ])
                                ])
                            ]),
                          "@[<hov1>Tobject(@,%a,@,@[<1>ref%t@])@]"
                        ]), raw_type, param[0], (function (ppf) {
                        var match = nm[0];
                        if (match) {
                          var match$1 = match[0];
                          return Curry._4(Format.fprintf(ppf, /* Format */[
                                          /* String_literal */Block.__(11, [
                                              "(Some(",
                                              /* Formatting_lit */Block.__(17, [
                                                  /* Break */Block.__(0, [
                                                      "@,",
                                                      0,
                                                      0
                                                    ]),
                                                  /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                                          /* "," */44,
                                                          /* Formatting_lit */Block.__(17, [
                                                              /* Break */Block.__(0, [
                                                                  "@,",
                                                                  0,
                                                                  0
                                                                ]),
                                                              /* Alpha */Block.__(15, [/* String_literal */Block.__(11, [
                                                                      "))",
                                                                      /* End_of_format */0
                                                                    ])])
                                                            ])
                                                        ])])
                                                ])
                                            ]),
                                          "(Some(@,%a,@,%a))"
                                        ]), path, match$1[0], raw_type_list, match$1[1]);
                        } else {
                          return Format.fprintf(ppf, /* Format */[
                                      /* String_literal */Block.__(11, [
                                          " None",
                                          /* End_of_format */0
                                        ]),
                                      " None"
                                    ]);
                        }
                      }));
      case 5 : 
          return Curry._6(Format.fprintf(ppf, /* Format */[
                          /* Formatting_gen */Block.__(18, [
                              /* Open_box */Block.__(1, [/* Format */[
                                    /* String_literal */Block.__(11, [
                                        "<hov1>",
                                        /* End_of_format */0
                                      ]),
                                    "<hov1>"
                                  ]]),
                              /* String_literal */Block.__(11, [
                                  "Tfield(",
                                  /* Formatting_lit */Block.__(17, [
                                      /* Break */Block.__(0, [
                                          "@,",
                                          0,
                                          0
                                        ]),
                                      /* String */Block.__(2, [
                                          /* No_padding */0,
                                          /* Char_literal */Block.__(12, [
                                              /* "," */44,
                                              /* Formatting_lit */Block.__(17, [
                                                  /* Break */Block.__(0, [
                                                      "@,",
                                                      0,
                                                      0
                                                    ]),
                                                  /* String */Block.__(2, [
                                                      /* No_padding */0,
                                                      /* Char_literal */Block.__(12, [
                                                          /* "," */44,
                                                          /* Formatting_lit */Block.__(17, [
                                                              /* Break */Block.__(0, [
                                                                  "@,",
                                                                  0,
                                                                  0
                                                                ]),
                                                              /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                                                      /* "," */44,
                                                                      /* Formatting_lit */Block.__(17, [
                                                                          /* Break */Block.__(0, [
                                                                              "@;<0 -1>",
                                                                              0,
                                                                              -1
                                                                            ]),
                                                                          /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                                                                  /* ")" */41,
                                                                                  /* Formatting_lit */Block.__(17, [
                                                                                      /* Close_box */0,
                                                                                      /* End_of_format */0
                                                                                    ])
                                                                                ])])
                                                                        ])
                                                                    ])])
                                                            ])
                                                        ])
                                                    ])
                                                ])
                                            ])
                                        ])
                                    ])
                                ])
                            ]),
                          "@[<hov1>Tfield(@,%s,@,%s,@,%a,@;<0 -1>%a)@]"
                        ]), param[0], safe_kind_repr(/* [] */0, param[1]), raw_type, param[2], raw_type, param[3]);
      case 6 : 
          return Curry._2(Format.fprintf(ppf, /* Format */[
                          /* Formatting_gen */Block.__(18, [
                              /* Open_box */Block.__(1, [/* Format */[
                                    /* String_literal */Block.__(11, [
                                        "<1>",
                                        /* End_of_format */0
                                      ]),
                                    "<1>"
                                  ]]),
                              /* String_literal */Block.__(11, [
                                  "Tlink",
                                  /* Formatting_lit */Block.__(17, [
                                      /* Break */Block.__(0, [
                                          "@,",
                                          0,
                                          0
                                        ]),
                                      /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                              /* Close_box */0,
                                              /* End_of_format */0
                                            ])])
                                    ])
                                ])
                            ]),
                          "@[<1>Tlink@,%a@]"
                        ]), raw_type, param[0]);
      case 7 : 
          return Curry._2(Format.fprintf(ppf, /* Format */[
                          /* Formatting_gen */Block.__(18, [
                              /* Open_box */Block.__(1, [/* Format */[
                                    /* String_literal */Block.__(11, [
                                        "<1>",
                                        /* End_of_format */0
                                      ]),
                                    "<1>"
                                  ]]),
                              /* String_literal */Block.__(11, [
                                  "Tsubst",
                                  /* Formatting_lit */Block.__(17, [
                                      /* Break */Block.__(0, [
                                          "@,",
                                          0,
                                          0
                                        ]),
                                      /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                              /* Close_box */0,
                                              /* End_of_format */0
                                            ])])
                                    ])
                                ])
                            ]),
                          "@[<1>Tsubst@,%a@]"
                        ]), raw_type, param[0]);
      case 8 : 
          var row = param[0];
          return Curry.app(Format.fprintf(ppf, /* Format */[
                          /* Formatting_gen */Block.__(18, [
                              /* Open_box */Block.__(1, [/* Format */[
                                    /* String_literal */Block.__(11, [
                                        "<hov1>",
                                        /* End_of_format */0
                                      ]),
                                    "<hov1>"
                                  ]]),
                              /* Char_literal */Block.__(12, [
                                  /* "{" */123,
                                  /* Formatting_gen */Block.__(18, [
                                      /* Open_box */Block.__(1, [/* Format */[
                                            /* End_of_format */0,
                                            ""
                                          ]]),
                                      /* String */Block.__(2, [
                                          /* No_padding */0,
                                          /* Formatting_lit */Block.__(17, [
                                              /* Break */Block.__(0, [
                                                  "@,",
                                                  0,
                                                  0
                                                ]),
                                              /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                                      /* ";" */59,
                                                      /* Formatting_lit */Block.__(17, [
                                                          /* Close_box */0,
                                                          /* Formatting_lit */Block.__(17, [
                                                              /* Break */Block.__(0, [
                                                                  "@ ",
                                                                  1,
                                                                  0
                                                                ]),
                                                              /* Formatting_gen */Block.__(18, [
                                                                  /* Open_box */Block.__(1, [/* Format */[
                                                                        /* End_of_format */0,
                                                                        ""
                                                                      ]]),
                                                                  /* String */Block.__(2, [
                                                                      /* No_padding */0,
                                                                      /* Formatting_lit */Block.__(17, [
                                                                          /* Break */Block.__(0, [
                                                                              "@,",
                                                                              0,
                                                                              0
                                                                            ]),
                                                                          /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                                                                  /* ";" */59,
                                                                                  /* Formatting_lit */Block.__(17, [
                                                                                      /* Close_box */0,
                                                                                      /* Formatting_lit */Block.__(17, [
                                                                                          /* Break */Block.__(0, [
                                                                                              "@ ",
                                                                                              1,
                                                                                              0
                                                                                            ]),
                                                                                          /* String */Block.__(2, [
                                                                                              /* No_padding */0,
                                                                                              /* Bool */Block.__(9, [/* Char_literal */Block.__(12, [
                                                                                                      /* ";" */59,
                                                                                                      /* Formatting_lit */Block.__(17, [
                                                                                                          /* Break */Block.__(0, [
                                                                                                              "@ ",
                                                                                                              1,
                                                                                                              0
                                                                                                            ]),
                                                                                                          /* String */Block.__(2, [
                                                                                                              /* No_padding */0,
                                                                                                              /* Bool */Block.__(9, [/* Char_literal */Block.__(12, [
                                                                                                                      /* ";" */59,
                                                                                                                      /* Formatting_lit */Block.__(17, [
                                                                                                                          /* Break */Block.__(0, [
                                                                                                                              "@ ",
                                                                                                                              1,
                                                                                                                              0
                                                                                                                            ]),
                                                                                                                          /* Formatting_gen */Block.__(18, [
                                                                                                                              /* Open_box */Block.__(1, [/* Format */[
                                                                                                                                    /* String_literal */Block.__(11, [
                                                                                                                                        "<1>",
                                                                                                                                        /* End_of_format */0
                                                                                                                                      ]),
                                                                                                                                    "<1>"
                                                                                                                                  ]]),
                                                                                                                              /* String */Block.__(2, [
                                                                                                                                  /* No_padding */0,
                                                                                                                                  /* Theta */Block.__(16, [/* Formatting_lit */Block.__(17, [
                                                                                                                                          /* Close_box */0,
                                                                                                                                          /* Char_literal */Block.__(12, [
                                                                                                                                              /* "}" */125,
                                                                                                                                              /* Formatting_lit */Block.__(17, [
                                                                                                                                                  /* Close_box */0,
                                                                                                                                                  /* End_of_format */0
                                                                                                                                                ])
                                                                                                                                            ])
                                                                                                                                        ])])
                                                                                                                                ])
                                                                                                                            ])
                                                                                                                        ])
                                                                                                                    ])])
                                                                                                            ])
                                                                                                        ])
                                                                                                    ])])
                                                                                            ])
                                                                                        ])
                                                                                    ])
                                                                                ])])
                                                                        ])
                                                                    ])
                                                                ])
                                                            ])
                                                        ])
                                                    ])])
                                            ])
                                        ])
                                    ])
                                ])
                            ]),
                          "@[<hov1>{@[%s@,%a;@]@ @[%s@,%a;@]@ %s%b;@ %s%b;@ @[<1>%s%t@]}@]"
                        ]), [
                      "row_fields=",
                      (function (param, param$1) {
                          return raw_list((function (ppf, param) {
                                        return Curry._3(Format.fprintf(ppf, /* Format */[
                                                        /* Formatting_gen */Block.__(18, [
                                                            /* Open_box */Block.__(1, [/* Format */[
                                                                  /* End_of_format */0,
                                                                  ""
                                                                ]]),
                                                            /* String */Block.__(2, [
                                                                /* No_padding */0,
                                                                /* Char_literal */Block.__(12, [
                                                                    /* "," */44,
                                                                    /* Formatting_lit */Block.__(17, [
                                                                        /* Break */Block.__(0, [
                                                                            "@ ",
                                                                            1,
                                                                            0
                                                                          ]),
                                                                        /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                                /* Close_box */0,
                                                                                /* End_of_format */0
                                                                              ])])
                                                                      ])
                                                                  ])
                                                              ])
                                                          ]),
                                                        "@[%s,@ %a@]"
                                                      ]), param[0], raw_field, param[1]);
                                      }), param, param$1);
                        }),
                      row[/* row_fields */0],
                      "row_more=",
                      raw_type,
                      row[/* row_more */1],
                      "row_closed=",
                      row[/* row_closed */3],
                      "row_fixed=",
                      row[/* row_fixed */4],
                      "row_name=",
                      (function (ppf) {
                          var match = row[/* row_name */5];
                          if (match) {
                            var match$1 = match[0];
                            return Curry._4(Format.fprintf(ppf, /* Format */[
                                            /* String_literal */Block.__(11, [
                                                "Some(",
                                                /* Formatting_lit */Block.__(17, [
                                                    /* Break */Block.__(0, [
                                                        "@,",
                                                        0,
                                                        0
                                                      ]),
                                                    /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                                            /* "," */44,
                                                            /* Formatting_lit */Block.__(17, [
                                                                /* Break */Block.__(0, [
                                                                    "@,",
                                                                    0,
                                                                    0
                                                                  ]),
                                                                /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                                                        /* ")" */41,
                                                                        /* End_of_format */0
                                                                      ])])
                                                              ])
                                                          ])])
                                                  ])
                                              ]),
                                            "Some(@,%a,@,%a)"
                                          ]), path, match$1[0], raw_type_list, match$1[1]);
                          } else {
                            return Format.fprintf(ppf, /* Format */[
                                        /* String_literal */Block.__(11, [
                                            "None",
                                            /* End_of_format */0
                                          ]),
                                        "None"
                                      ]);
                          }
                        })
                    ]);
      case 9 : 
          return Curry._2(Format.fprintf(ppf, /* Format */[
                          /* String_literal */Block.__(11, [
                              "Tunivar ",
                              /* Alpha */Block.__(15, [/* End_of_format */0])
                            ]),
                          "Tunivar %a"
                        ]), print_name, param[0]);
      case 10 : 
          return Curry._4(Format.fprintf(ppf, /* Format */[
                          /* Formatting_gen */Block.__(18, [
                              /* Open_box */Block.__(1, [/* Format */[
                                    /* String_literal */Block.__(11, [
                                        "<hov1>",
                                        /* End_of_format */0
                                      ]),
                                    "<hov1>"
                                  ]]),
                              /* String_literal */Block.__(11, [
                                  "Tpoly(",
                                  /* Formatting_lit */Block.__(17, [
                                      /* Break */Block.__(0, [
                                          "@,",
                                          0,
                                          0
                                        ]),
                                      /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                              /* "," */44,
                                              /* Formatting_lit */Block.__(17, [
                                                  /* Break */Block.__(0, [
                                                      "@,",
                                                      0,
                                                      0
                                                    ]),
                                                  /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                                          /* ")" */41,
                                                          /* Formatting_lit */Block.__(17, [
                                                              /* Close_box */0,
                                                              /* End_of_format */0
                                                            ])
                                                        ])])
                                                ])
                                            ])])
                                    ])
                                ])
                            ]),
                          "@[<hov1>Tpoly(@,%a,@,%a)@]"
                        ]), raw_type, param[0], raw_type_list, param[1]);
      case 11 : 
          return Curry._4(Format.fprintf(ppf, /* Format */[
                          /* Formatting_gen */Block.__(18, [
                              /* Open_box */Block.__(1, [/* Format */[
                                    /* String_literal */Block.__(11, [
                                        "<hov1>",
                                        /* End_of_format */0
                                      ]),
                                    "<hov1>"
                                  ]]),
                              /* String_literal */Block.__(11, [
                                  "Tpackage(",
                                  /* Formatting_lit */Block.__(17, [
                                      /* Break */Block.__(0, [
                                          "@,",
                                          0,
                                          0
                                        ]),
                                      /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                              /* Break */Block.__(0, [
                                                  "@,",
                                                  0,
                                                  0
                                                ]),
                                              /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                                      /* ")" */41,
                                                      /* Formatting_lit */Block.__(17, [
                                                          /* Close_box */0,
                                                          /* End_of_format */0
                                                        ])
                                                    ])])
                                            ])])
                                    ])
                                ])
                            ]),
                          "@[<hov1>Tpackage(@,%a@,%a)@]"
                        ]), path, param[0], raw_type_list, param[2]);
      
    }
  }
}

function raw_field(ppf, param) {
  if (typeof param === "number") {
    return Format.fprintf(ppf, /* Format */[
                /* String_literal */Block.__(11, [
                    "Rabsent",
                    /* End_of_format */0
                  ]),
                "Rabsent"
              ]);
  } else if (param.tag) {
    var e = param[3];
    return Curry._5(Format.fprintf(ppf, /* Format */[
                    /* Formatting_gen */Block.__(18, [
                        /* Open_box */Block.__(1, [/* Format */[
                              /* String_literal */Block.__(11, [
                                  "<hov1>",
                                  /* End_of_format */0
                                ]),
                              "<hov1>"
                            ]]),
                        /* String_literal */Block.__(11, [
                            "Reither(",
                            /* Bool */Block.__(9, [/* Char_literal */Block.__(12, [
                                    /* "," */44,
                                    /* Formatting_lit */Block.__(17, [
                                        /* Break */Block.__(0, [
                                            "@,",
                                            0,
                                            0
                                          ]),
                                        /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                                /* "," */44,
                                                /* Formatting_lit */Block.__(17, [
                                                    /* Break */Block.__(0, [
                                                        "@,",
                                                        0,
                                                        0
                                                      ]),
                                                    /* Bool */Block.__(9, [/* Char_literal */Block.__(12, [
                                                            /* "," */44,
                                                            /* Formatting_lit */Block.__(17, [
                                                                /* Break */Block.__(0, [
                                                                    "@,",
                                                                    0,
                                                                    0
                                                                  ]),
                                                                /* Formatting_gen */Block.__(18, [
                                                                    /* Open_box */Block.__(1, [/* Format */[
                                                                          /* String_literal */Block.__(11, [
                                                                              "<1>",
                                                                              /* End_of_format */0
                                                                            ]),
                                                                          "<1>"
                                                                        ]]),
                                                                    /* String_literal */Block.__(11, [
                                                                        "ref",
                                                                        /* Theta */Block.__(16, [/* Formatting_lit */Block.__(17, [
                                                                                /* Close_box */0,
                                                                                /* Char_literal */Block.__(12, [
                                                                                    /* ")" */41,
                                                                                    /* Formatting_lit */Block.__(17, [
                                                                                        /* Close_box */0,
                                                                                        /* End_of_format */0
                                                                                      ])
                                                                                  ])
                                                                              ])])
                                                                      ])
                                                                  ])
                                                              ])
                                                          ])])
                                                  ])
                                              ])])
                                      ])
                                  ])])
                          ])
                      ]),
                    "@[<hov1>Reither(%b,@,%a,@,%b,@,@[<1>ref%t@])@]"
                  ]), param[0], raw_type_list, param[1], param[2], (function (ppf) {
                  var match = e[0];
                  if (match) {
                    return Curry._2(Format.fprintf(ppf, /* Format */[
                                    /* Formatting_lit */Block.__(17, [
                                        /* Break */Block.__(0, [
                                            "@,",
                                            0,
                                            0
                                          ]),
                                        /* Formatting_gen */Block.__(18, [
                                            /* Open_box */Block.__(1, [/* Format */[
                                                  /* String_literal */Block.__(11, [
                                                      "<1>",
                                                      /* End_of_format */0
                                                    ]),
                                                  "<1>"
                                                ]]),
                                            /* Char_literal */Block.__(12, [
                                                /* "(" */40,
                                                /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                                        /* ")" */41,
                                                        /* Formatting_lit */Block.__(17, [
                                                            /* Close_box */0,
                                                            /* End_of_format */0
                                                          ])
                                                      ])])
                                              ])
                                          ])
                                      ]),
                                    "@,@[<1>(%a)@]"
                                  ]), raw_field, match[0]);
                  } else {
                    return Format.fprintf(ppf, /* Format */[
                                /* String_literal */Block.__(11, [
                                    " None",
                                    /* End_of_format */0
                                  ]),
                                " None"
                              ]);
                  }
                }));
  } else {
    var match = param[0];
    if (match) {
      return Curry._2(Format.fprintf(ppf, /* Format */[
                      /* Formatting_gen */Block.__(18, [
                          /* Open_box */Block.__(1, [/* Format */[
                                /* String_literal */Block.__(11, [
                                    "<1>",
                                    /* End_of_format */0
                                  ]),
                                "<1>"
                              ]]),
                          /* String_literal */Block.__(11, [
                              "Rpresent(Some",
                              /* Formatting_lit */Block.__(17, [
                                  /* Break */Block.__(0, [
                                      "@,",
                                      0,
                                      0
                                    ]),
                                  /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                          /* ")" */41,
                                          /* Formatting_lit */Block.__(17, [
                                              /* Close_box */0,
                                              /* End_of_format */0
                                            ])
                                        ])])
                                ])
                            ])
                        ]),
                      "@[<1>Rpresent(Some@,%a)@]"
                    ]), raw_type, match[0]);
    } else {
      return Format.fprintf(ppf, /* Format */[
                  /* String_literal */Block.__(11, [
                      "Rpresent None",
                      /* End_of_format */0
                    ]),
                  "Rpresent None"
                ]);
    }
  }
}

function raw_type_expr(ppf, t) {
  visited[0] = /* [] */0;
  raw_type(ppf, t);
  visited[0] = /* [] */0;
  return /* () */0;
}

print_raw = raw_type_expr;

function is_nth(param) {
  if (typeof param === "number" || param.tag) {
    return /* false */0;
  } else {
    return /* true */1;
  }
}

function compose(l1, param) {
  if (typeof param === "number") {
    return /* Map */Block.__(1, [l1]);
  } else if (param.tag) {
    return /* Map */Block.__(1, [List.map((function (param) {
                      return List.nth(l1, param);
                    }), param[0])]);
  } else {
    return /* Nth */Block.__(0, [List.nth(l1, param[0])]);
  }
}

function apply_subst(s1, tyl) {
  if (typeof s1 === "number") {
    return tyl;
  } else if (s1.tag) {
    return List.map((function (param) {
                  return List.nth(tyl, param);
                }), s1[0]);
  } else {
    return /* :: */[
            List.nth(tyl, s1[0]),
            /* [] */0
          ];
  }
}

var printing_env = [empty];

var printing_depth = [0];

var printing_cont = [/* [] */0];

var printing_old = [empty];

var printing_pers = [/* Empty */0];

function compare$2(_p1, _p2) {
  while(true) {
    var p2 = _p2;
    var p1 = _p1;
    switch (p1.tag | 0) {
      case 0 : 
          return Caml_obj.caml_compare(p1, p2);
      case 1 : 
          switch (p2.tag | 0) {
            case 1 : 
                var c = compare$2(p1[0], p2[0]);
                if (c !== 0) {
                  return c;
                } else {
                  return Caml_string.caml_string_compare(p1[1], p2[1]);
                }
            case 0 : 
            case 2 : 
                return Caml_obj.caml_compare(p1, p2);
            
          }
          break;
      case 2 : 
          switch (p2.tag | 0) {
            case 0 : 
            case 1 : 
                return Caml_obj.caml_compare(p1, p2);
            case 2 : 
                var c$1 = compare$2(p1[0], p2[0]);
                if (c$1 !== 0) {
                  return c$1;
                } else {
                  _p2 = p2[1];
                  _p1 = p1[1];
                  continue ;
                  
                }
                break;
            
          }
          break;
      
    }
  };
}

function height$6(param) {
  if (param) {
    return param[4];
  } else {
    return 0;
  }
}

function create$7(l, x, d, r) {
  var hl = height$6(l);
  var hr = height$6(r);
  return /* Node */[
          l,
          x,
          d,
          r,
          hl >= hr ? hl + 1 | 0 : hr + 1 | 0
        ];
}

function bal$6(l, x, d, r) {
  var hl = l ? l[4] : 0;
  var hr = r ? r[4] : 0;
  if (hl > (hr + 2 | 0)) {
    if (l) {
      var lr = l[3];
      var ld = l[2];
      var lv = l[1];
      var ll = l[0];
      if (height$6(ll) >= height$6(lr)) {
        return create$7(ll, lv, ld, create$7(lr, x, d, r));
      } else if (lr) {
        return create$7(create$7(ll, lv, ld, lr[0]), lr[1], lr[2], create$7(lr[3], x, d, r));
      } else {
        throw [
              Caml_builtin_exceptions.invalid_argument,
              "Map.bal"
            ];
      }
    } else {
      throw [
            Caml_builtin_exceptions.invalid_argument,
            "Map.bal"
          ];
    }
  } else if (hr > (hl + 2 | 0)) {
    if (r) {
      var rr = r[3];
      var rd = r[2];
      var rv = r[1];
      var rl = r[0];
      if (height$6(rr) >= height$6(rl)) {
        return create$7(create$7(l, x, d, rl), rv, rd, rr);
      } else if (rl) {
        return create$7(create$7(l, x, d, rl[0]), rl[1], rl[2], create$7(rl[3], rv, rd, rr));
      } else {
        throw [
              Caml_builtin_exceptions.invalid_argument,
              "Map.bal"
            ];
      }
    } else {
      throw [
            Caml_builtin_exceptions.invalid_argument,
            "Map.bal"
          ];
    }
  } else {
    return /* Node */[
            l,
            x,
            d,
            r,
            hl >= hr ? hl + 1 | 0 : hr + 1 | 0
          ];
  }
}

function add$8(x, data, param) {
  if (param) {
    var r = param[3];
    var d = param[2];
    var v = param[1];
    var l = param[0];
    var c = compare$2(x, v);
    if (c) {
      if (c < 0) {
        return bal$6(add$8(x, data, l), v, d, r);
      } else {
        return bal$6(l, v, d, add$8(x, data, r));
      }
    } else {
      return /* Node */[
              l,
              x,
              data,
              r,
              param[4]
            ];
    }
  } else {
    return /* Node */[
            /* Empty */0,
            x,
            data,
            /* Empty */0,
            1
          ];
  }
}

function find$4(x, _param) {
  while(true) {
    var param = _param;
    if (param) {
      var c = compare$2(x, param[1]);
      if (c) {
        _param = c < 0 ? param[0] : param[3];
        continue ;
        
      } else {
        return param[2];
      }
    } else {
      throw Caml_builtin_exceptions.not_found;
    }
  };
}

var printing_map = [/* Empty */0];

function same_type(t, t$prime) {
  return +(repr(t) === repr(t$prime));
}

function index(l, x) {
  if (l) {
    if (x === l[0]) {
      return 0;
    } else {
      return 1 + index(l[1], x) | 0;
    }
  } else {
    throw Caml_builtin_exceptions.not_found;
  }
}

function uniq(_param) {
  while(true) {
    var param = _param;
    if (param) {
      var l = param[1];
      if (List.memq(param[0], l)) {
        return /* false */0;
      } else {
        _param = l;
        continue ;
        
      }
    } else {
      return /* true */1;
    }
  };
}

function normalize_type_path($staropt$star, env, p) {
  var cache = $staropt$star ? $staropt$star[0] : /* false */0;
  try {
    var match = find_type_expansion(p, env);
    var params = List.map(repr, match[0]);
    var ty = repr(match[1]);
    var match$1 = ty[/* desc */0];
    if (typeof match$1 === "number") {
      return /* tuple */[
              p,
              /* Nth */Block.__(0, [index(params, ty)])
            ];
    } else if (match$1.tag === 3) {
      var p1 = match$1[0];
      var tyl = List.map(repr, match$1[1]);
      if (List.length(params) === List.length(tyl) && List.for_all2((function (prim, prim$1) {
                return +(prim === prim$1);
              }), params, tyl)) {
        return normalize_type_path(/* Some */[cache], env, p1);
      } else if (cache || List.length(params) <= List.length(tyl) || !uniq(tyl)) {
        return /* tuple */[
                p,
                /* Id */0
              ];
      } else {
        var l1 = List.map((function (param) {
                return index(params, param);
              }), tyl);
        var match$2 = normalize_type_path(/* Some */[cache], env, p1);
        return /* tuple */[
                match$2[0],
                compose(l1, match$2[1])
              ];
      }
    } else {
      return /* tuple */[
              p,
              /* Nth */Block.__(0, [index(params, ty)])
            ];
    }
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return /* tuple */[
              p,
              /* Id */0
            ];
    } else {
      throw exn;
    }
  }
}

function path_size(param) {
  switch (param.tag | 0) {
    case 0 : 
        var id = param[0];
        var s = id[/* name */1];
        return /* tuple */[
                s !== "" && Caml_string.get(s, 0) === /* "_" */95 ? 10 : 1,
                -id[/* stamp */0] | 0
              ];
    case 1 : 
        var match = path_size(param[0]);
        return /* tuple */[
                1 + match[0] | 0,
                match[1]
              ];
    case 2 : 
        var match$1 = path_size(param[0]);
        return /* tuple */[
                match$1[0] + path_size(param[1])[0] | 0,
                match$1[1]
              ];
    
  }
}

function same_printing_env(env) {
  var used_pers = used_persistent(/* () */0);
  if (same_types(printing_old[0], env)) {
    return equal$2(printing_pers[0], used_pers);
  } else {
    return /* false */0;
  }
}

function set_printing_env(env) {
  printing_env[0] = real_paths[0] ? empty : env;
  if (printing_env[0] === empty || same_printing_env(env)) {
    return /* () */0;
  } else {
    printing_old[0] = env;
    printing_pers[0] = used_persistent(/* () */0);
    printing_map[0] = /* Empty */0;
    printing_depth[0] = 0;
    var partial_arg = iter_types((function (p, param) {
            var match = normalize_type_path(/* Some */[/* true */1], env, param[0]);
            if (match[1]) {
              return 0;
            } else {
              var p1 = match[0];
              try {
                var r = find$4(p1, printing_map[0]);
                var match$1 = r[0];
                if (match$1.tag) {
                  r[0] = /* Paths */Block.__(0, [/* :: */[
                        p,
                        /* :: */[
                          match$1[0],
                          /* [] */0
                        ]
                      ]]);
                  return /* () */0;
                } else {
                  r[0] = /* Paths */Block.__(0, [/* :: */[
                        p,
                        match$1[0]
                      ]]);
                  return /* () */0;
                }
              }
              catch (exn){
                if (exn === Caml_builtin_exceptions.not_found) {
                  printing_map[0] = add$8(p1, [/* Paths */Block.__(0, [/* :: */[
                              p,
                              /* [] */0
                            ]])], printing_map[0]);
                  return /* () */0;
                } else {
                  throw exn;
                }
              }
            }
          }));
    var cont = function (param) {
      return partial_arg(env, param);
    };
    printing_cont[0] = /* :: */[
      cont,
      /* [] */0
    ];
    return /* () */0;
  }
}

function wrap_printing_env(env, f) {
  set_printing_env(env);
  return try_finally(f, (function () {
                return set_printing_env(empty);
              }));
}

function is_unambiguous(path, env) {
  var l = find_shadowed_types(path, env);
  if (List.exists((function (param) {
            return same(path, param);
          }), l)) {
    return /* true */1;
  } else if (l) {
    var rem = l[1];
    var p = l[0];
    var normalize = function (p) {
      return normalize_type_path(/* Some */[/* true */1], env, p)[0];
    };
    var p$prime = normalize(p);
    if (List.for_all((function (p) {
              return same(normalize(p), p$prime);
            }), rem)) {
      return /* true */1;
    } else {
      var id = lid_of_path(/* None */0, p);
      if (List.for_all((function (p) {
                return Caml_obj.caml_equal(lid_of_path(/* None */0, p), id);
              }), rem)) {
        return same(p, lookup_type$1(id, env)[0]);
      } else {
        return /* false */0;
      }
    }
  } else {
    return /* true */1;
  }
}

function best_type_path(p) {
  if (real_paths[0] || printing_env[0] === empty) {
    return /* tuple */[
            p,
            /* Id */0
          ];
  } else {
    var match = normalize_type_path(/* None */0, printing_env[0], p);
    var p$prime = match[0];
    var get_path = function () {
      var r = find$4(p$prime, printing_map[0]);
      while(true) {
        var match = r[0];
        if (match.tag) {
          return match[0];
        } else {
          var l = match[0];
          if (l) {
            r[0] = /* Paths */Block.__(0, [/* [] */0]);
            List.iter((function (p) {
                    var match = r[0];
                    var exit = 0;
                    if (match.tag) {
                      if (Caml_obj.caml_greaterequal(path_size(p), path_size(match[0]))) {
                        return /* () */0;
                      } else {
                        exit = 1;
                      }
                    } else {
                      exit = 1;
                    }
                    if (exit === 1) {
                      if (is_unambiguous(p, printing_env[0])) {
                        r[0] = /* Best */Block.__(1, [p]);
                        return /* () */0;
                      } else {
                        return 0;
                      }
                    }
                    
                  }), l);
            continue ;
            
          } else {
            throw Caml_builtin_exceptions.not_found;
          }
        }
      };
    };
    while((function () {
            var $js;
            try {
              get_path(/* () */0);
              $js = /* false */0;
            }
            catch (exn){
              if (exn === Caml_builtin_exceptions.not_found) {
                $js = /* true */1;
              } else {
                throw exn;
              }
            }
            return +(printing_cont[0] !== /* [] */0) && $js;
          })()) {
      printing_cont[0] = List.map((function (prim) {
              return prim[1];
            }), run_iter_cont(printing_cont[0]));
      printing_depth[0] = printing_depth[0] + 1 | 0;
    };
    var p$prime$prime;
    try {
      p$prime$prime = get_path(/* () */0);
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        p$prime$prime = p$prime;
      } else {
        throw exn;
      }
    }
    return /* tuple */[
            p$prime$prime,
            match[1]
          ];
  }
}

var names = [/* [] */0];

var name_counter = [0];

var named_vars = [/* [] */0];

function reset_names() {
  names[0] = /* [] */0;
  name_counter[0] = 0;
  named_vars[0] = /* [] */0;
  return /* () */0;
}

function add_named_var(ty) {
  var match = ty[/* desc */0];
  var exit = 0;
  if (typeof match === "number") {
    return /* () */0;
  } else {
    switch (match.tag | 0) {
      case 0 : 
      case 9 : 
          exit = 1;
          break;
      default:
        return /* () */0;
    }
  }
  if (exit === 1) {
    var match$1 = match[0];
    if (match$1) {
      var name = match$1[0];
      if (List.mem(name, named_vars[0])) {
        return /* () */0;
      } else {
        named_vars[0] = /* :: */[
          name,
          named_vars[0]
        ];
        return /* () */0;
      }
    } else {
      return /* () */0;
    }
  }
  
}

function new_name(_param) {
  while(true) {
    var name;
    if (name_counter[0] < 26) {
      var c = Char.chr(97 + name_counter[0] | 0);
      name = Caml_string.bytes_to_string(Bytes.make(1, c));
    } else {
      var c$1 = Char.chr(97 + name_counter[0] % 26 | 0);
      name = Caml_string.bytes_to_string(Bytes.make(1, c$1)) + (name_counter[0] / 26 | 0);
    }
    name_counter[0] = name_counter[0] + 1 | 0;
    if (List.mem(name, named_vars[0]) || List.exists((function(name){
          return function (param) {
            return +(name === param[1]);
          }
          }(name)), names[0])) {
      _param = /* () */0;
      continue ;
      
    } else {
      return name;
    }
  };
}

function name_of_type(t) {
  try {
    return List.assq(t, names[0]);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      var match = t[/* desc */0];
      var name;
      var exit = 0;
      if (typeof match === "number") {
        name = new_name(/* () */0);
      } else {
        switch (match.tag | 0) {
          case 0 : 
          case 9 : 
              exit = 1;
              break;
          default:
            name = new_name(/* () */0);
        }
      }
      if (exit === 1) {
        var match$1 = match[0];
        if (match$1) {
          var name$1 = match$1[0];
          var current_name = [name$1];
          var i = 0;
          while(List.exists((function (param) {
                    return +(current_name[0] === param[1]);
                  }), names[0])) {
            current_name[0] = name$1 + i;
            i = i + 1 | 0;
          };
          name = current_name[0];
        } else {
          name = new_name(/* () */0);
        }
      }
      if (name !== "_") {
        names[0] = /* :: */[
          /* tuple */[
            t,
            name
          ],
          names[0]
        ];
      }
      return name;
    } else {
      throw exn;
    }
  }
}

function check_name_of_type(t) {
  name_of_type(t);
  return /* () */0;
}

function remove_names(tyl) {
  var tyl$1 = List.map(repr, tyl);
  names[0] = List.filter((function (param) {
            return 1 - List.memq(param[0], tyl$1);
          }))(names[0]);
  return /* () */0;
}

var visited_objects = [/* [] */0];

var aliased = [/* [] */0];

var delayed = [/* [] */0];

function add_delayed(t) {
  if (List.memq(t, delayed[0])) {
    return 0;
  } else {
    delayed[0] = /* :: */[
      t,
      delayed[0]
    ];
    return /* () */0;
  }
}

function is_aliased(ty) {
  return List.memq(proxy(ty), aliased[0]);
}

function add_alias(ty) {
  var px = proxy(ty);
  if (is_aliased(px)) {
    return 0;
  } else {
    aliased[0] = /* :: */[
      px,
      aliased[0]
    ];
    return add_named_var(px);
  }
}

function aliasable(ty) {
  var match = ty[/* desc */0];
  if (typeof match === "number") {
    return /* true */1;
  } else {
    switch (match.tag | 0) {
      case 3 : 
          return 1 - is_nth(best_type_path(match[0])[1]);
      case 0 : 
      case 9 : 
      case 10 : 
          return /* false */0;
      default:
        return /* true */1;
    }
  }
}

function namable_row(row) {
  if (row[/* row_name */5] !== /* None */0) {
    return List.for_all((function (param) {
                  var match = row_field_repr_aux(/* [] */0, param[1]);
                  if (typeof match === "number") {
                    return /* true */1;
                  } else if (match.tag) {
                    var l = match[1];
                    if (row[/* row_closed */3]) {
                      if (match[0]) {
                        return +(l === /* [] */0);
                      } else {
                        return +(List.length(l) === 1);
                      }
                    } else {
                      return /* false */0;
                    }
                  } else {
                    return /* true */1;
                  }
                }), row[/* row_fields */0]);
  } else {
    return /* false */0;
  }
}

function mark_loops_rec(_visited, _ty) {
  while(true) {
    var ty = _ty;
    var visited = _visited;
    var ty$1 = repr(ty);
    var px = proxy(ty$1);
    if (List.memq(px, visited) && aliasable(ty$1)) {
      return add_alias(px);
    } else {
      var visited$1 = /* :: */[
        px,
        visited
      ];
      var match = ty$1[/* desc */0];
      if (typeof match === "number") {
        return /* () */0;
      } else {
        switch (match.tag | 0) {
          case 1 : 
              mark_loops_rec(visited$1, match[1]);
              _ty = match[2];
              _visited = visited$1;
              continue ;
              case 2 : 
              return List.iter((function(visited$1){
                        return function (param) {
                          return mark_loops_rec(visited$1, param);
                        }
                        }(visited$1)), match[0]);
          case 3 : 
              var match$1 = best_type_path(match[0]);
              return List.iter((function(visited$1){
                        return function (param) {
                          return mark_loops_rec(visited$1, param);
                        }
                        }(visited$1)), apply_subst(match$1[1], match[1]));
          case 4 : 
              if (List.memq(px, visited_objects[0])) {
                return add_alias(px);
              } else {
                if (opened_object(ty$1)) {
                  visited_objects[0] = /* :: */[
                    px,
                    visited_objects[0]
                  ];
                }
                var match$2 = match[1][0];
                if (match$2) {
                  return List.iter((function(visited$1){
                            return function (param) {
                              return mark_loops_rec(visited$1, param);
                            }
                            }(visited$1)), List.tl(match$2[0][1]));
                } else {
                  var match$3 = flatten_fields(match[0]);
                  return List.iter((function(visited$1){
                            return function (param) {
                              if (field_kind_repr(param[1])) {
                                return 0;
                              } else {
                                return mark_loops_rec(visited$1, param[2]);
                              }
                            }
                            }(visited$1)), match$3[0]);
                }
              }
              break;
          case 5 : 
              var ty2 = match[3];
              if (field_kind_repr(match[1])) {
                _ty = ty2;
                _visited = visited$1;
                continue ;
                
              } else {
                mark_loops_rec(visited$1, match[2]);
                _ty = ty2;
                _visited = visited$1;
                continue ;
                
              }
              break;
          case 6 : 
              return fatal_error("Printtyp.mark_loops_rec (2)");
          case 7 : 
              _ty = match[0];
              _visited = visited$1;
              continue ;
              case 8 : 
              if (List.memq(px, visited_objects[0])) {
                return add_alias(px);
              } else {
                var row = row_repr_aux(/* [] */0, match[0]);
                if (!static_row(row)) {
                  visited_objects[0] = /* :: */[
                    px,
                    visited_objects[0]
                  ];
                }
                var match$4 = row[/* row_name */5];
                if (match$4) {
                  if (namable_row(row)) {
                    return List.iter((function(visited$1){
                              return function (param) {
                                return mark_loops_rec(visited$1, param);
                              }
                              }(visited$1)), match$4[0][1]);
                  } else {
                    return iter_row((function(visited$1){
                              return function (param) {
                                return mark_loops_rec(visited$1, param);
                              }
                              }(visited$1)), row);
                  }
                } else {
                  return iter_row((function(visited$1){
                            return function (param) {
                              return mark_loops_rec(visited$1, param);
                            }
                            }(visited$1)), row);
                }
              }
              break;
          case 0 : 
          case 9 : 
              return add_named_var(ty$1);
          case 10 : 
              List.iter(add_alias, match[1]);
              _ty = match[0];
              _visited = visited$1;
              continue ;
              case 11 : 
              return List.iter((function(visited$1){
                        return function (param) {
                          return mark_loops_rec(visited$1, param);
                        }
                        }(visited$1)), match[2]);
          
        }
      }
    }
  };
}

function mark_loops(ty) {
  normalize_type(empty, ty);
  return mark_loops_rec(/* [] */0, ty);
}

function reset() {
  unique_names[0] = /* Empty */0;
  reset_names(/* () */0);
  visited_objects[0] = /* [] */0;
  aliased[0] = /* [] */0;
  delayed[0] = /* [] */0;
  return /* () */0;
}

function reset_and_mark_loops_list(tyl) {
  reset(/* () */0);
  return List.iter(mark_loops, tyl);
}

var print_labels = [/* true */1];

function tree_of_typexp(sch, ty) {
  var ty$1 = repr(ty);
  var px = proxy(ty$1);
  if (List.mem_assq(px, names[0]) && !List.memq(px, delayed[0])) {
    var mark = is_non_gen(sch, ty$1);
    return /* Otyp_var */Block.__(10, [
              mark,
              name_of_type(px)
            ]);
  } else {
    var pr_typ = function () {
      var match = ty$1[/* desc */0];
      if (typeof match === "number") {
        return tree_of_typobject(sch, ty$1, /* None */0);
      } else {
        switch (match.tag | 0) {
          case 0 : 
              return /* Otyp_var */Block.__(10, [
                        is_non_gen(sch, ty$1),
                        name_of_type(ty$1)
                      ]);
          case 1 : 
              var l = match[0];
              var ty1 = match[1];
              var ty2 = match[2];
              var lab = print_labels[0] && l !== "" || is_optional(l) ? l : "";
              var t1;
              if (is_optional(l)) {
                var match$1 = repr(ty1)[/* desc */0];
                if (typeof match$1 === "number") {
                  t1 = /* Otyp_stuff */Block.__(7, ["<hidden>"]);
                } else if (match$1.tag === 3) {
                  var match$2 = match$1[1];
                  t1 = match$2 ? (
                      match$2[1] ? /* Otyp_stuff */Block.__(7, ["<hidden>"]) : (
                          same(match$1[0], path_option) ? tree_of_typexp(sch, match$2[0]) : /* Otyp_stuff */Block.__(7, ["<hidden>"])
                        )
                    ) : /* Otyp_stuff */Block.__(7, ["<hidden>"]);
                } else {
                  t1 = /* Otyp_stuff */Block.__(7, ["<hidden>"]);
                }
              } else {
                t1 = tree_of_typexp(sch, ty1);
              }
              return /* Otyp_arrow */Block.__(1, [
                        lab,
                        t1,
                        tree_of_typexp(sch, ty2)
                      ]);
          case 2 : 
              return /* Otyp_tuple */Block.__(9, [List.map((function (param) {
                                return tree_of_typexp(sch, param);
                              }), match[0])]);
          case 3 : 
              var match$3 = best_type_path(match[0]);
              var s = match$3[1];
              var tyl$prime = apply_subst(s, match[1]);
              if (is_nth(s)) {
                return tree_of_typexp(sch, List.hd(tyl$prime));
              } else {
                return /* Otyp_constr */Block.__(3, [
                          tree_of_path(match$3[0]),
                          List.map((function (param) {
                                  return tree_of_typexp(sch, param);
                                }), tyl$prime)
                        ]);
              }
          case 4 : 
              return tree_of_typobject(sch, match[0], match[1][0]);
          case 5 : 
              return tree_of_typobject(sch, ty$1, /* None */0);
          case 6 : 
              return fatal_error("Printtyp.tree_of_typexp");
          case 7 : 
              return tree_of_typexp(sch, match[0]);
          case 8 : 
              var row = row_repr_aux(/* [] */0, match[0]);
              var fields = row[/* row_closed */3] ? List.filter((function (param) {
                          return +(row_field_repr_aux(/* [] */0, param[1]) !== /* Rabsent */0);
                        }))(row[/* row_fields */0]) : row[/* row_fields */0];
              var present = List.filter((function (param) {
                        var match = row_field_repr_aux(/* [] */0, param[1]);
                        if (typeof match === "number" || match.tag) {
                          return /* false */0;
                        } else {
                          return /* true */1;
                        }
                      }))(fields);
              var all_present = +(List.length(present) === List.length(fields));
              var match$4 = row[/* row_name */5];
              var exit = 0;
              if (match$4) {
                var match$5 = match$4[0];
                var tyl = match$5[1];
                var p = match$5[0];
                if (namable_row(row)) {
                  var match$6 = best_type_path(p);
                  var s$1 = match$6[1];
                  var id = tree_of_path(match$6[0]);
                  var tyl$1 = apply_subst(s$1, tyl);
                  var args = List.map((function (param) {
                          return tree_of_typexp(sch, param);
                        }), tyl$1);
                  if (row[/* row_closed */3] && all_present) {
                    if (is_nth(s$1)) {
                      return List.hd(args);
                    } else {
                      return /* Otyp_constr */Block.__(3, [
                                id,
                                args
                              ]);
                    }
                  } else {
                    var non_gen = is_non_gen(sch, px);
                    var tags = all_present ? /* None */0 : /* Some */[List.map((function (prim) {
                                return prim[0];
                              }), present)];
                    var inh;
                    var exit$1 = 0;
                    if (args) {
                      var match$7 = args[0];
                      if (typeof match$7 === "number" || !(match$7.tag === 3 && !(args[1] || !is_nth(s$1)))) {
                        exit$1 = 2;
                      } else {
                        inh = /* Ovar_name */Block.__(1, [
                            match$7[0],
                            match$7[1]
                          ]);
                      }
                    } else {
                      exit$1 = 2;
                    }
                    if (exit$1 === 2) {
                      inh = /* Ovar_name */Block.__(1, [
                          tree_of_path(p),
                          List.map((function (param) {
                                  return tree_of_typexp(sch, param);
                                }), tyl)
                        ]);
                    }
                    return /* Otyp_variant */Block.__(11, [
                              non_gen,
                              inh,
                              row[/* row_closed */3],
                              tags
                            ]);
                  }
                } else {
                  exit = 1;
                }
              } else {
                exit = 1;
              }
              if (exit === 1) {
                var non_gen$1 = 1 - (row[/* row_closed */3] && all_present) && is_non_gen(sch, px);
                var fields$1 = List.map((function (param) {
                        var sch$1 = sch;
                        var param$1 = param;
                        var l = param$1[0];
                        var match = row_field_repr_aux(/* [] */0, param$1[1]);
                        if (typeof match === "number") {
                          return /* tuple */[
                                  l,
                                  /* false */0,
                                  /* [] */0
                                ];
                        } else if (match.tag) {
                          var c = match[0];
                          var exit = 0;
                          if (c !== 0) {
                            if (match[1]) {
                              exit = 1;
                            } else {
                              return /* tuple */[
                                      l,
                                      /* false */0,
                                      /* [] */0
                                    ];
                            }
                          } else {
                            exit = 1;
                          }
                          if (exit === 1) {
                            var tyl = match[1];
                            if (c) {
                              return /* tuple */[
                                      l,
                                      /* true */1,
                                      List.map((function (param) {
                                              return tree_of_typexp(sch$1, param);
                                            }), tyl)
                                    ];
                            } else {
                              return /* tuple */[
                                      l,
                                      /* false */0,
                                      List.map((function (param) {
                                              return tree_of_typexp(sch$1, param);
                                            }), tyl)
                                    ];
                            }
                          }
                          
                        } else {
                          var match$1 = match[0];
                          if (match$1) {
                            return /* tuple */[
                                    l,
                                    /* false */0,
                                    /* :: */[
                                      tree_of_typexp(sch$1, match$1[0]),
                                      /* [] */0
                                    ]
                                  ];
                          } else {
                            return /* tuple */[
                                    l,
                                    /* false */0,
                                    /* [] */0
                                  ];
                          }
                        }
                      }), fields);
                var tags$1 = all_present ? /* None */0 : /* Some */[List.map((function (prim) {
                            return prim[0];
                          }), present)];
                return /* Otyp_variant */Block.__(11, [
                          non_gen$1,
                          /* Ovar_fields */Block.__(0, [fields$1]),
                          row[/* row_closed */3],
                          tags$1
                        ]);
              }
              break;
          case 9 : 
              return /* Otyp_var */Block.__(10, [
                        /* false */0,
                        name_of_type(ty$1)
                      ]);
          case 10 : 
              var tyl$2 = match[1];
              var ty$2 = match[0];
              if (tyl$2) {
                var tyl$3 = List.map(repr, tyl$2);
                if (tyl$3) {
                  var old_delayed = delayed[0];
                  List.iter(add_delayed, tyl$3);
                  var tl = List.map(name_of_type, tyl$3);
                  var tr_001 = tree_of_typexp(sch, ty$2);
                  var tr = /* Otyp_poly */Block.__(12, [
                      tl,
                      tr_001
                    ]);
                  remove_names(tyl$3);
                  delayed[0] = old_delayed;
                  return tr;
                } else {
                  return tree_of_typexp(sch, ty$2);
                }
              } else {
                return tree_of_typexp(sch, ty$2);
              }
              break;
          case 11 : 
              var n = List.map((function (li) {
                      return $$String.concat(".", flat(/* [] */0, li));
                    }), match[1]);
              return /* Otyp_module */Block.__(13, [
                        name(/* None */0, match[0]),
                        n,
                        List.map((function (param) {
                                return tree_of_typexp(sch, param);
                              }), match[2])
                      ]);
          
        }
      }
    };
    if (List.memq(px, delayed[0])) {
      delayed[0] = List.filter((function (param) {
                return +(px !== param);
              }))(delayed[0]);
    }
    if (is_aliased(px) && aliasable(ty$1)) {
      name_of_type(px);
      return /* Otyp_alias */Block.__(0, [
                pr_typ(/* () */0),
                name_of_type(px)
              ]);
    } else {
      return pr_typ(/* () */0);
    }
  }
}

function tree_of_typobject(sch, fi, nm) {
  if (nm) {
    var match = nm[0];
    var match$1 = match[1];
    if (match$1) {
      var non_gen = is_non_gen(sch, repr(match$1[0]));
      var args = List.map((function (param) {
              return tree_of_typexp(sch, param);
            }), match$1[1]);
      var match$2 = best_type_path(match[0]);
      if (match$2[1] !== /* Id */0) {
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "printtyp.ml",
                688,
                6
              ]
            ];
      }
      return /* Otyp_class */Block.__(2, [
                non_gen,
                tree_of_path(match$2[0]),
                args
              ]);
    } else {
      return fatal_error("Printtyp.tree_of_typobject");
    }
  } else {
    var pr_fields = function (fi) {
      var match = flatten_fields(fi);
      var present_fields = List.fold_right((function (param, l) {
              var match = field_kind_repr(param[1]);
              if (typeof match === "number" && match === 0) {
                return /* :: */[
                        /* tuple */[
                          param[0],
                          param[2]
                        ],
                        l
                      ];
              } else {
                return l;
              }
            }), match[0], /* [] */0);
      var sorted_fields = List.sort((function (param, param$1) {
              return Caml_string.caml_string_compare(param[0], param$1[0]);
            }), present_fields);
      return tree_of_typfields(sch, match[1], sorted_fields);
    };
    var match$3 = pr_fields(fi);
    return /* Otyp_object */Block.__(5, [
              match$3[0],
              match$3[1]
            ]);
  }
}

function is_non_gen(sch, ty) {
  if (sch && is_Tvar(ty)) {
    return +(ty[/* level */1] !== 100000000);
  } else {
    return /* false */0;
  }
}

function tree_of_typfields(sch, rest, param) {
  if (param) {
    var match = param[0];
    var field_000 = match[0];
    var field_001 = tree_of_typexp(sch, match[1]);
    var field = /* tuple */[
      field_000,
      field_001
    ];
    var match$1 = tree_of_typfields(sch, rest, param[1]);
    return /* tuple */[
            /* :: */[
              field,
              match$1[0]
            ],
            match$1[1]
          ];
  } else {
    var match$2 = rest[/* desc */0];
    var rest$1;
    if (typeof match$2 === "number") {
      rest$1 = match$2 ? fatal_error("typfields (1)") : /* None */0;
    } else {
      switch (match$2.tag | 0) {
        case 3 : 
            rest$1 = /* Some */[/* false */0];
            break;
        case 0 : 
        case 9 : 
            rest$1 = /* Some */[is_non_gen(sch, rest)];
            break;
        default:
          rest$1 = fatal_error("typfields (1)");
      }
    }
    return /* tuple */[
            /* [] */0,
            rest$1
          ];
  }
}

function typexp$1(sch, _, ppf, ty) {
  return Curry._2(out_type[0], ppf, tree_of_typexp(sch, ty));
}

function type_expr$1(ppf, ty) {
  return typexp$1(/* false */0, 0, ppf, ty);
}

function type_scheme(ppf, ty) {
  reset(/* () */0);
  mark_loops(ty);
  return typexp$1(/* true */1, 0, ppf, ty);
}

function tree_of_type_scheme(ty) {
  reset(/* () */0);
  mark_loops(ty);
  return tree_of_typexp(/* true */1, ty);
}

function tree_of_constraints(params) {
  return List.fold_right((function (ty, list) {
                var ty$prime = unalias(ty);
                if (proxy(ty) !== proxy(ty$prime)) {
                  var tr = tree_of_typexp(/* true */1, ty);
                  return /* :: */[
                          /* tuple */[
                            tr,
                            tree_of_typexp(/* true */1, ty$prime)
                          ],
                          list
                        ];
                } else {
                  return list;
                }
              }), params, /* [] */0);
}

function filter_params(tyl) {
  return List.rev(List.fold_left((function (tyl, ty) {
                    var ty$1 = repr(ty);
                    if (List.memq(ty$1, tyl)) {
                      return /* :: */[
                              newty2(100000000, /* Tsubst */Block.__(7, [ty$1])),
                              tyl
                            ];
                    } else {
                      return /* :: */[
                              ty$1,
                              tyl
                            ];
                    }
                  }), /* [] */0, tyl));
}

function tree_of_constructor(cd) {
  var name = cd[/* cd_id */0][/* name */1];
  var match = cd[/* cd_res */2];
  if (match) {
    var nm = names[0];
    names[0] = /* [] */0;
    var ret = tree_of_typexp(/* false */0, match[0]);
    var args = List.map((function (param) {
            return tree_of_typexp(/* false */0, param);
          }), cd[/* cd_args */1]);
    names[0] = nm;
    return /* tuple */[
            name,
            args,
            /* Some */[ret]
          ];
  } else {
    return /* tuple */[
            name,
            List.map((function (param) {
                    return tree_of_typexp(/* false */0, param);
                  }), cd[/* cd_args */1]),
            /* None */0
          ];
  }
}

function tree_of_label(l) {
  return /* tuple */[
          l[/* ld_id */0][/* name */1],
          +(l[/* ld_mutable */1] === /* Mutable */1),
          tree_of_typexp(/* false */0, l[/* ld_type */2])
        ];
}

function tree_of_type_decl(id, decl) {
  reset(/* () */0);
  var params = filter_params(decl[/* type_params */0]);
  var match = decl[/* type_manifest */4];
  if (match) {
    var vars = free_variables$1(/* None */0, match[0]);
    List.iter((function (ty) {
            var match = ty[/* desc */0];
            if (typeof match === "number") {
              return /* () */0;
            } else if (match.tag) {
              return /* () */0;
            } else {
              var match$1 = match[0];
              if (match$1 && match$1[0] === "_" && List.memq(ty, vars)) {
                ty[/* desc */0] = /* Tvar */Block.__(0, [/* None */0]);
                return /* () */0;
              } else {
                return /* () */0;
              }
            }
          }), params);
  }
  List.iter(add_alias, params);
  List.iter(mark_loops, params);
  List.iter(check_name_of_type, List.map(proxy, params));
  var match$1 = decl[/* type_manifest */4];
  var ty_manifest;
  if (match$1) {
    var ty = match$1[0];
    var match$2 = repr(ty);
    var match$3 = match$2[/* desc */0];
    var ty$1;
    if (typeof match$3 === "number") {
      ty$1 = ty;
    } else if (match$3.tag === 8) {
      var row = row_repr_aux(/* [] */0, match$3[0]);
      var match$4 = row[/* row_name */5];
      if (match$4) {
        var match$5 = match$4[0][0];
        switch (match$5.tag | 0) {
          case 0 : 
              if (Caml_obj.caml_equal(id, match$5[0])) {
                var newrecord = row.slice();
                ty$1 = newty2(100000000, /* Tvariant */Block.__(8, [(newrecord[/* row_name */5] = /* None */0, newrecord)]));
              } else {
                ty$1 = ty;
              }
              break;
          case 1 : 
          case 2 : 
              ty$1 = ty;
              break;
          
        }
      } else {
        ty$1 = ty;
      }
    } else {
      ty$1 = ty;
    }
    mark_loops(ty$1);
    ty_manifest = /* Some */[ty$1];
  } else {
    ty_manifest = /* None */0;
  }
  var match$6 = decl[/* type_kind */2];
  if (typeof match$6 === "number") {
    +(match$6 === 0);
  } else if (match$6.tag) {
    List.iter((function (c) {
            List.iter(mark_loops, c[/* cd_args */1]);
            return may(mark_loops, c[/* cd_res */2]);
          }), match$6[0]);
  } else {
    List.iter((function (l) {
            return mark_loops(l[/* ld_type */2]);
          }), match$6[0]);
  }
  var type_param = function (param) {
    if (typeof param === "number") {
      return "?";
    } else if (param.tag === 10) {
      return param[1];
    } else {
      return "?";
    }
  };
  var type_defined = function (decl) {
    var match = decl[/* type_kind */2];
    var abstr;
    abstr = typeof match === "number" ? (
        match ? +(decl[/* type_manifest */4] === /* None */0) : +(decl[/* type_manifest */4] === /* None */0 || decl[/* type_private */3] === /* Private */0)
      ) : (
        match.tag ? +(decl[/* type_private */3] === /* Private */0) || List.exists((function (cd) {
                  return +(cd[/* cd_res */2] !== /* None */0);
                }), match[0]) : +(decl[/* type_private */3] === /* Private */0)
      );
    var vari = List.map2((function (ty, v) {
            if (abstr || !is_Tvar(repr(ty))) {
              return Curry._1(Types_003[/* get_upper */10], v);
            } else {
              return /* tuple */[
                      /* true */1,
                      /* true */1
                    ];
            }
          }), decl[/* type_params */0], decl[/* type_variance */5]);
    return /* tuple */[
            id[/* name */1],
            List.map2((function (ty, cocn) {
                    return /* tuple */[
                            type_param(tree_of_typexp(/* false */0, ty)),
                            cocn
                          ];
                  }), params, vari)
          ];
  };
  var tree_of_manifest = function (ty1) {
    if (ty_manifest) {
      return /* Otyp_manifest */Block.__(4, [
                tree_of_typexp(/* false */0, ty_manifest[0]),
                ty1
              ]);
    } else {
      return ty1;
    }
  };
  var match$7 = type_defined(decl);
  var constraints = tree_of_constraints(params);
  var match$8 = decl[/* type_kind */2];
  var match$9;
  match$9 = typeof match$8 === "number" ? (
      match$8 ? /* tuple */[
          tree_of_manifest(/* Otyp_open */1),
          /* Public */1
        ] : (
          ty_manifest ? /* tuple */[
              tree_of_typexp(/* false */0, ty_manifest[0]),
              decl[/* type_private */3]
            ] : /* tuple */[
              /* Otyp_abstract */0,
              /* Public */1
            ]
        )
    ) : (
      match$8.tag ? /* tuple */[
          tree_of_manifest(/* Otyp_sum */Block.__(8, [List.map(tree_of_constructor, match$8[0])])),
          decl[/* type_private */3]
        ] : /* tuple */[
          tree_of_manifest(/* Otyp_record */Block.__(6, [List.map(tree_of_label, match$8[0])])),
          decl[/* type_private */3]
        ]
    );
  return /* record */[
          /* otype_name */match$7[0],
          /* otype_params */match$7[1],
          /* otype_type */match$9[0],
          /* otype_private */match$9[1],
          /* otype_cstrs */constraints
        ];
}

function tree_of_type_declaration(id, decl, rs) {
  return /* Osig_type */Block.__(5, [
            tree_of_type_decl(id, decl),
            tree_of_rec(rs)
          ]);
}

function type_declaration$1(id, ppf, decl) {
  return Curry._2(out_sig_item[0], ppf, tree_of_type_declaration(id, decl, /* Trec_first */1));
}

function tree_of_extension_constructor(id, ext, es) {
  reset(/* () */0);
  var ty_name = name(/* None */0, ext[/* ext_type_path */0]);
  var ty_params = filter_params(ext[/* ext_type_params */1]);
  List.iter(add_alias, ty_params);
  List.iter(mark_loops, ty_params);
  List.iter(check_name_of_type, List.map(proxy, ty_params));
  List.iter(mark_loops, ext[/* ext_args */2]);
  may(mark_loops, ext[/* ext_ret_type */3]);
  var ty_params$1 = List.map((function (ty) {
          var param = tree_of_typexp(/* false */0, ty);
          if (typeof param === "number") {
            return "?";
          } else if (param.tag === 10) {
            return param[1];
          } else {
            return "?";
          }
        }), ty_params);
  var name$1 = id[/* name */1];
  var match = ext[/* ext_ret_type */3];
  var match$1;
  if (match) {
    var nm = names[0];
    names[0] = /* [] */0;
    var ret = tree_of_typexp(/* false */0, match[0]);
    var args = List.map((function (param) {
            return tree_of_typexp(/* false */0, param);
          }), ext[/* ext_args */2]);
    names[0] = nm;
    match$1 = /* tuple */[
      args,
      /* Some */[ret]
    ];
  } else {
    match$1 = /* tuple */[
      List.map((function (param) {
              return tree_of_typexp(/* false */0, param);
            }), ext[/* ext_args */2]),
      /* None */0
    ];
  }
  var ext_003 = /* oext_args */match$1[0];
  var ext_004 = /* oext_ret_type */match$1[1];
  var ext_005 = /* oext_private */ext[/* ext_private */4];
  var ext$1 = /* record */[
    /* oext_name */name$1,
    /* oext_type_name */ty_name,
    /* oext_type_params */ty_params$1,
    ext_003,
    ext_004,
    ext_005
  ];
  var es$1;
  switch (es) {
    case 0 : 
        es$1 = /* Oext_first */0;
        break;
    case 1 : 
        es$1 = /* Oext_next */1;
        break;
    case 2 : 
        es$1 = /* Oext_exception */2;
        break;
    
  }
  return /* Osig_typext */Block.__(2, [
            ext$1,
            es$1
          ]);
}

function extension_constructor$1(id, ppf, ext) {
  return Curry._2(out_sig_item[0], ppf, tree_of_extension_constructor(id, ext, /* Text_first */0));
}

function tree_of_value_description(id, decl) {
  var id$1 = id[/* name */1];
  var ty = tree_of_type_scheme(decl[/* val_type */0]);
  var match = decl[/* val_kind */1];
  var prims;
  prims = typeof match === "number" || match.tag ? /* [] */0 : description_list(match[0]);
  return /* Osig_value */Block.__(6, [
            id$1,
            ty,
            prims
          ]);
}

function value_description$1(id, ppf, decl) {
  return Curry._2(out_sig_item[0], ppf, tree_of_value_description(id, decl));
}

function method_type(param) {
  var match = field_kind_repr(param[1]);
  var match$1 = repr(param[2]);
  if (typeof match === "number") {
    if (match !== 0) {
      return /* tuple */[
              match$1,
              /* [] */0
            ];
    } else {
      var match$2 = match$1[/* desc */0];
      if (typeof match$2 === "number") {
        return /* tuple */[
                match$1,
                /* [] */0
              ];
      } else if (match$2.tag === 10) {
        return /* tuple */[
                match$2[0],
                match$2[1]
              ];
      } else {
        return /* tuple */[
                match$1,
                /* [] */0
              ];
      }
    }
  } else {
    return /* tuple */[
            match$1,
            /* [] */0
          ];
  }
}

function prepare_class_type(params, _param) {
  while(true) {
    var param = _param;
    switch (param.tag | 0) {
      case 0 : 
          var cty = param[2];
          var tyl = param[1];
          var sty = repr(signature_of_class_type(cty)[/* csig_self */0]);
          if (List.memq(proxy(sty), visited_objects[0]) || !List.for_all(is_Tvar, params) || List.exists((function(sty){
                return function (param) {
                  return deep_occur(sty, param);
                }
                }(sty)), tyl)) {
            _param = cty;
            continue ;
            
          } else {
            return List.iter(mark_loops, tyl);
          }
          break;
      case 1 : 
          var sign = param[0];
          var sty$1 = repr(sign[/* csig_self */0]);
          var px = proxy(sty$1);
          if (List.memq(px, visited_objects[0])) {
            add_alias(sty$1);
          } else {
            visited_objects[0] = /* :: */[
              px,
              visited_objects[0]
            ];
          }
          var match = flatten_fields(object_fields(sign[/* csig_self */0]));
          List.iter((function (met) {
                  return mark_loops(method_type(met)[0]);
                }), match[0]);
          return iter$1((function (_, param) {
                        return mark_loops(param[2]);
                      }), sign[/* csig_vars */1]);
      case 2 : 
          mark_loops(param[1]);
          _param = param[2];
          continue ;
          
    }
  };
}

function tree_of_class_type(sch, params, _param) {
  while(true) {
    var param = _param;
    switch (param.tag | 0) {
      case 0 : 
          var cty = param[2];
          var sty = repr(signature_of_class_type(cty)[/* csig_self */0]);
          if (List.memq(proxy(sty), visited_objects[0]) || !List.for_all(is_Tvar, params)) {
            _param = cty;
            continue ;
            
          } else {
            return /* Octy_constr */Block.__(0, [
                      tree_of_path(param[0]),
                      List.map((function (param) {
                              return tree_of_typexp(/* true */1, param);
                            }), param[1])
                    ]);
          }
          break;
      case 1 : 
          var sign = param[0];
          var sty$1 = repr(sign[/* csig_self */0]);
          var self_ty = is_aliased(sty$1) ? /* Some */[/* Otyp_var */Block.__(10, [
                  /* false */0,
                  name_of_type(proxy(sty$1))
                ])] : /* None */0;
          var match = flatten_fields(object_fields(sign[/* csig_self */0]));
          var csil = List.fold_left((function (csil, param) {
                  return /* :: */[
                          /* Ocsg_constraint */Block.__(0, [
                              param[0],
                              param[1]
                            ]),
                          csil
                        ];
                }), /* [] */0, tree_of_constraints(params));
          var all_vars = fold((function (l, param, all) {
                  return /* :: */[
                          /* tuple */[
                            l,
                            param[0],
                            param[1],
                            param[2]
                          ],
                          all
                        ];
                }), sign[/* csig_vars */1], /* [] */0);
          var all_vars$1 = List.rev(all_vars);
          var csil$1 = List.fold_left((function (csil, param) {
                  return /* :: */[
                          /* Ocsg_value */Block.__(2, [
                              param[0],
                              +(param[1] === /* Mutable */1),
                              +(param[2] === /* Virtual */0),
                              tree_of_typexp(sch, param[3])
                            ]),
                          csil
                        ];
                }), csil, all_vars$1);
          var partial_arg = sign[/* csig_concr */2];
          var csil$2 = List.fold_left((function(partial_arg){
              return function (param, param$1) {
                var sch$1 = sch;
                var concrete = partial_arg;
                var csil = param;
                var param$2 = param$1;
                var lab = param$2[0];
                if (lab !== dummy_method) {
                  var kind = field_kind_repr(param$2[1]);
                  var priv = +(kind !== /* Fpresent */0);
                  var virt = 1 - mem$2(lab, concrete);
                  var match = method_type(/* tuple */[
                        lab,
                        kind,
                        param$2[2]
                      ]);
                  var tty = tree_of_typexp(sch$1, match[0]);
                  remove_names(match[1]);
                  return /* :: */[
                          /* Ocsg_method */Block.__(1, [
                              lab,
                              priv,
                              virt,
                              tty
                            ]),
                          csil
                        ];
                } else {
                  return csil;
                }
              }
              }(partial_arg)), csil$1, match[0]);
          return /* Octy_signature */Block.__(2, [
                    self_ty,
                    List.rev(csil$2)
                  ]);
      case 2 : 
          var ty = param[1];
          var l = param[0];
          var lab = print_labels[0] && l !== "" || is_optional(l) ? l : "";
          var ty$1;
          if (is_optional(l)) {
            var match$1 = repr(ty)[/* desc */0];
            var exit = 0;
            if (typeof match$1 === "number") {
              exit = 1;
            } else if (match$1.tag === 3) {
              var match$2 = match$1[1];
              if (match$2 && !(match$2[1] || !same(match$1[0], path_option))) {
                ty$1 = match$2[0];
              } else {
                exit = 1;
              }
            } else {
              exit = 1;
            }
            if (exit === 1) {
              ty$1 = newconstr(/* Pident */Block.__(0, [create("<hidden>")]), /* [] */0);
            }
            
          } else {
            ty$1 = ty;
          }
          var tr = tree_of_typexp(sch, ty$1);
          return /* Octy_arrow */Block.__(1, [
                    lab,
                    tr,
                    tree_of_class_type(sch, params, param[2])
                  ]);
      
    }
  };
}

function class_type$1(ppf, cty) {
  reset(/* () */0);
  prepare_class_type(/* [] */0, cty);
  return Curry._2(out_class_type[0], ppf, tree_of_class_type(/* false */0, /* [] */0, cty));
}

function tree_of_class_param(param, variance) {
  var match = tree_of_typexp(/* true */1, param);
  var $js;
  $js = typeof match === "number" ? "?" : (
      match.tag === 10 ? match[1] : "?"
    );
  return /* tuple */[
          $js,
          is_Tvar(repr(param)) ? /* tuple */[
              /* true */1,
              /* true */1
            ] : variance
        ];
}

function class_variance(param) {
  return List.map((function (v) {
                return /* tuple */[
                        Curry._2(Types_003[/* mem */8], /* May_pos */0, v),
                        Curry._2(Types_003[/* mem */8], /* May_neg */1, v)
                      ];
              }), param);
}

function tree_of_class_declaration(id, cl, rs) {
  var params = filter_params(cl[/* cty_params */0]);
  reset(/* () */0);
  List.iter(add_alias, params);
  prepare_class_type(params, cl[/* cty_type */1]);
  var sty = repr(signature_of_class_type(cl[/* cty_type */1])[/* csig_self */0]);
  List.iter(mark_loops, params);
  List.iter(check_name_of_type, List.map(proxy, params));
  if (is_aliased(sty)) {
    var t = proxy(sty);
    name_of_type(t);
  }
  var vir_flag = +(cl[/* cty_new */3] === /* None */0);
  return /* Osig_class */Block.__(0, [
            vir_flag,
            id[/* name */1],
            List.map2(tree_of_class_param, params, class_variance(cl[/* cty_variance */4])),
            tree_of_class_type(/* true */1, params, cl[/* cty_type */1]),
            tree_of_rec(rs)
          ]);
}

function class_declaration$1(id, ppf, cl) {
  return Curry._2(out_sig_item[0], ppf, tree_of_class_declaration(id, cl, /* Trec_first */1));
}

function tree_of_cltype_declaration(id, cl, rs) {
  var params = List.map(repr, cl[/* clty_params */0]);
  reset(/* () */0);
  List.iter(add_alias, params);
  prepare_class_type(params, cl[/* clty_type */1]);
  var sty = repr(signature_of_class_type(cl[/* clty_type */1])[/* csig_self */0]);
  List.iter(mark_loops, params);
  List.iter(check_name_of_type, List.map(proxy, params));
  if (is_aliased(sty)) {
    var t = proxy(sty);
    name_of_type(t);
  }
  var sign = signature_of_class_type(cl[/* clty_type */1]);
  var match = flatten_fields(object_fields(sign[/* csig_self */0]));
  var virt = List.exists((function (param) {
          var lab = param[0];
          return 1 - (+(lab === dummy_method) || mem$2(lab, sign[/* csig_concr */2]));
        }), match[0]) || fold((function (_, param, b) {
          if (param[1]) {
            return b;
          } else {
            return /* true */1;
          }
        }), sign[/* csig_vars */1], /* false */0);
  return /* Osig_class_type */Block.__(1, [
            virt,
            id[/* name */1],
            List.map2(tree_of_class_param, params, class_variance(cl[/* clty_variance */3])),
            tree_of_class_type(/* true */1, params, cl[/* clty_type */1]),
            tree_of_rec(rs)
          ]);
}

function cltype_declaration$1(id, ppf, cl) {
  return Curry._2(out_sig_item[0], ppf, tree_of_cltype_declaration(id, cl, /* Trec_first */1));
}

function wrap_env(fenv, ftree, arg) {
  var env = printing_env[0];
  set_printing_env(Curry._1(fenv, env));
  var tree = Curry._1(ftree, arg);
  set_printing_env(env);
  return tree;
}

function filter_rem_sig(item, rem) {
  switch (item.tag | 0) {
    case 5 : 
        if (rem) {
          var match = rem[1];
          if (match) {
            var match$1 = match[1];
            if (match$1) {
              return /* tuple */[
                      /* :: */[
                        rem[0],
                        /* :: */[
                          match[0],
                          /* :: */[
                            match$1[0],
                            /* [] */0
                          ]
                        ]
                      ],
                      match$1[1]
                    ];
            } else {
              return /* tuple */[
                      /* [] */0,
                      rem
                    ];
            }
          } else {
            return /* tuple */[
                    /* [] */0,
                    rem
                  ];
          }
        } else {
          return /* tuple */[
                  /* [] */0,
                  rem
                ];
        }
        break;
    case 6 : 
        if (rem) {
          var match$2 = rem[1];
          if (match$2) {
            return /* tuple */[
                    /* :: */[
                      rem[0],
                      /* :: */[
                        match$2[0],
                        /* [] */0
                      ]
                    ],
                    match$2[1]
                  ];
          } else {
            return /* tuple */[
                    /* [] */0,
                    rem
                  ];
          }
        } else {
          return /* tuple */[
                  /* [] */0,
                  rem
                ];
        }
        break;
    default:
      return /* tuple */[
              /* [] */0,
              rem
            ];
  }
}

var dummy = /* record */[
  /* type_params : [] */0,
  /* type_arity */0,
  /* type_kind : Type_abstract */0,
  /* type_private : Public */1,
  /* type_manifest : None */0,
  /* type_variance : [] */0,
  /* type_newtype_level : None */0,
  /* type_loc */none,
  /* type_attributes : [] */0
];

function hide_rec_items(param) {
  if (param) {
    var match = param[0];
    if (match.tag === 1) {
      if (match[2] === /* Trec_first */1 && !real_paths[0]) {
        var get_ids = function (param) {
          if (param) {
            var match = param[0];
            if (match.tag === 1 && match[2] >= 2) {
              return /* :: */[
                      match[0],
                      get_ids(param[1])
                    ];
            } else {
              return /* [] */0;
            }
          } else {
            return /* [] */0;
          }
        };
        var ids_000 = match[0];
        var ids_001 = get_ids(param[1]);
        var ids = /* :: */[
          ids_000,
          ids_001
        ];
        return set_printing_env(List.fold_right((function (id) {
                          var partial_arg = rename(id);
                          return (function (param) {
                              return add_type$1(/* false */0, partial_arg, dummy, param);
                            });
                        }), ids, printing_env[0]));
      } else {
        return /* () */0;
      }
    } else {
      return /* () */0;
    }
  } else {
    return /* () */0;
  }
}

function tree_of_modtype(param) {
  switch (param.tag | 0) {
    case 0 : 
        return /* Omty_ident */Block.__(1, [tree_of_path(param[0])]);
    case 1 : 
        return /* Omty_signature */Block.__(2, [tree_of_signature(param[0])]);
    case 2 : 
        var ty_res = param[2];
        var ty_arg = param[1];
        var param$1 = param[0];
        var res;
        if (ty_arg) {
          var mty = ty_arg[0];
          var partial_arg = /* Some */[/* true */1];
          res = wrap_env((function (param$2) {
                  return add_module$1(partial_arg, param$1, mty, param$2);
                }), tree_of_modtype, ty_res);
        } else {
          res = tree_of_modtype(ty_res);
        }
        return /* Omty_functor */Block.__(0, [
                  param$1[/* name */1],
                  may_map(tree_of_modtype, ty_arg),
                  res
                ]);
    case 3 : 
        return /* Omty_alias */Block.__(3, [tree_of_path(param[0])]);
    
  }
}

function tree_of_signature(sg) {
  var partial_arg = printing_env[0];
  return wrap_env((function (env) {
                return env;
              }), (function (param) {
                return tree_of_signature_rec(partial_arg, /* false */0, param);
              }), sg);
}

function tree_of_signature_rec(env$prime, in_type_group, param) {
  if (param) {
    var item = param[0];
    var in_type_group$1;
    var exit = 0;
    if (in_type_group !== 0) {
      if (item.tag === 1) {
        if (item[2] >= 2) {
          in_type_group$1 = /* true */1;
        } else {
          exit = 1;
        }
      } else {
        set_printing_env(env$prime);
        in_type_group$1 = /* false */0;
      }
    } else {
      exit = 1;
    }
    if (exit === 1) {
      set_printing_env(env$prime);
      in_type_group$1 = item.tag === 1 && item[2] < 2 ? /* true */1 : /* false */0;
    }
    var match = filter_rem_sig(item, param[1]);
    var rem = match[1];
    var trees;
    switch (item.tag | 0) {
      case 0 : 
          trees = /* :: */[
            tree_of_value_description(item[0], item[1]),
            /* [] */0
          ];
          break;
      case 1 : 
          var id = item[0];
          if (is_row_name(id[/* name */1])) {
            trees = /* [] */0;
          } else {
            hide_rec_items(/* :: */[
                  item,
                  rem
                ]);
            trees = /* :: */[
              /* Osig_type */Block.__(5, [
                  tree_of_type_decl(id, item[1]),
                  tree_of_rec(item[2])
                ]),
              /* [] */0
            ];
          }
          break;
      case 2 : 
          trees = /* :: */[
            tree_of_extension_constructor(item[0], item[1], item[2]),
            /* [] */0
          ];
          break;
      case 3 : 
          trees = /* :: */[
            /* Osig_module */Block.__(4, [
                item[0][/* name */1],
                tree_of_modtype(item[1][/* md_type */0]),
                tree_of_rec(item[2])
              ]),
            /* [] */0
          ];
          break;
      case 4 : 
          trees = /* :: */[
            tree_of_modtype_declaration(item[0], item[1]),
            /* [] */0
          ];
          break;
      case 5 : 
          trees = /* :: */[
            tree_of_class_declaration(item[0], item[1], item[2]),
            /* [] */0
          ];
          break;
      case 6 : 
          trees = /* :: */[
            tree_of_cltype_declaration(item[0], item[1], item[2]),
            /* [] */0
          ];
          break;
      
    }
    var env$prime$1 = add_signature(/* :: */[
          item,
          match[0]
        ], env$prime);
    return Pervasives.$at(trees, tree_of_signature_rec(env$prime$1, in_type_group$1, rem));
  } else {
    return /* [] */0;
  }
}

function tree_of_modtype_declaration(id, decl) {
  var match = decl[/* mtd_type */0];
  var mty = match ? tree_of_modtype(match[0]) : /* Omty_abstract */0;
  return /* Osig_modtype */Block.__(3, [
            id[/* name */1],
            mty
          ]);
}

function modtype$1(ppf, mty) {
  return Curry._2(out_module_type[0], ppf, tree_of_modtype(mty));
}

function modtype_declaration$1(id, ppf, decl) {
  return Curry._2(out_sig_item[0], ppf, tree_of_modtype_declaration(id, decl));
}

function print_signature(ppf, tree) {
  return Curry._2(Format.fprintf(ppf, /* Format */[
                  /* Formatting_gen */Block.__(18, [
                      /* Open_box */Block.__(1, [/* Format */[
                            /* String_literal */Block.__(11, [
                                "<v>",
                                /* End_of_format */0
                              ]),
                            "<v>"
                          ]]),
                      /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                              /* Close_box */0,
                              /* End_of_format */0
                            ])])
                    ]),
                  "@[<v>%a@]"
                ]), out_signature[0], tree);
}

function signature$3(ppf, sg) {
  return Curry._2(Format.fprintf(ppf, /* Format */[
                  /* Alpha */Block.__(15, [/* End_of_format */0]),
                  "%a"
                ]), print_signature, tree_of_signature(sg));
}

function same_path(t, t$prime) {
  var t$1 = repr(t);
  var t$prime$1 = repr(t$prime);
  if (t$1 === t$prime$1) {
    return /* true */1;
  } else {
    var match = t$1[/* desc */0];
    var match$1 = t$prime$1[/* desc */0];
    if (typeof match === "number") {
      return /* false */0;
    } else if (match.tag === 3) {
      if (typeof match$1 === "number") {
        return /* false */0;
      } else if (match$1.tag === 3) {
        var match$2 = best_type_path(match[0]);
        var s1 = match$2[1];
        var match$3 = best_type_path(match$1[0]);
        var s2 = match$3[1];
        var exit = 0;
        if (typeof s1 === "number") {
          exit = 1;
        } else if (s1.tag) {
          exit = 1;
        } else if (typeof s2 === "number" || !(!s2.tag && s1[0] === s2[0])) {
          return /* false */0;
        } else {
          return /* true */1;
        }
        if (exit === 1) {
          var exit$1 = 0;
          if (typeof s2 === "number") {
            exit$1 = 2;
          } else if (s2.tag) {
            exit$1 = 2;
          } else {
            return /* false */0;
          }
          if (exit$1 === 2) {
            if (same(match$2[0], match$3[0])) {
              var tl = apply_subst(s1, match[1]);
              var tl$prime = apply_subst(s2, match$1[1]);
              if (List.length(tl) === List.length(tl$prime)) {
                return List.for_all2(same_type, tl, tl$prime);
              } else {
                return /* false */0;
              }
            } else {
              return /* false */0;
            }
          }
          
        }
        
      } else {
        return /* false */0;
      }
    } else {
      return /* false */0;
    }
  }
}

function type_expansion(t, ppf, t$prime) {
  if (same_path(t, t$prime)) {
    return type_expr$1(ppf, t);
  } else {
    var t$prime$1 = proxy(t) === proxy(t$prime) ? unalias(t$prime) : t$prime;
    return Curry._4(Format.fprintf(ppf, /* Format */[
                    /* Formatting_gen */Block.__(18, [
                        /* Open_box */Block.__(1, [/* Format */[
                              /* String_literal */Block.__(11, [
                                  "<2>",
                                  /* End_of_format */0
                                ]),
                              "<2>"
                            ]]),
                        /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                /* Break */Block.__(0, [
                                    "@ ",
                                    1,
                                    0
                                  ]),
                                /* Char_literal */Block.__(12, [
                                    /* "=" */61,
                                    /* Formatting_lit */Block.__(17, [
                                        /* Break */Block.__(0, [
                                            "@ ",
                                            1,
                                            0
                                          ]),
                                        /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                /* Close_box */0,
                                                /* End_of_format */0
                                              ])])
                                      ])
                                  ])
                              ])])
                      ]),
                    "@[<2>%a@ =@ %a@]"
                  ]), type_expr$1, t, type_expr$1, t$prime$1);
  }
}

function type_path_expansion(tp, ppf, tp$prime) {
  if (same(tp, tp$prime)) {
    return path(ppf, tp);
  } else {
    return Curry._4(Format.fprintf(ppf, /* Format */[
                    /* Formatting_gen */Block.__(18, [
                        /* Open_box */Block.__(1, [/* Format */[
                              /* String_literal */Block.__(11, [
                                  "<2>",
                                  /* End_of_format */0
                                ]),
                              "<2>"
                            ]]),
                        /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                /* Break */Block.__(0, [
                                    "@ ",
                                    1,
                                    0
                                  ]),
                                /* Char_literal */Block.__(12, [
                                    /* "=" */61,
                                    /* Formatting_lit */Block.__(17, [
                                        /* Break */Block.__(0, [
                                            "@ ",
                                            1,
                                            0
                                          ]),
                                        /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                /* Close_box */0,
                                                /* End_of_format */0
                                              ])])
                                      ])
                                  ])
                              ])])
                      ]),
                    "@[<2>%a@ =@ %a@]"
                  ]), path, tp, path, tp$prime);
  }
}

function trace(fst, txt, ppf, param) {
  if (param) {
    var match = param[1];
    if (match) {
      var match$1 = match[0];
      var t2 = match$1[0];
      var match$2 = param[0];
      var t1 = match$2[0];
      if (!fst) {
        Format.fprintf(ppf, /* Format */[
              /* Formatting_lit */Block.__(17, [
                  /* Break */Block.__(0, [
                      "@,",
                      0,
                      0
                    ]),
                  /* End_of_format */0
                ]),
              "@,"
            ]);
      }
      return Curry._7(Format.fprintf(ppf, /* Format */[
                      /* Formatting_gen */Block.__(18, [
                          /* Open_box */Block.__(1, [/* Format */[
                                /* End_of_format */0,
                                ""
                              ]]),
                          /* String_literal */Block.__(11, [
                              "Type",
                              /* Formatting_lit */Block.__(17, [
                                  /* Break */Block.__(0, [
                                      "@;<1 2>",
                                      1,
                                      2
                                    ]),
                                  /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                          /* Break */Block.__(0, [
                                              "@ ",
                                              1,
                                              0
                                            ]),
                                          /* String */Block.__(2, [
                                              /* No_padding */0,
                                              /* Formatting_lit */Block.__(17, [
                                                  /* Break */Block.__(0, [
                                                      "@;<1 2>",
                                                      1,
                                                      2
                                                    ]),
                                                  /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                          /* Close_box */0,
                                                          /* Char_literal */Block.__(12, [
                                                              /* " " */32,
                                                              /* Alpha */Block.__(15, [/* End_of_format */0])
                                                            ])
                                                        ])])
                                                ])
                                            ])
                                        ])])
                                ])
                            ])
                        ]),
                      "@[Type@;<1 2>%a@ %s@;<1 2>%a@] %a"
                    ]), (function (param, param$1) {
                    return type_expansion(t1, param, param$1);
                  }), match$2[1], txt, (function (param, param$1) {
                    return type_expansion(t2, param, param$1);
                  }), match$1[1], (function (param, param$1) {
                    return trace(/* false */0, txt, param, param$1);
                  }), match[1]);
    } else {
      return /* () */0;
    }
  } else {
    return /* () */0;
  }
}

function filter_trace(keep_last, param) {
  if (param) {
    var match = param[1];
    if (match) {
      var rem = match[1];
      var match$1 = match[0];
      var t2$prime = match$1[1];
      var t2 = match$1[0];
      var match$2 = param[0];
      var t1$prime = match$2[1];
      var t1 = match$2[0];
      var exit = 0;
      if (rem) {
        exit = 1;
      } else if (is_Tvar(t1$prime) || is_Tvar(t2$prime)) {
        return /* [] */0;
      } else {
        exit = 1;
      }
      if (exit === 1) {
        var rem$prime = filter_trace(keep_last, rem);
        if (is_constr_row(t1$prime) || is_constr_row(t2$prime) || same_path(t1, t1$prime) && same_path(t2, t2$prime) && !(keep_last && rem$prime === /* [] */0)) {
          return rem$prime;
        } else {
          return /* :: */[
                  /* tuple */[
                    t1,
                    t1$prime
                  ],
                  /* :: */[
                    /* tuple */[
                      t2,
                      t2$prime
                    ],
                    rem$prime
                  ]
                ];
        }
      }
      
    } else {
      return /* [] */0;
    }
  } else {
    return /* [] */0;
  }
}

function type_path_list(ppf, param) {
  if (param) {
    var rem = param[1];
    var match = param[0];
    var tp$prime = match[1];
    var tp = match[0];
    if (rem) {
      return Curry._4(Format.fprintf(ppf, /* Format */[
                      /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                              /* Break */Block.__(0, [
                                  "@;<2 0>",
                                  2,
                                  0
                                ]),
                              /* Alpha */Block.__(15, [/* End_of_format */0])
                            ])]),
                      "%a@;<2 0>%a"
                    ]), (function (param, param$1) {
                    return type_path_expansion(tp, param, param$1);
                  }), tp$prime, type_path_list, rem);
    } else {
      return type_path_expansion(tp, ppf, tp$prime);
    }
  } else {
    return /* () */0;
  }
}

function hide_variant_name(t) {
  var t$1 = repr(t);
  var match = t$1[/* desc */0];
  if (typeof match === "number") {
    return t;
  } else if (match.tag === 8) {
    var row = match[0];
    if (row_repr_aux(/* [] */0, row)[/* row_name */5] !== /* None */0) {
      var init = row_repr_aux(/* [] */0, row);
      var level = row_more(row)[/* level */1];
      return newty2(t$1[/* level */1], /* Tvariant */Block.__(8, [/* record */[
                      /* row_fields */init[/* row_fields */0],
                      /* row_more */newty2(level, /* Tvar */Block.__(0, [/* None */0])),
                      /* row_bound */init[/* row_bound */2],
                      /* row_closed */init[/* row_closed */3],
                      /* row_fixed */init[/* row_fixed */4],
                      /* row_name : None */0
                    ]]));
    } else {
      return t;
    }
  } else {
    return t;
  }
}

function prepare_expansion(param) {
  var t = param[0];
  var t$prime = hide_variant_name(param[1]);
  mark_loops(t);
  if (!same_path(t, t$prime)) {
    mark_loops(t$prime);
  }
  return /* tuple */[
          t,
          t$prime
        ];
}

function may_prepare_expansion(compact, param) {
  var t$prime = param[1];
  var t = param[0];
  var match = repr(t$prime)[/* desc */0];
  var exit = 0;
  if (typeof match === "number") {
    return prepare_expansion(/* tuple */[
                t,
                t$prime
              ]);
  } else {
    switch (match.tag | 0) {
      case 4 : 
      case 8 : 
          exit = 1;
          break;
      default:
        return prepare_expansion(/* tuple */[
                    t,
                    t$prime
                  ]);
    }
  }
  if (exit === 1) {
    if (compact) {
      mark_loops(t);
      return /* tuple */[
              t,
              t
            ];
    } else {
      return prepare_expansion(/* tuple */[
                  t,
                  t$prime
                ]);
    }
  }
  
}

function print_tags(ppf, fields) {
  if (fields) {
    Curry._1(Format.fprintf(ppf, /* Format */[
              /* Char_literal */Block.__(12, [
                  /* "`" */96,
                  /* String */Block.__(2, [
                      /* No_padding */0,
                      /* End_of_format */0
                    ])
                ]),
              "`%s"
            ]), fields[0][0]);
    return List.iter((function (param) {
                  return Curry._1(Format.fprintf(ppf, /* Format */[
                                  /* Char_literal */Block.__(12, [
                                      /* "," */44,
                                      /* Formatting_lit */Block.__(17, [
                                          /* Break */Block.__(0, [
                                              "@ ",
                                              1,
                                              0
                                            ]),
                                          /* Char_literal */Block.__(12, [
                                              /* "`" */96,
                                              /* String */Block.__(2, [
                                                  /* No_padding */0,
                                                  /* End_of_format */0
                                                ])
                                            ])
                                        ])
                                    ]),
                                  ",@ `%s"
                                ]), param[0]);
                }), fields[1]);
  } else {
    return /* () */0;
  }
}

function has_explanation(_, t3, t4) {
  var match = t3[/* desc */0];
  var match$1 = t4[/* desc */0];
  var exit = 0;
  var exit$1 = 0;
  var exit$2 = 0;
  if (typeof match === "number") {
    if (match) {
      exit$2 = 3;
    } else if (typeof match$1 === "number") {
      exit$1 = 2;
    } else {
      switch (match$1.tag | 0) {
        case 0 : 
            exit$2 = 3;
            break;
        case 3 : 
            return /* true */1;
        default:
          exit$1 = 2;
      }
    }
  } else {
    switch (match.tag | 0) {
      case 0 : 
          return /* true */1;
      case 3 : 
          if (typeof match$1 === "number") {
            if (match$1) {
              exit$1 = 2;
            } else {
              return /* true */1;
            }
          } else if (match$1.tag) {
            exit$1 = 2;
          } else {
            exit$2 = 3;
          }
          break;
      case 5 : 
          var match$2 = match[3][/* desc */0];
          var exit$3 = 0;
          if (typeof match$2 === "number") {
            if (typeof match$1 === "number") {
              if (match$1) {
                return /* false */0;
              } else {
                exit$3 = 4;
              }
            } else {
              switch (match$1.tag | 0) {
                case 0 : 
                    exit$2 = 3;
                    break;
                case 3 : 
                    exit$3 = 4;
                    break;
                case 5 : 
                    var match$3 = match$1[3][/* desc */0];
                    if (typeof match$3 === "number") {
                      return +(match[0] === match$1[0]);
                    } else {
                      return /* false */0;
                    }
                default:
                  return /* false */0;
              }
            }
          } else {
            exit$3 = 4;
          }
          if (exit$3 === 4) {
            if (typeof match$1 === "number") {
              if (match$1) {
                return /* false */0;
              } else {
                return /* true */1;
              }
            } else {
              switch (match$1.tag | 0) {
                case 0 : 
                    exit$2 = 3;
                    break;
                case 3 : 
                    return /* true */1;
                default:
                  return /* false */0;
              }
            }
          }
          break;
      case 8 : 
          if (typeof match$1 === "number") {
            return /* false */0;
          } else {
            switch (match$1.tag | 0) {
              case 0 : 
                  exit$2 = 3;
                  break;
              case 8 : 
                  return /* true */1;
              default:
                return /* false */0;
            }
          }
          break;
      default:
        exit$2 = 3;
    }
  }
  if (exit$2 === 3) {
    if (typeof match$1 === "number") {
      exit$1 = 2;
    } else if (match$1.tag) {
      exit$1 = 2;
    } else {
      return /* true */1;
    }
  }
  if (exit$1 === 2) {
    if (typeof match === "number") {
      if (match) {
        return /* false */0;
      } else {
        exit = 1;
      }
    } else if (match.tag === 3) {
      exit = 1;
    } else {
      return /* false */0;
    }
  }
  if (exit === 1) {
    if (typeof match$1 === "number" || match$1.tag !== 5) {
      return /* false */0;
    } else {
      return /* true */1;
    }
  }
  
}

function mismatch(unif, param) {
  if (param) {
    var match = param[1];
    if (match) {
      var t$prime = match[0][1];
      var t = param[0][1];
      var m = mismatch(unif, match[1]);
      if (m) {
        return m;
      } else if (has_explanation(unif, t, t$prime)) {
        return /* Some */[/* tuple */[
                  t,
                  t$prime
                ]];
      } else {
        return /* None */0;
      }
    } else {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "printtyp.ml",
              1339,
              9
            ]
          ];
    }
  } else {
    return /* None */0;
  }
}

function explanation(unif, mis, ppf) {
  if (mis) {
    var match = mis[0];
    var unif$1 = unif;
    var t3 = match[0];
    var t4 = match[1];
    var ppf$1 = ppf;
    var match$1 = t3[/* desc */0];
    var match$2 = t4[/* desc */0];
    var exit = 0;
    var exit$1 = 0;
    var lab;
    var exit$2 = 0;
    var exit$3 = 0;
    var exit$4 = 0;
    if (typeof match$1 === "number") {
      if (match$1) {
        exit$4 = 9;
      } else if (typeof match$2 === "number") {
        exit = 2;
      } else {
        switch (match$2.tag | 0) {
          case 0 : 
              exit$4 = 9;
              break;
          case 3 : 
              exit = 1;
              break;
          case 5 : 
              exit$2 = 7;
              break;
          default:
            exit = 2;
        }
      }
    } else {
      switch (match$1.tag | 0) {
        case 0 : 
            if (typeof match$2 === "number") {
              exit$1 = 5;
            } else {
              switch (match$2.tag | 0) {
                case 2 : 
                    exit$1 = match$2[0] ? 5 : 3;
                    break;
                case 3 : 
                    var p = match$2[0];
                    if (unif$1 && t3[/* level */1] < binding_time(p)) {
                      return Curry._2(Format.fprintf(ppf$1, /* Format */[
                                      /* Formatting_lit */Block.__(17, [
                                          /* Break */Block.__(0, [
                                              "@,",
                                              0,
                                              0
                                            ]),
                                          /* Formatting_gen */Block.__(18, [
                                              /* Open_box */Block.__(1, [/* Format */[
                                                    /* End_of_format */0,
                                                    ""
                                                  ]]),
                                              /* String_literal */Block.__(11, [
                                                  "The type constructor",
                                                  /* Formatting_lit */Block.__(17, [
                                                      /* Break */Block.__(0, [
                                                          "@;<1 2>",
                                                          1,
                                                          2
                                                        ]),
                                                      /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                              /* Break */Block.__(0, [
                                                                  "@ ",
                                                                  1,
                                                                  0
                                                                ]),
                                                              /* String_literal */Block.__(11, [
                                                                  "would escape its scope",
                                                                  /* Formatting_lit */Block.__(17, [
                                                                      /* Close_box */0,
                                                                      /* End_of_format */0
                                                                    ])
                                                                ])
                                                            ])])
                                                    ])
                                                ])
                                            ])
                                        ]),
                                      "@,@[The type constructor@;<1 2>%a@ would escape its scope@]"
                                    ]), path, p);
                    } else {
                      exit$1 = 5;
                    }
                    break;
                case 9 : 
                    exit$1 = 4;
                    break;
                default:
                  exit$1 = 5;
              }
            }
            break;
        case 2 : 
            if (match$1[0]) {
              exit$4 = 9;
            } else if (typeof match$2 === "number") {
              exit = 2;
            } else {
              switch (match$2.tag | 0) {
                case 0 : 
                    exit$1 = 3;
                    break;
                case 5 : 
                    exit$2 = 7;
                    break;
                default:
                  exit = 2;
              }
            }
            break;
        case 3 : 
            var p$1 = match$1[0];
            if (typeof match$2 === "number") {
              exit = match$2 ? 2 : 1;
            } else {
              switch (match$2.tag | 0) {
                case 0 : 
                    if (unif$1 && t4[/* level */1] < binding_time(p$1)) {
                      return Curry._2(Format.fprintf(ppf$1, /* Format */[
                                      /* Formatting_lit */Block.__(17, [
                                          /* Break */Block.__(0, [
                                              "@,",
                                              0,
                                              0
                                            ]),
                                          /* Formatting_gen */Block.__(18, [
                                              /* Open_box */Block.__(1, [/* Format */[
                                                    /* End_of_format */0,
                                                    ""
                                                  ]]),
                                              /* String_literal */Block.__(11, [
                                                  "The type constructor",
                                                  /* Formatting_lit */Block.__(17, [
                                                      /* Break */Block.__(0, [
                                                          "@;<1 2>",
                                                          1,
                                                          2
                                                        ]),
                                                      /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                              /* Break */Block.__(0, [
                                                                  "@ ",
                                                                  1,
                                                                  0
                                                                ]),
                                                              /* String_literal */Block.__(11, [
                                                                  "would escape its scope",
                                                                  /* Formatting_lit */Block.__(17, [
                                                                      /* Close_box */0,
                                                                      /* End_of_format */0
                                                                    ])
                                                                ])
                                                            ])])
                                                    ])
                                                ])
                                            ])
                                        ]),
                                      "@,@[The type constructor@;<1 2>%a@ would escape its scope@]"
                                    ]), path, p$1);
                    } else {
                      exit$4 = 9;
                    }
                    break;
                case 5 : 
                    exit$2 = 7;
                    break;
                default:
                  exit = 2;
              }
            }
            break;
        case 8 : 
            if (typeof match$2 === "number") {
              exit = 2;
            } else {
              switch (match$2.tag | 0) {
                case 0 : 
                    exit$4 = 9;
                    break;
                case 5 : 
                    exit$2 = 7;
                    break;
                case 8 : 
                    var row1 = row_repr_aux(/* [] */0, match$1[0]);
                    var row2 = row_repr_aux(/* [] */0, match$2[0]);
                    var match$3 = row1[/* row_fields */0];
                    var match$4 = row1[/* row_closed */3];
                    var match$5 = row2[/* row_fields */0];
                    var match$6 = row2[/* row_closed */3];
                    var exit$5 = 0;
                    if (match$3) {
                      if (match$3[1]) {
                        exit$5 = 10;
                      } else if (match$4 !== 0) {
                        if (match$5) {
                          if (match$5[1]) {
                            return /* () */0;
                          } else if (match$6 !== 0) {
                            var l1 = match$3[0][0];
                            if (l1 === match$5[0][0]) {
                              return Curry._1(Format.fprintf(ppf$1, /* Format */[
                                              /* Formatting_lit */Block.__(17, [
                                                  /* Break */Block.__(0, [
                                                      "@,",
                                                      0,
                                                      0
                                                    ]),
                                                  /* String_literal */Block.__(11, [
                                                      "Types for tag `",
                                                      /* String */Block.__(2, [
                                                          /* No_padding */0,
                                                          /* String_literal */Block.__(11, [
                                                              " are incompatible",
                                                              /* End_of_format */0
                                                            ])
                                                        ])
                                                    ])
                                                ]),
                                              "@,Types for tag `%s are incompatible"
                                            ]), l1);
                            } else {
                              return /* () */0;
                            }
                          } else {
                            return /* () */0;
                          }
                        } else {
                          exit$5 = 10;
                        }
                      } else {
                        exit$5 = 10;
                      }
                    } else if (match$4 !== 0) {
                      var exit$6 = 0;
                      if (match$5) {
                        exit$6 = 11;
                      } else if (match$6 !== 0) {
                        return Format.fprintf(ppf$1, /* Format */[
                                    /* Formatting_lit */Block.__(17, [
                                        /* Break */Block.__(0, [
                                            "@,",
                                            0,
                                            0
                                          ]),
                                        /* String_literal */Block.__(11, [
                                            "These two variant types have no intersection",
                                            /* End_of_format */0
                                          ])
                                      ]),
                                    "@,These two variant types have no intersection"
                                  ]);
                      } else {
                        exit$6 = 11;
                      }
                      if (exit$6 === 11) {
                        return Curry._2(Format.fprintf(ppf$1, /* Format */[
                                        /* Formatting_lit */Block.__(17, [
                                            /* Break */Block.__(0, [
                                                "@,",
                                                0,
                                                0
                                              ]),
                                            /* Formatting_gen */Block.__(18, [
                                                /* Open_box */Block.__(1, [/* Format */[
                                                      /* End_of_format */0,
                                                      ""
                                                    ]]),
                                                /* String_literal */Block.__(11, [
                                                    "The first variant type does not allow tag(s)",
                                                    /* Formatting_lit */Block.__(17, [
                                                        /* Break */Block.__(0, [
                                                            "@ ",
                                                            1,
                                                            0
                                                          ]),
                                                        /* Formatting_gen */Block.__(18, [
                                                            /* Open_box */Block.__(1, [/* Format */[
                                                                  /* String_literal */Block.__(11, [
                                                                      "<hov>",
                                                                      /* End_of_format */0
                                                                    ]),
                                                                  "<hov>"
                                                                ]]),
                                                            /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                    /* Close_box */0,
                                                                    /* Formatting_lit */Block.__(17, [
                                                                        /* Close_box */0,
                                                                        /* End_of_format */0
                                                                      ])
                                                                  ])])
                                                          ])
                                                      ])
                                                  ])
                                              ])
                                          ]),
                                        "@,@[The first variant type does not allow tag(s)@ @[<hov>%a@]@]"
                                      ]), print_tags, match$5);
                      }
                      
                    } else {
                      exit$5 = 10;
                    }
                    if (exit$5 === 10) {
                      if (match$5 || match$6 === 0) {
                        return /* () */0;
                      } else {
                        return Curry._2(Format.fprintf(ppf$1, /* Format */[
                                        /* Formatting_lit */Block.__(17, [
                                            /* Break */Block.__(0, [
                                                "@,",
                                                0,
                                                0
                                              ]),
                                            /* Formatting_gen */Block.__(18, [
                                                /* Open_box */Block.__(1, [/* Format */[
                                                      /* End_of_format */0,
                                                      ""
                                                    ]]),
                                                /* String_literal */Block.__(11, [
                                                    "The second variant type does not allow tag(s)",
                                                    /* Formatting_lit */Block.__(17, [
                                                        /* Break */Block.__(0, [
                                                            "@ ",
                                                            1,
                                                            0
                                                          ]),
                                                        /* Formatting_gen */Block.__(18, [
                                                            /* Open_box */Block.__(1, [/* Format */[
                                                                  /* String_literal */Block.__(11, [
                                                                      "<hov>",
                                                                      /* End_of_format */0
                                                                    ]),
                                                                  "<hov>"
                                                                ]]),
                                                            /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                    /* Close_box */0,
                                                                    /* Formatting_lit */Block.__(17, [
                                                                        /* Close_box */0,
                                                                        /* End_of_format */0
                                                                      ])
                                                                  ])])
                                                          ])
                                                      ])
                                                  ])
                                              ])
                                          ]),
                                        "@,@[The second variant type does not allow tag(s)@ @[<hov>%a@]@]"
                                      ]), print_tags, match$3);
                      }
                    }
                    break;
                default:
                  exit = 2;
              }
            }
            break;
        case 9 : 
            if (typeof match$2 === "number") {
              exit = 2;
            } else {
              switch (match$2.tag | 0) {
                case 0 : 
                    exit$1 = 4;
                    break;
                case 5 : 
                    exit$2 = 7;
                    break;
                default:
                  exit = 2;
              }
            }
            break;
        default:
          exit$4 = 9;
      }
    }
    if (exit$4 === 9) {
      if (typeof match$2 === "number" || match$2.tag) {
        exit$3 = 8;
      } else {
        exit$1 = 5;
      }
    }
    if (exit$3 === 8) {
      if (typeof match$1 === "number") {
        exit$2 = 7;
      } else if (match$1.tag === 5) {
        lab = match$1[0];
        exit$1 = 6;
      } else {
        exit$2 = 7;
      }
    }
    if (exit$2 === 7) {
      if (typeof match$2 === "number") {
        exit = 2;
      } else if (match$2.tag === 5) {
        lab = match$2[0];
        exit$1 = 6;
      } else {
        exit = 2;
      }
    }
    switch (exit$1) {
      case 3 : 
          return Format.fprintf(ppf$1, /* Format */[
                      /* Formatting_lit */Block.__(17, [
                          /* Break */Block.__(0, [
                              "@,",
                              0,
                              0
                            ]),
                          /* String_literal */Block.__(11, [
                              "Self type cannot escape its class",
                              /* End_of_format */0
                            ])
                        ]),
                      "@,Self type cannot escape its class"
                    ]);
      case 4 : 
          return Curry._2(Format.fprintf(ppf$1, /* Format */[
                          /* Formatting_lit */Block.__(17, [
                              /* Break */Block.__(0, [
                                  "@,",
                                  0,
                                  0
                                ]),
                              /* String_literal */Block.__(11, [
                                  "The universal variable ",
                                  /* Alpha */Block.__(15, [/* String_literal */Block.__(11, [
                                          " would escape its scope",
                                          /* End_of_format */0
                                        ])])
                                ])
                            ]),
                          "@,The universal variable %a would escape its scope"
                        ]), type_expr$1, is_Tunivar(t3) ? t3 : t4);
      case 5 : 
          var match$7 = is_Tvar(t3) ? /* tuple */[
              t3,
              t4
            ] : /* tuple */[
              t4,
              t3
            ];
          var t$prime = match$7[1];
          var t = match$7[0];
          if (occur_in(empty, t, t$prime)) {
            return Curry._4(Format.fprintf(ppf$1, /* Format */[
                            /* Formatting_lit */Block.__(17, [
                                /* Break */Block.__(0, [
                                    "@,",
                                    0,
                                    0
                                  ]),
                                /* Formatting_gen */Block.__(18, [
                                    /* Open_box */Block.__(1, [/* Format */[
                                          /* String_literal */Block.__(11, [
                                              "<hov>",
                                              /* End_of_format */0
                                            ]),
                                          "<hov>"
                                        ]]),
                                    /* String_literal */Block.__(11, [
                                        "The type variable ",
                                        /* Alpha */Block.__(15, [/* String_literal */Block.__(11, [
                                                " occurs inside",
                                                /* Formatting_lit */Block.__(17, [
                                                    /* Break */Block.__(0, [
                                                        "@ ",
                                                        1,
                                                        0
                                                      ]),
                                                    /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                            /* Close_box */0,
                                                            /* End_of_format */0
                                                          ])])
                                                  ])
                                              ])])
                                      ])
                                  ])
                              ]),
                            "@,@[<hov>The type variable %a occurs inside@ %a@]"
                          ]), type_expr$1, t, type_expr$1, t$prime);
          } else {
            return Curry._3(Format.fprintf(ppf$1, /* Format */[
                            /* Formatting_lit */Block.__(17, [
                                /* Break */Block.__(0, [
                                    "@,",
                                    0,
                                    0
                                  ]),
                                /* Formatting_gen */Block.__(18, [
                                    /* Open_box */Block.__(1, [/* Format */[
                                          /* String_literal */Block.__(11, [
                                              "<hov>",
                                              /* End_of_format */0
                                            ]),
                                          "<hov>"
                                        ]]),
                                    /* String_literal */Block.__(11, [
                                        "This instance of ",
                                        /* Alpha */Block.__(15, [/* String_literal */Block.__(11, [
                                                " is ambiguous:",
                                                /* Formatting_lit */Block.__(17, [
                                                    /* Break */Block.__(0, [
                                                        "@ ",
                                                        1,
                                                        0
                                                      ]),
                                                    /* String */Block.__(2, [
                                                        /* No_padding */0,
                                                        /* Formatting_lit */Block.__(17, [
                                                            /* Close_box */0,
                                                            /* End_of_format */0
                                                          ])
                                                      ])
                                                  ])
                                              ])])
                                      ])
                                  ])
                              ]),
                            "@,@[<hov>This instance of %a is ambiguous:@ %s@]"
                          ]), type_expr$1, t$prime, "it would escape the scope of its equation");
          }
      case 6 : 
          if (lab === dummy_method) {
            return Format.fprintf(ppf$1, /* Format */[
                        /* Formatting_lit */Block.__(17, [
                            /* Break */Block.__(0, [
                                "@,",
                                0,
                                0
                              ]),
                            /* String_literal */Block.__(11, [
                                "Self type cannot be unified with a closed object type",
                                /* End_of_format */0
                              ])
                          ]),
                        "@,Self type cannot be unified with a closed object type"
                      ]);
          } else {
            exit = 2;
          }
          break;
      
    }
    switch (exit) {
      case 1 : 
          return Curry._1(Format.fprintf(ppf$1, /* Format */[
                          /* Formatting_lit */Block.__(17, [
                              /* Break */Block.__(0, [
                                  "@,",
                                  0,
                                  0
                                ]),
                              /* Formatting_gen */Block.__(18, [
                                  /* Open_box */Block.__(1, [/* Format */[
                                        /* End_of_format */0,
                                        ""
                                      ]]),
                                  /* String_literal */Block.__(11, [
                                      "The ",
                                      /* String */Block.__(2, [
                                          /* No_padding */0,
                                          /* String_literal */Block.__(11, [
                                              " object type has an abstract row, it cannot be closed",
                                              /* Formatting_lit */Block.__(17, [
                                                  /* Close_box */0,
                                                  /* End_of_format */0
                                                ])
                                            ])
                                        ])
                                    ])
                                ])
                            ]),
                          "@,@[The %s object type has an abstract row, it cannot be closed@]"
                        ]), t4[/* desc */0] ? "second" : "first");
      case 2 : 
          var exit$7 = 0;
          if (typeof match$1 === "number") {
            if (match$1) {
              return /* () */0;
            } else {
              exit$7 = 3;
            }
          } else {
            switch (match$1.tag | 0) {
              case 3 : 
                  exit$7 = 3;
                  break;
              case 5 : 
                  var l = match$1[0];
                  var match$8 = match$1[3][/* desc */0];
                  var exit$8 = 0;
                  if (typeof match$8 === "number") {
                    if (typeof match$2 === "number") {
                      if (match$2) {
                        return /* () */0;
                      } else {
                        exit$8 = 4;
                      }
                    } else {
                      switch (match$2.tag | 0) {
                        case 3 : 
                            exit$8 = 4;
                            break;
                        case 5 : 
                            var match$9 = match$2[3][/* desc */0];
                            if (typeof match$9 === "number" && l === match$2[0]) {
                              return Curry._1(Format.fprintf(ppf$1, /* Format */[
                                              /* Formatting_lit */Block.__(17, [
                                                  /* Break */Block.__(0, [
                                                      "@,",
                                                      0,
                                                      0
                                                    ]),
                                                  /* String_literal */Block.__(11, [
                                                      "Types for method ",
                                                      /* String */Block.__(2, [
                                                          /* No_padding */0,
                                                          /* String_literal */Block.__(11, [
                                                              " are incompatible",
                                                              /* End_of_format */0
                                                            ])
                                                        ])
                                                    ])
                                                ]),
                                              "@,Types for method %s are incompatible"
                                            ]), l);
                            } else {
                              return /* () */0;
                            }
                        default:
                          return /* () */0;
                      }
                    }
                  } else {
                    exit$8 = 4;
                  }
                  if (exit$8 === 4) {
                    var exit$9 = 0;
                    if (typeof match$2 === "number") {
                      if (match$2) {
                        return /* () */0;
                      } else {
                        exit$9 = 5;
                      }
                    } else if (match$2.tag === 3) {
                      exit$9 = 5;
                    } else {
                      return /* () */0;
                    }
                    if (exit$9 === 5) {
                      return Curry._1(Format.fprintf(ppf$1, /* Format */[
                                      /* Formatting_lit */Block.__(17, [
                                          /* Break */Block.__(0, [
                                              "@,",
                                              0,
                                              0
                                            ]),
                                          /* Formatting_gen */Block.__(18, [
                                              /* Open_box */Block.__(1, [/* Format */[
                                                    /* End_of_format */0,
                                                    ""
                                                  ]]),
                                              /* String_literal */Block.__(11, [
                                                  "The second object type has no method ",
                                                  /* String */Block.__(2, [
                                                      /* No_padding */0,
                                                      /* Formatting_lit */Block.__(17, [
                                                          /* Close_box */0,
                                                          /* End_of_format */0
                                                        ])
                                                    ])
                                                ])
                                            ])
                                        ]),
                                      "@,@[The second object type has no method %s@]"
                                    ]), l);
                    }
                    
                  }
                  break;
              default:
                return /* () */0;
            }
          }
          if (exit$7 === 3) {
            if (typeof match$2 === "number" || match$2.tag !== 5) {
              return /* () */0;
            } else {
              return Curry._1(Format.fprintf(ppf$1, /* Format */[
                              /* Formatting_lit */Block.__(17, [
                                  /* Break */Block.__(0, [
                                      "@,",
                                      0,
                                      0
                                    ]),
                                  /* Formatting_gen */Block.__(18, [
                                      /* Open_box */Block.__(1, [/* Format */[
                                            /* End_of_format */0,
                                            ""
                                          ]]),
                                      /* String_literal */Block.__(11, [
                                          "The first object type has no method ",
                                          /* String */Block.__(2, [
                                              /* No_padding */0,
                                              /* Formatting_lit */Block.__(17, [
                                                  /* Close_box */0,
                                                  /* End_of_format */0
                                                ])
                                            ])
                                        ])
                                    ])
                                ]),
                              "@,@[The first object type has no method %s@]"
                            ]), match$2[0]);
            }
          }
          break;
      
    }
  } else {
    return /* () */0;
  }
}

function path_same_name(_p1, _p2) {
  while(true) {
    var p2 = _p2;
    var p1 = _p1;
    switch (p1.tag | 0) {
      case 0 : 
          switch (p2.tag | 0) {
            case 0 : 
                var id1 = p1[0];
                var id2 = p2[0];
                if (equal(id1, id2) && !Caml_obj.caml_equal(id1, id2)) {
                  add_unique(id1);
                  return add_unique(id2);
                } else {
                  return 0;
                }
            case 1 : 
            case 2 : 
                return /* () */0;
            
          }
          break;
      case 1 : 
          switch (p2.tag | 0) {
            case 1 : 
                if (p1[1] === p2[1]) {
                  _p2 = p2[0];
                  _p1 = p1[0];
                  continue ;
                  
                } else {
                  return /* () */0;
                }
                break;
            case 0 : 
            case 2 : 
                return /* () */0;
            
          }
          break;
      case 2 : 
          switch (p2.tag | 0) {
            case 0 : 
            case 1 : 
                return /* () */0;
            case 2 : 
                path_same_name(p1[0], p2[0]);
                _p2 = p2[1];
                _p1 = p1[1];
                continue ;
                
          }
          break;
      
    }
  };
}

function type_same_name(t1, t2) {
  var match = repr(t1)[/* desc */0];
  var match$1 = repr(t2)[/* desc */0];
  if (typeof match === "number" || !(match.tag === 3 && !(typeof match$1 === "number" || match$1.tag !== 3))) {
    return /* () */0;
  } else {
    return path_same_name(best_type_path(match[0])[0], best_type_path(match$1[0])[0]);
  }
}

function trace_same_names(_param) {
  while(true) {
    var param = _param;
    if (param) {
      var match = param[1];
      if (match) {
        var match$1 = match[0];
        var match$2 = param[0];
        type_same_name(match$2[0], match$1[0]);
        type_same_name(match$2[1], match$1[1]);
        _param = match[1];
        continue ;
        
      } else {
        return /* () */0;
      }
    } else {
      return /* () */0;
    }
  };
}

function report_unification_error(ppf, env, $staropt$star, tr, txt1, txt2) {
  var unif = $staropt$star ? $staropt$star[0] : /* true */1;
  return wrap_printing_env(env, (function () {
                var unif$1 = unif;
                var tr$1 = tr;
                var txt1$1 = txt1;
                var ppf$1 = ppf;
                var txt2$1 = txt2;
                reset(/* () */0);
                trace_same_names(tr$1);
                var tr$2 = List.map((function (param) {
                        return /* tuple */[
                                param[0],
                                hide_variant_name(param[1])
                              ];
                      }), tr$1);
                var mis = mismatch(unif$1, tr$2);
                if (tr$2) {
                  var match = tr$2[1];
                  if (match) {
                    try {
                      var tr$3 = filter_trace(+(mis === /* None */0), match[1]);
                      var match$1 = may_prepare_expansion(+(tr$3 === /* [] */0), tr$2[0]);
                      var t1 = match$1[0];
                      var match$2 = may_prepare_expansion(+(tr$3 === /* [] */0), match[0]);
                      var t2 = match$2[0];
                      print_labels[0] = 1 - classic[0];
                      var tr$4 = List.map(prepare_expansion, tr$3);
                      Curry.app(Format.fprintf(ppf$1, /* Format */[
                                /* Formatting_gen */Block.__(18, [
                                    /* Open_box */Block.__(1, [/* Format */[
                                          /* String_literal */Block.__(11, [
                                              "<v>",
                                              /* End_of_format */0
                                            ]),
                                          "<v>"
                                        ]]),
                                    /* Formatting_gen */Block.__(18, [
                                        /* Open_box */Block.__(1, [/* Format */[
                                              /* End_of_format */0,
                                              ""
                                            ]]),
                                        /* Theta */Block.__(16, [/* Formatting_lit */Block.__(17, [
                                                /* Break */Block.__(0, [
                                                    "@;<1 2>",
                                                    1,
                                                    2
                                                  ]),
                                                /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                        /* Break */Block.__(0, [
                                                            "@ ",
                                                            1,
                                                            0
                                                          ]),
                                                        /* Theta */Block.__(16, [/* Formatting_lit */Block.__(17, [
                                                                /* Break */Block.__(0, [
                                                                    "@;<1 2>",
                                                                    1,
                                                                    2
                                                                  ]),
                                                                /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                        /* Close_box */0,
                                                                        /* Alpha */Block.__(15, [/* Theta */Block.__(16, [/* Formatting_lit */Block.__(17, [
                                                                                    /* Close_box */0,
                                                                                    /* End_of_format */0
                                                                                  ])])])
                                                                      ])])
                                                              ])])
                                                      ])])
                                              ])])
                                      ])
                                  ]),
                                "@[<v>@[%t@;<1 2>%a@ %t@;<1 2>%a@]%a%t@]"
                              ]), [
                            txt1$1,
                            (function (param, param$1) {
                                return type_expansion(t1, param, param$1);
                              }),
                            match$1[1],
                            txt2$1,
                            (function (param, param$1) {
                                return type_expansion(t2, param, param$1);
                              }),
                            match$2[1],
                            (function (param, param$1) {
                                return trace(/* false */0, "is not compatible with type", param, param$1);
                              }),
                            tr$4,
                            (function (param) {
                                return explanation(unif$1, mis, param);
                              })
                          ]);
                      print_labels[0] = /* true */1;
                      return /* () */0;
                    }
                    catch (exn){
                      print_labels[0] = /* true */1;
                      throw exn;
                    }
                  } else {
                    throw [
                          Caml_builtin_exceptions.assert_failure,
                          [
                            "printtyp.ml",
                            1438,
                            20
                          ]
                        ];
                  }
                } else {
                  throw [
                        Caml_builtin_exceptions.assert_failure,
                        [
                          "printtyp.ml",
                          1438,
                          20
                        ]
                      ];
                }
              }));
}

function trace$1(fst, keep_last, txt, ppf, tr) {
  print_labels[0] = 1 - classic[0];
  trace_same_names(tr);
  try {
    if (tr) {
      var match = tr[1];
      if (match) {
        if (fst) {
          trace(fst, txt, ppf, /* :: */[
                tr[0],
                /* :: */[
                  match[0],
                  filter_trace(keep_last, match[1])
                ]
              ]);
        } else {
          trace(fst, txt, ppf, filter_trace(keep_last, tr));
        }
        print_labels[0] = /* true */1;
        return /* () */0;
      } else {
        return /* () */0;
      }
    } else {
      return /* () */0;
    }
  }
  catch (exn){
    print_labels[0] = /* true */1;
    throw exn;
  }
}

function class_types(env, cty1, cty2) {
  return match_class_types(/* None */0, env, cty1, cty2);
}

function class_type_declarations(env, cty1, cty2) {
  return match_class_declarations(env, cty1[/* clty_params */0], cty1[/* clty_type */1], cty2[/* clty_params */0], cty2[/* clty_type */1]);
}

function class_declarations(env, cty1, cty2) {
  var match = cty1[/* cty_new */3];
  var match$1 = cty2[/* cty_new */3];
  var exit = 0;
  if (match) {
    exit = 1;
  } else if (match$1) {
    return /* :: */[
            /* CM_Virtual_class */0,
            /* [] */0
          ];
  } else {
    exit = 1;
  }
  if (exit === 1) {
    return match_class_declarations(env, cty1[/* cty_params */0], cty1[/* cty_type */1], cty2[/* cty_params */0], cty2[/* cty_type */1]);
  }
  
}

function include_err(ppf, param) {
  if (typeof param === "number") {
    return Format.fprintf(ppf, /* Format */[
                /* String_literal */Block.__(11, [
                    "A class cannot be changed from virtual to concrete",
                    /* End_of_format */0
                  ]),
                "A class cannot be changed from virtual to concrete"
              ]);
  } else {
    switch (param.tag | 0) {
      case 0 : 
          return Format.fprintf(ppf, /* Format */[
                      /* String_literal */Block.__(11, [
                          "The classes do not have the same number of type parameters",
                          /* End_of_format */0
                        ]),
                      "The classes do not have the same number of type parameters"
                    ]);
      case 1 : 
          return report_unification_error(ppf, param[0], /* Some */[/* false */0], param[1], (function (ppf) {
                        return Format.fprintf(ppf, /* Format */[
                                    /* String_literal */Block.__(11, [
                                        "A type parameter has type",
                                        /* End_of_format */0
                                      ]),
                                    "A type parameter has type"
                                  ]);
                      }), (function (ppf) {
                        return Format.fprintf(ppf, /* Format */[
                                    /* String_literal */Block.__(11, [
                                        "but is expected to have type",
                                        /* End_of_format */0
                                      ]),
                                    "but is expected to have type"
                                  ]);
                      }));
      case 2 : 
          var cty2 = param[2];
          var cty1 = param[1];
          return wrap_printing_env(param[0], (function () {
                        return Curry._5(Format.fprintf(ppf, /* Format */[
                                        /* Formatting_gen */Block.__(18, [
                                            /* Open_box */Block.__(1, [/* Format */[
                                                  /* End_of_format */0,
                                                  ""
                                                ]]),
                                            /* String_literal */Block.__(11, [
                                                "The class type",
                                                /* Formatting_lit */Block.__(17, [
                                                    /* Break */Block.__(0, [
                                                        "@;<1 2>",
                                                        1,
                                                        2
                                                      ]),
                                                    /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                            /* Break */Block.__(0, [
                                                                "@ ",
                                                                1,
                                                                0
                                                              ]),
                                                            /* String */Block.__(2, [
                                                                /* No_padding */0,
                                                                /* Formatting_lit */Block.__(17, [
                                                                    /* Break */Block.__(0, [
                                                                        "@;<1 2>",
                                                                        1,
                                                                        2
                                                                      ]),
                                                                    /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                            /* Close_box */0,
                                                                            /* End_of_format */0
                                                                          ])])
                                                                  ])
                                                              ])
                                                          ])])
                                                  ])
                                              ])
                                          ]),
                                        "@[The class type@;<1 2>%a@ %s@;<1 2>%a@]"
                                      ]), class_type$1, cty1, "is not matched by the class type", class_type$1, cty2);
                      }));
      case 3 : 
          return report_unification_error(ppf, param[0], /* Some */[/* false */0], param[1], (function (ppf) {
                        return Format.fprintf(ppf, /* Format */[
                                    /* String_literal */Block.__(11, [
                                        "A parameter has type",
                                        /* End_of_format */0
                                      ]),
                                    "A parameter has type"
                                  ]);
                      }), (function (ppf) {
                        return Format.fprintf(ppf, /* Format */[
                                    /* String_literal */Block.__(11, [
                                        "but is expected to have type",
                                        /* End_of_format */0
                                      ]),
                                    "but is expected to have type"
                                  ]);
                      }));
      case 4 : 
          var lab = param[0];
          return report_unification_error(ppf, param[1], /* Some */[/* false */0], param[2], (function (ppf) {
                        return Curry._1(Format.fprintf(ppf, /* Format */[
                                        /* String_literal */Block.__(11, [
                                            "The instance variable ",
                                            /* String */Block.__(2, [
                                                /* No_padding */0,
                                                /* Formatting_lit */Block.__(17, [
                                                    /* Break */Block.__(0, [
                                                        "@ ",
                                                        1,
                                                        0
                                                      ]),
                                                    /* String_literal */Block.__(11, [
                                                        "has type",
                                                        /* End_of_format */0
                                                      ])
                                                  ])
                                              ])
                                          ]),
                                        "The instance variable %s@ has type"
                                      ]), lab);
                      }), (function (ppf) {
                        return Format.fprintf(ppf, /* Format */[
                                    /* String_literal */Block.__(11, [
                                        "but is expected to have type",
                                        /* End_of_format */0
                                      ]),
                                    "but is expected to have type"
                                  ]);
                      }));
      case 5 : 
          var lab$1 = param[0];
          return report_unification_error(ppf, param[1], /* Some */[/* false */0], param[2], (function (ppf) {
                        return Curry._1(Format.fprintf(ppf, /* Format */[
                                        /* String_literal */Block.__(11, [
                                            "The method ",
                                            /* String */Block.__(2, [
                                                /* No_padding */0,
                                                /* Formatting_lit */Block.__(17, [
                                                    /* Break */Block.__(0, [
                                                        "@ ",
                                                        1,
                                                        0
                                                      ]),
                                                    /* String_literal */Block.__(11, [
                                                        "has type",
                                                        /* End_of_format */0
                                                      ])
                                                  ])
                                              ])
                                          ]),
                                        "The method %s@ has type"
                                      ]), lab$1);
                      }), (function (ppf) {
                        return Format.fprintf(ppf, /* Format */[
                                    /* String_literal */Block.__(11, [
                                        "but is expected to have type",
                                        /* End_of_format */0
                                      ]),
                                    "but is expected to have type"
                                  ]);
                      }));
      case 6 : 
          return Curry._1(Format.fprintf(ppf, /* Format */[
                          /* Formatting_gen */Block.__(18, [
                              /* Open_box */Block.__(1, [/* Format */[
                                    /* End_of_format */0,
                                    ""
                                  ]]),
                              /* String_literal */Block.__(11, [
                                  "The non-mutable instance variable ",
                                  /* String */Block.__(2, [
                                      /* No_padding */0,
                                      /* String_literal */Block.__(11, [
                                          " cannot become mutable",
                                          /* Formatting_lit */Block.__(17, [
                                              /* Close_box */0,
                                              /* End_of_format */0
                                            ])
                                        ])
                                    ])
                                ])
                            ]),
                          "@[The non-mutable instance variable %s cannot become mutable@]"
                        ]), param[0]);
      case 7 : 
          return Curry._1(Format.fprintf(ppf, /* Format */[
                          /* Formatting_gen */Block.__(18, [
                              /* Open_box */Block.__(1, [/* Format */[
                                    /* End_of_format */0,
                                    ""
                                  ]]),
                              /* String_literal */Block.__(11, [
                                  "The virtual instance variable ",
                                  /* String */Block.__(2, [
                                      /* No_padding */0,
                                      /* String_literal */Block.__(11, [
                                          " cannot become concrete",
                                          /* Formatting_lit */Block.__(17, [
                                              /* Close_box */0,
                                              /* End_of_format */0
                                            ])
                                        ])
                                    ])
                                ])
                            ]),
                          "@[The virtual instance variable %s cannot become concrete@]"
                        ]), param[0]);
      case 8 : 
          return Curry._1(Format.fprintf(ppf, /* Format */[
                          /* Formatting_gen */Block.__(18, [
                              /* Open_box */Block.__(1, [/* Format */[
                                    /* End_of_format */0,
                                    ""
                                  ]]),
                              /* String_literal */Block.__(11, [
                                  "The first class type has no instance variable ",
                                  /* String */Block.__(2, [
                                      /* No_padding */0,
                                      /* Formatting_lit */Block.__(17, [
                                          /* Close_box */0,
                                          /* End_of_format */0
                                        ])
                                    ])
                                ])
                            ]),
                          "@[The first class type has no instance variable %s@]"
                        ]), param[0]);
      case 9 : 
          return Curry._1(Format.fprintf(ppf, /* Format */[
                          /* Formatting_gen */Block.__(18, [
                              /* Open_box */Block.__(1, [/* Format */[
                                    /* End_of_format */0,
                                    ""
                                  ]]),
                              /* String_literal */Block.__(11, [
                                  "The first class type has no method ",
                                  /* String */Block.__(2, [
                                      /* No_padding */0,
                                      /* Formatting_lit */Block.__(17, [
                                          /* Close_box */0,
                                          /* End_of_format */0
                                        ])
                                    ])
                                ])
                            ]),
                          "@[The first class type has no method %s@]"
                        ]), param[0]);
      case 10 : 
          return Curry._1(Format.fprintf(ppf, /* Format */[
                          /* Formatting_gen */Block.__(18, [
                              /* Open_box */Block.__(1, [/* Format */[
                                    /* End_of_format */0,
                                    ""
                                  ]]),
                              /* String_literal */Block.__(11, [
                                  "The public method ",
                                  /* String */Block.__(2, [
                                      /* No_padding */0,
                                      /* String_literal */Block.__(11, [
                                          " cannot be hidden",
                                          /* Formatting_lit */Block.__(17, [
                                              /* Close_box */0,
                                              /* End_of_format */0
                                            ])
                                        ])
                                    ])
                                ])
                            ]),
                          "@[The public method %s cannot be hidden@]"
                        ]), param[0]);
      case 11 : 
          return Curry._2(Format.fprintf(ppf, /* Format */[
                          /* Formatting_gen */Block.__(18, [
                              /* Open_box */Block.__(1, [/* Format */[
                                    /* End_of_format */0,
                                    ""
                                  ]]),
                              /* String_literal */Block.__(11, [
                                  "The virtual ",
                                  /* String */Block.__(2, [
                                      /* No_padding */0,
                                      /* Char_literal */Block.__(12, [
                                          /* " " */32,
                                          /* String */Block.__(2, [
                                              /* No_padding */0,
                                              /* String_literal */Block.__(11, [
                                                  " cannot be hidden",
                                                  /* Formatting_lit */Block.__(17, [
                                                      /* Close_box */0,
                                                      /* End_of_format */0
                                                    ])
                                                ])
                                            ])
                                        ])
                                    ])
                                ])
                            ]),
                          "@[The virtual %s %s cannot be hidden@]"
                        ]), param[0], param[1]);
      case 12 : 
          return Curry._1(Format.fprintf(ppf, /* Format */[
                          /* Formatting_gen */Block.__(18, [
                              /* Open_box */Block.__(1, [/* Format */[
                                    /* End_of_format */0,
                                    ""
                                  ]]),
                              /* String_literal */Block.__(11, [
                                  "The public method ",
                                  /* String */Block.__(2, [
                                      /* No_padding */0,
                                      /* String_literal */Block.__(11, [
                                          " cannot become private",
                                          /* End_of_format */0
                                        ])
                                    ])
                                ])
                            ]),
                          "@[The public method %s cannot become private"
                        ]), param[0]);
      case 13 : 
          return Curry._1(Format.fprintf(ppf, /* Format */[
                          /* String_literal */Block.__(11, [
                              "The private method ",
                              /* String */Block.__(2, [
                                  /* No_padding */0,
                                  /* String_literal */Block.__(11, [
                                      " cannot become public",
                                      /* End_of_format */0
                                    ])
                                ])
                            ]),
                          "The private method %s cannot become public"
                        ]), param[0]);
      case 14 : 
          return Curry._1(Format.fprintf(ppf, /* Format */[
                          /* Formatting_gen */Block.__(18, [
                              /* Open_box */Block.__(1, [/* Format */[
                                    /* End_of_format */0,
                                    ""
                                  ]]),
                              /* String_literal */Block.__(11, [
                                  "The virtual method ",
                                  /* String */Block.__(2, [
                                      /* No_padding */0,
                                      /* String_literal */Block.__(11, [
                                          " cannot become concrete",
                                          /* End_of_format */0
                                        ])
                                    ])
                                ])
                            ]),
                          "@[The virtual method %s cannot become concrete"
                        ]), param[0]);
      
    }
  }
}

function report_error$3(ppf, param) {
  if (param) {
    var print_errs = function (ppf, errs) {
      return List.iter((function (err) {
                    return Curry._2(Format.fprintf(ppf, /* Format */[
                                    /* Formatting_lit */Block.__(17, [
                                        /* Break */Block.__(0, [
                                            "@ ",
                                            1,
                                            0
                                          ]),
                                        /* Alpha */Block.__(15, [/* End_of_format */0])
                                      ]),
                                    "@ %a"
                                  ]), include_err, err);
                  }), errs);
    };
    return Curry._4(Format.fprintf(ppf, /* Format */[
                    /* Formatting_gen */Block.__(18, [
                        /* Open_box */Block.__(1, [/* Format */[
                              /* String_literal */Block.__(11, [
                                  "<v>",
                                  /* End_of_format */0
                                ]),
                              "<v>"
                            ]]),
                        /* Alpha */Block.__(15, [/* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                    /* Close_box */0,
                                    /* End_of_format */0
                                  ])])])
                      ]),
                    "@[<v>%a%a@]"
                  ]), include_err, param[0], print_errs, param[1]);
  } else {
    return /* () */0;
  }
}

var Dont_match = Caml_exceptions.create("Ocaml_typedtree_test.Includecore.Dont_match");

function private_flags(decl1, decl2) {
  var match = decl1[/* type_private */3];
  var match$1 = decl2[/* type_private */3];
  if (match !== 0 || match$1 === 0) {
    return /* true */1;
  } else if (decl2[/* type_kind */2]) {
    return /* false */0;
  } else if (decl2[/* type_manifest */4]) {
    return +(decl1[/* type_kind */2] !== /* Type_abstract */0);
  } else {
    return /* true */1;
  }
}

function is_absrow(env, ty) {
  var match = ty[/* desc */0];
  if (typeof match === "number") {
    return /* false */0;
  } else if (match.tag === 3) {
    switch (match[0].tag | 0) {
      case 0 : 
          var match$1 = expand_head(env, ty);
          var match$2 = match$1[/* desc */0];
          if (typeof match$2 === "number") {
            return /* false */0;
          } else {
            switch (match$2.tag | 0) {
              case 4 : 
              case 8 : 
                  return /* true */1;
              default:
                return /* false */0;
            }
          }
          break;
      case 1 : 
      case 2 : 
          return /* false */0;
      
    }
  } else {
    return /* false */0;
  }
}

function type_manifest(env, ty1, params1, ty2, params2, priv2) {
  var ty1$prime = expand_head(env, ty1);
  var ty2$prime = expand_head(env, ty2);
  var match = ty1$prime[/* desc */0];
  var match$1 = ty2$prime[/* desc */0];
  var exit = 0;
  if (typeof match === "number") {
    exit = 1;
  } else {
    switch (match.tag | 0) {
      case 4 : 
          if (typeof match$1 === "number") {
            exit = 1;
          } else if (match$1.tag === 4) {
            var fi2 = match$1[0];
            if (is_absrow(env, flatten_fields(fi2)[1])) {
              var match$2 = flatten_fields(fi2);
              if (equal$4(env, /* true */1, /* :: */[
                      ty1,
                      params1
                    ], /* :: */[
                      match$2[1],
                      params2
                    ])) {
                var match$3 = flatten_fields(match[0]);
                var match$4 = match$3[1][/* desc */0];
                var $js;
                if (typeof match$4 === "number") {
                  $js = match$4 ? /* false */0 : /* true */1;
                } else {
                  switch (match$4.tag | 0) {
                    case 0 : 
                    case 3 : 
                        $js = /* true */1;
                        break;
                    default:
                      $js = /* false */0;
                  }
                }
                if ($js) {
                  var match$5 = associate_fields(match$3[0], match$2[0]);
                  if (match$5[2]) {
                    return /* false */0;
                  } else {
                    var match$6 = List.split(List.map((function (param) {
                                return /* tuple */[
                                        param[2],
                                        param[4]
                                      ];
                              }), match$5[0]));
                    return equal$4(env, /* true */1, Pervasives.$at(params1, match$6[0]), Pervasives.$at(params2, match$6[1]));
                  }
                } else {
                  return /* false */0;
                }
              } else {
                return /* false */0;
              }
            } else {
              exit = 1;
            }
          } else {
            exit = 1;
          }
          break;
      case 8 : 
          if (typeof match$1 === "number") {
            exit = 1;
          } else if (match$1.tag === 8) {
            var row2 = match$1[0];
            if (is_absrow(env, row_more(row2))) {
              var row1 = row_repr_aux(/* [] */0, match[0]);
              var row2$1 = row_repr_aux(/* [] */0, row2);
              if (equal$4(env, /* true */1, /* :: */[
                      ty1,
                      params1
                    ], /* :: */[
                      row2$1[/* row_more */1],
                      params2
                    ])) {
                var match$7 = row1[/* row_more */1];
                var match$8 = match$7[/* desc */0];
                var $js$1;
                if (typeof match$8 === "number") {
                  $js$1 = match$8 ? /* false */0 : /* true */1;
                } else {
                  switch (match$8.tag | 0) {
                    case 0 : 
                    case 3 : 
                        $js$1 = /* true */1;
                        break;
                    default:
                      $js$1 = /* false */0;
                  }
                }
                if ($js$1) {
                  var match$9 = merge_row_fields(row1[/* row_fields */0], row2$1[/* row_fields */0]);
                  if (!row2$1[/* row_closed */3] || row1[/* row_closed */3] && filter_row_fields(/* false */0, match$9[0]) === /* [] */0) {
                    if (List.for_all((function (param) {
                              var match = row_field_repr_aux(/* [] */0, param[1]);
                              if (typeof match === "number" || match.tag) {
                                return /* true */1;
                              } else {
                                return /* false */0;
                              }
                            }), match$9[1])) {
                      var to_equal = [List.combine(params1, params2)];
                      if (List.for_all((function (param) {
                                var match = row_field_repr_aux(/* [] */0, param[1]);
                                var match$1 = row_field_repr_aux(/* [] */0, param[2]);
                                if (typeof match === "number") {
                                  if (typeof match$1 === "number" || match$1.tag) {
                                    return /* true */1;
                                  } else {
                                    return /* false */0;
                                  }
                                } else if (match.tag) {
                                  var tl1 = match[1];
                                  if (typeof match$1 === "number") {
                                    return /* false */0;
                                  } else if (match$1.tag) {
                                    var tl2 = match$1[1];
                                    if (List.length(tl1) === List.length(tl2) && Caml_obj.caml_equal(match[0], match$1[0])) {
                                      to_equal[0] = Pervasives.$at(List.combine(tl1, tl2), to_equal[0]);
                                      return /* true */1;
                                    } else {
                                      return /* false */0;
                                    }
                                  } else {
                                    return /* false */0;
                                  }
                                } else {
                                  var match$2 = match[0];
                                  if (match$2) {
                                    var exit = 0;
                                    var t2;
                                    if (typeof match$1 === "number") {
                                      return /* false */0;
                                    } else if (match$1.tag) {
                                      if (match$1[0] !== 0) {
                                        return /* false */0;
                                      } else {
                                        var match$3 = match$1[1];
                                        if (match$3) {
                                          if (match$3[1]) {
                                            return /* false */0;
                                          } else {
                                            t2 = match$3[0];
                                            exit = 1;
                                          }
                                        } else {
                                          return /* false */0;
                                        }
                                      }
                                    } else {
                                      var match$4 = match$1[0];
                                      if (match$4) {
                                        t2 = match$4[0];
                                        exit = 1;
                                      } else {
                                        return /* false */0;
                                      }
                                    }
                                    if (exit === 1) {
                                      to_equal[0] = /* :: */[
                                        /* tuple */[
                                          match$2[0],
                                          t2
                                        ],
                                        to_equal[0]
                                      ];
                                      return /* true */1;
                                    }
                                    
                                  } else if (typeof match$1 === "number") {
                                    return /* false */0;
                                  } else if (match$1.tag) {
                                    if (match$1[0] !== 0 && !match$1[1]) {
                                      return /* true */1;
                                    } else {
                                      return /* false */0;
                                    }
                                  } else if (match$1[0]) {
                                    return /* false */0;
                                  } else {
                                    return /* true */1;
                                  }
                                }
                              }), match$9[2])) {
                        var match$10 = List.split(to_equal[0]);
                        return equal$4(env, /* true */1, match$10[0], match$10[1]);
                      } else {
                        return /* false */0;
                      }
                    } else {
                      return /* false */0;
                    }
                  } else {
                    return /* false */0;
                  }
                } else {
                  return /* false */0;
                }
              } else {
                return /* false */0;
              }
            } else {
              exit = 1;
            }
          } else {
            exit = 1;
          }
          break;
      default:
        exit = 1;
    }
  }
  if (exit === 1) {
    var check_super = function (ty1) {
      if (equal$4(env, /* true */1, /* :: */[
              ty1,
              params1
            ], /* :: */[
              ty2,
              params2
            ])) {
        return /* true */1;
      } else if (priv2) {
        return /* false */0;
      } else {
        try {
          return check_super(try_expand_once_opt(env, expand_head(env, ty1)));
        }
        catch (exn){
          if (exn === Cannot_expand) {
            return /* false */0;
          } else {
            throw exn;
          }
        }
      }
    };
    return check_super(ty1);
  }
  
}

function report_type_mismatch(first, second, decl, ppf) {
  return (function (param) {
      return List.iter((function (err) {
                    if (err === /* Manifest */4) {
                      return /* () */0;
                    } else {
                      return Curry._2(Format.fprintf(ppf, /* Format */[
                                      /* Formatting_lit */Block.__(17, [
                                          /* Break */Block.__(0, [
                                              "@ ",
                                              1,
                                              0
                                            ]),
                                          /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                                  /* "." */46,
                                                  /* End_of_format */0
                                                ])])
                                        ]),
                                      "@ %a."
                                    ]), (function (param, param$1) {
                                    var first$1 = first;
                                    var second$1 = second;
                                    var decl$1 = decl;
                                    var ppf = param;
                                    var err = param$1;
                                    if (typeof err === "number") {
                                      switch (err) {
                                        case 0 : 
                                            return Format.fprintf(ppf, /* Format */[
                                                        /* String_literal */Block.__(11, [
                                                            "They have different arities",
                                                            /* End_of_format */0
                                                          ]),
                                                        "They have different arities"
                                                      ]);
                                        case 1 : 
                                            return Format.fprintf(ppf, /* Format */[
                                                        /* String_literal */Block.__(11, [
                                                            "A private type would be revealed",
                                                            /* End_of_format */0
                                                          ]),
                                                        "A private type would be revealed"
                                                      ]);
                                        case 2 : 
                                            return Format.fprintf(ppf, /* Format */[
                                                        /* String_literal */Block.__(11, [
                                                            "Their kinds differ",
                                                            /* End_of_format */0
                                                          ]),
                                                        "Their kinds differ"
                                                      ]);
                                        case 3 : 
                                            return Format.fprintf(ppf, /* Format */[
                                                        /* String_literal */Block.__(11, [
                                                            "Their constraints differ",
                                                            /* End_of_format */0
                                                          ]),
                                                        "Their constraints differ"
                                                      ]);
                                        case 4 : 
                                            return /* () */0;
                                        case 5 : 
                                            return Format.fprintf(ppf, /* Format */[
                                                        /* String_literal */Block.__(11, [
                                                            "Their variances do not agree",
                                                            /* End_of_format */0
                                                          ]),
                                                        "Their variances do not agree"
                                                      ]);
                                        
                                      }
                                    } else {
                                      switch (err.tag | 0) {
                                        case 0 : 
                                            return Curry._1(Format.fprintf(ppf, /* Format */[
                                                            /* String_literal */Block.__(11, [
                                                                "The types for field ",
                                                                /* String */Block.__(2, [
                                                                    /* No_padding */0,
                                                                    /* String_literal */Block.__(11, [
                                                                        " are not equal",
                                                                        /* End_of_format */0
                                                                      ])
                                                                  ])
                                                              ]),
                                                            "The types for field %s are not equal"
                                                          ]), err[0][/* name */1]);
                                        case 1 : 
                                            return Curry._1(Format.fprintf(ppf, /* Format */[
                                                            /* String_literal */Block.__(11, [
                                                                "The mutability of field ",
                                                                /* String */Block.__(2, [
                                                                    /* No_padding */0,
                                                                    /* String_literal */Block.__(11, [
                                                                        " is different",
                                                                        /* End_of_format */0
                                                                      ])
                                                                  ])
                                                              ]),
                                                            "The mutability of field %s is different"
                                                          ]), err[0][/* name */1]);
                                        case 2 : 
                                            return Curry._1(Format.fprintf(ppf, /* Format */[
                                                            /* String_literal */Block.__(11, [
                                                                "The arities for field ",
                                                                /* String */Block.__(2, [
                                                                    /* No_padding */0,
                                                                    /* String_literal */Block.__(11, [
                                                                        " differ",
                                                                        /* End_of_format */0
                                                                      ])
                                                                  ])
                                                              ]),
                                                            "The arities for field %s differ"
                                                          ]), err[0][/* name */1]);
                                        case 3 : 
                                            return Curry._3(Format.fprintf(ppf, /* Format */[
                                                            /* String_literal */Block.__(11, [
                                                                "Fields number ",
                                                                /* Int */Block.__(4, [
                                                                    /* Int_i */3,
                                                                    /* No_padding */0,
                                                                    /* No_precision */0,
                                                                    /* String_literal */Block.__(11, [
                                                                        " have different names, ",
                                                                        /* String */Block.__(2, [
                                                                            /* No_padding */0,
                                                                            /* String_literal */Block.__(11, [
                                                                                " and ",
                                                                                /* String */Block.__(2, [
                                                                                    /* No_padding */0,
                                                                                    /* End_of_format */0
                                                                                  ])
                                                                              ])
                                                                          ])
                                                                      ])
                                                                  ])
                                                              ]),
                                                            "Fields number %i have different names, %s and %s"
                                                          ]), err[0], err[1][/* name */1], err[2][/* name */1]);
                                        case 4 : 
                                            return Curry._3(Format.fprintf(ppf, /* Format */[
                                                            /* String_literal */Block.__(11, [
                                                                "The field ",
                                                                /* String */Block.__(2, [
                                                                    /* No_padding */0,
                                                                    /* String_literal */Block.__(11, [
                                                                        " is only present in ",
                                                                        /* String */Block.__(2, [
                                                                            /* No_padding */0,
                                                                            /* Char_literal */Block.__(12, [
                                                                                /* " " */32,
                                                                                /* String */Block.__(2, [
                                                                                    /* No_padding */0,
                                                                                    /* End_of_format */0
                                                                                  ])
                                                                              ])
                                                                          ])
                                                                      ])
                                                                  ])
                                                              ]),
                                                            "The field %s is only present in %s %s"
                                                          ]), err[1][/* name */1], err[0] ? second$1 : first$1, decl$1);
                                        case 5 : 
                                            return Curry._3(Format.fprintf(ppf, /* Format */[
                                                            /* String_literal */Block.__(11, [
                                                                "Their internal representations differ:",
                                                                /* Formatting_lit */Block.__(17, [
                                                                    /* Break */Block.__(0, [
                                                                        "@ ",
                                                                        1,
                                                                        0
                                                                      ]),
                                                                    /* String */Block.__(2, [
                                                                        /* No_padding */0,
                                                                        /* Char_literal */Block.__(12, [
                                                                            /* " " */32,
                                                                            /* String */Block.__(2, [
                                                                                /* No_padding */0,
                                                                                /* Char_literal */Block.__(12, [
                                                                                    /* " " */32,
                                                                                    /* String */Block.__(2, [
                                                                                        /* No_padding */0,
                                                                                        /* End_of_format */0
                                                                                      ])
                                                                                  ])
                                                                              ])
                                                                          ])
                                                                      ])
                                                                  ])
                                                              ]),
                                                            "Their internal representations differ:@ %s %s %s"
                                                          ]), err[0] ? second$1 : first$1, decl$1, "uses unboxed float representation");
                                        
                                      }
                                    }
                                  }), err);
                    }
                  }), param);
    });
}

function compare_variants(env, decl1, decl2, _n, _cstrs1, _cstrs2) {
  while(true) {
    var cstrs2 = _cstrs2;
    var cstrs1 = _cstrs1;
    var n = _n;
    if (cstrs1) {
      var c = cstrs1[0];
      if (cstrs2) {
        var match = cstrs2[0];
        var ret2 = match[/* cd_res */2];
        var arg2 = match[/* cd_args */1];
        var cstr2 = match[/* cd_id */0];
        var ret1 = c[/* cd_res */2];
        var arg1 = c[/* cd_args */1];
        var cstr1 = c[/* cd_id */0];
        if (cstr1[/* name */1] !== cstr2[/* name */1]) {
          return /* :: */[
                  /* Field_names */Block.__(3, [
                      n,
                      cstr1,
                      cstr2
                    ]),
                  /* [] */0
                ];
        } else if (List.length(arg1) !== List.length(arg2)) {
          return /* :: */[
                  /* Field_arity */Block.__(2, [cstr1]),
                  /* [] */0
                ];
        } else {
          var exit = 0;
          if (ret1) {
            if (ret2) {
              if (equal$4(env, /* true */1, /* :: */[
                      ret1[0],
                      /* [] */0
                    ], /* :: */[
                      ret2[0],
                      /* [] */0
                    ])) {
                exit = 1;
              } else {
                return /* :: */[
                        /* Field_type */Block.__(0, [cstr1]),
                        /* [] */0
                      ];
              }
            } else {
              return /* :: */[
                      /* Field_type */Block.__(0, [cstr1]),
                      /* [] */0
                    ];
            }
          } else if (ret2) {
            return /* :: */[
                    /* Field_type */Block.__(0, [cstr1]),
                    /* [] */0
                  ];
          } else {
            exit = 1;
          }
          if (exit === 1) {
            if (for_all2((function (ty1, ty2) {
                      return equal$4(env, /* true */1, /* :: */[
                                  ty1,
                                  decl1[/* type_params */0]
                                ], /* :: */[
                                  ty2,
                                  decl2[/* type_params */0]
                                ]);
                    }), arg1, arg2)) {
              _cstrs2 = cstrs2[1];
              _cstrs1 = cstrs1[1];
              _n = n + 1 | 0;
              continue ;
              
            } else {
              return /* :: */[
                      /* Field_type */Block.__(0, [cstr1]),
                      /* [] */0
                    ];
            }
          }
          
        }
      } else {
        return /* :: */[
                /* Field_missing */Block.__(4, [
                    /* false */0,
                    c[/* cd_id */0]
                  ]),
                /* [] */0
              ];
      }
    } else if (cstrs2) {
      return /* :: */[
              /* Field_missing */Block.__(4, [
                  /* true */1,
                  cstrs2[0][/* cd_id */0]
                ]),
              /* [] */0
            ];
    } else {
      return /* [] */0;
    }
  };
}

function compare_records(env, decl1, decl2, _n, _labels1, _labels2) {
  while(true) {
    var labels2 = _labels2;
    var labels1 = _labels1;
    var n = _n;
    if (labels1) {
      var l = labels1[0];
      if (labels2) {
        var match = labels2[0];
        var lab2 = match[/* ld_id */0];
        var lab1 = l[/* ld_id */0];
        if (lab1[/* name */1] !== lab2[/* name */1]) {
          return /* :: */[
                  /* Field_names */Block.__(3, [
                      n,
                      lab1,
                      lab2
                    ]),
                  /* [] */0
                ];
        } else if (Caml_obj.caml_notequal(l[/* ld_mutable */1], match[/* ld_mutable */1])) {
          return /* :: */[
                  /* Field_mutable */Block.__(1, [lab1]),
                  /* [] */0
                ];
        } else if (equal$4(env, /* true */1, /* :: */[
                l[/* ld_type */2],
                decl1[/* type_params */0]
              ], /* :: */[
                match[/* ld_type */2],
                decl2[/* type_params */0]
              ])) {
          _labels2 = labels2[1];
          _labels1 = labels1[1];
          _n = n + 1 | 0;
          continue ;
          
        } else {
          return /* :: */[
                  /* Field_type */Block.__(0, [lab1]),
                  /* [] */0
                ];
        }
      } else {
        return /* :: */[
                /* Field_missing */Block.__(4, [
                    /* false */0,
                    l[/* ld_id */0]
                  ]),
                /* [] */0
              ];
      }
    } else if (labels2) {
      return /* :: */[
              /* Field_missing */Block.__(4, [
                  /* true */1,
                  labels2[0][/* ld_id */0]
                ]),
              /* [] */0
            ];
    } else {
      return /* [] */0;
    }
  };
}

function type_declarations$1($staropt$star, env, name, decl1, id, decl2) {
  var equality = $staropt$star ? $staropt$star[0] : /* false */0;
  if (decl1[/* type_arity */1] !== decl2[/* type_arity */1]) {
    return /* :: */[
            /* Arity */0,
            /* [] */0
          ];
  } else if (private_flags(decl1, decl2)) {
    var match = decl1[/* type_kind */2];
    var match$1 = decl2[/* type_kind */2];
    var err;
    var exit = 0;
    if (typeof match$1 === "number" && match$1 === 0) {
      err = /* [] */0;
    } else {
      exit = 1;
    }
    if (exit === 1) {
      if (typeof match === "number") {
        err = match ? (
            typeof match$1 === "number" ? /* [] */0 : /* :: */[
                /* Kind */2,
                /* [] */0
              ]
          ) : /* :: */[
            /* Kind */2,
            /* [] */0
          ];
      } else if (match.tag) {
        var cstrs1 = match[0];
        if (typeof match$1 === "number") {
          err = /* :: */[
            /* Kind */2,
            /* [] */0
          ];
        } else if (match$1.tag) {
          var cstrs2 = match$1[0];
          var mark = function (cstrs, usage, name, decl) {
            return List.iter((function (c) {
                          return mark_constructor_used(usage, env, name, decl, c[/* cd_id */0][/* name */1]);
                        }), cstrs);
          };
          var usage = decl1[/* type_private */3] === /* Private */0 || decl2[/* type_private */3] === /* Public */1 ? /* Positive */0 : /* Privatize */2;
          mark(cstrs1, usage, name, decl1);
          if (equality) {
            mark(cstrs2, /* Positive */0, id[/* name */1], decl2);
          }
          err = compare_variants(env, decl1, decl2, 1, cstrs1, cstrs2);
        } else {
          err = /* :: */[
            /* Kind */2,
            /* [] */0
          ];
        }
      } else if (typeof match$1 === "number") {
        err = /* :: */[
          /* Kind */2,
          /* [] */0
        ];
      } else if (match$1.tag) {
        err = /* :: */[
          /* Kind */2,
          /* [] */0
        ];
      } else {
        var rep2 = match$1[1];
        var err$1 = compare_records(env, decl1, decl2, 1, match[0], match$1[0]);
        err = err$1 !== /* [] */0 || Caml_obj.caml_equal(match[1], rep2) ? err$1 : /* :: */[
            /* Record_representation */Block.__(5, [+(rep2 === /* Record_float */1)]),
            /* [] */0
          ];
      }
    }
    if (err !== /* [] */0) {
      return err;
    } else {
      var match$2 = decl1[/* type_manifest */4];
      var match$3 = decl2[/* type_manifest */4];
      var err$2;
      if (match$3) {
        if (match$2) {
          err$2 = type_manifest(env, match$2[0], decl1[/* type_params */0], match$3[0], decl2[/* type_params */0], decl2[/* type_private */3]) ? /* [] */0 : /* :: */[
              /* Manifest */4,
              /* [] */0
            ];
        } else {
          var ty1 = newty2(100000000, /* Tconstr */Block.__(3, [
                  /* Pident */Block.__(0, [id]),
                  decl2[/* type_params */0],
                  [/* Mnil */0]
                ]));
          err$2 = equal$4(env, /* true */1, decl1[/* type_params */0], decl2[/* type_params */0]) ? (
              equal$4(env, /* false */0, /* :: */[
                    ty1,
                    /* [] */0
                  ], /* :: */[
                    match$3[0],
                    /* [] */0
                  ]) ? /* [] */0 : /* :: */[
                  /* Manifest */4,
                  /* [] */0
                ]
            ) : /* :: */[
              /* Constraint */3,
              /* [] */0
            ];
        }
      } else {
        err$2 = equal$4(env, /* true */1, decl1[/* type_params */0], decl2[/* type_params */0]) ? /* [] */0 : /* :: */[
            /* Constraint */3,
            /* [] */0
          ];
      }
      if (err$2 !== /* [] */0) {
        return err$2;
      } else {
        var abstr = +(decl2[/* type_private */3] === /* Private */0 || decl2[/* type_kind */2] === /* Type_abstract */0 && decl2[/* type_manifest */4] === /* None */0);
        var opn = +(decl2[/* type_kind */2] === /* Type_open */1 && decl2[/* type_manifest */4] === /* None */0);
        var constrained = function (ty) {
          return 1 - is_Tvar(repr(ty));
        };
        if (List.for_all2((function (ty, param) {
                  var v2 = param[1];
                  var v1 = param[0];
                  var match = Curry._1(Types_003[/* get_upper */10], v1);
                  var cn1 = match[1];
                  var co1 = match[0];
                  var match$1 = Curry._1(Types_003[/* get_upper */10], v2);
                  var cn2 = match$1[1];
                  var co2 = match$1[0];
                  if (abstr ? (1 - co1 || co2) && (1 - cn1 || cn2) : (
                        opn || constrained(ty) ? Caml_obj.caml_equal(co1, co2) && Caml_obj.caml_equal(cn1, cn2) : /* true */1
                      )) {
                    var match$2 = Curry._1(Types_003[/* get_lower */11], v1);
                    var match$3 = Curry._1(Types_003[/* get_lower */11], v2);
                    var b = (1 - match$3[0] || match$2[0]) && (1 - match$3[1] || match$2[1]) && (1 - match$3[2] || match$2[2]) && (1 - match$3[3] || match$2[3]);
                    return abstr ? b : /* true */1;
                  } else {
                    return /* false */0;
                  }
                }), decl2[/* type_params */0], List.combine(decl1[/* type_variance */5], decl2[/* type_variance */5]))) {
          return /* [] */0;
        } else {
          return /* :: */[
                  /* Variance */5,
                  /* [] */0
                ];
        }
      }
    }
  } else {
    return /* :: */[
            /* Privacy */1,
            /* [] */0
          ];
  }
}

function extension_constructors(env, id, ext1, ext2) {
  var usage = ext1[/* ext_private */4] === /* Private */0 || ext2[/* ext_private */4] === /* Public */1 ? /* Positive */0 : /* Privatize */2;
  mark_extension_used(usage, env, ext1, id[/* name */1]);
  var ty1 = newty2(100000000, /* Tconstr */Block.__(3, [
          ext1[/* ext_type_path */0],
          ext1[/* ext_type_params */1],
          [/* Mnil */0]
        ]));
  var ty2 = newty2(100000000, /* Tconstr */Block.__(3, [
          ext2[/* ext_type_path */0],
          ext2[/* ext_type_params */1],
          [/* Mnil */0]
        ]));
  if (equal$4(env, /* true */1, /* :: */[
          ty1,
          ext1[/* ext_type_params */1]
        ], /* :: */[
          ty2,
          ext2[/* ext_type_params */1]
        ])) {
    if (List.length(ext1[/* ext_args */2]) === List.length(ext2[/* ext_args */2])) {
      var match = ext1[/* ext_ret_type */3];
      var match$1 = ext2[/* ext_ret_type */3];
      var $js;
      var exit = 0;
      if (match) {
        if (match$1 && equal$4(env, /* true */1, /* :: */[
                match[0],
                /* [] */0
              ], /* :: */[
                match$1[0],
                /* [] */0
              ])) {
          exit = 1;
        } else {
          $js = /* false */0;
        }
      } else if (match$1) {
        $js = /* false */0;
      } else {
        exit = 1;
      }
      if (exit === 1) {
        $js = for_all2((function (ty1, ty2) {
                return equal$4(env, /* true */1, /* :: */[
                            ty1,
                            ext1[/* ext_type_params */1]
                          ], /* :: */[
                            ty2,
                            ext2[/* ext_type_params */1]
                          ]);
              }), ext1[/* ext_args */2], ext2[/* ext_args */2]);
      }
      if ($js) {
        var match$2 = ext1[/* ext_private */4];
        var match$3 = ext2[/* ext_private */4];
        if (match$2 !== 0 || match$3 === 0) {
          return /* true */1;
        } else {
          return /* false */0;
        }
      } else {
        return /* false */0;
      }
    } else {
      return /* false */0;
    }
  } else {
    return /* false */0;
  }
}

function scrape(env, mty) {
  if (mty.tag) {
    return mty;
  } else {
    try {
      return scrape(env, find_modtype_expansion(mty[0], env));
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        return mty;
      } else {
        throw exn;
      }
    }
  }
}

function freshen(mty) {
  return modtype(identity, mty);
}

function strengthen$1(env, mty, p) {
  var mty$1 = scrape(env, mty);
  switch (mty$1.tag | 0) {
    case 1 : 
        return /* Mty_signature */Block.__(1, [strengthen_sig(env, mty$1[0], p)]);
    case 2 : 
        var param = mty$1[0];
        if (applicative_functors[0] && param[/* name */1] !== "*") {
          return /* Mty_functor */Block.__(2, [
                    param,
                    mty$1[1],
                    strengthen$1(env, mty$1[2], /* Papply */Block.__(2, [
                            p,
                            /* Pident */Block.__(0, [param])
                          ]))
                  ]);
        } else {
          return mty$1;
        }
    case 0 : 
    case 3 : 
        return mty$1;
    
  }
}

function strengthen_sig(env, sg, p) {
  if (sg) {
    var sigelt = sg[0];
    switch (sigelt.tag | 0) {
      case 1 : 
          var decl = sigelt[1];
          var id = sigelt[0];
          var match = decl[/* type_manifest */4];
          var match$1 = decl[/* type_private */3];
          var match$2 = decl[/* type_kind */2];
          var newdecl;
          var exit = 0;
          if (match && (match$1 !== 0 || typeof match$2 !== "number")) {
            newdecl = decl;
          } else {
            exit = 1;
          }
          if (exit === 1) {
            var manif = /* Some */[newty2(100000000, /* Tconstr */Block.__(3, [
                      /* Pdot */Block.__(1, [
                          p,
                          id[/* name */1],
                          -1
                        ]),
                      decl[/* type_params */0],
                      [/* Mnil */0]
                    ]))];
            if (decl[/* type_kind */2]) {
              var newrecord = decl.slice();
              newrecord[/* type_manifest */4] = manif;
              newdecl = newrecord;
            } else {
              var newrecord$1 = decl.slice();
              newrecord$1[/* type_private */3] = /* Public */1;
              newrecord$1[/* type_manifest */4] = manif;
              newdecl = newrecord$1;
            }
          }
          return /* :: */[
                  /* Sig_type */Block.__(1, [
                      id,
                      newdecl,
                      sigelt[2]
                    ]),
                  strengthen_sig(env, sg[1], p)
                ];
      case 3 : 
          var md = sigelt[1];
          var id$1 = sigelt[0];
          var str = strengthen_decl(env, md, /* Pdot */Block.__(1, [
                  p,
                  id$1[/* name */1],
                  -1
                ]));
          return /* :: */[
                  /* Sig_module */Block.__(3, [
                      id$1,
                      str,
                      sigelt[2]
                    ]),
                  strengthen_sig(add_module_declaration(/* None */0, id$1, md, env), sg[1], p)
                ];
      case 4 : 
          var decl$1 = sigelt[1];
          var id$2 = sigelt[0];
          var match$3 = decl$1[/* mtd_type */0];
          var newdecl$1 = match$3 ? decl$1 : /* record */[
              /* mtd_type : Some */[/* Mty_ident */Block.__(0, [/* Pdot */Block.__(1, [
                        p,
                        id$2[/* name */1],
                        -1
                      ])])],
              /* mtd_attributes */decl$1[/* mtd_attributes */1],
              /* mtd_loc */decl$1[/* mtd_loc */2]
            ];
          return /* :: */[
                  /* Sig_modtype */Block.__(4, [
                      id$2,
                      newdecl$1
                    ]),
                  strengthen_sig(add_modtype$1(id$2, decl$1, env), sg[1], p)
                ];
      default:
        return /* :: */[
                sigelt,
                strengthen_sig(env, sg[1], p)
              ];
    }
  } else {
    return /* [] */0;
  }
}

function strengthen_decl(env, md, p) {
  return /* record */[
          /* md_type */strengthen$1(env, md[/* md_type */0], p),
          /* md_attributes */md[/* md_attributes */1],
          /* md_loc */md[/* md_loc */2]
        ];
}

strengthen[0] = strengthen$1;

function nondep_supertype(env, mid, mty) {
  var nondep_mty = function (env, va, _mty) {
    while(true) {
      var mty = _mty;
      switch (mty.tag | 0) {
        case 0 : 
            var p = mty[0];
            if (isfree(mid, p)) {
              _mty = find_modtype_expansion(p, env);
              continue ;
              
            } else {
              return mty;
            }
            break;
        case 1 : 
            return /* Mty_signature */Block.__(1, [nondep_sig(env, va, mty[0])]);
        case 2 : 
            var arg = mty[1];
            var param = mty[0];
            var var_inv;
            switch (va) {
              case 0 : 
                  var_inv = /* Contra */1;
                  break;
              case 1 : 
                  var_inv = /* Co */0;
                  break;
              case 2 : 
                  var_inv = /* Strict */2;
                  break;
              
            }
            return /* Mty_functor */Block.__(2, [
                      param,
                      may_map((function(var_inv){
                          return function (param) {
                            return nondep_mty(env, var_inv, param);
                          }
                          }(var_inv)), arg),
                      nondep_mty(add_module$1(/* Some */[/* true */1], param, default_mty(arg), env), va, mty[2])
                    ]);
        case 3 : 
            var p$1 = mty[0];
            if (isfree(mid, p$1)) {
              _mty = find_module(/* false */0, p$1, env)[/* md_type */0];
              continue ;
              
            } else {
              return mty;
            }
            break;
        
      }
    };
  };
  var nondep_sig = function (env, va, param) {
    if (param) {
      var item = param[0];
      var rem$prime = nondep_sig(env, va, param[1]);
      switch (item.tag | 0) {
        case 0 : 
            var d = item[1];
            return /* :: */[
                    /* Sig_value */Block.__(0, [
                        item[0],
                        /* record */[
                          /* val_type */nondep_type(env, mid, d[/* val_type */0]),
                          /* val_kind */d[/* val_kind */1],
                          /* val_loc */d[/* val_loc */2],
                          /* val_attributes */d[/* val_attributes */3]
                        ]
                      ]),
                    rem$prime
                  ];
        case 1 : 
            var id = item[0];
            return /* :: */[
                    /* Sig_type */Block.__(1, [
                        id,
                        nondep_type_decl(env, mid, id, +(va === /* Co */0), item[1]),
                        item[2]
                      ]),
                    rem$prime
                  ];
        case 2 : 
            return /* :: */[
                    /* Sig_typext */Block.__(2, [
                        item[0],
                        nondep_extension_constructor(env, mid, item[1]),
                        item[2]
                      ]),
                    rem$prime
                  ];
        case 3 : 
            var md = item[1];
            return /* :: */[
                    /* Sig_module */Block.__(3, [
                        item[0],
                        /* record */[
                          /* md_type */nondep_mty(env, va, md[/* md_type */0]),
                          /* md_attributes */md[/* md_attributes */1],
                          /* md_loc */md[/* md_loc */2]
                        ],
                        item[2]
                      ]),
                    rem$prime
                  ];
        case 4 : 
            var id$1 = item[0];
            try {
              return /* :: */[
                      /* Sig_modtype */Block.__(4, [
                          id$1,
                          nondep_modtype_decl(env, item[1])
                        ]),
                      rem$prime
                    ];
            }
            catch (exn){
              if (exn === Caml_builtin_exceptions.not_found) {
                if (va !== 0) {
                  throw Caml_builtin_exceptions.not_found;
                } else {
                  return /* :: */[
                          /* Sig_modtype */Block.__(4, [
                              id$1,
                              /* record */[
                                /* mtd_type : None */0,
                                /* mtd_attributes : [] */0,
                                /* mtd_loc */none
                              ]
                            ]),
                          rem$prime
                        ];
                }
              } else {
                throw exn;
              }
            }
            break;
        case 5 : 
            return /* :: */[
                    /* Sig_class */Block.__(5, [
                        item[0],
                        nondep_class_declaration(env, mid, item[1]),
                        item[2]
                      ]),
                    rem$prime
                  ];
        case 6 : 
            return /* :: */[
                    /* Sig_class_type */Block.__(6, [
                        item[0],
                        nondep_cltype_declaration(env, mid, item[1]),
                        item[2]
                      ]),
                    rem$prime
                  ];
        
      }
    } else {
      return /* [] */0;
    }
  };
  var nondep_modtype_decl = function (env, mtd) {
    return /* record */[
            /* mtd_type */may_map((function (param) {
                    return nondep_mty(env, /* Strict */2, param);
                  }), mtd[/* mtd_type */0]),
            /* mtd_attributes */mtd[/* mtd_attributes */1],
            /* mtd_loc */mtd[/* mtd_loc */2]
          ];
  };
  return nondep_mty(env, /* Co */0, mty);
}

function enrich_typedecl(env, p, decl) {
  var match = decl[/* type_manifest */4];
  if (match) {
    return decl;
  } else {
    try {
      var orig_decl = find_type_full(p, env)[0];
      if (orig_decl[/* type_arity */1] !== decl[/* type_arity */1]) {
        return decl;
      } else {
        var newrecord = decl.slice();
        newrecord[/* type_manifest */4] = /* Some */[newty2(100000000, /* Tconstr */Block.__(3, [
                  p,
                  decl[/* type_params */0],
                  [/* Mnil */0]
                ]))];
        return newrecord;
      }
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        return decl;
      } else {
        throw exn;
      }
    }
  }
}

function enrich_modtype(env, p, mty) {
  if (mty.tag === 1) {
    return /* Mty_signature */Block.__(1, [List.map((function (param) {
                      var env$1 = env;
                      var p$1 = p;
                      var item = param;
                      switch (item.tag | 0) {
                        case 1 : 
                            var id = item[0];
                            return /* Sig_type */Block.__(1, [
                                      id,
                                      enrich_typedecl(env$1, /* Pdot */Block.__(1, [
                                              p$1,
                                              id[/* name */1],
                                              -1
                                            ]), item[1]),
                                      item[2]
                                    ]);
                        case 3 : 
                            var md = item[1];
                            var id$1 = item[0];
                            return /* Sig_module */Block.__(3, [
                                      id$1,
                                      /* record */[
                                        /* md_type */enrich_modtype(env$1, /* Pdot */Block.__(1, [
                                                p$1,
                                                id$1[/* name */1],
                                                -1
                                              ]), md[/* md_type */0]),
                                        /* md_attributes */md[/* md_attributes */1],
                                        /* md_loc */md[/* md_loc */2]
                                      ],
                                      item[2]
                                    ]);
                        default:
                          return item;
                      }
                    }), mty[0])]);
  } else {
    return mty;
  }
}

function type_paths(env, p, mty) {
  var match = scrape(env, mty);
  if (match.tag === 1) {
    return type_paths_sig(env, p, 0, match[0]);
  } else {
    return /* [] */0;
  }
}

function type_paths_sig(_env, p, _pos, _sg) {
  while(true) {
    var sg = _sg;
    var pos = _pos;
    var env = _env;
    if (sg) {
      var match = sg[0];
      var exit = 0;
      switch (match.tag | 0) {
        case 0 : 
            var match$1 = match[1][/* val_kind */1];
            var pos$prime;
            pos$prime = typeof match$1 === "number" || match$1.tag ? pos + 1 | 0 : pos;
            _sg = sg[1];
            _pos = pos$prime;
            continue ;
            case 1 : 
            return /* :: */[
                    /* Pdot */Block.__(1, [
                        p,
                        match[0][/* name */1],
                        -1
                      ]),
                    type_paths_sig(env, p, pos, sg[1])
                  ];
        case 3 : 
            var md = match[1];
            var id = match[0];
            return Pervasives.$at(type_paths(env, /* Pdot */Block.__(1, [
                              p,
                              id[/* name */1],
                              pos
                            ]), md[/* md_type */0]), type_paths_sig(add_module_declaration(/* None */0, id, md, env), p, pos + 1 | 0, sg[1]));
        case 4 : 
            _sg = sg[1];
            _env = add_modtype$1(match[0], match[1], env);
            continue ;
            case 2 : 
        case 5 : 
            exit = 1;
            break;
        case 6 : 
            _sg = sg[1];
            continue ;
            
      }
      if (exit === 1) {
        _sg = sg[1];
        _pos = pos + 1 | 0;
        continue ;
        
      }
      
    } else {
      return /* [] */0;
    }
  };
}

function contains_type(env, _param) {
  while(true) {
    var param = _param;
    switch (param.tag | 0) {
      case 0 : 
          try {
            var match = find_modtype(param[0], env)[/* mtd_type */0];
            if (match) {
              return contains_type(env, match[0]);
            } else {
              throw Pervasives.Exit;
            }
          }
          catch (exn){
            if (exn === Caml_builtin_exceptions.not_found) {
              throw Pervasives.Exit;
            } else {
              throw exn;
            }
          }
          break;
      case 1 : 
          return List.iter((function (param) {
                        var env$1 = env;
                        var param$1 = param;
                        switch (param$1.tag | 0) {
                          case 1 : 
                              var match = param$1[1];
                              var match$1 = match[/* type_kind */2];
                              if (match[/* type_manifest */4]) {
                                if (typeof match$1 === "number") {
                                  if (match$1 !== 0) {
                                    return /* () */0;
                                  } else if (match[/* type_private */3] !== 0) {
                                    return /* () */0;
                                  } else {
                                    throw Pervasives.Exit;
                                  }
                                } else {
                                  return /* () */0;
                                }
                              } else {
                                throw Pervasives.Exit;
                              }
                              break;
                          case 3 : 
                              return contains_type(env$1, param$1[1][/* md_type */0]);
                          case 4 : 
                              throw Pervasives.Exit;
                          default:
                            return /* () */0;
                        }
                      }), param[0]);
      case 2 : 
          _param = param[2];
          continue ;
          case 3 : 
          return /* () */0;
      
    }
  };
}

function contains_type$1(env, mty) {
  try {
    contains_type(env, mty);
    return /* false */0;
  }
  catch (exn){
    if (exn === Pervasives.Exit) {
      return /* true */1;
    } else {
      throw exn;
    }
  }
}

function compare$3(p1, p2) {
  if (same(p1, p2)) {
    return 0;
  } else {
    return Caml_obj.caml_compare(p1, p2);
  }
}

function height$7(param) {
  if (param) {
    return param[3];
  } else {
    return 0;
  }
}

function create$8(l, v, r) {
  var hl = l ? l[3] : 0;
  var hr = r ? r[3] : 0;
  return /* Node */[
          l,
          v,
          r,
          hl >= hr ? hl + 1 | 0 : hr + 1 | 0
        ];
}

function bal$7(l, v, r) {
  var hl = l ? l[3] : 0;
  var hr = r ? r[3] : 0;
  if (hl > (hr + 2 | 0)) {
    if (l) {
      var lr = l[2];
      var lv = l[1];
      var ll = l[0];
      if (height$7(ll) >= height$7(lr)) {
        return create$8(ll, lv, create$8(lr, v, r));
      } else if (lr) {
        return create$8(create$8(ll, lv, lr[0]), lr[1], create$8(lr[2], v, r));
      } else {
        throw [
              Caml_builtin_exceptions.invalid_argument,
              "Set.bal"
            ];
      }
    } else {
      throw [
            Caml_builtin_exceptions.invalid_argument,
            "Set.bal"
          ];
    }
  } else if (hr > (hl + 2 | 0)) {
    if (r) {
      var rr = r[2];
      var rv = r[1];
      var rl = r[0];
      if (height$7(rr) >= height$7(rl)) {
        return create$8(create$8(l, v, rl), rv, rr);
      } else if (rl) {
        return create$8(create$8(l, v, rl[0]), rl[1], create$8(rl[2], rv, rr));
      } else {
        throw [
              Caml_builtin_exceptions.invalid_argument,
              "Set.bal"
            ];
      }
    } else {
      throw [
            Caml_builtin_exceptions.invalid_argument,
            "Set.bal"
          ];
    }
  } else {
    return /* Node */[
            l,
            v,
            r,
            hl >= hr ? hl + 1 | 0 : hr + 1 | 0
          ];
  }
}

function add$9(x, t) {
  if (t) {
    var r = t[2];
    var v = t[1];
    var l = t[0];
    var c = compare$3(x, v);
    if (c) {
      if (c < 0) {
        return bal$7(add$9(x, l), v, r);
      } else {
        return bal$7(l, v, add$9(x, r));
      }
    } else {
      return t;
    }
  } else {
    return /* Node */[
            /* Empty */0,
            x,
            /* Empty */0,
            1
          ];
  }
}

function singleton$2(x) {
  return /* Node */[
          /* Empty */0,
          x,
          /* Empty */0,
          1
        ];
}

function add_min_element$2(v, param) {
  if (param) {
    return bal$7(add_min_element$2(v, param[0]), param[1], param[2]);
  } else {
    return singleton$2(v);
  }
}

function add_max_element$2(v, param) {
  if (param) {
    return bal$7(param[0], param[1], add_max_element$2(v, param[2]));
  } else {
    return singleton$2(v);
  }
}

function join$2(l, v, r) {
  if (l) {
    if (r) {
      var rh = r[3];
      var lh = l[3];
      if (lh > (rh + 2 | 0)) {
        return bal$7(l[0], l[1], join$2(l[2], v, r));
      } else if (rh > (lh + 2 | 0)) {
        return bal$7(join$2(l, v, r[0]), r[1], r[2]);
      } else {
        return create$8(l, v, r);
      }
    } else {
      return add_max_element$2(v, l);
    }
  } else {
    return add_min_element$2(v, r);
  }
}

function split$2(x, param) {
  if (param) {
    var r = param[2];
    var v = param[1];
    var l = param[0];
    var c = compare$3(x, v);
    if (c) {
      if (c < 0) {
        var match = split$2(x, l);
        return /* tuple */[
                match[0],
                match[1],
                join$2(match[2], v, r)
              ];
      } else {
        var match$1 = split$2(x, r);
        return /* tuple */[
                join$2(l, v, match$1[0]),
                match$1[1],
                match$1[2]
              ];
      }
    } else {
      return /* tuple */[
              l,
              /* true */1,
              r
            ];
    }
  } else {
    return /* tuple */[
            /* Empty */0,
            /* false */0,
            /* Empty */0
          ];
  }
}

function union$3(s1, s2) {
  if (s1) {
    if (s2) {
      var h2 = s2[3];
      var v2 = s2[1];
      var h1 = s1[3];
      var v1 = s1[1];
      if (h1 >= h2) {
        if (h2 === 1) {
          return add$9(v2, s1);
        } else {
          var match = split$2(v1, s2);
          return join$2(union$3(s1[0], match[0]), v1, union$3(s1[2], match[2]));
        }
      } else if (h1 === 1) {
        return add$9(v1, s2);
      } else {
        var match$1 = split$2(v2, s1);
        return join$2(union$3(match$1[0], s2[0]), v2, union$3(match$1[2], s2[2]));
      }
    } else {
      return s1;
    }
  } else {
    return s2;
  }
}

function fold$5(f, _s, _accu) {
  while(true) {
    var accu = _accu;
    var s = _s;
    if (s) {
      _accu = Curry._2(f, s[1], fold$5(f, s[0], accu));
      _s = s[2];
      continue ;
      
    } else {
      return accu;
    }
  };
}

function height$8(param) {
  if (param) {
    return param[4];
  } else {
    return 0;
  }
}

function create$9(l, x, d, r) {
  var hl = height$8(l);
  var hr = height$8(r);
  return /* Node */[
          l,
          x,
          d,
          r,
          hl >= hr ? hl + 1 | 0 : hr + 1 | 0
        ];
}

function bal$8(l, x, d, r) {
  var hl = l ? l[4] : 0;
  var hr = r ? r[4] : 0;
  if (hl > (hr + 2 | 0)) {
    if (l) {
      var lr = l[3];
      var ld = l[2];
      var lv = l[1];
      var ll = l[0];
      if (height$8(ll) >= height$8(lr)) {
        return create$9(ll, lv, ld, create$9(lr, x, d, r));
      } else if (lr) {
        return create$9(create$9(ll, lv, ld, lr[0]), lr[1], lr[2], create$9(lr[3], x, d, r));
      } else {
        throw [
              Caml_builtin_exceptions.invalid_argument,
              "Map.bal"
            ];
      }
    } else {
      throw [
            Caml_builtin_exceptions.invalid_argument,
            "Map.bal"
          ];
    }
  } else if (hr > (hl + 2 | 0)) {
    if (r) {
      var rr = r[3];
      var rd = r[2];
      var rv = r[1];
      var rl = r[0];
      if (height$8(rr) >= height$8(rl)) {
        return create$9(create$9(l, x, d, rl), rv, rd, rr);
      } else if (rl) {
        return create$9(create$9(l, x, d, rl[0]), rl[1], rl[2], create$9(rl[3], rv, rd, rr));
      } else {
        throw [
              Caml_builtin_exceptions.invalid_argument,
              "Map.bal"
            ];
      }
    } else {
      throw [
            Caml_builtin_exceptions.invalid_argument,
            "Map.bal"
          ];
    }
  } else {
    return /* Node */[
            l,
            x,
            d,
            r,
            hl >= hr ? hl + 1 | 0 : hr + 1 | 0
          ];
  }
}

function add$10(x, data, param) {
  if (param) {
    var r = param[3];
    var d = param[2];
    var v = param[1];
    var l = param[0];
    var c = compare$3(x, v);
    if (c) {
      if (c < 0) {
        return bal$8(add$10(x, data, l), v, d, r);
      } else {
        return bal$8(l, v, d, add$10(x, data, r));
      }
    } else {
      return /* Node */[
              l,
              x,
              data,
              r,
              param[4]
            ];
    }
  } else {
    return /* Node */[
            /* Empty */0,
            x,
            data,
            /* Empty */0,
            1
          ];
  }
}

function find$5(x, _param) {
  while(true) {
    var param = _param;
    if (param) {
      var c = compare$3(x, param[1]);
      if (c) {
        _param = c < 0 ? param[0] : param[3];
        continue ;
        
      } else {
        return param[2];
      }
    } else {
      throw Caml_builtin_exceptions.not_found;
    }
  };
}

function height$9(param) {
  if (param) {
    return param[3];
  } else {
    return 0;
  }
}

function create$10(l, v, r) {
  var hl = l ? l[3] : 0;
  var hr = r ? r[3] : 0;
  return /* Node */[
          l,
          v,
          r,
          hl >= hr ? hl + 1 | 0 : hr + 1 | 0
        ];
}

function bal$9(l, v, r) {
  var hl = l ? l[3] : 0;
  var hr = r ? r[3] : 0;
  if (hl > (hr + 2 | 0)) {
    if (l) {
      var lr = l[2];
      var lv = l[1];
      var ll = l[0];
      if (height$9(ll) >= height$9(lr)) {
        return create$10(ll, lv, create$10(lr, v, r));
      } else if (lr) {
        return create$10(create$10(ll, lv, lr[0]), lr[1], create$10(lr[2], v, r));
      } else {
        throw [
              Caml_builtin_exceptions.invalid_argument,
              "Set.bal"
            ];
      }
    } else {
      throw [
            Caml_builtin_exceptions.invalid_argument,
            "Set.bal"
          ];
    }
  } else if (hr > (hl + 2 | 0)) {
    if (r) {
      var rr = r[2];
      var rv = r[1];
      var rl = r[0];
      if (height$9(rr) >= height$9(rl)) {
        return create$10(create$10(l, v, rl), rv, rr);
      } else if (rl) {
        return create$10(create$10(l, v, rl[0]), rl[1], create$10(rl[2], rv, rr));
      } else {
        throw [
              Caml_builtin_exceptions.invalid_argument,
              "Set.bal"
            ];
      }
    } else {
      throw [
            Caml_builtin_exceptions.invalid_argument,
            "Set.bal"
          ];
    }
  } else {
    return /* Node */[
            l,
            v,
            r,
            hl >= hr ? hl + 1 | 0 : hr + 1 | 0
          ];
  }
}

function add$11(x, t) {
  if (t) {
    var r = t[2];
    var v = t[1];
    var l = t[0];
    var c = Caml_obj.caml_compare(x, v);
    if (c) {
      if (c < 0) {
        return bal$9(add$11(x, l), v, r);
      } else {
        return bal$9(l, v, add$11(x, r));
      }
    } else {
      return t;
    }
  } else {
    return /* Node */[
            /* Empty */0,
            x,
            /* Empty */0,
            1
          ];
  }
}

function singleton$3(x) {
  return /* Node */[
          /* Empty */0,
          x,
          /* Empty */0,
          1
        ];
}

function add_min_element$3(v, param) {
  if (param) {
    return bal$9(add_min_element$3(v, param[0]), param[1], param[2]);
  } else {
    return singleton$3(v);
  }
}

function add_max_element$3(v, param) {
  if (param) {
    return bal$9(param[0], param[1], add_max_element$3(v, param[2]));
  } else {
    return singleton$3(v);
  }
}

function join$3(l, v, r) {
  if (l) {
    if (r) {
      var rh = r[3];
      var lh = l[3];
      if (lh > (rh + 2 | 0)) {
        return bal$9(l[0], l[1], join$3(l[2], v, r));
      } else if (rh > (lh + 2 | 0)) {
        return bal$9(join$3(l, v, r[0]), r[1], r[2]);
      } else {
        return create$10(l, v, r);
      }
    } else {
      return add_max_element$3(v, l);
    }
  } else {
    return add_min_element$3(v, r);
  }
}

function split$3(x, param) {
  if (param) {
    var r = param[2];
    var v = param[1];
    var l = param[0];
    var c = Caml_obj.caml_compare(x, v);
    if (c) {
      if (c < 0) {
        var match = split$3(x, l);
        return /* tuple */[
                match[0],
                match[1],
                join$3(match[2], v, r)
              ];
      } else {
        var match$1 = split$3(x, r);
        return /* tuple */[
                join$3(l, v, match$1[0]),
                match$1[1],
                match$1[2]
              ];
      }
    } else {
      return /* tuple */[
              l,
              /* true */1,
              r
            ];
    }
  } else {
    return /* tuple */[
            /* Empty */0,
            /* false */0,
            /* Empty */0
          ];
  }
}

function mem$5(x, _param) {
  while(true) {
    var param = _param;
    if (param) {
      var c = Caml_obj.caml_compare(x, param[1]);
      if (c) {
        _param = c < 0 ? param[0] : param[2];
        continue ;
        
      } else {
        return /* true */1;
      }
    } else {
      return /* false */0;
    }
  };
}

function union$4(s1, s2) {
  if (s1) {
    if (s2) {
      var h2 = s2[3];
      var v2 = s2[1];
      var h1 = s1[3];
      var v1 = s1[1];
      if (h1 >= h2) {
        if (h2 === 1) {
          return add$11(v2, s1);
        } else {
          var match = split$3(v1, s2);
          return join$3(union$4(s1[0], match[0]), v1, union$4(s1[2], match[2]));
        }
      } else if (h1 === 1) {
        return add$11(v1, s2);
      } else {
        var match$1 = split$3(v2, s1);
        return join$3(union$4(match$1[0], s2[0]), v2, union$4(match$1[2], s2[2]));
      }
    } else {
      return s1;
    }
  } else {
    return s2;
  }
}

function get_prefixes(param) {
  var exit = 0;
  switch (param.tag | 0) {
    case 0 : 
        return /* Empty */0;
    case 1 : 
    case 2 : 
        exit = 1;
        break;
    
  }
  if (exit === 1) {
    var p = param[0];
    return add$9(p, get_prefixes(p));
  }
  
}

function get_arg_paths(_param) {
  while(true) {
    var param = _param;
    switch (param.tag | 0) {
      case 0 : 
          return /* Empty */0;
      case 1 : 
          _param = param[0];
          continue ;
          case 2 : 
          var p2 = param[1];
          return add$9(p2, union$3(get_prefixes(p2), union$3(get_arg_paths(param[0]), get_arg_paths(p2))));
      
    }
  };
}

function rollback_path(subst, _p) {
  while(true) {
    var p = _p;
    try {
      return /* Pident */Block.__(0, [find$5(p, subst)]);
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        switch (p.tag | 0) {
          case 1 : 
              var p1 = p[0];
              var p1$prime = rollback_path(subst, p1);
              if (same(p1, p1$prime)) {
                return p;
              } else {
                _p = /* Pdot */Block.__(1, [
                    p1$prime,
                    p[1],
                    p[2]
                  ]);
                continue ;
                
              }
              break;
          case 0 : 
          case 2 : 
              return p;
          
        }
      } else {
        throw exn;
      }
    }
  };
}

function collect_ids(subst, bindings, p) {
  var match = rollback_path(subst, p);
  switch (match.tag | 0) {
    case 0 : 
        var id = match[0];
        var ids;
        try {
          ids = collect_ids(subst, bindings, find_same(id, bindings));
        }
        catch (exn){
          if (exn === Caml_builtin_exceptions.not_found) {
            ids = /* Empty */0;
          } else {
            throw exn;
          }
        }
        return add$11(id, ids);
    case 1 : 
    case 2 : 
        return /* Empty */0;
    
  }
}

function collect_arg_paths(mty) {
  var paths = [/* Empty */0];
  var subst = [/* Empty */0];
  var bindings = [/* Empty */0];
  var it_path = function (p) {
    paths[0] = union$3(get_arg_paths(p), paths[0]);
    return /* () */0;
  };
  var it_signature_item = function (it, si) {
    Curry._2(newrecord[/* it_signature_item */1], it, si);
    if (si.tag === 3) {
      var match = si[1][/* md_type */0];
      var id = si[0];
      switch (match.tag | 0) {
        case 1 : 
            return List.iter((function (param) {
                          if (param.tag === 3) {
                            var id$prime = param[0];
                            subst[0] = add$10(/* Pdot */Block.__(1, [
                                    /* Pident */Block.__(0, [id]),
                                    id$prime[/* name */1],
                                    -1
                                  ]), id$prime, subst[0]);
                            return /* () */0;
                          } else {
                            return /* () */0;
                          }
                        }), match[0]);
        case 0 : 
        case 2 : 
            return /* () */0;
        case 3 : 
            bindings[0] = add(id, match[0], bindings[0]);
            return /* () */0;
        
      }
    } else {
      return /* () */0;
    }
  };
  var newrecord$3 = newrecord.slice();
  newrecord$3[/* it_signature_item */1] = it_signature_item;
  newrecord$3[/* it_path */14] = it_path;
  Curry._2(newrecord$3[/* it_module_type */9], newrecord$3, mty);
  Curry._2(newrecord$3[/* it_module_type */9], newrecord$1, mty);
  return fold$5((function (p) {
                var partial_arg = collect_ids(subst[0], bindings[0], p);
                return (function (param) {
                    return union$4(partial_arg, param);
                  });
              }), paths[0], /* Empty */0);
}

function remove_aliases(env, excl, _mty) {
  while(true) {
    var mty = _mty;
    switch (mty.tag | 0) {
      case 1 : 
          return /* Mty_signature */Block.__(1, [remove_aliases_sig(env, excl, mty[0])]);
      case 0 : 
      case 2 : 
          return mty;
      case 3 : 
          var mty$prime = scrape_alias(env, /* None */0, mty);
          if (Caml_obj.caml_equal(mty$prime, mty)) {
            return mty;
          } else {
            _mty = mty$prime;
            continue ;
            
          }
          break;
      
    }
  };
}

function remove_aliases_sig(env, excl, sg) {
  if (sg) {
    var it = sg[0];
    switch (it.tag | 0) {
      case 3 : 
          var md = it[1];
          var id = it[0];
          var mty = md[/* md_type */0];
          var mty$1;
          mty$1 = mty.tag === 3 && mem$5(id, excl) ? md[/* md_type */0] : remove_aliases(env, excl, mty);
          return /* :: */[
                  /* Sig_module */Block.__(3, [
                      id,
                      /* record */[
                        /* md_type */mty$1,
                        /* md_attributes */md[/* md_attributes */1],
                        /* md_loc */md[/* md_loc */2]
                      ],
                      it[2]
                    ]),
                  remove_aliases_sig(add_module$1(/* None */0, id, mty$1, env), excl, sg[1])
                ];
      case 4 : 
          var mtd = it[1];
          var id$1 = it[0];
          return /* :: */[
                  /* Sig_modtype */Block.__(4, [
                      id$1,
                      mtd
                    ]),
                  remove_aliases_sig(add_modtype$1(id$1, mtd, env), excl, sg[1])
                ];
      default:
        return /* :: */[
                it,
                remove_aliases_sig(env, excl, sg[1])
              ];
    }
  } else {
    return /* [] */0;
  }
}

function remove_aliases$1(env, sg) {
  var excl = collect_arg_paths(sg);
  return remove_aliases(env, excl, sg);
}

var $$Error$5 = Caml_exceptions.create("Ocaml_typedtree_test.Includemod.Error");

function value_descriptions(env, cxt, subst, id, vd1, vd2) {
  record_value_dependency(vd1, vd2);
  mark_value_used(env, id[/* name */1], vd1);
  var vd2$1 = value_description(subst, vd2);
  try {
    var env$1 = env;
    var id$1 = id;
    var vd1$1 = vd1;
    var vd2$2 = vd2$1;
    if (moregeneral(env$1, /* true */1, vd1$1[/* val_type */0], vd2$2[/* val_type */0])) {
      var match = vd1$1[/* val_kind */1];
      var match$1 = vd2$2[/* val_kind */1];
      var exit = 0;
      if (typeof match === "number") {
        exit = 1;
      } else if (match.tag) {
        exit = 1;
      } else {
        var p1 = match[0];
        if (typeof match$1 === "number") {
          return /* Tcoerce_primitive */Block.__(2, [
                    id$1,
                    p1
                  ]);
        } else if (match$1.tag) {
          return /* Tcoerce_primitive */Block.__(2, [
                    id$1,
                    p1
                  ]);
        } else if (Caml_obj.caml_equal(p1, match$1[0])) {
          return /* Tcoerce_none */0;
        } else {
          throw Dont_match;
        }
      }
      if (exit === 1) {
        if (typeof match$1 === "number") {
          return /* Tcoerce_none */0;
        } else if (match$1.tag) {
          return /* Tcoerce_none */0;
        } else {
          throw Dont_match;
        }
      }
      
    } else {
      throw Dont_match;
    }
  }
  catch (exn){
    if (exn === Dont_match) {
      throw [
            $$Error$5,
            /* :: */[
              /* tuple */[
                cxt,
                env,
                /* Value_descriptions */Block.__(1, [
                    id,
                    vd1,
                    vd2$1
                  ])
              ],
              /* [] */0
            ]
          ];
    } else {
      throw exn;
    }
  }
}

function type_declarations$2(env, $staropt$star, cxt, subst, id, decl1, decl2) {
  var old_env = $staropt$star ? $staropt$star[0] : env;
  mark_type_used(env, id[/* name */1], decl1);
  var decl2$1 = type_declaration(subst, decl2);
  var err = type_declarations$1(/* None */0, env, id[/* name */1], decl1, id, decl2$1);
  if (err !== /* [] */0) {
    throw [
          $$Error$5,
          /* :: */[
            /* tuple */[
              cxt,
              old_env,
              /* Type_declarations */Block.__(2, [
                  id,
                  decl1,
                  decl2$1,
                  err
                ])
            ],
            /* [] */0
          ]
        ];
  } else {
    return 0;
  }
}

function extension_constructors$1(env, cxt, subst, id, ext1, ext2) {
  var ext2$1 = extension_constructor(subst, ext2);
  if (extension_constructors(env, id, ext1, ext2$1)) {
    return /* () */0;
  } else {
    throw [
          $$Error$5,
          /* :: */[
            /* tuple */[
              cxt,
              env,
              /* Extension_constructors */Block.__(3, [
                  id,
                  ext1,
                  ext2$1
                ])
            ],
            /* [] */0
          ]
        ];
  }
}

function class_type_declarations$1(old_env, env, cxt, subst, id, decl1, decl2) {
  var decl2$1 = cltype_declaration(subst, decl2);
  var reason = class_type_declarations(env, decl1, decl2$1);
  if (reason) {
    throw [
          $$Error$5,
          /* :: */[
            /* tuple */[
              cxt,
              old_env,
              /* Class_type_declarations */Block.__(7, [
                  id,
                  decl1,
                  decl2$1,
                  reason
                ])
            ],
            /* [] */0
          ]
        ];
  } else {
    return /* () */0;
  }
}

function class_declarations$1(old_env, env, cxt, subst, id, decl1, decl2) {
  var decl2$1 = class_declaration(subst, decl2);
  var reason = class_declarations(env, decl1, decl2$1);
  if (reason) {
    throw [
          $$Error$5,
          /* :: */[
            /* tuple */[
              cxt,
              old_env,
              /* Class_declarations */Block.__(8, [
                  id,
                  decl1,
                  decl2$1,
                  reason
                ])
            ],
            /* [] */0
          ]
        ];
  } else {
    return /* () */0;
  }
}

var Dont_match$1 = Caml_exceptions.create("Ocaml_typedtree_test.Includemod.Dont_match");

function may_expand_module_path(env, path) {
  try {
    find_modtype_expansion(path, env);
    return /* true */1;
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return /* false */0;
    } else {
      throw exn;
    }
  }
}

function expand_module_path(env, cxt, path) {
  try {
    return find_modtype_expansion(path, env);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      throw [
            $$Error$5,
            /* :: */[
              /* tuple */[
                cxt,
                env,
                /* Unbound_modtype_path */Block.__(9, [path])
              ],
              /* [] */0
            ]
          ];
    } else {
      throw exn;
    }
  }
}

function expand_module_alias(env, cxt, path) {
  try {
    return find_module(/* false */0, path, env)[/* md_type */0];
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      throw [
            $$Error$5,
            /* :: */[
              /* tuple */[
                cxt,
                env,
                /* Unbound_module_path */Block.__(10, [path])
              ],
              /* [] */0
            ]
          ];
    } else {
      throw exn;
    }
  }
}

function kind_of_field_desc(param) {
  switch (param.tag | 0) {
    case 0 : 
        return "value";
    case 1 : 
        return "type";
    case 2 : 
        return "extension constructor";
    case 3 : 
        return "module";
    case 4 : 
        return "module type";
    case 5 : 
        return "class";
    case 6 : 
        return "class type";
    
  }
}

function item_ident_name(param) {
  switch (param.tag | 0) {
    case 0 : 
        var id = param[0];
        return /* tuple */[
                id,
                param[1][/* val_loc */2],
                /* Field_value */Block.__(0, [id[/* name */1]])
              ];
    case 1 : 
        var id$1 = param[0];
        return /* tuple */[
                id$1,
                param[1][/* type_loc */7],
                /* Field_type */Block.__(1, [id$1[/* name */1]])
              ];
    case 2 : 
        var id$2 = param[0];
        return /* tuple */[
                id$2,
                param[1][/* ext_loc */5],
                /* Field_typext */Block.__(2, [id$2[/* name */1]])
              ];
    case 3 : 
        var id$3 = param[0];
        return /* tuple */[
                id$3,
                param[1][/* md_loc */2],
                /* Field_module */Block.__(3, [id$3[/* name */1]])
              ];
    case 4 : 
        var id$4 = param[0];
        return /* tuple */[
                id$4,
                param[1][/* mtd_loc */2],
                /* Field_modtype */Block.__(4, [id$4[/* name */1]])
              ];
    case 5 : 
        var id$5 = param[0];
        return /* tuple */[
                id$5,
                param[1][/* cty_loc */5],
                /* Field_class */Block.__(5, [id$5[/* name */1]])
              ];
    case 6 : 
        var id$6 = param[0];
        return /* tuple */[
                id$6,
                param[1][/* clty_loc */4],
                /* Field_classtype */Block.__(6, [id$6[/* name */1]])
              ];
    
  }
}

function is_runtime_component(param) {
  switch (param.tag | 0) {
    case 0 : 
        var $js = param[1][/* val_kind */1];
        if (typeof $js === "number" || $js.tag) {
          return /* true */1;
        } else {
          return /* false */0;
        }
        break;
    case 1 : 
    case 4 : 
    case 6 : 
        return /* false */0;
    default:
      return /* true */1;
  }
}

function modtypes(env, cxt, subst, mty1, mty2) {
  try {
    return try_modtypes(env, cxt, subst, mty1, mty2);
  }
  catch (raw_err){
    var err = Js_exn.internalToOCamlException(raw_err);
    if (err === Dont_match$1) {
      throw [
            $$Error$5,
            /* :: */[
              /* tuple */[
                cxt,
                env,
                /* Module_types */Block.__(4, [
                    mty1,
                    modtype(subst, mty2)
                  ])
              ],
              /* [] */0
            ]
          ];
    } else if (err[0] === $$Error$5) {
      if (mty1.tag === 3) {
        throw err;
      } else if (mty2.tag === 3) {
        throw err;
      } else {
        throw [
              $$Error$5,
              /* :: */[
                /* tuple */[
                  cxt,
                  env,
                  /* Module_types */Block.__(4, [
                      mty1,
                      modtype(subst, mty2)
                    ])
                ],
                err[1]
              ]
            ];
      }
    } else {
      throw err;
    }
  }
}

function try_modtypes(env, cxt, subst, _mty1, mty2) {
  while(true) {
    var mty1 = _mty1;
    var exit = 0;
    switch (mty1.tag | 0) {
      case 0 : 
          var p1 = mty1[0];
          if (may_expand_module_path(env, p1)) {
            _mty1 = expand_module_path(env, cxt, p1);
            continue ;
            
          } else {
            exit = 1;
          }
          break;
      case 1 : 
          switch (mty2.tag | 0) {
            case 0 : 
                exit = 1;
                break;
            case 1 : 
                return signatures(env, cxt, subst, mty1[0], mty2[0]);
            case 2 : 
            case 3 : 
                throw Dont_match$1;
            
          }
          break;
      case 2 : 
          var match = mty1[1];
          var param1 = mty1[0];
          if (match) {
            switch (mty2.tag | 0) {
              case 0 : 
                  exit = 1;
                  break;
              case 2 : 
                  var match$1 = mty2[1];
                  if (match$1) {
                    var arg2$prime = modtype(subst, match$1[0]);
                    var cc_arg = modtypes(env, /* :: */[
                          /* Arg */Block.__(2, [param1]),
                          cxt
                        ], identity, arg2$prime, match[0]);
                    var cc_res = modtypes(add_module$1(/* None */0, param1, arg2$prime, env), /* :: */[
                          /* Body */Block.__(3, [param1]),
                          cxt
                        ], add_module(mty2[0], /* Pident */Block.__(0, [param1]), subst), mty1[2], mty2[2]);
                    if (typeof cc_arg === "number") {
                      if (typeof cc_res === "number") {
                        return /* Tcoerce_none */0;
                      } else {
                        return /* Tcoerce_functor */Block.__(1, [
                                  cc_arg,
                                  cc_res
                                ]);
                      }
                    } else {
                      return /* Tcoerce_functor */Block.__(1, [
                                cc_arg,
                                cc_res
                              ]);
                    }
                  } else {
                    throw Dont_match$1;
                  }
                  break;
              case 1 : 
              case 3 : 
                  throw Dont_match$1;
              
            }
          } else {
            switch (mty2.tag | 0) {
              case 0 : 
                  exit = 1;
                  break;
              case 2 : 
                  if (mty2[1]) {
                    throw Dont_match$1;
                  } else {
                    var cc = modtypes(env, /* :: */[
                          /* Body */Block.__(3, [param1]),
                          cxt
                        ], subst, mty1[2], mty2[2]);
                    if (typeof cc === "number") {
                      return /* Tcoerce_none */0;
                    } else {
                      return /* Tcoerce_functor */Block.__(1, [
                                /* Tcoerce_none */0,
                                cc
                              ]);
                    }
                  }
                  break;
              case 1 : 
              case 3 : 
                  throw Dont_match$1;
              
            }
          }
          break;
      case 3 : 
          var p1$1 = mty1[0];
          if (mty2.tag === 3) {
            var p2 = mty2[0];
            if (is_functor_arg(p2, env)) {
              throw [
                    $$Error$5,
                    /* :: */[
                      /* tuple */[
                        cxt,
                        env,
                        /* Invalid_module_alias */Block.__(11, [p2])
                      ],
                      /* [] */0
                    ]
                  ];
            }
            if (same(p1$1, p2)) {
              return /* Tcoerce_none */0;
            } else {
              var p1$2 = normalize_path$1(/* None */0, env, p1$1);
              var p2$1 = normalize_path$1(/* None */0, env, module_path(subst, p2));
              if (same(p1$2, p2$1)) {
                return /* Tcoerce_none */0;
              } else {
                throw Dont_match$1;
              }
            }
          } else {
            var p1$3;
            try {
              p1$3 = normalize_path$1(/* Some */[none], env, p1$1);
            }
            catch (raw_exn){
              var exn = Js_exn.internalToOCamlException(raw_exn);
              if (exn[0] === $$Error$2) {
                var match$2 = exn[1];
                if (match$2.tag === 3) {
                  throw [
                        $$Error$5,
                        /* :: */[
                          /* tuple */[
                            cxt,
                            env,
                            /* Unbound_module_path */Block.__(10, [match$2[2]])
                          ],
                          /* [] */0
                        ]
                      ];
                } else {
                  throw exn;
                }
              } else {
                throw exn;
              }
            }
            var mty1$1 = strengthen$1(env, expand_module_alias(env, cxt, p1$3), p1$3);
            return /* Tcoerce_alias */Block.__(3, [
                      p1$3,
                      modtypes(env, cxt, subst, mty1$1, mty2)
                    ]);
          }
          break;
      
    }
    if (exit === 1) {
      if (mty2.tag) {
        throw Dont_match$1;
      } else {
        var env$1 = env;
        var cxt$1 = cxt;
        var mty1$2 = mty1;
        var mty2$1 = modtype(subst, mty2);
        var exit$1 = 0;
        if (mty1$2.tag) {
          exit$1 = 1;
        } else if (mty2$1.tag) {
          throw [
                Caml_builtin_exceptions.assert_failure,
                [
                  "includemod.ml",
                  275,
                  6
                ]
              ];
        } else if (same(mty1$2[0], mty2$1[0])) {
          return /* Tcoerce_none */0;
        } else {
          exit$1 = 1;
        }
        if (exit$1 === 1) {
          if (mty2$1.tag) {
            throw [
                  Caml_builtin_exceptions.assert_failure,
                  [
                    "includemod.ml",
                    275,
                    6
                  ]
                ];
          } else {
            return try_modtypes(env$1, cxt$1, identity, mty1$2, expand_module_path(env$1, cxt$1, mty2$1[0]));
          }
        }
        
      }
    }
    
  };
}

function signatures(env, cxt, subst, sig1, sig2) {
  var new_env = add_signature(sig1, in_signature(env));
  var match = List.fold_left((function (param, item) {
          var pos = param[1];
          var l = param[0];
          if (item.tag === 3) {
            return /* tuple */[
                    /* :: */[
                      /* tuple */[
                        item[0],
                        pos,
                        /* Tcoerce_none */0
                      ],
                      l
                    ],
                    pos + 1 | 0
                  ];
          } else {
            return /* tuple */[
                    l,
                    is_runtime_component(item) ? pos + 1 | 0 : pos
                  ];
          }
        }), /* tuple */[
        /* [] */0,
        0
      ], sig1);
  var id_pos_list = match[0];
  var build_component_table = function (_pos, _tbl, _param) {
    while(true) {
      var param = _param;
      var tbl = _tbl;
      var pos = _pos;
      if (param) {
        var item = param[0];
        var match = item_ident_name(item);
        var nextpos = is_runtime_component(item) ? pos + 1 | 0 : pos;
        _param = param[1];
        _tbl = add$5(match[2], /* tuple */[
              match[0],
              item,
              pos
            ], tbl);
        _pos = nextpos;
        continue ;
        
      } else {
        return /* tuple */[
                pos,
                tbl
              ];
      }
    };
  };
  var match$1 = build_component_table(0, /* Empty */0, sig1);
  var comps1 = match$1[1];
  var len1 = match$1[0];
  var len2 = List.fold_left((function (n, i) {
          if (is_runtime_component(i)) {
            return n + 1 | 0;
          } else {
            return n;
          }
        }), 0, sig2);
  var pair_components = function (subst, paired, _unpaired, _param) {
    while(true) {
      var param = _param;
      var unpaired = _unpaired;
      if (param) {
        var rem = param[1];
        var item2 = param[0];
        var match = item_ident_name(item2);
        var name2 = match[2];
        var id2 = match[0];
        var match$1;
        if (item2.tag === 1) {
          if (item2[1][/* type_manifest */4]) {
            match$1 = /* tuple */[
              name2,
              /* true */1
            ];
          } else if (name2.tag === 1) {
            var s = name2[0];
            var l = s.length;
            match$1 = l >= 4 && $$String.sub(s, l - 4 | 0, 4) === "#row" ? /* tuple */[
                /* Field_type */Block.__(1, [$$String.sub(s, 0, s.length - 4 | 0)]),
                /* false */0
              ] : /* tuple */[
                name2,
                /* true */1
              ];
          } else {
            match$1 = /* tuple */[
              name2,
              /* true */1
            ];
          }
        } else {
          match$1 = /* tuple */[
            name2,
            /* true */1
          ];
        }
        var name2$1 = match$1[0];
        try {
          var match$2 = find$2(name2$1, comps1);
          var id1 = match$2[0];
          var new_subst;
          switch (item2.tag | 0) {
            case 1 : 
                new_subst = add_type(id2, /* Pident */Block.__(0, [id1]), subst);
                break;
            case 3 : 
                new_subst = add_module(id2, /* Pident */Block.__(0, [id1]), subst);
                break;
            case 4 : 
                new_subst = add_modtype(id2, /* Mty_ident */Block.__(0, [/* Pident */Block.__(0, [id1])]), subst);
                break;
            default:
              new_subst = subst;
          }
          return pair_components(new_subst, /* :: */[
                      /* tuple */[
                        match$2[1],
                        item2,
                        match$2[2]
                      ],
                      paired
                    ], unpaired, rem);
        }
        catch (exn){
          if (exn === Caml_builtin_exceptions.not_found) {
            var unpaired$1 = match$1[1] ? /* :: */[
                /* tuple */[
                  cxt,
                  env,
                  /* Missing_field */Block.__(0, [
                      id2,
                      match[1],
                      kind_of_field_desc(name2$1)
                    ])
                ],
                unpaired
              ] : unpaired;
            _param = rem;
            _unpaired = unpaired$1;
            continue ;
            
          } else {
            throw exn;
          }
        }
      } else if (unpaired) {
        throw [
              $$Error$5,
              unpaired
            ];
      } else {
        var cc = signature_components(env, new_env, cxt, subst, List.rev(paired));
        if (len1 === len2) {
          var cc$1 = cc;
          var id_pos_list$1 = id_pos_list;
          var is_identity_coercion = function (_pos, _param) {
            while(true) {
              var param = _param;
              var pos = _pos;
              if (param) {
                var match = param[0];
                if (match[0] === pos) {
                  if (match[1]) {
                    return /* false */0;
                  } else {
                    _param = param[1];
                    _pos = pos + 1 | 0;
                    continue ;
                    
                  }
                } else {
                  return /* false */0;
                }
              } else {
                return /* true */1;
              }
            };
          };
          if (is_identity_coercion(0, cc$1)) {
            return /* Tcoerce_none */0;
          } else {
            return /* Tcoerce_structure */Block.__(0, [
                      cc$1,
                      id_pos_list$1
                    ]);
          }
        } else {
          return /* Tcoerce_structure */Block.__(0, [
                    cc,
                    id_pos_list
                  ]);
        }
      }
    };
  };
  return pair_components(subst, /* [] */0, /* [] */0, sig2);
}

function signature_components(old_env, env, cxt, subst, paired) {
  var comps_rec = function (rem) {
    return signature_components(old_env, env, cxt, subst, rem);
  };
  var exit = 0;
  if (paired) {
    var match = paired[0];
    var match$1 = match[0];
    switch (match$1.tag | 0) {
      case 0 : 
          var match$2 = match[1];
          if (match$2.tag) {
            exit = 1;
          } else {
            var rem = paired[1];
            var pos = match[2];
            var valdecl2 = match$2[1];
            var cc = value_descriptions(env, cxt, subst, match$1[0], match$1[1], valdecl2);
            var match$3 = valdecl2[/* val_kind */1];
            if (typeof match$3 === "number") {
              return /* :: */[
                      /* tuple */[
                        pos,
                        cc
                      ],
                      comps_rec(rem)
                    ];
            } else if (match$3.tag) {
              return /* :: */[
                      /* tuple */[
                        pos,
                        cc
                      ],
                      comps_rec(rem)
                    ];
            } else {
              return comps_rec(rem);
            }
          }
          break;
      case 1 : 
          var match$4 = match[1];
          if (match$4.tag === 1) {
            type_declarations$2(env, /* Some */[old_env], cxt, subst, match$1[0], match$1[1], match$4[1]);
            return comps_rec(paired[1]);
          } else {
            exit = 1;
          }
          break;
      case 2 : 
          var match$5 = match[1];
          if (match$5.tag === 2) {
            extension_constructors$1(env, cxt, subst, match$1[0], match$1[1], match$5[1]);
            return /* :: */[
                    /* tuple */[
                      match[2],
                      /* Tcoerce_none */0
                    ],
                    comps_rec(paired[1])
                  ];
          } else {
            exit = 1;
          }
          break;
      case 3 : 
          var match$6 = match[1];
          if (match$6.tag === 3) {
            var id1 = match$1[0];
            var cc$1 = modtypes(env, /* :: */[
                  /* Module */Block.__(0, [id1]),
                  cxt
                ], subst, strengthen$1(env, match$1[1][/* md_type */0], /* Pident */Block.__(0, [id1])), match$6[1][/* md_type */0]);
            return /* :: */[
                    /* tuple */[
                      match[2],
                      cc$1
                    ],
                    comps_rec(paired[1])
                  ];
          } else {
            exit = 1;
          }
          break;
      case 4 : 
          var match$7 = match[1];
          if (match$7.tag === 4) {
            modtype_infos(env, cxt, subst, match$1[0], match$1[1], match$7[1]);
            return comps_rec(paired[1]);
          } else {
            exit = 1;
          }
          break;
      case 5 : 
          var match$8 = match[1];
          if (match$8.tag === 5) {
            class_declarations$1(old_env, env, cxt, subst, match$1[0], match$1[1], match$8[1]);
            return /* :: */[
                    /* tuple */[
                      match[2],
                      /* Tcoerce_none */0
                    ],
                    comps_rec(paired[1])
                  ];
          } else {
            exit = 1;
          }
          break;
      case 6 : 
          var match$9 = match[1];
          if (match$9.tag === 6) {
            class_type_declarations$1(old_env, env, cxt, subst, match$1[0], match$1[1], match$9[1]);
            return comps_rec(paired[1]);
          } else {
            exit = 1;
          }
          break;
      
    }
  } else {
    return /* [] */0;
  }
  if (exit === 1) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "includemod.ml",
            400,
            6
          ]
        ];
  }
  
}

function modtype_infos(env, cxt, subst, id, info1, info2) {
  var info2$1 = modtype_declaration(subst, info2);
  var cxt$prime_000 = /* Modtype */Block.__(1, [id]);
  var cxt$prime = /* :: */[
    cxt$prime_000,
    cxt
  ];
  try {
    var match = info1[/* mtd_type */0];
    var match$1 = info2$1[/* mtd_type */0];
    if (match) {
      if (match$1) {
        return check_modtype_equiv(env, cxt$prime, match[0], match$1[0]);
      } else {
        return /* () */0;
      }
    } else if (match$1) {
      return check_modtype_equiv(env, cxt$prime, /* Mty_ident */Block.__(0, [/* Pident */Block.__(0, [id])]), match$1[0]);
    } else {
      return /* () */0;
    }
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === $$Error$5) {
      throw [
            $$Error$5,
            /* :: */[
              /* tuple */[
                cxt,
                env,
                /* Modtype_infos */Block.__(5, [
                    id,
                    info1,
                    info2$1
                  ])
              ],
              exn[1]
            ]
          ];
    } else {
      throw exn;
    }
  }
}

function check_modtype_equiv(env, cxt, mty1, mty2) {
  var match = modtypes(env, cxt, identity, mty1, mty2);
  var match$1 = modtypes(env, cxt, identity, mty2, mty1);
  var exit = 0;
  if (typeof match === "number") {
    if (typeof match$1 === "number") {
      return /* () */0;
    } else {
      exit = 1;
    }
  } else {
    exit = 1;
  }
  if (exit === 1) {
    throw [
          $$Error$5,
          /* :: */[
            /* tuple */[
              cxt,
              env,
              /* Modtype_permutation */0
            ],
            /* [] */0
          ]
        ];
  }
  
}

function check_modtype_inclusion$1(env, mty1, path1, mty2) {
  try {
    modtypes(env, /* [] */0, identity, strengthen$1(env, mty1, path1), mty2);
    return /* () */0;
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === $$Error$5) {
      throw Caml_builtin_exceptions.not_found;
    } else {
      throw exn;
    }
  }
}

check_modtype_inclusion[0] = check_modtype_inclusion$1;

function compunit(env, impl_name, impl_sig, intf_name, intf_sig) {
  try {
    return signatures(env, /* [] */0, identity, impl_sig, intf_sig);
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === $$Error$5) {
      throw [
            $$Error$5,
            /* :: */[
              /* tuple */[
                /* [] */0,
                empty,
                /* Interface_mismatch */Block.__(6, [
                    impl_name,
                    intf_name
                  ])
              ],
              exn[1]
            ]
          ];
    } else {
      throw exn;
    }
  }
}

function modtypes$1(env, mty1, mty2) {
  return modtypes(env, /* [] */0, identity, mty1, mty2);
}

function type_declarations$3(env, id, decl1, decl2) {
  return type_declarations$2(env, /* None */0, /* [] */0, identity, id, decl1, decl2);
}

function show_loc(msg, ppf, loc) {
  var pos = loc[/* loc_start */0];
  if (List.mem(pos[/* pos_fname */0], /* :: */[
          "",
          /* :: */[
            "_none_",
            /* :: */[
              "//toplevel//",
              /* [] */0
            ]
          ]
        ])) {
    return /* () */0;
  } else {
    return Curry._3(Format.fprintf(ppf, /* Format */[
                    /* Formatting_lit */Block.__(17, [
                        /* Force_newline */3,
                        /* Formatting_gen */Block.__(18, [
                            /* Open_box */Block.__(1, [/* Format */[
                                  /* String_literal */Block.__(11, [
                                      "<2>",
                                      /* End_of_format */0
                                    ]),
                                  "<2>"
                                ]]),
                            /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                    /* ":" */58,
                                    /* Formatting_lit */Block.__(17, [
                                        /* Break */Block.__(0, [
                                            "@ ",
                                            1,
                                            0
                                          ]),
                                        /* String */Block.__(2, [
                                            /* No_padding */0,
                                            /* Formatting_lit */Block.__(17, [
                                                /* Close_box */0,
                                                /* End_of_format */0
                                              ])
                                          ])
                                      ])
                                  ])])
                          ])
                      ]),
                    "@\n@[<2>%a:@ %s@]"
                  ]), print_loc, loc, msg);
  }
}

function show_locs(ppf, param) {
  show_loc("Expected declaration", ppf, param[1]);
  return show_loc("Actual declaration", ppf, param[0]);
}

function include_err$1(ppf, param) {
  if (typeof param === "number") {
    return Format.fprintf(ppf, /* Format */[
                /* String_literal */Block.__(11, [
                    "Illegal permutation of structure fields",
                    /* End_of_format */0
                  ]),
                "Illegal permutation of structure fields"
              ]);
  } else {
    switch (param.tag | 0) {
      case 0 : 
          Curry._3(Format.fprintf(ppf, /* Format */[
                    /* String_literal */Block.__(11, [
                        "The ",
                        /* String */Block.__(2, [
                            /* No_padding */0,
                            /* String_literal */Block.__(11, [
                                " `",
                                /* Alpha */Block.__(15, [/* String_literal */Block.__(11, [
                                        "' is required but not provided",
                                        /* End_of_format */0
                                      ])])
                              ])
                          ])
                      ]),
                    "The %s `%a' is required but not provided"
                  ]), param[2], ident$3, param[0]);
          return show_loc("Expected declaration", ppf, param[1]);
      case 1 : 
          var d2 = param[2];
          var d1 = param[1];
          var id = param[0];
          Curry._4(Format.fprintf(ppf, /* Format */[
                    /* Formatting_gen */Block.__(18, [
                        /* Open_box */Block.__(1, [/* Format */[
                              /* String_literal */Block.__(11, [
                                  "<hv 2>",
                                  /* End_of_format */0
                                ]),
                              "<hv 2>"
                            ]]),
                        /* String_literal */Block.__(11, [
                            "Values do not match:",
                            /* Formatting_lit */Block.__(17, [
                                /* Break */Block.__(0, [
                                    "@ ",
                                    1,
                                    0
                                  ]),
                                /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                        /* Break */Block.__(0, [
                                            "@;<1 -2>",
                                            1,
                                            -2
                                          ]),
                                        /* String_literal */Block.__(11, [
                                            "is not included in",
                                            /* Formatting_lit */Block.__(17, [
                                                /* Break */Block.__(0, [
                                                    "@ ",
                                                    1,
                                                    0
                                                  ]),
                                                /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                        /* Close_box */0,
                                                        /* End_of_format */0
                                                      ])])
                                              ])
                                          ])
                                      ])])
                              ])
                          ])
                      ]),
                    "@[<hv 2>Values do not match:@ %a@;<1 -2>is not included in@ %a@]"
                  ]), (function (param, param$1) {
                  return value_description$1(id, param, param$1);
                }), d1, (function (param, param$1) {
                  return value_description$1(id, param, param$1);
                }), d2);
          return show_locs(ppf, /* tuple */[
                      d1[/* val_loc */2],
                      d2[/* val_loc */2]
                    ]);
      case 2 : 
          var d2$1 = param[2];
          var d1$1 = param[1];
          var id$1 = param[0];
          return Curry.app(Format.fprintf(ppf, /* Format */[
                          /* Formatting_gen */Block.__(18, [
                              /* Open_box */Block.__(1, [/* Format */[
                                    /* String_literal */Block.__(11, [
                                        "<v>",
                                        /* End_of_format */0
                                      ]),
                                    "<v>"
                                  ]]),
                              /* Formatting_gen */Block.__(18, [
                                  /* Open_box */Block.__(1, [/* Format */[
                                        /* String_literal */Block.__(11, [
                                            "<hv>",
                                            /* End_of_format */0
                                          ]),
                                        "<hv>"
                                      ]]),
                                  /* String */Block.__(2, [
                                      /* No_padding */0,
                                      /* Char_literal */Block.__(12, [
                                          /* ":" */58,
                                          /* Formatting_lit */Block.__(17, [
                                              /* Break */Block.__(0, [
                                                  "@;<1 2>",
                                                  1,
                                                  2
                                                ]),
                                              /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                      /* Break */Block.__(0, [
                                                          "@ ",
                                                          1,
                                                          0
                                                        ]),
                                                      /* String */Block.__(2, [
                                                          /* No_padding */0,
                                                          /* Formatting_lit */Block.__(17, [
                                                              /* Break */Block.__(0, [
                                                                  "@;<1 2>",
                                                                  1,
                                                                  2
                                                                ]),
                                                              /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                      /* Close_box */0,
                                                                      /* Alpha */Block.__(15, [/* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                                  /* Close_box */0,
                                                                                  /* End_of_format */0
                                                                                ])])])
                                                                    ])])
                                                            ])
                                                        ])
                                                    ])])
                                            ])
                                        ])
                                    ])
                                ])
                            ]),
                          "@[<v>@[<hv>%s:@;<1 2>%a@ %s@;<1 2>%a@]%a%a@]"
                        ]), [
                      "Type declarations do not match",
                      (function (param, param$1) {
                          return type_declaration$1(id$1, param, param$1);
                        }),
                      d1$1,
                      "is not included in",
                      (function (param, param$1) {
                          return type_declaration$1(id$1, param, param$1);
                        }),
                      d2$1,
                      show_locs,
                      /* tuple */[
                        d1$1[/* type_loc */7],
                        d2$1[/* type_loc */7]
                      ],
                      (function (param) {
                          return report_type_mismatch("the first", "the second", "declaration", param);
                        }),
                      param[3]
                    ]);
      case 3 : 
          var x2 = param[2];
          var x1 = param[1];
          var id$2 = param[0];
          Curry._4(Format.fprintf(ppf, /* Format */[
                    /* Formatting_gen */Block.__(18, [
                        /* Open_box */Block.__(1, [/* Format */[
                              /* String_literal */Block.__(11, [
                                  "<hv 2>",
                                  /* End_of_format */0
                                ]),
                              "<hv 2>"
                            ]]),
                        /* String_literal */Block.__(11, [
                            "Extension declarations do not match:",
                            /* Formatting_lit */Block.__(17, [
                                /* Break */Block.__(0, [
                                    "@ ",
                                    1,
                                    0
                                  ]),
                                /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                        /* Break */Block.__(0, [
                                            "@;<1 -2>",
                                            1,
                                            -2
                                          ]),
                                        /* String_literal */Block.__(11, [
                                            "is not included in",
                                            /* Formatting_lit */Block.__(17, [
                                                /* Break */Block.__(0, [
                                                    "@ ",
                                                    1,
                                                    0
                                                  ]),
                                                /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                        /* Close_box */0,
                                                        /* End_of_format */0
                                                      ])])
                                              ])
                                          ])
                                      ])])
                              ])
                          ])
                      ]),
                    "@[<hv 2>Extension declarations do not match:@ %a@;<1 -2>is not included in@ %a@]"
                  ]), (function (param, param$1) {
                  return extension_constructor$1(id$2, param, param$1);
                }), x1, (function (param, param$1) {
                  return extension_constructor$1(id$2, param, param$1);
                }), x2);
          return show_locs(ppf, /* tuple */[
                      x1[/* ext_loc */5],
                      x2[/* ext_loc */5]
                    ]);
      case 4 : 
          return Curry._4(Format.fprintf(ppf, /* Format */[
                          /* Formatting_gen */Block.__(18, [
                              /* Open_box */Block.__(1, [/* Format */[
                                    /* String_literal */Block.__(11, [
                                        "<hv 2>",
                                        /* End_of_format */0
                                      ]),
                                    "<hv 2>"
                                  ]]),
                              /* String_literal */Block.__(11, [
                                  "Modules do not match:",
                                  /* Formatting_lit */Block.__(17, [
                                      /* Break */Block.__(0, [
                                          "@ ",
                                          1,
                                          0
                                        ]),
                                      /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                              /* Break */Block.__(0, [
                                                  "@;<1 -2>",
                                                  1,
                                                  -2
                                                ]),
                                              /* String_literal */Block.__(11, [
                                                  "is not included in",
                                                  /* Formatting_lit */Block.__(17, [
                                                      /* Break */Block.__(0, [
                                                          "@ ",
                                                          1,
                                                          0
                                                        ]),
                                                      /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                              /* Close_box */0,
                                                              /* End_of_format */0
                                                            ])])
                                                    ])
                                                ])
                                            ])])
                                    ])
                                ])
                            ]),
                          "@[<hv 2>Modules do not match:@ %a@;<1 -2>is not included in@ %a@]"
                        ]), modtype$1, param[0], modtype$1, param[1]);
      case 5 : 
          var id$3 = param[0];
          return Curry._4(Format.fprintf(ppf, /* Format */[
                          /* Formatting_gen */Block.__(18, [
                              /* Open_box */Block.__(1, [/* Format */[
                                    /* String_literal */Block.__(11, [
                                        "<hv 2>",
                                        /* End_of_format */0
                                      ]),
                                    "<hv 2>"
                                  ]]),
                              /* String_literal */Block.__(11, [
                                  "Module type declarations do not match:",
                                  /* Formatting_lit */Block.__(17, [
                                      /* Break */Block.__(0, [
                                          "@ ",
                                          1,
                                          0
                                        ]),
                                      /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                              /* Break */Block.__(0, [
                                                  "@;<1 -2>",
                                                  1,
                                                  -2
                                                ]),
                                              /* String_literal */Block.__(11, [
                                                  "does not match",
                                                  /* Formatting_lit */Block.__(17, [
                                                      /* Break */Block.__(0, [
                                                          "@ ",
                                                          1,
                                                          0
                                                        ]),
                                                      /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                              /* Close_box */0,
                                                              /* End_of_format */0
                                                            ])])
                                                    ])
                                                ])
                                            ])])
                                    ])
                                ])
                            ]),
                          "@[<hv 2>Module type declarations do not match:@ %a@;<1 -2>does not match@ %a@]"
                        ]), (function (param, param$1) {
                        return modtype_declaration$1(id$3, param, param$1);
                      }), param[1], (function (param, param$1) {
                        return modtype_declaration$1(id$3, param, param$1);
                      }), param[2]);
      case 6 : 
          return Curry._2(Format.fprintf(ppf, /* Format */[
                          /* Formatting_gen */Block.__(18, [
                              /* Open_box */Block.__(1, [/* Format */[
                                    /* End_of_format */0,
                                    ""
                                  ]]),
                              /* String_literal */Block.__(11, [
                                  "The implementation ",
                                  /* String */Block.__(2, [
                                      /* No_padding */0,
                                      /* Formatting_lit */Block.__(17, [
                                          /* Break */Block.__(0, [
                                              "@ ",
                                              1,
                                              0
                                            ]),
                                          /* String_literal */Block.__(11, [
                                              "does not match the interface ",
                                              /* String */Block.__(2, [
                                                  /* No_padding */0,
                                                  /* Char_literal */Block.__(12, [
                                                      /* ":" */58,
                                                      /* End_of_format */0
                                                    ])
                                                ])
                                            ])
                                        ])
                                    ])
                                ])
                            ]),
                          "@[The implementation %s@ does not match the interface %s:"
                        ]), param[0], param[1]);
      case 7 : 
          var id$4 = param[0];
          return Curry._6(Format.fprintf(ppf, /* Format */[
                          /* Formatting_gen */Block.__(18, [
                              /* Open_box */Block.__(1, [/* Format */[
                                    /* String_literal */Block.__(11, [
                                        "<hv 2>",
                                        /* End_of_format */0
                                      ]),
                                    "<hv 2>"
                                  ]]),
                              /* String_literal */Block.__(11, [
                                  "Class type declarations do not match:",
                                  /* Formatting_lit */Block.__(17, [
                                      /* Break */Block.__(0, [
                                          "@ ",
                                          1,
                                          0
                                        ]),
                                      /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                              /* Break */Block.__(0, [
                                                  "@;<1 -2>",
                                                  1,
                                                  -2
                                                ]),
                                              /* String_literal */Block.__(11, [
                                                  "does not match",
                                                  /* Formatting_lit */Block.__(17, [
                                                      /* Break */Block.__(0, [
                                                          "@ ",
                                                          1,
                                                          0
                                                        ]),
                                                      /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                              /* Close_box */0,
                                                              /* Formatting_lit */Block.__(17, [
                                                                  /* Break */Block.__(0, [
                                                                      "@ ",
                                                                      1,
                                                                      0
                                                                    ]),
                                                                  /* Alpha */Block.__(15, [/* End_of_format */0])
                                                                ])
                                                            ])])
                                                    ])
                                                ])
                                            ])])
                                    ])
                                ])
                            ]),
                          "@[<hv 2>Class type declarations do not match:@ %a@;<1 -2>does not match@ %a@]@ %a"
                        ]), (function (param, param$1) {
                        return cltype_declaration$1(id$4, param, param$1);
                      }), param[1], (function (param, param$1) {
                        return cltype_declaration$1(id$4, param, param$1);
                      }), param[2], report_error$3, param[3]);
      case 8 : 
          var id$5 = param[0];
          return Curry._6(Format.fprintf(ppf, /* Format */[
                          /* Formatting_gen */Block.__(18, [
                              /* Open_box */Block.__(1, [/* Format */[
                                    /* String_literal */Block.__(11, [
                                        "<hv 2>",
                                        /* End_of_format */0
                                      ]),
                                    "<hv 2>"
                                  ]]),
                              /* String_literal */Block.__(11, [
                                  "Class declarations do not match:",
                                  /* Formatting_lit */Block.__(17, [
                                      /* Break */Block.__(0, [
                                          "@ ",
                                          1,
                                          0
                                        ]),
                                      /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                              /* Break */Block.__(0, [
                                                  "@;<1 -2>",
                                                  1,
                                                  -2
                                                ]),
                                              /* String_literal */Block.__(11, [
                                                  "does not match",
                                                  /* Formatting_lit */Block.__(17, [
                                                      /* Break */Block.__(0, [
                                                          "@ ",
                                                          1,
                                                          0
                                                        ]),
                                                      /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                              /* Close_box */0,
                                                              /* Formatting_lit */Block.__(17, [
                                                                  /* Break */Block.__(0, [
                                                                      "@ ",
                                                                      1,
                                                                      0
                                                                    ]),
                                                                  /* Alpha */Block.__(15, [/* End_of_format */0])
                                                                ])
                                                            ])])
                                                    ])
                                                ])
                                            ])])
                                    ])
                                ])
                            ]),
                          "@[<hv 2>Class declarations do not match:@ %a@;<1 -2>does not match@ %a@]@ %a"
                        ]), (function (param, param$1) {
                        return class_declaration$1(id$5, param, param$1);
                      }), param[1], (function (param, param$1) {
                        return class_declaration$1(id$5, param, param$1);
                      }), param[2], report_error$3, param[3]);
      case 9 : 
          return Curry._2(Format.fprintf(ppf, /* Format */[
                          /* String_literal */Block.__(11, [
                              "Unbound module type ",
                              /* Alpha */Block.__(15, [/* End_of_format */0])
                            ]),
                          "Unbound module type %a"
                        ]), path, param[0]);
      case 10 : 
          return Curry._2(Format.fprintf(ppf, /* Format */[
                          /* String_literal */Block.__(11, [
                              "Unbound module ",
                              /* Alpha */Block.__(15, [/* End_of_format */0])
                            ]),
                          "Unbound module %a"
                        ]), path, param[0]);
      case 11 : 
          return Curry._2(Format.fprintf(ppf, /* Format */[
                          /* String_literal */Block.__(11, [
                              "Module ",
                              /* Alpha */Block.__(15, [/* String_literal */Block.__(11, [
                                      " cannot be aliased",
                                      /* End_of_format */0
                                    ])])
                            ]),
                          "Module %a cannot be aliased"
                        ]), path, param[0]);
      
    }
  }
}

function context(ppf, param) {
  if (param) {
    var match = param[0];
    switch (match.tag | 0) {
      case 0 : 
          return Curry._4(Format.fprintf(ppf, /* Format */[
                          /* Formatting_gen */Block.__(18, [
                              /* Open_box */Block.__(1, [/* Format */[
                                    /* String_literal */Block.__(11, [
                                        "<2>",
                                        /* End_of_format */0
                                      ]),
                                    "<2>"
                                  ]]),
                              /* String_literal */Block.__(11, [
                                  "module ",
                                  /* Alpha */Block.__(15, [/* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                              /* Close_box */0,
                                              /* End_of_format */0
                                            ])])])
                                ])
                            ]),
                          "@[<2>module %a%a@]"
                        ]), ident$3, match[0], args, param[1]);
      case 1 : 
          return Curry._4(Format.fprintf(ppf, /* Format */[
                          /* Formatting_gen */Block.__(18, [
                              /* Open_box */Block.__(1, [/* Format */[
                                    /* String_literal */Block.__(11, [
                                        "<2>",
                                        /* End_of_format */0
                                      ]),
                                    "<2>"
                                  ]]),
                              /* String_literal */Block.__(11, [
                                  "module type ",
                                  /* Alpha */Block.__(15, [/* String_literal */Block.__(11, [
                                          " =",
                                          /* Formatting_lit */Block.__(17, [
                                              /* Break */Block.__(0, [
                                                  "@ ",
                                                  1,
                                                  0
                                                ]),
                                              /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                      /* Close_box */0,
                                                      /* End_of_format */0
                                                    ])])
                                            ])
                                        ])])
                                ])
                            ]),
                          "@[<2>module type %a =@ %a@]"
                        ]), ident$3, match[0], context_mty, param[1]);
      case 2 : 
          return Curry._4(Format.fprintf(ppf, /* Format */[
                          /* String_literal */Block.__(11, [
                              "functor (",
                              /* Alpha */Block.__(15, [/* String_literal */Block.__(11, [
                                      " : ",
                                      /* Alpha */Block.__(15, [/* String_literal */Block.__(11, [
                                              ") -> ...",
                                              /* End_of_format */0
                                            ])])
                                    ])])
                            ]),
                          "functor (%a : %a) -> ..."
                        ]), ident$3, match[0], context_mty, param[1]);
      case 3 : 
          return Curry._3(Format.fprintf(ppf, /* Format */[
                          /* String_literal */Block.__(11, [
                              "functor (",
                              /* String */Block.__(2, [
                                  /* No_padding */0,
                                  /* String_literal */Block.__(11, [
                                      ") ->",
                                      /* Formatting_lit */Block.__(17, [
                                          /* Break */Block.__(0, [
                                              "@ ",
                                              1,
                                              0
                                            ]),
                                          /* Alpha */Block.__(15, [/* End_of_format */0])
                                        ])
                                    ])
                                ])
                            ]),
                          "functor (%s) ->@ %a"
                        ]), argname(match[0]), context_mty, param[1]);
      
    }
  } else {
    return Format.fprintf(ppf, /* Format */[
                /* String_literal */Block.__(11, [
                    "<here>",
                    /* End_of_format */0
                  ]),
                "<here>"
              ]);
  }
}

function context_mty(ppf, rem) {
  if (rem) {
    var exit = 0;
    switch (rem[0].tag | 0) {
      case 0 : 
      case 1 : 
          exit = 1;
          break;
      case 2 : 
      case 3 : 
          return context(ppf, rem);
      
    }
    if (exit === 1) {
      return Curry._2(Format.fprintf(ppf, /* Format */[
                      /* Formatting_gen */Block.__(18, [
                          /* Open_box */Block.__(1, [/* Format */[
                                /* String_literal */Block.__(11, [
                                    "<2>",
                                    /* End_of_format */0
                                  ]),
                                "<2>"
                              ]]),
                          /* String_literal */Block.__(11, [
                              "sig",
                              /* Formatting_lit */Block.__(17, [
                                  /* Break */Block.__(0, [
                                      "@ ",
                                      1,
                                      0
                                    ]),
                                  /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                          /* Break */Block.__(0, [
                                              "@;<1 -2>",
                                              1,
                                              -2
                                            ]),
                                          /* String_literal */Block.__(11, [
                                              "end",
                                              /* Formatting_lit */Block.__(17, [
                                                  /* Close_box */0,
                                                  /* End_of_format */0
                                                ])
                                            ])
                                        ])])
                                ])
                            ])
                        ]),
                      "@[<2>sig@ %a@;<1 -2>end@]"
                    ]), context, rem);
    }
    
  } else {
    return context(ppf, rem);
  }
}

function args(ppf, cxt) {
  var exit = 0;
  if (cxt) {
    var match = cxt[0];
    switch (match.tag | 0) {
      case 0 : 
      case 1 : 
          exit = 1;
          break;
      case 2 : 
          return Curry._4(Format.fprintf(ppf, /* Format */[
                          /* Char_literal */Block.__(12, [
                              /* "(" */40,
                              /* Alpha */Block.__(15, [/* String_literal */Block.__(11, [
                                      " :",
                                      /* Formatting_lit */Block.__(17, [
                                          /* Break */Block.__(0, [
                                              "@ ",
                                              1,
                                              0
                                            ]),
                                          /* Alpha */Block.__(15, [/* String_literal */Block.__(11, [
                                                  ") : ...",
                                                  /* End_of_format */0
                                                ])])
                                        ])
                                    ])])
                            ]),
                          "(%a :@ %a) : ..."
                        ]), ident$3, match[0], context_mty, cxt[1]);
      case 3 : 
          return Curry._3(Format.fprintf(ppf, /* Format */[
                          /* Char_literal */Block.__(12, [
                              /* "(" */40,
                              /* String */Block.__(2, [
                                  /* No_padding */0,
                                  /* Char_literal */Block.__(12, [
                                      /* ")" */41,
                                      /* Alpha */Block.__(15, [/* End_of_format */0])
                                    ])
                                ])
                            ]),
                          "(%s)%a"
                        ]), argname(match[0]), args, cxt[1]);
      
    }
  } else {
    exit = 1;
  }
  if (exit === 1) {
    return Curry._2(Format.fprintf(ppf, /* Format */[
                    /* String_literal */Block.__(11, [
                        " :",
                        /* Formatting_lit */Block.__(17, [
                            /* Break */Block.__(0, [
                                "@ ",
                                1,
                                0
                              ]),
                            /* Alpha */Block.__(15, [/* End_of_format */0])
                          ])
                      ]),
                    " :@ %a"
                  ]), context_mty, cxt);
  }
  
}

function argname(x) {
  var s = x[/* name */1];
  if (s === "*") {
    return "";
  } else {
    return s;
  }
}

function path_of_context(param) {
  if (param) {
    var match = param[0];
    if (match.tag) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "includemod.ml",
              573,
              9
            ]
          ];
    } else {
      var _path = /* Pident */Block.__(0, [match[0]]);
      var _param = param[1];
      while(true) {
        var param$1 = _param;
        var path = _path;
        if (param$1) {
          var match$1 = param$1[0];
          if (match$1.tag) {
            throw [
                  Caml_builtin_exceptions.assert_failure,
                  [
                    "includemod.ml",
                    571,
                    15
                  ]
                ];
          } else {
            _param = param$1[1];
            _path = /* Pdot */Block.__(1, [
                path,
                match$1[0][/* name */1],
                -1
              ]);
            continue ;
            
          }
        } else {
          return path;
        }
      };
    }
  } else {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "includemod.ml",
            573,
            9
          ]
        ];
  }
}

function context$1(ppf, cxt) {
  if (cxt) {
    if (List.for_all((function (param) {
              return param.tag ? /* false */0 : /* true */1;
            }), cxt)) {
      return Curry._2(Format.fprintf(ppf, /* Format */[
                      /* String_literal */Block.__(11, [
                          "In module ",
                          /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                  /* ":" */58,
                                  /* Formatting_lit */Block.__(17, [
                                      /* Break */Block.__(0, [
                                          "@ ",
                                          1,
                                          0
                                        ]),
                                      /* End_of_format */0
                                    ])
                                ])])
                        ]),
                      "In module %a:@ "
                    ]), path, path_of_context(cxt));
    } else {
      return Curry._2(Format.fprintf(ppf, /* Format */[
                      /* Formatting_gen */Block.__(18, [
                          /* Open_box */Block.__(1, [/* Format */[
                                /* String_literal */Block.__(11, [
                                    "<hv 2>",
                                    /* End_of_format */0
                                  ]),
                                "<hv 2>"
                              ]]),
                          /* String_literal */Block.__(11, [
                              "At position",
                              /* Formatting_lit */Block.__(17, [
                                  /* Break */Block.__(0, [
                                      "@ ",
                                      1,
                                      0
                                    ]),
                                  /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                          /* Close_box */0,
                                          /* Formatting_lit */Block.__(17, [
                                              /* Break */Block.__(0, [
                                                  "@ ",
                                                  1,
                                                  0
                                                ]),
                                              /* End_of_format */0
                                            ])
                                        ])])
                                ])
                            ])
                        ]),
                      "@[<hv 2>At position@ %a@]@ "
                    ]), context, cxt);
    }
  } else {
    return /* () */0;
  }
}

function include_err$2(ppf, param) {
  var err = param[2];
  var cxt = param[0];
  return wrap_printing_env(param[1], (function () {
                return Curry._4(Format.fprintf(ppf, /* Format */[
                                /* Formatting_gen */Block.__(18, [
                                    /* Open_box */Block.__(1, [/* Format */[
                                          /* String_literal */Block.__(11, [
                                              "<v>",
                                              /* End_of_format */0
                                            ]),
                                          "<v>"
                                        ]]),
                                    /* Alpha */Block.__(15, [/* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                /* Close_box */0,
                                                /* End_of_format */0
                                              ])])])
                                  ]),
                                "@[<v>%a%a@]"
                              ]), context$1, List.rev(cxt), include_err$1, err);
              }));
}

var buffer = [Bytes.empty];

function is_big(obj) {
  var size = error_size[0];
  if (size > 0) {
    if (buffer[0].length < size) {
      buffer[0] = Caml_string.caml_create_string(size);
    }
    try {
      Marshal.to_buffer(buffer[0], 0, size, obj, /* [] */0);
      return /* false */0;
    }
    catch (exn){
      return /* true */1;
    }
  } else {
    return /* false */0;
  }
}

function report_error$4(ppf, errs) {
  if (errs) {
    var match = split_last(errs);
    var pe = [/* true */1];
    var print_errs = function (ppf) {
      return (function (param) {
          return List.iter((function (param) {
                        var ppf$1 = ppf;
                        var err = param;
                        if (is_big(err[2])) {
                          if (pe[0]) {
                            Format.fprintf(ppf$1, /* Format */[
                                  /* String_literal */Block.__(11, [
                                      "...",
                                      /* Formatting_lit */Block.__(17, [
                                          /* Break */Block.__(0, [
                                              "@ ",
                                              1,
                                              0
                                            ]),
                                          /* End_of_format */0
                                        ])
                                    ]),
                                  "...@ "
                                ]);
                            pe[0] = /* false */0;
                            return /* () */0;
                          } else {
                            return 0;
                          }
                        } else {
                          return Curry._2(Format.fprintf(ppf$1, /* Format */[
                                          /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                  /* Break */Block.__(0, [
                                                      "@ ",
                                                      1,
                                                      0
                                                    ]),
                                                  /* End_of_format */0
                                                ])]),
                                          "%a@ "
                                        ]), include_err$2, err);
                        }
                      }), param);
        });
    };
    return Curry._4(Format.fprintf(ppf, /* Format */[
                    /* Formatting_gen */Block.__(18, [
                        /* Open_box */Block.__(1, [/* Format */[
                              /* String_literal */Block.__(11, [
                                  "<v>",
                                  /* End_of_format */0
                                ]),
                              "<v>"
                            ]]),
                        /* Alpha */Block.__(15, [/* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                    /* Close_box */0,
                                    /* End_of_format */0
                                  ])])])
                      ]),
                    "@[<v>%a%a@]"
                  ]), print_errs, match[0], include_err$2, match[1]);
  } else {
    return /* () */0;
  }
}

register_error_of_exn((function (param) {
        if (param[0] === $$Error$5) {
          return /* Some */[error_of_printer_file(report_error$4, param[1])];
        } else {
          return /* None */0;
        }
      }));

function get_location(ti) {
  switch (ti.tag | 0) {
    case 0 : 
    case 1 : 
    case 2 : 
    case 3 : 
        return ti[0][/* mod_loc */1];
    case 4 : 
    case 5 : 
        return ti[0];
    
  }
}

var annotations$1 = [/* [] */0];

var phrases = [/* [] */0];

function record$2(ti) {
  if (annotations[0] && !get_location(ti)[/* loc_ghost */2]) {
    annotations$1[0] = /* :: */[
      ti,
      annotations$1[0]
    ];
    return /* () */0;
  } else {
    return 0;
  }
}

function make_pat(desc, ty, tenv) {
  return /* record */[
          /* pat_desc */desc,
          /* pat_loc */none,
          /* pat_extra : [] */0,
          /* pat_type */ty,
          /* pat_env */tenv,
          /* pat_attributes : [] */0
        ];
}

var omega = make_pat(/* Tpat_any */0, none$2, empty);

var extra_pat = make_pat(/* Tpat_var */Block.__(0, [
        create("+"),
        /* record */[
          /* txt */"+",
          /* loc */none
        ]
      ]), none$2, empty);

function omegas(i) {
  if (i <= 0) {
    return /* [] */0;
  } else {
    return /* :: */[
            omega,
            omegas(i - 1 | 0)
          ];
  }
}

var zero = make_pat(/* Tpat_constant */Block.__(2, [/* Const_int */Block.__(0, [0])]), none$2, empty);

function is_absent(tag, row) {
  return +(row_field(tag, row[0]) === /* Rabsent */0);
}

function is_absent_pat(p) {
  var match = p[/* pat_desc */0];
  if (typeof match === "number" || match.tag !== 5) {
    return /* false */0;
  } else {
    return is_absent(match[0], match[2]);
  }
}

function const_compare(x, y) {
  switch (x.tag | 0) {
    case 2 : 
        if (y.tag === 2) {
          return Caml_string.caml_string_compare(x[0], y[0]);
        } else {
          return Caml_obj.caml_compare(x, y);
        }
        break;
    case 3 : 
        if (y.tag === 3) {
          return Caml_float.caml_float_compare(Caml_format.caml_float_of_string(x[0]), Caml_format.caml_float_of_string(y[0]));
        } else {
          return Caml_obj.caml_compare(x, y);
        }
        break;
    default:
      return Caml_obj.caml_compare(x, y);
  }
}

function records_args(l1, l2) {
  var _r1 = /* [] */0;
  var _r2 = /* [] */0;
  var _l1 = l1;
  var _l2 = l2;
  while(true) {
    var l2$1 = _l2;
    var l1$1 = _l1;
    var r2 = _r2;
    var r1 = _r1;
    if (l1$1) {
      var rem1 = l1$1[1];
      var match = l1$1[0];
      var p1 = match[2];
      var lbl1 = match[1];
      if (l2$1) {
        var rem2 = l2$1[1];
        var match$1 = l2$1[0];
        var p2 = match$1[2];
        var lbl2 = match$1[1];
        if (lbl1[/* lbl_pos */4] < lbl2[/* lbl_pos */4]) {
          _l1 = rem1;
          _r2 = /* :: */[
            omega,
            r2
          ];
          _r1 = /* :: */[
            p1,
            r1
          ];
          continue ;
          
        } else {
          _l2 = rem2;
          if (lbl1[/* lbl_pos */4] > lbl2[/* lbl_pos */4]) {
            _r2 = /* :: */[
              p2,
              r2
            ];
            _r1 = /* :: */[
              omega,
              r1
            ];
            continue ;
            
          } else {
            _l1 = rem1;
            _r2 = /* :: */[
              p2,
              r2
            ];
            _r1 = /* :: */[
              p1,
              r1
            ];
            continue ;
            
          }
        }
      } else {
        _l2 = /* [] */0;
        _l1 = rem1;
        _r2 = /* :: */[
          omega,
          r2
        ];
        _r1 = /* :: */[
          p1,
          r1
        ];
        continue ;
        
      }
    } else if (l2$1) {
      _l2 = l2$1[1];
      _l1 = /* [] */0;
      _r2 = /* :: */[
        l2$1[0][2],
        r2
      ];
      _r1 = /* :: */[
        omega,
        r1
      ];
      continue ;
      
    } else {
      return /* tuple */[
              List.rev(r1),
              List.rev(r2)
            ];
    }
  };
}

function compat(_p, _q) {
  while(true) {
    var q = _q;
    var p = _p;
    var match = p[/* pat_desc */0];
    var match$1 = q[/* pat_desc */0];
    var exit = 0;
    if (typeof match === "number") {
      exit = 1;
    } else {
      switch (match.tag | 0) {
        case 1 : 
            _p = match[0];
            continue ;
            case 2 : 
            if (typeof match$1 === "number") {
              exit = match$1 ? 3 : 1;
            } else {
              switch (match$1.tag | 0) {
                case 0 : 
                case 1 : 
                    exit = 1;
                    break;
                case 2 : 
                    return +(const_compare(match[0], match$1[0]) === 0);
                case 8 : 
                    exit = 2;
                    break;
                default:
                  exit = 3;
              }
            }
            break;
        case 3 : 
            if (typeof match$1 === "number") {
              exit = match$1 ? 3 : 1;
            } else {
              switch (match$1.tag | 0) {
                case 0 : 
                case 1 : 
                    exit = 1;
                    break;
                case 3 : 
                    return compats(match[0], match$1[0]);
                case 8 : 
                    exit = 2;
                    break;
                default:
                  exit = 3;
              }
            }
            break;
        case 4 : 
            if (typeof match$1 === "number") {
              exit = match$1 ? 3 : 1;
            } else {
              switch (match$1.tag | 0) {
                case 0 : 
                case 1 : 
                    exit = 1;
                    break;
                case 4 : 
                    if (equal_tag(match[1][/* cstr_tag */5], match$1[1][/* cstr_tag */5])) {
                      return compats(match[2], match$1[2]);
                    } else {
                      return /* false */0;
                    }
                case 8 : 
                    exit = 2;
                    break;
                default:
                  exit = 3;
              }
            }
            break;
        case 5 : 
            var match$2 = match[1];
            var l1 = match[0];
            if (match$2) {
              if (typeof match$1 === "number") {
                exit = match$1 ? 3 : 1;
              } else {
                switch (match$1.tag | 0) {
                  case 0 : 
                  case 1 : 
                      exit = 1;
                      break;
                  case 5 : 
                      var match$3 = match$1[1];
                      if (match$3) {
                        if (l1 === match$1[0]) {
                          _q = match$3[0];
                          _p = match$2[0];
                          continue ;
                          
                        } else {
                          return /* false */0;
                        }
                      } else {
                        return /* false */0;
                      }
                      break;
                  case 8 : 
                      exit = 2;
                      break;
                  default:
                    exit = 3;
                }
              }
            } else if (typeof match$1 === "number") {
              exit = match$1 ? 3 : 1;
            } else {
              switch (match$1.tag | 0) {
                case 0 : 
                case 1 : 
                    exit = 1;
                    break;
                case 5 : 
                    if (match$1[1]) {
                      return /* false */0;
                    } else {
                      return +(l1 === match$1[0]);
                    }
                case 8 : 
                    exit = 2;
                    break;
                default:
                  exit = 3;
              }
            }
            break;
        case 6 : 
            if (typeof match$1 === "number") {
              exit = match$1 ? 3 : 1;
            } else {
              switch (match$1.tag | 0) {
                case 0 : 
                case 1 : 
                    exit = 1;
                    break;
                case 6 : 
                    var match$4 = records_args(match[0], match$1[0]);
                    return compats(match$4[0], match$4[1]);
                case 8 : 
                    exit = 2;
                    break;
                default:
                  exit = 3;
              }
            }
            break;
        case 7 : 
            var ps = match[0];
            if (typeof match$1 === "number") {
              exit = match$1 ? 3 : 1;
            } else {
              switch (match$1.tag | 0) {
                case 0 : 
                case 1 : 
                    exit = 1;
                    break;
                case 7 : 
                    var qs = match$1[0];
                    if (List.length(ps) === List.length(qs)) {
                      return compats(ps, qs);
                    } else {
                      return /* false */0;
                    }
                case 8 : 
                    exit = 2;
                    break;
                default:
                  exit = 3;
              }
            }
            break;
        case 9 : 
            if (typeof match$1 === "number") {
              exit = match$1 ? 3 : 1;
            } else {
              switch (match$1.tag | 0) {
                case 0 : 
                case 1 : 
                    exit = 1;
                    break;
                case 8 : 
                    exit = 2;
                    break;
                case 9 : 
                    _q = match$1[0];
                    _p = match[0];
                    continue ;
                    default:
                  exit = 3;
              }
            }
            break;
        default:
          exit = 1;
      }
    }
    switch (exit) {
      case 1 : 
          if (typeof match$1 === "number") {
            if (match$1) {
              if (typeof match === "number") {
                return /* true */1;
              } else if (match.tag) {
                if (compat(match[0], q)) {
                  return /* true */1;
                } else {
                  _p = match[1];
                  continue ;
                  
                }
              } else {
                return /* true */1;
              }
            } else {
              return /* true */1;
            }
          } else {
            switch (match$1.tag | 0) {
              case 0 : 
                  return /* true */1;
              case 1 : 
                  _q = match$1[0];
                  continue ;
                  default:
                if (typeof match === "number") {
                  return /* true */1;
                } else if (match.tag) {
                  if (compat(match[0], q)) {
                    return /* true */1;
                  } else {
                    _p = match[1];
                    continue ;
                    
                  }
                } else {
                  return /* true */1;
                }
            }
          }
          break;
      case 2 : 
          if (compat(p, match$1[0])) {
            return /* true */1;
          } else {
            _q = match$1[1];
            continue ;
            
          }
          break;
      case 3 : 
          throw [
                Caml_builtin_exceptions.assert_failure,
                [
                  "parmatch.ml",
                  106,
                  6
                ]
              ];
      
    }
  };
}

function compats(_ps, _qs) {
  while(true) {
    var qs = _qs;
    var ps = _ps;
    if (ps) {
      if (qs) {
        if (compat(ps[0], qs[0])) {
          _qs = qs[1];
          _ps = ps[1];
          continue ;
          
        } else {
          return /* false */0;
        }
      } else {
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "parmatch.ml",
                111,
                12
              ]
            ];
      }
    } else if (qs) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "parmatch.ml",
              111,
              12
            ]
          ];
    } else {
      return /* true */1;
    }
  };
}

var Empty = Caml_exceptions.create("Ocaml_typedtree_test.Parmatch.Empty");

function clean_copy(ty) {
  if (ty[/* level */1] === 100000000) {
    return ty;
  } else {
    return type_expr(identity, ty);
  }
}

function get_type_path(ty, tenv) {
  var ty$1 = repr(expand_head(tenv, clean_copy(ty)));
  var match = ty$1[/* desc */0];
  if (typeof match === "number") {
    return fatal_error("Parmatch.get_type_path");
  } else if (match.tag === 3) {
    return match[0];
  } else {
    return fatal_error("Parmatch.get_type_path");
  }
}

function is_cons(param) {
  if (param[/* cstr_name */0] === "::") {
    return /* true */1;
  } else {
    return /* false */0;
  }
}

function pretty_const(c) {
  switch (c.tag | 0) {
    case 0 : 
        return Curry._1(Printf.sprintf(/* Format */[
                        /* Int */Block.__(4, [
                            /* Int_d */0,
                            /* No_padding */0,
                            /* No_precision */0,
                            /* End_of_format */0
                          ]),
                        "%d"
                      ]), c[0]);
    case 1 : 
        return Curry._1(Printf.sprintf(/* Format */[
                        /* Caml_char */Block.__(1, [/* End_of_format */0]),
                        "%C"
                      ]), c[0]);
    case 2 : 
        return Curry._1(Printf.sprintf(/* Format */[
                        /* Caml_string */Block.__(3, [
                            /* No_padding */0,
                            /* End_of_format */0
                          ]),
                        "%S"
                      ]), c[0]);
    case 3 : 
        return Curry._1(Printf.sprintf(/* Format */[
                        /* String */Block.__(2, [
                            /* No_padding */0,
                            /* End_of_format */0
                          ]),
                        "%s"
                      ]), c[0]);
    case 4 : 
        return Curry._1(Printf.sprintf(/* Format */[
                        /* Int32 */Block.__(5, [
                            /* Int_d */0,
                            /* No_padding */0,
                            /* No_precision */0,
                            /* Char_literal */Block.__(12, [
                                /* "l" */108,
                                /* End_of_format */0
                              ])
                          ]),
                        "%ldl"
                      ]), c[0]);
    case 5 : 
        return Curry._1(Printf.sprintf(/* Format */[
                        /* Int64 */Block.__(7, [
                            /* Int_d */0,
                            /* No_padding */0,
                            /* No_precision */0,
                            /* Char_literal */Block.__(12, [
                                /* "L" */76,
                                /* End_of_format */0
                              ])
                          ]),
                        "%LdL"
                      ]), c[0]);
    case 6 : 
        return Curry._1(Printf.sprintf(/* Format */[
                        /* Nativeint */Block.__(6, [
                            /* Int_d */0,
                            /* No_padding */0,
                            /* No_precision */0,
                            /* Char_literal */Block.__(12, [
                                /* "n" */110,
                                /* End_of_format */0
                              ])
                          ]),
                        "%ndn"
                      ]), c[0]);
    
  }
}

function pretty_val(ppf, v) {
  var match = v[/* pat_extra */2];
  if (match) {
    var rem = match[1];
    var $js = match[0][0];
    if (typeof $js === "number") {
      var newrecord = v.slice();
      return Curry._2(Format.fprintf(ppf, /* Format */[
                      /* Formatting_gen */Block.__(18, [
                          /* Open_box */Block.__(1, [/* Format */[
                                /* End_of_format */0,
                                ""
                              ]]),
                          /* String_literal */Block.__(11, [
                              "(module ",
                              /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                      /* ")" */41,
                                      /* Formatting_lit */Block.__(17, [
                                          /* Close_box */0,
                                          /* End_of_format */0
                                        ])
                                    ])])
                            ])
                        ]),
                      "@[(module %a)@]"
                    ]), pretty_val, (newrecord[/* pat_extra */2] = rem, newrecord));
    } else if ($js.tag) {
      var newrecord$1 = v.slice();
      return Curry._2(Format.fprintf(ppf, /* Format */[
                      /* Formatting_gen */Block.__(18, [
                          /* Open_box */Block.__(1, [/* Format */[
                                /* End_of_format */0,
                                ""
                              ]]),
                          /* String_literal */Block.__(11, [
                              "(# ",
                              /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                      /* ")" */41,
                                      /* Formatting_lit */Block.__(17, [
                                          /* Close_box */0,
                                          /* End_of_format */0
                                        ])
                                    ])])
                            ])
                        ]),
                      "@[(# %a)@]"
                    ]), pretty_val, (newrecord$1[/* pat_extra */2] = rem, newrecord$1));
    } else {
      var newrecord$2 = v.slice();
      return Curry._2(Format.fprintf(ppf, /* Format */[
                      /* Formatting_gen */Block.__(18, [
                          /* Open_box */Block.__(1, [/* Format */[
                                /* End_of_format */0,
                                ""
                              ]]),
                          /* Char_literal */Block.__(12, [
                              /* "(" */40,
                              /* Alpha */Block.__(15, [/* String_literal */Block.__(11, [
                                      " : _)",
                                      /* Formatting_lit */Block.__(17, [
                                          /* Close_box */0,
                                          /* End_of_format */0
                                        ])
                                    ])])
                            ])
                        ]),
                      "@[(%a : _)@]"
                    ]), pretty_val, (newrecord$2[/* pat_extra */2] = rem, newrecord$2));
    }
  } else {
    var match$1 = v[/* pat_desc */0];
    if (typeof match$1 === "number") {
      return Format.fprintf(ppf, /* Format */[
                  /* Char_literal */Block.__(12, [
                      /* "_" */95,
                      /* End_of_format */0
                    ]),
                  "_"
                ]);
    } else {
      switch (match$1.tag | 0) {
        case 0 : 
            return print$2(ppf, match$1[0]);
        case 1 : 
            return Curry._4(Format.fprintf(ppf, /* Format */[
                            /* Formatting_gen */Block.__(18, [
                                /* Open_box */Block.__(1, [/* Format */[
                                      /* End_of_format */0,
                                      ""
                                    ]]),
                                /* Char_literal */Block.__(12, [
                                    /* "(" */40,
                                    /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                            /* Break */Block.__(0, [
                                                "@ ",
                                                1,
                                                0
                                              ]),
                                            /* String_literal */Block.__(11, [
                                                "as ",
                                                /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                                        /* ")" */41,
                                                        /* Formatting_lit */Block.__(17, [
                                                            /* Close_box */0,
                                                            /* End_of_format */0
                                                          ])
                                                      ])])
                                              ])
                                          ])])
                                  ])
                              ]),
                            "@[(%a@ as %a)@]"
                          ]), pretty_val, match$1[0], print$2, match$1[1]);
        case 2 : 
            return Curry._1(Format.fprintf(ppf, /* Format */[
                            /* String */Block.__(2, [
                                /* No_padding */0,
                                /* End_of_format */0
                              ]),
                            "%s"
                          ]), pretty_const(match$1[0]));
        case 3 : 
            return Curry._2(Format.fprintf(ppf, /* Format */[
                            /* Formatting_gen */Block.__(18, [
                                /* Open_box */Block.__(1, [/* Format */[
                                      /* End_of_format */0,
                                      ""
                                    ]]),
                                /* Char_literal */Block.__(12, [
                                    /* "(" */40,
                                    /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                            /* ")" */41,
                                            /* Formatting_lit */Block.__(17, [
                                                /* Close_box */0,
                                                /* End_of_format */0
                                              ])
                                          ])])
                                  ])
                              ]),
                            "@[(%a)@]"
                          ]), (function (param, param$1) {
                          return pretty_vals(",", param, param$1);
                        }), match$1[0]);
        case 4 : 
            var vs = match$1[2];
            var cstr = match$1[1];
            if (vs) {
              if (vs[1]) {
                var name = cstr[/* cstr_name */0];
                var exit = 0;
                if (name === "::") {
                  if (vs) {
                    var match$2 = vs[1];
                    if (match$2) {
                      if (match$2[1]) {
                        exit = 1;
                      } else {
                        return Curry._4(Format.fprintf(ppf, /* Format */[
                                        /* Formatting_gen */Block.__(18, [
                                            /* Open_box */Block.__(1, [/* Format */[
                                                  /* End_of_format */0,
                                                  ""
                                                ]]),
                                            /* Alpha */Block.__(15, [/* String_literal */Block.__(11, [
                                                    "::",
                                                    /* Formatting_lit */Block.__(17, [
                                                        /* Break */Block.__(0, [
                                                            "@,",
                                                            0,
                                                            0
                                                          ]),
                                                        /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                /* Close_box */0,
                                                                /* End_of_format */0
                                                              ])])
                                                      ])
                                                  ])])
                                          ]),
                                        "@[%a::@,%a@]"
                                      ]), pretty_car, vs[0], pretty_cdr, match$2[0]);
                      }
                    } else {
                      exit = 1;
                    }
                  } else {
                    exit = 1;
                  }
                } else {
                  exit = 1;
                }
                if (exit === 1) {
                  return Curry._3(Format.fprintf(ppf, /* Format */[
                                  /* Formatting_gen */Block.__(18, [
                                      /* Open_box */Block.__(1, [/* Format */[
                                            /* String_literal */Block.__(11, [
                                                "<2>",
                                                /* End_of_format */0
                                              ]),
                                            "<2>"
                                          ]]),
                                      /* String */Block.__(2, [
                                          /* No_padding */0,
                                          /* Formatting_lit */Block.__(17, [
                                              /* Break */Block.__(0, [
                                                  "@ ",
                                                  1,
                                                  0
                                                ]),
                                              /* Formatting_gen */Block.__(18, [
                                                  /* Open_box */Block.__(1, [/* Format */[
                                                        /* End_of_format */0,
                                                        ""
                                                      ]]),
                                                  /* Char_literal */Block.__(12, [
                                                      /* "(" */40,
                                                      /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                                              /* ")" */41,
                                                              /* Formatting_lit */Block.__(17, [
                                                                  /* Close_box */0,
                                                                  /* Formatting_lit */Block.__(17, [
                                                                      /* Close_box */0,
                                                                      /* End_of_format */0
                                                                    ])
                                                                ])
                                                            ])])
                                                    ])
                                                ])
                                            ])
                                        ])
                                    ]),
                                  "@[<2>%s@ @[(%a)@]@]"
                                ]), name, (function (param, param$1) {
                                return pretty_vals(",", param, param$1);
                              }), vs);
                }
                
              } else {
                return Curry._3(Format.fprintf(ppf, /* Format */[
                                /* Formatting_gen */Block.__(18, [
                                    /* Open_box */Block.__(1, [/* Format */[
                                          /* String_literal */Block.__(11, [
                                              "<2>",
                                              /* End_of_format */0
                                            ]),
                                          "<2>"
                                        ]]),
                                    /* String */Block.__(2, [
                                        /* No_padding */0,
                                        /* Formatting_lit */Block.__(17, [
                                            /* Break */Block.__(0, [
                                                "@ ",
                                                1,
                                                0
                                              ]),
                                            /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                    /* Close_box */0,
                                                    /* End_of_format */0
                                                  ])])
                                          ])
                                      ])
                                  ]),
                                "@[<2>%s@ %a@]"
                              ]), cstr[/* cstr_name */0], pretty_arg, vs[0]);
              }
            } else {
              return Curry._1(Format.fprintf(ppf, /* Format */[
                              /* String */Block.__(2, [
                                  /* No_padding */0,
                                  /* End_of_format */0
                                ]),
                              "%s"
                            ]), cstr[/* cstr_name */0]);
            }
            break;
        case 5 : 
            var match$3 = match$1[1];
            var l = match$1[0];
            if (match$3) {
              return Curry._3(Format.fprintf(ppf, /* Format */[
                              /* Formatting_gen */Block.__(18, [
                                  /* Open_box */Block.__(1, [/* Format */[
                                        /* String_literal */Block.__(11, [
                                            "<2>",
                                            /* End_of_format */0
                                          ]),
                                        "<2>"
                                      ]]),
                                  /* Char_literal */Block.__(12, [
                                      /* "`" */96,
                                      /* String */Block.__(2, [
                                          /* No_padding */0,
                                          /* Formatting_lit */Block.__(17, [
                                              /* Break */Block.__(0, [
                                                  "@ ",
                                                  1,
                                                  0
                                                ]),
                                              /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                      /* Close_box */0,
                                                      /* End_of_format */0
                                                    ])])
                                            ])
                                        ])
                                    ])
                                ]),
                              "@[<2>`%s@ %a@]"
                            ]), l, pretty_arg, match$3[0]);
            } else {
              return Curry._1(Format.fprintf(ppf, /* Format */[
                              /* Char_literal */Block.__(12, [
                                  /* "`" */96,
                                  /* String */Block.__(2, [
                                      /* No_padding */0,
                                      /* End_of_format */0
                                    ])
                                ]),
                              "`%s"
                            ]), l);
            }
        case 6 : 
            return Curry._2(Format.fprintf(ppf, /* Format */[
                            /* Formatting_gen */Block.__(18, [
                                /* Open_box */Block.__(1, [/* Format */[
                                      /* End_of_format */0,
                                      ""
                                    ]]),
                                /* Char_literal */Block.__(12, [
                                    /* "{" */123,
                                    /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                            /* "}" */125,
                                            /* Formatting_lit */Block.__(17, [
                                                /* Close_box */0,
                                                /* End_of_format */0
                                              ])
                                          ])])
                                  ])
                              ]),
                            "@[{%a}@]"
                          ]), pretty_lvals, List.filter((function (param) {
                                if (typeof param[2][/* pat_desc */0] === "number") {
                                  return /* false */0;
                                } else {
                                  return /* true */1;
                                }
                              }))(match$1[0]));
        case 7 : 
            return Curry._2(Format.fprintf(ppf, /* Format */[
                            /* Formatting_gen */Block.__(18, [
                                /* Open_box */Block.__(1, [/* Format */[
                                      /* End_of_format */0,
                                      ""
                                    ]]),
                                /* String_literal */Block.__(11, [
                                    "[| ",
                                    /* Alpha */Block.__(15, [/* String_literal */Block.__(11, [
                                            " |]",
                                            /* Formatting_lit */Block.__(17, [
                                                /* Close_box */0,
                                                /* End_of_format */0
                                              ])
                                          ])])
                                  ])
                              ]),
                            "@[[| %a |]@]"
                          ]), (function (param, param$1) {
                          return pretty_vals(" ;", param, param$1);
                        }), match$1[0]);
        case 8 : 
            return Curry._4(Format.fprintf(ppf, /* Format */[
                            /* Formatting_gen */Block.__(18, [
                                /* Open_box */Block.__(1, [/* Format */[
                                      /* End_of_format */0,
                                      ""
                                    ]]),
                                /* Char_literal */Block.__(12, [
                                    /* "(" */40,
                                    /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                            /* "|" */124,
                                            /* Formatting_lit */Block.__(17, [
                                                /* Break */Block.__(0, [
                                                    "@,",
                                                    0,
                                                    0
                                                  ]),
                                                /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                                        /* ")" */41,
                                                        /* Formatting_lit */Block.__(17, [
                                                            /* Close_box */0,
                                                            /* End_of_format */0
                                                          ])
                                                      ])])
                                              ])
                                          ])])
                                  ])
                              ]),
                            "@[(%a|@,%a)@]"
                          ]), pretty_or, match$1[0], pretty_or, match$1[1]);
        case 9 : 
            return Curry._2(Format.fprintf(ppf, /* Format */[
                            /* Formatting_gen */Block.__(18, [
                                /* Open_box */Block.__(1, [/* Format */[
                                      /* String_literal */Block.__(11, [
                                          "<2>",
                                          /* End_of_format */0
                                        ]),
                                      "<2>"
                                    ]]),
                                /* String_literal */Block.__(11, [
                                    "lazy",
                                    /* Formatting_lit */Block.__(17, [
                                        /* Break */Block.__(0, [
                                            "@ ",
                                            1,
                                            0
                                          ]),
                                        /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                /* Close_box */0,
                                                /* End_of_format */0
                                              ])])
                                      ])
                                  ])
                              ]),
                            "@[<2>lazy@ %a@]"
                          ]), pretty_arg, match$1[0]);
        
      }
    }
  }
}

function pretty_car(ppf, v) {
  var match = v[/* pat_desc */0];
  if (typeof match === "number") {
    return pretty_val(ppf, v);
  } else if (match.tag === 4) {
    var match$1 = match[2];
    if (match$1) {
      var match$2 = match$1[1];
      if (match$2 && !(match$2[1] || !is_cons(match[1]))) {
        return Curry._2(Format.fprintf(ppf, /* Format */[
                        /* Char_literal */Block.__(12, [
                            /* "(" */40,
                            /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                    /* ")" */41,
                                    /* End_of_format */0
                                  ])])
                          ]),
                        "(%a)"
                      ]), pretty_val, v);
      } else {
        return pretty_val(ppf, v);
      }
    } else {
      return pretty_val(ppf, v);
    }
  } else {
    return pretty_val(ppf, v);
  }
}

function pretty_cdr(ppf, v) {
  var match = v[/* pat_desc */0];
  if (typeof match === "number") {
    return pretty_val(ppf, v);
  } else if (match.tag === 4) {
    var match$1 = match[2];
    if (match$1) {
      var match$2 = match$1[1];
      if (match$2 && !(match$2[1] || !is_cons(match[1]))) {
        return Curry._4(Format.fprintf(ppf, /* Format */[
                        /* Alpha */Block.__(15, [/* String_literal */Block.__(11, [
                                "::",
                                /* Formatting_lit */Block.__(17, [
                                    /* Break */Block.__(0, [
                                        "@,",
                                        0,
                                        0
                                      ]),
                                    /* Alpha */Block.__(15, [/* End_of_format */0])
                                  ])
                              ])]),
                        "%a::@,%a"
                      ]), pretty_car, match$1[0], pretty_cdr, match$2[0]);
      } else {
        return pretty_val(ppf, v);
      }
    } else {
      return pretty_val(ppf, v);
    }
  } else {
    return pretty_val(ppf, v);
  }
}

function pretty_arg(ppf, v) {
  var match = v[/* pat_desc */0];
  var exit = 0;
  if (typeof match === "number") {
    return pretty_val(ppf, v);
  } else {
    switch (match.tag | 0) {
      case 4 : 
          if (match[2]) {
            exit = 1;
          } else {
            return pretty_val(ppf, v);
          }
          break;
      case 5 : 
          if (match[1]) {
            exit = 1;
          } else {
            return pretty_val(ppf, v);
          }
          break;
      default:
        return pretty_val(ppf, v);
    }
  }
  if (exit === 1) {
    return Curry._2(Format.fprintf(ppf, /* Format */[
                    /* Char_literal */Block.__(12, [
                        /* "(" */40,
                        /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                /* ")" */41,
                                /* End_of_format */0
                              ])])
                      ]),
                    "(%a)"
                  ]), pretty_val, v);
  }
  
}

function pretty_or(ppf, v) {
  var match = v[/* pat_desc */0];
  if (typeof match === "number" || match.tag !== 8) {
    return pretty_val(ppf, v);
  } else {
    return Curry._4(Format.fprintf(ppf, /* Format */[
                    /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                            /* "|" */124,
                            /* Formatting_lit */Block.__(17, [
                                /* Break */Block.__(0, [
                                    "@,",
                                    0,
                                    0
                                  ]),
                                /* Alpha */Block.__(15, [/* End_of_format */0])
                              ])
                          ])]),
                    "%a|@,%a"
                  ]), pretty_or, match[0], pretty_or, match[1]);
  }
}

function pretty_vals(sep, ppf, param) {
  if (param) {
    var vs = param[1];
    var v = param[0];
    if (vs) {
      return Curry._5(Format.fprintf(ppf, /* Format */[
                      /* Alpha */Block.__(15, [/* String */Block.__(2, [
                              /* No_padding */0,
                              /* Formatting_lit */Block.__(17, [
                                  /* Break */Block.__(0, [
                                      "@ ",
                                      1,
                                      0
                                    ]),
                                  /* Alpha */Block.__(15, [/* End_of_format */0])
                                ])
                            ])]),
                      "%a%s@ %a"
                    ]), pretty_val, v, sep, (function (param, param$1) {
                    return pretty_vals(sep, param, param$1);
                  }), vs);
    } else {
      return pretty_val(ppf, v);
    }
  } else {
    return /* () */0;
  }
}

function pretty_lvals(ppf, param) {
  if (param) {
    var rest = param[1];
    var match = param[0];
    var v = match[2];
    var lbl = match[1];
    if (rest) {
      return Curry._5(Format.fprintf(ppf, /* Format */[
                      /* String */Block.__(2, [
                          /* No_padding */0,
                          /* Char_literal */Block.__(12, [
                              /* "=" */61,
                              /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                      /* ";" */59,
                                      /* Formatting_lit */Block.__(17, [
                                          /* Break */Block.__(0, [
                                              "@ ",
                                              1,
                                              0
                                            ]),
                                          /* Alpha */Block.__(15, [/* End_of_format */0])
                                        ])
                                    ])])
                            ])
                        ]),
                      "%s=%a;@ %a"
                    ]), lbl[/* lbl_name */0], pretty_val, v, pretty_lvals, rest);
    } else {
      return Curry._3(Format.fprintf(ppf, /* Format */[
                      /* String */Block.__(2, [
                          /* No_padding */0,
                          /* Char_literal */Block.__(12, [
                              /* "=" */61,
                              /* Alpha */Block.__(15, [/* End_of_format */0])
                            ])
                        ]),
                      "%s=%a"
                    ]), lbl[/* lbl_name */0], pretty_val, v);
    }
  } else {
    return /* () */0;
  }
}

function top_pretty(ppf, v) {
  return Curry._2(Format.fprintf(ppf, /* Format */[
                  /* Formatting_gen */Block.__(18, [
                      /* Open_box */Block.__(1, [/* Format */[
                            /* End_of_format */0,
                            ""
                          ]]),
                      /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                              /* Close_box */0,
                              /* Formatting_lit */Block.__(17, [
                                  /* FFlush */2,
                                  /* End_of_format */0
                                ])
                            ])])
                    ]),
                  "@[%a@]@?"
                ]), pretty_val, v);
}

function simple_match(p1, p2) {
  var match = p1[/* pat_desc */0];
  var match$1 = p2[/* pat_desc */0];
  var exit = 0;
  if (typeof match === "number") {
    exit = 1;
  } else {
    switch (match.tag | 0) {
      case 2 : 
          if (typeof match$1 === "number") {
            if (match$1) {
              return /* false */0;
            } else {
              exit = 1;
            }
          } else {
            switch (match$1.tag | 0) {
              case 0 : 
                  exit = 1;
                  break;
              case 2 : 
                  return +(const_compare(match[0], match$1[0]) === 0);
              default:
                return /* false */0;
            }
          }
          break;
      case 3 : 
          if (typeof match$1 === "number") {
            if (match$1) {
              return /* false */0;
            } else {
              exit = 1;
            }
          } else {
            switch (match$1.tag | 0) {
              case 0 : 
                  exit = 1;
                  break;
              case 3 : 
                  return /* true */1;
              default:
                return /* false */0;
            }
          }
          break;
      case 4 : 
          if (typeof match$1 === "number") {
            if (match$1) {
              return /* false */0;
            } else {
              exit = 1;
            }
          } else {
            switch (match$1.tag | 0) {
              case 0 : 
                  exit = 1;
                  break;
              case 4 : 
                  return equal_tag(match[1][/* cstr_tag */5], match$1[1][/* cstr_tag */5]);
              default:
                return /* false */0;
            }
          }
          break;
      case 5 : 
          if (typeof match$1 === "number") {
            if (match$1) {
              return /* false */0;
            } else {
              exit = 1;
            }
          } else {
            switch (match$1.tag | 0) {
              case 0 : 
                  exit = 1;
                  break;
              case 5 : 
                  return +(match[0] === match$1[0]);
              default:
                return /* false */0;
            }
          }
          break;
      case 6 : 
          if (typeof match$1 === "number") {
            if (match$1) {
              return /* false */0;
            } else {
              exit = 1;
            }
          } else {
            switch (match$1.tag | 0) {
              case 0 : 
                  exit = 1;
                  break;
              case 6 : 
                  return /* true */1;
              default:
                return /* false */0;
            }
          }
          break;
      case 7 : 
          if (typeof match$1 === "number") {
            if (match$1) {
              return /* false */0;
            } else {
              exit = 1;
            }
          } else {
            switch (match$1.tag | 0) {
              case 0 : 
                  exit = 1;
                  break;
              case 7 : 
                  return +(List.length(match[0]) === List.length(match$1[0]));
              default:
                return /* false */0;
            }
          }
          break;
      case 9 : 
          if (typeof match$1 === "number") {
            if (match$1) {
              return /* false */0;
            } else {
              exit = 1;
            }
          } else {
            switch (match$1.tag | 0) {
              case 0 : 
                  exit = 1;
                  break;
              case 9 : 
                  return /* true */1;
              default:
                return /* false */0;
            }
          }
          break;
      default:
        exit = 1;
    }
  }
  if (exit === 1) {
    if (typeof match$1 === "number") {
      if (match$1) {
        return /* false */0;
      } else {
        return /* true */1;
      }
    } else if (match$1.tag) {
      return /* false */0;
    } else {
      return /* true */1;
    }
  }
  
}

function record_arg(p) {
  var match = p[/* pat_desc */0];
  if (typeof match === "number") {
    if (match) {
      return fatal_error("Parmatch.as_record");
    } else {
      return /* [] */0;
    }
  } else if (match.tag === 6) {
    return match[0];
  } else {
    return fatal_error("Parmatch.as_record");
  }
}

function get_field(pos, arg) {
  return List.find((function (param) {
                  return +(pos === param[1][/* lbl_pos */4]);
                }), arg)[2];
}

function simple_match_args(p1, _p2) {
  while(true) {
    var p2 = _p2;
    var match = p2[/* pat_desc */0];
    var exit = 0;
    if (typeof match === "number") {
      exit = 1;
    } else {
      switch (match.tag | 0) {
        case 0 : 
            exit = 1;
            break;
        case 1 : 
            _p2 = match[0];
            continue ;
            case 4 : 
            return match[2];
        case 5 : 
            var match$1 = match[1];
            if (match$1) {
              return /* :: */[
                      match$1[0],
                      /* [] */0
                    ];
            } else {
              return /* [] */0;
            }
        case 6 : 
            var omegas = record_arg(p1);
            var arg = match[0];
            return List.map((function(arg){
                      return function (param) {
                        try {
                          return get_field(param[1][/* lbl_pos */4], arg);
                        }
                        catch (exn){
                          if (exn === Caml_builtin_exceptions.not_found) {
                            return omega;
                          } else {
                            throw exn;
                          }
                        }
                      }
                      }(arg)), omegas);
        case 3 : 
        case 7 : 
            return match[0];
        case 2 : 
        case 8 : 
            return /* [] */0;
        case 9 : 
            return /* :: */[
                    match[0],
                    /* [] */0
                  ];
        
      }
    }
    if (exit === 1) {
      var match$2 = p1[/* pat_desc */0];
      if (typeof match$2 === "number") {
        return /* [] */0;
      } else {
        switch (match$2.tag | 0) {
          case 3 : 
              return List.map((function () {
                            return omega;
                          }), match$2[0]);
          case 4 : 
              return List.map((function () {
                            return omega;
                          }), match$2[2]);
          case 5 : 
              if (match$2[1]) {
                return /* :: */[
                        omega,
                        /* [] */0
                      ];
              } else {
                return /* [] */0;
              }
          case 6 : 
              return List.map((function () {
                            return omega;
                          }), match$2[0]);
          case 7 : 
              return List.map((function () {
                            return omega;
                          }), match$2[0]);
          case 9 : 
              return /* :: */[
                      omega,
                      /* [] */0
                    ];
          default:
            return /* [] */0;
        }
      }
    }
    
  };
}

function normalize_pat(_q) {
  while(true) {
    var q = _q;
    var match = q[/* pat_desc */0];
    if (typeof match === "number") {
      return q;
    } else {
      switch (match.tag | 0) {
        case 0 : 
            return make_pat(/* Tpat_any */0, q[/* pat_type */3], q[/* pat_env */4]);
        case 1 : 
            _q = match[0];
            continue ;
            case 2 : 
            return q;
        case 3 : 
            return make_pat(/* Tpat_tuple */Block.__(3, [List.map((function () {
                                  return omega;
                                }), match[0])]), q[/* pat_type */3], q[/* pat_env */4]);
        case 4 : 
            return make_pat(/* Tpat_construct */Block.__(4, [
                          match[0],
                          match[1],
                          List.map((function () {
                                  return omega;
                                }), match[2])
                        ]), q[/* pat_type */3], q[/* pat_env */4]);
        case 5 : 
            return make_pat(/* Tpat_variant */Block.__(5, [
                          match[0],
                          may_map((function () {
                                  return omega;
                                }), match[1]),
                          match[2]
                        ]), q[/* pat_type */3], q[/* pat_env */4]);
        case 6 : 
            return make_pat(/* Tpat_record */Block.__(6, [
                          List.map((function (param) {
                                  return /* tuple */[
                                          param[0],
                                          param[1],
                                          omega
                                        ];
                                }), match[0]),
                          match[1]
                        ]), q[/* pat_type */3], q[/* pat_env */4]);
        case 7 : 
            return make_pat(/* Tpat_array */Block.__(7, [List.map((function () {
                                  return omega;
                                }), match[0])]), q[/* pat_type */3], q[/* pat_env */4]);
        case 8 : 
            return fatal_error("Parmatch.normalize_pat");
        case 9 : 
            return make_pat(/* Tpat_lazy */Block.__(9, [omega]), q[/* pat_type */3], q[/* pat_env */4]);
        
      }
    }
  };
}

function discr_pat(q, pss) {
  var acc_pat = function (_acc, _pss) {
    while(true) {
      var pss = _pss;
      var acc = _acc;
      if (pss) {
        var match = pss[0];
        if (match) {
          var p = match[0];
          var match$1 = p[/* pat_desc */0];
          if (typeof match$1 === "number") {
            if (match$1) {
              return acc;
            } else {
              _pss = pss[1];
              continue ;
              
            }
          } else {
            switch (match$1.tag | 0) {
              case 0 : 
                  _pss = pss[1];
                  continue ;
                  case 1 : 
                  _pss = /* :: */[
                    /* :: */[
                      match$1[0],
                      match[1]
                    ],
                    pss[1]
                  ];
                  continue ;
                  case 6 : 
                  var new_omegas = List.fold_right((function (param, r) {
                          var lbl = param[1];
                          try {
                            get_field(lbl[/* lbl_pos */4], r);
                            return r;
                          }
                          catch (exn){
                            if (exn === Caml_builtin_exceptions.not_found) {
                              return /* :: */[
                                      /* tuple */[
                                        param[0],
                                        lbl,
                                        omega
                                      ],
                                      r
                                    ];
                            } else {
                              throw exn;
                            }
                          }
                        }), match$1[0], record_arg(acc));
                  _pss = pss[1];
                  _acc = make_pat(/* Tpat_record */Block.__(6, [
                          new_omegas,
                          match$1[1]
                        ]), p[/* pat_type */3], p[/* pat_env */4]);
                  continue ;
                  case 8 : 
                  var ps = match[1];
                  _pss = /* :: */[
                    /* :: */[
                      match$1[0],
                      ps
                    ],
                    /* :: */[
                      /* :: */[
                        match$1[1],
                        ps
                      ],
                      pss[1]
                    ]
                  ];
                  continue ;
                  case 3 : 
              case 9 : 
                  return normalize_pat(p);
              default:
                return acc;
            }
          }
        } else {
          return acc;
        }
      } else {
        return acc;
      }
    };
  };
  var q$1 = normalize_pat(q);
  var $js = q$1[/* pat_desc */0];
  if (typeof $js === "number") {
    if ($js) {
      return q$1;
    } else {
      return acc_pat(q$1, pss);
    }
  } else if ($js.tag === 6) {
    return acc_pat(q$1, pss);
  } else {
    return q$1;
  }
}

function read_args(xs, r) {
  if (xs) {
    if (r) {
      var match = read_args(xs[1], r[1]);
      return /* tuple */[
              /* :: */[
                r[0],
                match[0]
              ],
              match[1]
            ];
    } else {
      return fatal_error("Parmatch.read_args");
    }
  } else {
    return /* tuple */[
            /* [] */0,
            r
          ];
  }
}

function do_set_args(erase_mutable, q, r) {
  var match = q[/* pat_desc */0];
  if (typeof match === "number") {
    if (match) {
      return fatal_error("Parmatch.set_args");
    } else {
      return /* :: */[
              q,
              r
            ];
    }
  } else {
    switch (match.tag | 0) {
      case 2 : 
          return /* :: */[
                  q,
                  r
                ];
      case 3 : 
          var match$1 = read_args(match[0], r);
          return /* :: */[
                  make_pat(/* Tpat_tuple */Block.__(3, [match$1[0]]), q[/* pat_type */3], q[/* pat_env */4]),
                  match$1[1]
                ];
      case 4 : 
          var match$2 = read_args(match[2], r);
          return /* :: */[
                  make_pat(/* Tpat_construct */Block.__(4, [
                          match[0],
                          match[1],
                          match$2[0]
                        ]), q[/* pat_type */3], q[/* pat_env */4]),
                  match$2[1]
                ];
      case 5 : 
          var match$3;
          if (match[1]) {
            if (r) {
              match$3 = /* tuple */[
                /* Some */[r[0]],
                r[1]
              ];
            } else {
              throw [
                    Caml_builtin_exceptions.assert_failure,
                    [
                      "parmatch.ml",
                      450,
                      13
                    ]
                  ];
            }
          } else {
            match$3 = /* tuple */[
              /* None */0,
              r
            ];
          }
          return /* :: */[
                  make_pat(/* Tpat_variant */Block.__(5, [
                          match[0],
                          match$3[0],
                          match[2]
                        ]), q[/* pat_type */3], q[/* pat_env */4]),
                  match$3[1]
                ];
      case 6 : 
          var omegas = match[0];
          var match$4 = read_args(omegas, r);
          return /* :: */[
                  make_pat(/* Tpat_record */Block.__(6, [
                          List.map2((function (param, arg) {
                                  var lbl = param[1];
                                  var lid = param[0];
                                  var match = lbl[/* lbl_mut */3];
                                  if (erase_mutable && (
                                      match !== 0 ? /* true */1 : /* false */0
                                    )) {
                                    return /* tuple */[
                                            lid,
                                            lbl,
                                            omega
                                          ];
                                  } else {
                                    return /* tuple */[
                                            lid,
                                            lbl,
                                            arg
                                          ];
                                  }
                                }), omegas, match$4[0]),
                          match[1]
                        ]), q[/* pat_type */3], q[/* pat_env */4]),
                  match$4[1]
                ];
      case 7 : 
          var match$5 = read_args(match[0], r);
          return /* :: */[
                  make_pat(/* Tpat_array */Block.__(7, [match$5[0]]), q[/* pat_type */3], q[/* pat_env */4]),
                  match$5[1]
                ];
      case 9 : 
          if (r) {
            return /* :: */[
                    make_pat(/* Tpat_lazy */Block.__(9, [r[0]]), q[/* pat_type */3], q[/* pat_env */4]),
                    r[1]
                  ];
          } else {
            return fatal_error("Parmatch.do_set_args (lazy)");
          }
      default:
        return fatal_error("Parmatch.set_args");
    }
  }
}

function filter_one(q, pss) {
  var filter_rec = function (_param) {
    while(true) {
      var param = _param;
      if (param) {
        var match = param[0];
        if (match) {
          var p = match[0];
          var match$1 = p[/* pat_desc */0];
          var exit = 0;
          if (typeof match$1 === "number") {
            exit = 1;
          } else {
            switch (match$1.tag | 0) {
              case 1 : 
                  _param = /* :: */[
                    /* :: */[
                      match$1[0],
                      match[1]
                    ],
                    param[1]
                  ];
                  continue ;
                  case 8 : 
                  var ps = match[1];
                  _param = /* :: */[
                    /* :: */[
                      match$1[0],
                      ps
                    ],
                    /* :: */[
                      /* :: */[
                        match$1[1],
                        ps
                      ],
                      param[1]
                    ]
                  ];
                  continue ;
                  default:
                exit = 1;
            }
          }
          if (exit === 1) {
            var pss = param[1];
            if (simple_match(q, p)) {
              return /* :: */[
                      Pervasives.$at(simple_match_args(q, p), match[1]),
                      filter_rec(pss)
                    ];
            } else {
              _param = pss;
              continue ;
              
            }
          }
          
        } else {
          return /* [] */0;
        }
      } else {
        return /* [] */0;
      }
    };
  };
  return filter_rec(pss);
}

function filter_extra(pss) {
  var filter_rec = function (_param) {
    while(true) {
      var param = _param;
      if (param) {
        var match = param[0];
        if (match) {
          var match$1 = match[0][/* pat_desc */0];
          if (typeof match$1 === "number") {
            if (match$1) {
              _param = param[1];
              continue ;
              
            } else {
              return /* :: */[
                      match[1],
                      filter_rec(param[1])
                    ];
            }
          } else {
            switch (match$1.tag | 0) {
              case 0 : 
                  return /* :: */[
                          match[1],
                          filter_rec(param[1])
                        ];
              case 1 : 
                  _param = /* :: */[
                    /* :: */[
                      match$1[0],
                      match[1]
                    ],
                    param[1]
                  ];
                  continue ;
                  case 8 : 
                  var ps = match[1];
                  _param = /* :: */[
                    /* :: */[
                      match$1[0],
                      ps
                    ],
                    /* :: */[
                      /* :: */[
                        match$1[1],
                        ps
                      ],
                      param[1]
                    ]
                  ];
                  continue ;
                  default:
                _param = param[1];
                continue ;
                
            }
          }
        } else {
          _param = param[1];
          continue ;
          
        }
      } else {
        return /* [] */0;
      }
    };
  };
  return filter_rec(pss);
}

function filter_all(pat0, pss) {
  var insert = function (q, qs, env) {
    if (env) {
      var env$1 = env[1];
      var c = env[0];
      var q0 = c[0];
      if (simple_match(q0, q)) {
        return /* :: */[
                /* tuple */[
                  q0,
                  /* :: */[
                    Pervasives.$at(simple_match_args(q0, q), qs),
                    c[1]
                  ]
                ],
                env$1
              ];
      } else {
        return /* :: */[
                c,
                insert(q, qs, env$1)
              ];
      }
    } else {
      var q0$1 = normalize_pat(q);
      return /* :: */[
              /* tuple */[
                q0$1,
                /* :: */[
                  Pervasives.$at(simple_match_args(q0$1, q), qs),
                  /* [] */0
                ]
              ],
              /* [] */0
            ];
    }
  };
  var filter_rec = function (_env, _param) {
    while(true) {
      var param = _param;
      var env = _env;
      if (param) {
        var match = param[0];
        if (match) {
          var p = match[0];
          var match$1 = p[/* pat_desc */0];
          if (typeof match$1 === "number") {
            _param = param[1];
            if (match$1) {
              _env = insert(p, match[1], env);
              continue ;
              
            } else {
              continue ;
              
            }
          } else {
            switch (match$1.tag | 0) {
              case 0 : 
                  _param = param[1];
                  continue ;
                  case 1 : 
                  _param = /* :: */[
                    /* :: */[
                      match$1[0],
                      match[1]
                    ],
                    param[1]
                  ];
                  continue ;
                  case 8 : 
                  var ps = match[1];
                  _param = /* :: */[
                    /* :: */[
                      match$1[0],
                      ps
                    ],
                    /* :: */[
                      /* :: */[
                        match$1[1],
                        ps
                      ],
                      param[1]
                    ]
                  ];
                  continue ;
                  default:
                _param = param[1];
                _env = insert(p, match[1], env);
                continue ;
                
            }
          }
        } else {
          return env;
        }
      } else {
        return env;
      }
    };
  };
  var match = pat0[/* pat_desc */0];
  var $js;
  var exit = 0;
  if (typeof match === "number") {
    $js = /* [] */0;
  } else {
    switch (match.tag | 0) {
      case 3 : 
      case 6 : 
      case 9 : 
          exit = 1;
          break;
      default:
        $js = /* [] */0;
    }
  }
  if (exit === 1) {
    $js = /* :: */[
      /* tuple */[
        pat0,
        /* [] */0
      ],
      /* [] */0
    ];
  }
  var _env = filter_rec($js, pss);
  var _param = pss;
  while(true) {
    var param = _param;
    var env = _env;
    if (param) {
      var match$1 = param[0];
      if (match$1) {
        var match$2 = match$1[0][/* pat_desc */0];
        var exit$1 = 0;
        if (typeof match$2 === "number") {
          if (match$2) {
            _param = param[1];
            continue ;
            
          } else {
            exit$1 = 1;
          }
        } else {
          switch (match$2.tag | 0) {
            case 0 : 
                exit$1 = 1;
                break;
            case 1 : 
                _param = /* :: */[
                  /* :: */[
                    match$2[0],
                    match$1[1]
                  ],
                  param[1]
                ];
                continue ;
                case 8 : 
                var ps = match$1[1];
                _param = /* :: */[
                  /* :: */[
                    match$2[0],
                    ps
                  ],
                  /* :: */[
                    /* :: */[
                      match$2[1],
                      ps
                    ],
                    param[1]
                  ]
                ];
                continue ;
                default:
              _param = param[1];
              continue ;
              
          }
        }
        if (exit$1 === 1) {
          var ps$1 = match$1[1];
          _param = param[1];
          _env = List.map((function(ps$1){
              return function (param) {
                var q = param[0];
                return /* tuple */[
                        q,
                        /* :: */[
                          Pervasives.$at(simple_match_args(q, omega), ps$1),
                          param[1]
                        ]
                      ];
              }
              }(ps$1)), env);
          continue ;
          
        }
        
      } else {
        _param = param[1];
        continue ;
        
      }
    } else {
      return env;
    }
  };
}

function set_last(a, param) {
  if (param) {
    var l = param[1];
    if (l) {
      return /* :: */[
              param[0],
              set_last(a, l)
            ];
    } else {
      return /* :: */[
              a,
              /* [] */0
            ];
    }
  } else {
    return /* [] */0;
  }
}

function mark_partial(_param) {
  while(true) {
    var param = _param;
    if (param) {
      var ps = param[0];
      var exit = 0;
      if (ps) {
        var match = ps[0][/* pat_desc */0];
        if (typeof match === "number") {
          if (match) {
            exit = 1;
          } else {
            return /* :: */[
                    ps,
                    mark_partial(param[1])
                  ];
          }
        } else {
          switch (match.tag | 0) {
            case 0 : 
                return /* :: */[
                        ps,
                        mark_partial(param[1])
                      ];
            case 1 : 
                _param = /* :: */[
                  /* :: */[
                    match[0],
                    ps[1]
                  ],
                  param[1]
                ];
                continue ;
                case 8 : 
                var ps$1 = ps[1];
                _param = /* :: */[
                  /* :: */[
                    match[0],
                    ps$1
                  ],
                  /* :: */[
                    /* :: */[
                      match[1],
                      ps$1
                    ],
                    param[1]
                  ]
                ];
                continue ;
                default:
              exit = 1;
          }
        }
      } else {
        exit = 1;
      }
      if (exit === 1) {
        return /* :: */[
                set_last(zero, ps),
                mark_partial(param[1])
              ];
      }
      
    } else {
      return /* [] */0;
    }
  };
}

function close_variant(env, row) {
  var row$1 = row_repr_aux(/* [] */0, row);
  var nm = List.fold_left((function (nm, param) {
          var match = row_field_repr_aux(/* [] */0, param[1]);
          if (typeof match === "number" || !match.tag || match[2] !== 0) {
            return nm;
          } else {
            set_row_field(match[3], /* Rabsent */0);
            return /* None */0;
          }
        }), row$1[/* row_name */5], row$1[/* row_fields */0]);
  if (!row$1[/* row_closed */3] || nm !== row$1[/* row_name */5]) {
    return unify$2(env, row$1[/* row_more */1], newty2(100000000, /* Tvariant */Block.__(8, [/* record */[
                        /* row_fields : [] */0,
                        /* row_more */newty2(100000000, /* Tvar */Block.__(0, [/* None */0])),
                        /* row_bound */row$1[/* row_bound */2],
                        /* row_closed : true */1,
                        /* row_fixed */row$1[/* row_fixed */4],
                        /* row_name */nm
                      ]])));
  } else {
    return 0;
  }
}

function row_of_pat(pat) {
  var match = expand_head(pat[/* pat_env */4], pat[/* pat_type */3]);
  var match$1 = match[/* desc */0];
  if (typeof match$1 === "number") {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "parmatch.ml",
            602,
            9
          ]
        ];
  } else if (match$1.tag === 8) {
    return row_repr_aux(/* [] */0, match$1[0]);
  } else {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "parmatch.ml",
            602,
            9
          ]
        ];
  }
}

function generalized_constructor(x) {
  var match = x[0][/* pat_desc */0];
  if (typeof match === "number") {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "parmatch.ml",
            613,
            9
          ]
        ];
  } else if (match.tag === 4) {
    return match[1][/* cstr_generalized */9];
  } else {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "parmatch.ml",
            613,
            9
          ]
        ];
  }
}

function clean_env(env) {
  var loop = function (_param) {
    while(true) {
      var param = _param;
      if (param) {
        var xs = param[1];
        var x = param[0];
        if (generalized_constructor(x)) {
          _param = xs;
          continue ;
          
        } else {
          return /* :: */[
                  x,
                  loop(xs)
                ];
        }
      } else {
        return /* [] */0;
      }
    };
  };
  return loop(env);
}

function full_match(ignore_generalized, closing, env) {
  if (env) {
    var p = env[0][0];
    var match = p[/* pat_desc */0];
    if (typeof match === "number") {
      return fatal_error("Parmatch.full_match");
    } else {
      switch (match.tag | 0) {
        case 2 : 
            if (match[0].tag === 1) {
              return +(List.length(env) === 256);
            } else {
              return /* false */0;
            }
            break;
        case 4 : 
            var c = match[1];
            if (c[/* cstr_consts */6] < 0) {
              return /* false */0;
            } else if (ignore_generalized) {
              var env$1 = clean_env(env);
              return +(List.length(env$1) === c[/* cstr_normal */8]);
            } else {
              return +(List.length(env) === (c[/* cstr_consts */6] + c[/* cstr_nonconsts */7] | 0));
            }
            break;
        case 5 : 
            var fields = List.map((function (param) {
                    var match = param[0][/* pat_desc */0];
                    if (typeof match === "number") {
                      throw [
                            Caml_builtin_exceptions.assert_failure,
                            [
                              "parmatch.ml",
                              640,
                              17
                            ]
                          ];
                    } else if (match.tag === 5) {
                      return match[0];
                    } else {
                      throw [
                            Caml_builtin_exceptions.assert_failure,
                            [
                              "parmatch.ml",
                              640,
                              17
                            ]
                          ];
                    }
                  }), env);
            var row = row_of_pat(p);
            if (closing && !row_fixed(row)) {
              return List.for_all((function (param) {
                            var tag = param[0];
                            var match = row_field_repr_aux(/* [] */0, param[1]);
                            if (typeof match === "number") {
                              return /* true */1;
                            } else if (match.tag) {
                              if (match[2] !== 0) {
                                return List.mem(tag, fields);
                              } else {
                                return /* true */1;
                              }
                            } else {
                              return List.mem(tag, fields);
                            }
                          }), row[/* row_fields */0]);
            } else if (row[/* row_closed */3]) {
              return List.for_all((function (param) {
                            if (row_field_repr_aux(/* [] */0, param[1])) {
                              return List.mem(param[0], fields);
                            } else {
                              return /* true */1;
                            }
                          }), row[/* row_fields */0]);
            } else {
              return /* false */0;
            }
        case 7 : 
            return /* false */0;
        case 3 : 
        case 6 : 
        case 9 : 
            return /* true */1;
        default:
          return fatal_error("Parmatch.full_match");
      }
    }
  } else {
    return fatal_error("Parmatch.full_match");
  }
}

function full_match_gadt(env) {
  if (env) {
    var match = env[0][0][/* pat_desc */0];
    if (typeof match === "number") {
      return /* true */1;
    } else if (match.tag === 4) {
      var c = match[1];
      return +(List.length(env) === (c[/* cstr_consts */6] + c[/* cstr_nonconsts */7] | 0));
    } else {
      return /* true */1;
    }
  } else {
    return /* true */1;
  }
}

function should_extend(ext, env) {
  if (ext) {
    if (env) {
      var p = env[0][0];
      var match = p[/* pat_desc */0];
      if (typeof match === "number") {
        return /* false */0;
      } else if (match.tag === 4) {
        var exit = 0;
        switch (match[1][/* cstr_tag */5].tag | 0) {
          case 0 : 
          case 1 : 
              exit = 1;
              break;
          case 2 : 
              return /* false */0;
          
        }
        if (exit === 1) {
          var path = get_type_path(p[/* pat_type */3], p[/* pat_env */4]);
          return same(path, ext[0]);
        }
        
      } else {
        return /* false */0;
      }
    } else {
      return /* false */0;
    }
  } else {
    return /* false */0;
  }
}

function complete_tags(nconsts, nconstrs, tags) {
  var seen_const = Caml_array.caml_make_vect(nconsts, /* false */0);
  var seen_constr = Caml_array.caml_make_vect(nconstrs, /* false */0);
  List.iter((function (param) {
          switch (param.tag | 0) {
            case 0 : 
                return Caml_array.caml_array_set(seen_const, param[0], /* true */1);
            case 1 : 
                return Caml_array.caml_array_set(seen_constr, param[0], /* true */1);
            case 2 : 
                throw [
                      Caml_builtin_exceptions.assert_failure,
                      [
                        "parmatch.ml",
                        703,
                        14
                      ]
                    ];
            
          }
        }), tags);
  var r = /* [] */0;
  for(var i = 0 ,i_finish = nconsts - 1 | 0; i <= i_finish; ++i){
    if (!Caml_array.caml_array_get(seen_const, i)) {
      r = /* :: */[
        /* Cstr_constant */Block.__(0, [i]),
        r
      ];
    }
    
  }
  for(var i$1 = 0 ,i_finish$1 = nconstrs - 1 | 0; i$1 <= i_finish$1; ++i$1){
    if (!Caml_array.caml_array_get(seen_constr, i$1)) {
      r = /* :: */[
        /* Cstr_block */Block.__(1, [i$1]),
        r
      ];
    }
    
  }
  return r;
}

function pat_of_constr(ex_pat, cstr) {
  var newrecord = ex_pat.slice();
  newrecord[/* pat_desc */0] = /* Tpat_construct */Block.__(4, [
      /* record */[
        /* txt : Lident */Block.__(0, ["?pat_of_constr?"]),
        /* loc */none
      ],
      cstr,
      omegas(cstr[/* cstr_arity */4])
    ]);
  return newrecord;
}

function pat_of_constrs(ex_pat, param) {
  if (param) {
    var rem = param[1];
    var cstr = param[0];
    if (rem) {
      var newrecord = ex_pat.slice();
      newrecord[/* pat_desc */0] = /* Tpat_or */Block.__(8, [
          pat_of_constr(ex_pat, cstr),
          pat_of_constrs(ex_pat, rem),
          /* None */0
        ]);
      return newrecord;
    } else {
      return pat_of_constr(ex_pat, cstr);
    }
  } else {
    throw Empty;
  }
}

function get_variant_constructors(env, _ty) {
  while(true) {
    var ty = _ty;
    var match = repr(ty)[/* desc */0];
    if (typeof match === "number") {
      return fatal_error("Parmatch.get_variant_constructors");
    } else if (match.tag === 3) {
      var path = match[0];
      var match$1 = find_type_full(path, env)[0];
      var exit = 0;
      var $js = match$1[/* type_kind */2];
      if (typeof $js === "number") {
        exit = 1;
      } else if ($js.tag === 1) {
        return find_type_full(path, env)[1][0];
      } else {
        exit = 1;
      }
      if (exit === 1) {
        if (match$1[/* type_manifest */4]) {
          _ty = expand_head_once(env, clean_copy(ty));
          continue ;
          
        } else {
          return fatal_error("Parmatch.get_variant_constructors");
        }
      }
      
    } else {
      return fatal_error("Parmatch.get_variant_constructors");
    }
  };
}

function map_filter(f, _param) {
  while(true) {
    var param = _param;
    if (param) {
      var xs = param[1];
      var match = Curry._1(f, param[0]);
      if (match) {
        return /* :: */[
                match[0],
                map_filter(f, xs)
              ];
      } else {
        _param = xs;
        continue ;
        
      }
    } else {
      return /* [] */0;
    }
  };
}

function complete_constrs(p, all_tags) {
  var match = p[/* pat_desc */0];
  if (typeof match === "number") {
    return fatal_error("Parmatch.complete_constr");
  } else if (match.tag === 4) {
    var c = match[1];
    var not_tags = complete_tags(c[/* cstr_consts */6], c[/* cstr_nonconsts */7], all_tags);
    var constrs = get_variant_constructors(p[/* pat_env */4], c[/* cstr_res */1]);
    return map_filter((function (cnstr) {
                  if (List.exists((function (tag) {
                            return equal_tag(tag, cnstr[/* cstr_tag */5]);
                          }), not_tags)) {
                    return /* Some */[cnstr];
                  } else {
                    return /* None */0;
                  }
                }), constrs);
  } else {
    return fatal_error("Parmatch.complete_constr");
  }
}

function build_other_constant(proj, make, first, next, p, env) {
  var all = List.map((function (param) {
          return Curry._1(proj, param[0][/* pat_desc */0]);
        }), env);
  var _i = first;
  while(true) {
    var i = _i;
    if (List.mem(i, all)) {
      _i = Curry._1(next, i);
      continue ;
      
    } else {
      return make_pat(Curry._1(make, i), p[/* pat_type */3], p[/* pat_env */4]);
    }
  };
}

function build_other(ext, env) {
  if (env) {
    var p = env[0][0];
    var match = p[/* pat_desc */0];
    if (typeof match === "number") {
      return omega;
    } else {
      switch (match.tag | 0) {
        case 2 : 
            switch (match[0].tag | 0) {
              case 0 : 
                  return build_other_constant((function (param) {
                                var exit = 0;
                                if (typeof param === "number") {
                                  exit = 1;
                                } else if (param.tag === 2) {
                                  var match = param[0];
                                  if (match.tag) {
                                    exit = 1;
                                  } else {
                                    return match[0];
                                  }
                                } else {
                                  exit = 1;
                                }
                                if (exit === 1) {
                                  throw [
                                        Caml_builtin_exceptions.assert_failure,
                                        [
                                          "parmatch.ml",
                                          857,
                                          55
                                        ]
                                      ];
                                }
                                
                              }), (function (i) {
                                return /* Tpat_constant */Block.__(2, [/* Const_int */Block.__(0, [i])]);
                              }), 0, (function (prim) {
                                return prim + 1 | 0;
                              }), p, env);
              case 1 : 
                  var all_chars = List.map((function (param) {
                          var match = param[0][/* pat_desc */0];
                          var exit = 0;
                          if (typeof match === "number") {
                            exit = 1;
                          } else if (match.tag === 2) {
                            var match$1 = match[0];
                            if (match$1.tag === 1) {
                              return match$1[0];
                            } else {
                              exit = 1;
                            }
                          } else {
                            exit = 1;
                          }
                          if (exit === 1) {
                            throw [
                                  Caml_builtin_exceptions.assert_failure,
                                  [
                                    "parmatch.ml",
                                    832,
                                    15
                                  ]
                                ];
                          }
                          
                        }), env);
                  var _param = /* :: */[
                    /* tuple */[
                      /* "a" */97,
                      /* "z" */122
                    ],
                    /* :: */[
                      /* tuple */[
                        /* "A" */65,
                        /* "Z" */90
                      ],
                      /* :: */[
                        /* tuple */[
                          /* "0" */48,
                          /* "9" */57
                        ],
                        /* :: */[
                          /* tuple */[
                            /* " " */32,
                            /* "~" */126
                          ],
                          /* :: */[
                            /* tuple */[
                              Char.chr(0),
                              Char.chr(255)
                            ],
                            /* [] */0
                          ]
                        ]
                      ]
                    ]
                  ];
                  while(true) {
                    var param = _param;
                    if (param) {
                      var match$1 = param[0];
                      try {
                        var _i = match$1[0];
                        var imax = match$1[1];
                        while(true) {
                          var i = _i;
                          if (i > imax) {
                            throw Caml_builtin_exceptions.not_found;
                          } else {
                            var ci = Char.chr(i);
                            if (List.mem(ci, all_chars)) {
                              _i = i + 1 | 0;
                              continue ;
                              
                            } else {
                              return make_pat(/* Tpat_constant */Block.__(2, [/* Const_char */Block.__(1, [ci])]), p[/* pat_type */3], p[/* pat_env */4]);
                            }
                          }
                        };
                      }
                      catch (exn){
                        if (exn === Caml_builtin_exceptions.not_found) {
                          _param = param[1];
                          continue ;
                          
                        } else {
                          throw exn;
                        }
                      }
                    } else {
                      return omega;
                    }
                  };
              case 2 : 
                  return build_other_constant((function (param) {
                                var exit = 0;
                                if (typeof param === "number") {
                                  exit = 1;
                                } else if (param.tag === 2) {
                                  var match = param[0];
                                  if (match.tag === 2) {
                                    return match[0].length;
                                  } else {
                                    exit = 1;
                                  }
                                } else {
                                  exit = 1;
                                }
                                if (exit === 1) {
                                  throw [
                                        Caml_builtin_exceptions.assert_failure,
                                        [
                                          "parmatch.ml",
                                          878,
                                          21
                                        ]
                                      ];
                                }
                                
                              }), (function (i) {
                                return /* Tpat_constant */Block.__(2, [/* Const_string */Block.__(2, [
                                              Caml_string.bytes_to_string(Bytes.make(i, /* "*" */42)),
                                              /* None */0
                                            ])]);
                              }), 0, (function (prim) {
                                return prim + 1 | 0;
                              }), p, env);
              case 3 : 
                  return build_other_constant((function (param) {
                                var exit = 0;
                                if (typeof param === "number") {
                                  exit = 1;
                                } else if (param.tag === 2) {
                                  var match = param[0];
                                  if (match.tag === 3) {
                                    return Caml_format.caml_float_of_string(match[0]);
                                  } else {
                                    exit = 1;
                                  }
                                } else {
                                  exit = 1;
                                }
                                if (exit === 1) {
                                  throw [
                                        Caml_builtin_exceptions.assert_failure,
                                        [
                                          "parmatch.ml",
                                          884,
                                          21
                                        ]
                                      ];
                                }
                                
                              }), (function (f) {
                                return /* Tpat_constant */Block.__(2, [/* Const_float */Block.__(3, [Pervasives.string_of_float(f)])]);
                              }), 0.0, (function (f) {
                                return f + 1.0;
                              }), p, env);
              case 4 : 
                  return build_other_constant((function (param) {
                                var exit = 0;
                                if (typeof param === "number") {
                                  exit = 1;
                                } else if (param.tag === 2) {
                                  var match = param[0];
                                  if (match.tag === 4) {
                                    return match[0];
                                  } else {
                                    exit = 1;
                                  }
                                } else {
                                  exit = 1;
                                }
                                if (exit === 1) {
                                  throw [
                                        Caml_builtin_exceptions.assert_failure,
                                        [
                                          "parmatch.ml",
                                          862,
                                          57
                                        ]
                                      ];
                                }
                                
                              }), (function (i) {
                                return /* Tpat_constant */Block.__(2, [/* Const_int32 */Block.__(4, [i])]);
                              }), 0, Int32.succ, p, env);
              case 5 : 
                  return build_other_constant((function (param) {
                                var exit = 0;
                                if (typeof param === "number") {
                                  exit = 1;
                                } else if (param.tag === 2) {
                                  var match = param[0];
                                  if (match.tag === 5) {
                                    return match[0];
                                  } else {
                                    exit = 1;
                                  }
                                } else {
                                  exit = 1;
                                }
                                if (exit === 1) {
                                  throw [
                                        Caml_builtin_exceptions.assert_failure,
                                        [
                                          "parmatch.ml",
                                          867,
                                          57
                                        ]
                                      ];
                                }
                                
                              }), (function (i) {
                                return /* Tpat_constant */Block.__(2, [/* Const_int64 */Block.__(5, [i])]);
                              }), /* int64 */[
                              /* hi */0,
                              /* lo */0
                            ], Int64.succ, p, env);
              case 6 : 
                  return build_other_constant((function (param) {
                                var exit = 0;
                                if (typeof param === "number") {
                                  exit = 1;
                                } else if (param.tag === 2) {
                                  var match = param[0];
                                  if (match.tag === 6) {
                                    return match[0];
                                  } else {
                                    exit = 1;
                                  }
                                } else {
                                  exit = 1;
                                }
                                if (exit === 1) {
                                  throw [
                                        Caml_builtin_exceptions.assert_failure,
                                        [
                                          "parmatch.ml",
                                          872,
                                          61
                                        ]
                                      ];
                                }
                                
                              }), (function (i) {
                                return /* Tpat_constant */Block.__(2, [/* Const_nativeint */Block.__(6, [i])]);
                              }), 0, Nativeint.succ, p, env);
              
            }
            break;
        case 4 : 
            var c = match[1];
            var exit = 0;
            switch (c[/* cstr_tag */5].tag | 0) {
              case 0 : 
              case 1 : 
                  exit = 1;
                  break;
              case 2 : 
                  var newrecord = c.slice();
                  newrecord[/* cstr_name */0] = "*extension*";
                  return make_pat(/* Tpat_construct */Block.__(4, [
                                match[0],
                                newrecord,
                                /* [] */0
                              ]), none$2, empty);
              
            }
            if (exit === 1) {
              var exit$1 = 0;
              if (ext) {
                if (same(ext[0], get_type_path(p[/* pat_type */3], p[/* pat_env */4]))) {
                  return extra_pat;
                } else {
                  exit$1 = 2;
                }
              } else {
                exit$1 = 2;
              }
              if (exit$1 === 2) {
                var all_tags = List.map((function (param) {
                        var param$1 = param[0];
                        var match = param$1[/* pat_desc */0];
                        if (typeof match === "number") {
                          return fatal_error("Parmatch.get_tag");
                        } else if (match.tag === 4) {
                          return match[1][/* cstr_tag */5];
                        } else {
                          return fatal_error("Parmatch.get_tag");
                        }
                      }), env);
                return pat_of_constrs(p, complete_constrs(p, all_tags));
              }
              
            }
            break;
        case 5 : 
            var r = match[2];
            var tags = List.map((function (param) {
                    var match = param[0][/* pat_desc */0];
                    if (typeof match === "number") {
                      throw [
                            Caml_builtin_exceptions.assert_failure,
                            [
                              "parmatch.ml",
                              801,
                              23
                            ]
                          ];
                    } else if (match.tag === 5) {
                      return match[0];
                    } else {
                      throw [
                            Caml_builtin_exceptions.assert_failure,
                            [
                              "parmatch.ml",
                              801,
                              23
                            ]
                          ];
                    }
                  }), env);
            var row = row_of_pat(p);
            var make_other_pat = function (tag, $$const) {
              var arg = $$const ? /* None */0 : /* Some */[omega];
              return make_pat(/* Tpat_variant */Block.__(5, [
                            tag,
                            arg,
                            r
                          ]), p[/* pat_type */3], p[/* pat_env */4]);
            };
            var match$2 = List.fold_left((function (others, param) {
                    var tag = param[0];
                    if (List.mem(tag, tags)) {
                      return others;
                    } else {
                      var match = row_field_repr_aux(/* [] */0, param[1]);
                      if (typeof match === "number") {
                        return others;
                      } else if (match.tag) {
                        return /* :: */[
                                make_other_pat(tag, match[0]),
                                others
                              ];
                      } else {
                        return /* :: */[
                                make_other_pat(tag, +(match[0] === /* None */0)),
                                others
                              ];
                      }
                    }
                  }), /* [] */0, row[/* row_fields */0]);
            if (match$2) {
              return List.fold_left((function (p_res, pat) {
                            return make_pat(/* Tpat_or */Block.__(8, [
                                          pat,
                                          p_res,
                                          /* None */0
                                        ]), p[/* pat_type */3], p[/* pat_env */4]);
                          }), match$2[0], match$2[1]);
            } else {
              return make_other_pat("AnyExtraTag", /* true */1);
            }
        case 7 : 
            var all_lengths = List.map((function (param) {
                    var match = param[0][/* pat_desc */0];
                    if (typeof match === "number") {
                      throw [
                            Caml_builtin_exceptions.assert_failure,
                            [
                              "parmatch.ml",
                              893,
                              15
                            ]
                          ];
                    } else if (match.tag === 7) {
                      return List.length(match[0]);
                    } else {
                      throw [
                            Caml_builtin_exceptions.assert_failure,
                            [
                              "parmatch.ml",
                              893,
                              15
                            ]
                          ];
                    }
                  }), env);
            var _l = 0;
            while(true) {
              var l = _l;
              if (List.mem(l, all_lengths)) {
                _l = l + 1 | 0;
                continue ;
                
              } else {
                return make_pat(/* Tpat_array */Block.__(7, [omegas(l)]), p[/* pat_type */3], p[/* pat_env */4]);
              }
            };
        default:
          return omega;
      }
    }
  } else {
    return omega;
  }
}

function build_other_gadt(_, env) {
  var exit = 0;
  if (env) {
    var p = env[0][0];
    var $js = p[/* pat_desc */0];
    if (typeof $js === "number") {
      exit = 1;
    } else if ($js.tag === 4) {
      var all_tags = List.map((function (param) {
              var param$1 = param[0];
              var match = param$1[/* pat_desc */0];
              if (typeof match === "number") {
                return fatal_error("Parmatch.get_tag");
              } else if (match.tag === 4) {
                return match[1][/* cstr_tag */5];
              } else {
                return fatal_error("Parmatch.get_tag");
              }
            }), env);
      var cnstrs = complete_constrs(p, all_tags);
      return List.map((function (param) {
                    return pat_of_constr(p, param);
                  }), cnstrs);
    } else {
      exit = 1;
    }
  } else {
    exit = 1;
  }
  if (exit === 1) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "parmatch.ml",
            917,
            11
          ]
        ];
  }
  
}

function has_instance(_p) {
  while(true) {
    var p = _p;
    var match = p[/* pat_desc */0];
    if (typeof match === "number") {
      return /* true */1;
    } else {
      switch (match.tag | 0) {
        case 4 : 
            return has_instances(match[2]);
        case 5 : 
            var match$1 = match[1];
            if (is_absent(match[0], match[2])) {
              return /* false */0;
            } else if (match$1) {
              _p = match$1[0];
              continue ;
              
            } else {
              return /* true */1;
            }
            break;
        case 6 : 
            return has_instances(List.map((function (param) {
                              return param[2];
                            }), match[0]));
        case 3 : 
        case 7 : 
            return has_instances(match[0]);
        case 8 : 
            if (has_instance(match[0])) {
              return /* true */1;
            } else {
              _p = match[1];
              continue ;
              
            }
            break;
        case 1 : 
        case 9 : 
            _p = match[0];
            continue ;
            default:
          return /* true */1;
      }
    }
  };
}

function has_instances(_param) {
  while(true) {
    var param = _param;
    if (param) {
      if (has_instance(param[0])) {
        _param = param[1];
        continue ;
        
      } else {
        return /* false */0;
      }
    } else {
      return /* true */1;
    }
  };
}

function satisfiable(_pss, _qs) {
  while(true) {
    var qs = _qs;
    var pss = _pss;
    if (pss) {
      if (qs) {
        var q = qs[0];
        var match = q[/* pat_desc */0];
        var exit = 0;
        if (typeof match === "number") {
          exit = match ? 2 : 1;
        } else {
          switch (match.tag | 0) {
            case 0 : 
                exit = 1;
                break;
            case 1 : 
                _qs = /* :: */[
                  match[0],
                  qs[1]
                ];
                continue ;
                case 5 : 
                if (is_absent(match[0], match[2])) {
                  return /* false */0;
                } else {
                  exit = 2;
                }
                break;
            case 8 : 
                var qs$1 = qs[1];
                if (satisfiable(pss, /* :: */[
                        match[0],
                        qs$1
                      ])) {
                  return /* true */1;
                } else {
                  _qs = /* :: */[
                    match[1],
                    qs$1
                  ];
                  continue ;
                  
                }
                break;
            default:
              exit = 2;
          }
        }
        switch (exit) {
          case 1 : 
              var qs$2 = qs[1];
              var q0 = discr_pat(omega, pss);
              var constrs = filter_all(q0, pss);
              if (constrs) {
                if (full_match(/* false */0, /* false */0, constrs)) {
                  return List.exists((function(qs$2){
                            return function (param) {
                              var p = param[0];
                              if (is_absent_pat(p)) {
                                return /* false */0;
                              } else {
                                return satisfiable(param[1], Pervasives.$at(simple_match_args(p, omega), qs$2));
                              }
                            }
                            }(qs$2)), constrs);
                } else {
                  _qs = qs$2;
                  _pss = filter_extra(pss);
                  continue ;
                  
                }
              } else {
                _qs = qs$2;
                _pss = filter_extra(pss);
                continue ;
                
              }
              break;
          case 2 : 
              var q0$1 = discr_pat(q, pss);
              _qs = Pervasives.$at(simple_match_args(q0$1, q), qs[1]);
              _pss = filter_one(q0$1, pss);
              continue ;
              
        }
      } else {
        return /* false */0;
      }
    } else {
      return has_instances(qs);
    }
  };
}

function orify_many(param) {
  if (param) {
    var xs = param[1];
    var x = param[0];
    if (xs) {
      var x$1 = x;
      var y = Curry._1(orify_many, xs);
      return make_pat(/* Tpat_or */Block.__(8, [
                    x$1,
                    y,
                    /* None */0
                  ]), x$1[/* pat_type */3], x$1[/* pat_env */4]);
    } else {
      return x;
    }
  } else {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "parmatch.ml",
            989,
            12
          ]
        ];
  }
}

function try_many_gadt(f, param) {
  if (param) {
    var match = param[0];
    var r1 = Curry._1(f, /* tuple */[
          match[0],
          match[1]
        ]);
    var r2 = try_many_gadt(f, param[1]);
    if (r1) {
      if (r2) {
        return /* Rsome */[Pervasives.$at(r1[0], r2[0])];
      } else {
        return r1;
      }
    } else {
      return r2;
    }
  } else {
    return /* Rnone */0;
  }
}

function exhaust(ext, pss, n) {
  if (pss) {
    if (pss[0]) {
      var q0 = discr_pat(omega, pss);
      var constrs = filter_all(q0, pss);
      if (constrs) {
        var try_non_omega = function (param) {
          var p = param[0];
          if (is_absent_pat(p)) {
            return /* Rnone */0;
          } else {
            var r = exhaust(ext, param[1], (List.length(simple_match_args(p, omega)) + n | 0) - 1 | 0);
            if (r) {
              return /* Rsome */[do_set_args(/* false */0, p, r[0])];
            } else {
              return r;
            }
          }
        };
        if (full_match(/* true */1, /* false */0, constrs) && !should_extend(ext, constrs)) {
          var f = try_non_omega;
          var _param = constrs;
          while(true) {
            var param = _param;
            if (param) {
              var match = param[0];
              var r = Curry._1(f, /* tuple */[
                    match[0],
                    match[1]
                  ]);
              if (r) {
                return r;
              } else {
                _param = param[1];
                continue ;
                
              }
            } else {
              return /* Rnone */0;
            }
          };
        } else {
          var r$1 = exhaust(ext, filter_extra(pss), n - 1 | 0);
          if (r$1) {
            try {
              return /* Rsome */[/* :: */[
                        build_other(ext, constrs),
                        r$1[0]
                      ]];
            }
            catch (exn){
              if (exn === Empty) {
                return fatal_error("Parmatch.exhaust");
              } else {
                throw exn;
              }
            }
          } else {
            return /* Rnone */0;
          }
        }
      } else {
        var r$2 = exhaust(ext, filter_extra(pss), n - 1 | 0);
        if (r$2) {
          return /* Rsome */[/* :: */[
                    q0,
                    r$2[0]
                  ]];
        } else {
          return r$2;
        }
      }
    } else {
      return /* Rnone */0;
    }
  } else {
    return /* Rsome */[omegas(n)];
  }
}

function combinations(f, lst, lst$prime) {
  var iter2 = function (x, param) {
    if (param) {
      return /* :: */[
              Curry._2(f, x, param[0]),
              iter2(x, param[1])
            ];
    } else {
      return /* [] */0;
    }
  };
  var iter = function (param) {
    if (param) {
      return Pervasives.$at(iter2(param[0], lst$prime), iter(param[1]));
    } else {
      return /* [] */0;
    }
  };
  return iter(lst);
}

function exhaust_gadt(ext, pss, n) {
  if (pss) {
    if (pss[0]) {
      var q0 = discr_pat(omega, pss);
      var constrs = filter_all(q0, pss);
      if (constrs) {
        var try_non_omega = function (param) {
          var p = param[0];
          if (is_absent_pat(p)) {
            return /* Rnone */0;
          } else {
            var r = exhaust_gadt(ext, param[1], (List.length(simple_match_args(p, omega)) + n | 0) - 1 | 0);
            if (r) {
              return /* Rsome */[List.map((function (row) {
                              return do_set_args(/* false */0, p, row);
                            }), r[0])];
            } else {
              return r;
            }
          }
        };
        var before = try_many_gadt(try_non_omega, constrs);
        if (full_match_gadt(constrs) && !should_extend(ext, constrs)) {
          return before;
        } else {
          var r = exhaust_gadt(ext, filter_extra(pss), n - 1 | 0);
          if (r) {
            try {
              var missing_trailing = build_other_gadt(ext, constrs);
              var dug = combinations((function (head, tail) {
                      return /* :: */[
                              head,
                              tail
                            ];
                    }), missing_trailing, r[0]);
              if (before) {
                return /* Rsome */[Pervasives.$at(before[0], dug)];
              } else {
                return /* Rsome */[dug];
              }
            }
            catch (exn){
              if (exn === Empty) {
                return fatal_error("Parmatch.exhaust");
              } else {
                throw exn;
              }
            }
          } else {
            return before;
          }
        }
      } else {
        var r$1 = exhaust_gadt(ext, filter_extra(pss), n - 1 | 0);
        if (r$1) {
          return /* Rsome */[List.map((function (row) {
                          return /* :: */[
                                  q0,
                                  row
                                ];
                        }), r$1[0])];
        } else {
          return r$1;
        }
      }
    } else {
      return /* Rnone */0;
    }
  } else {
    return /* Rsome */[/* :: */[
              omegas(n),
              /* [] */0
            ]];
  }
}

function exhaust_gadt$1(ext, pss, n) {
  var ret = exhaust_gadt(ext, pss, n);
  if (ret) {
    var lst = ret[0];
    if (lst) {
      var singletons = List.map((function (param) {
              if (param) {
                if (param[1]) {
                  throw [
                        Caml_builtin_exceptions.assert_failure,
                        [
                          "parmatch.ml",
                          1165,
                          19
                        ]
                      ];
                } else {
                  return param[0];
                }
              } else {
                throw [
                      Caml_builtin_exceptions.assert_failure,
                      [
                        "parmatch.ml",
                        1165,
                        19
                      ]
                    ];
              }
            }), lst);
      return /* Rsome */[/* :: */[
                Curry._1(orify_many, singletons),
                /* [] */0
              ]];
    } else {
      return /* Rsome */[omegas(n)];
    }
  } else {
    return /* Rnone */0;
  }
}

function pressure_variants(_tdefs, _pss) {
  while(true) {
    var pss = _pss;
    var tdefs = _tdefs;
    if (pss) {
      if (pss[0]) {
        var q0 = discr_pat(omega, pss);
        var constrs = filter_all(q0, pss);
        if (constrs) {
          var try_non_omega = (function(tdefs){
          return function try_non_omega(param) {
            if (param) {
              var ok = pressure_variants(tdefs, param[0][1]);
              if (try_non_omega(param[1])) {
                return ok;
              } else {
                return /* false */0;
              }
            } else {
              return /* true */1;
            }
          }
          }(tdefs));
          if (full_match(/* true */1, +(tdefs === /* None */0), constrs)) {
            return try_non_omega(constrs);
          } else if (tdefs) {
            var full = full_match(/* true */1, /* true */1, constrs);
            var ok = full ? try_non_omega(constrs) : try_non_omega(filter_all(q0, mark_partial(pss)));
            if (constrs) {
              var p = constrs[0][0];
              var $js = p[/* pat_desc */0];
              if (typeof $js !== "number") {
                if ($js.tag === 5) {
                  if (tdefs) {
                    var row = row_of_pat(p);
                    if (!(row_fixed(row) || pressure_variants(/* None */0, filter_extra(pss)))) {
                      close_variant(tdefs[0], row);
                    }
                    
                  }
                  
                }
                
              }
              
            }
            return ok;
          } else {
            _pss = filter_extra(pss);
            _tdefs = /* None */0;
            continue ;
            
          }
        } else {
          _pss = filter_extra(pss);
          continue ;
          
        }
      } else {
        return /* true */1;
      }
    } else {
      return /* false */0;
    }
  };
}

function make_row(ps) {
  return /* record */[
          /* no_ors : [] */0,
          /* ors : [] */0,
          /* active */ps
        ];
}

function unalias$1(_p) {
  while(true) {
    var p = _p;
    var match = p[/* pat_desc */0];
    if (typeof match === "number") {
      return p;
    } else if (match.tag === 1) {
      _p = match[0];
      continue ;
      
    } else {
      return p;
    }
  };
}

function is_var_column(rs) {
  return List.for_all((function (r) {
                var match = r[/* active */2];
                if (match) {
                  var p = match[0];
                  var match$1 = unalias$1(p)[/* pat_desc */0];
                  if (typeof match$1 === "number") {
                    if (match$1) {
                      return /* false */0;
                    } else {
                      return /* true */1;
                    }
                  } else if (match$1.tag) {
                    return /* false */0;
                  } else {
                    return /* true */1;
                  }
                } else {
                  throw [
                        Caml_builtin_exceptions.assert_failure,
                        [
                          "parmatch.ml",
                          1274,
                          14
                        ]
                      ];
                }
              }), rs);
}

function or_args(_p) {
  while(true) {
    var p = _p;
    var match = p[/* pat_desc */0];
    if (typeof match === "number") {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "parmatch.ml",
              1281,
              23
            ]
          ];
    } else {
      switch (match.tag | 0) {
        case 1 : 
            _p = match[0];
            continue ;
            case 8 : 
            return /* tuple */[
                    match[0],
                    match[1]
                  ];
        default:
          throw [
                Caml_builtin_exceptions.assert_failure,
                [
                  "parmatch.ml",
                  1281,
                  23
                ]
              ];
      }
    }
  };
}

function remove(r) {
  var match = r[/* active */2];
  if (match) {
    return /* record */[
            /* no_ors */r[/* no_ors */0],
            /* ors */r[/* ors */1],
            /* active */match[1]
          ];
  } else {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "parmatch.ml",
            1286,
            12
          ]
        ];
  }
}

function push_no_or(r) {
  var match = r[/* active */2];
  if (match) {
    return /* record */[
            /* no_ors : :: */[
              match[0],
              r[/* no_ors */0]
            ],
            /* ors */r[/* ors */1],
            /* active */match[1]
          ];
  } else {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "parmatch.ml",
            1293,
            8
          ]
        ];
  }
}

function push_or(r) {
  var match = r[/* active */2];
  if (match) {
    return /* record */[
            /* no_ors */r[/* no_ors */0],
            /* ors : :: */[
              match[0],
              r[/* ors */1]
            ],
            /* active */match[1]
          ];
  } else {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "parmatch.ml",
            1297,
            8
          ]
        ];
  }
}

function discr_pat$1(q, rs) {
  return discr_pat(q, List.map((function (r) {
                    return r[/* active */2];
                  }), rs));
}

function filter_one$1(q, rs) {
  var filter_rec = function (_rs) {
    while(true) {
      var rs = _rs;
      if (rs) {
        var rem = rs[1];
        var r = rs[0];
        var match = r[/* active */2];
        if (match) {
          var p = match[0];
          var match$1 = p[/* pat_desc */0];
          var exit = 0;
          if (typeof match$1 === "number") {
            exit = 1;
          } else {
            switch (match$1.tag | 0) {
              case 1 : 
                  _rs = /* :: */[
                    /* record */[
                      /* no_ors */r[/* no_ors */0],
                      /* ors */r[/* ors */1],
                      /* active : :: */[
                        match$1[0],
                        match[1]
                      ]
                    ],
                    rem
                  ];
                  continue ;
                  case 8 : 
                  var ps = match[1];
                  _rs = /* :: */[
                    /* record */[
                      /* no_ors */r[/* no_ors */0],
                      /* ors */r[/* ors */1],
                      /* active : :: */[
                        match$1[0],
                        ps
                      ]
                    ],
                    /* :: */[
                      /* record */[
                        /* no_ors */r[/* no_ors */0],
                        /* ors */r[/* ors */1],
                        /* active : :: */[
                          match$1[1],
                          ps
                        ]
                      ],
                      rem
                    ]
                  ];
                  continue ;
                  default:
                exit = 1;
            }
          }
          if (exit === 1) {
            if (simple_match(q, p)) {
              return /* :: */[
                      /* record */[
                        /* no_ors */r[/* no_ors */0],
                        /* ors */r[/* ors */1],
                        /* active */Pervasives.$at(simple_match_args(q, p), match[1])
                      ],
                      filter_rec(rem)
                    ];
            } else {
              _rs = rem;
              continue ;
              
            }
          }
          
        } else {
          throw [
                Caml_builtin_exceptions.assert_failure,
                [
                  "parmatch.ml",
                  1314,
                  14
                ]
              ];
        }
      } else {
        return /* [] */0;
      }
    };
  };
  return filter_rec(rs);
}

function make_vector(r) {
  return r[/* no_ors */0];
}

function extract_elements(qs) {
  var do_rec = function (seen, param) {
    if (param) {
      var rem = param[1];
      var q = param[0];
      return /* :: */[
              /* record */[
                /* no_ors */Pervasives.$at(List.rev_append(seen, rem), qs[/* no_ors */0]),
                /* ors : [] */0,
                /* active : :: */[
                  q,
                  /* [] */0
                ]
              ],
              do_rec(/* :: */[
                    q,
                    seen
                  ], rem)
            ];
    } else {
      return /* [] */0;
    }
  };
  return do_rec(/* [] */0, qs[/* ors */1]);
}

function extract_columns(pss, qs) {
  if (pss) {
    var rs = List.map(extract_elements, pss);
    if (rs) {
      var i = List.map((function (x) {
              return /* :: */[
                      x,
                      /* [] */0
                    ];
            }), rs[0]);
      return List.fold_left((function (param, param$1) {
                    return List.map2((function (r, x) {
                                  return /* :: */[
                                          x,
                                          r
                                        ];
                                }), param, param$1);
                  }), i, rs[1]);
    } else {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "parmatch.ml",
              1357,
              8
            ]
          ];
    }
  } else {
    return List.map((function () {
                  return /* [] */0;
                }), qs[/* ors */1]);
  }
}

function every_satisfiables(_pss, _qs) {
  while(true) {
    var qs = _qs;
    var pss = _pss;
    var match = qs[/* active */2];
    if (match) {
      var q = match[0];
      var uq = unalias$1(q);
      var match$1 = uq[/* pat_desc */0];
      var exit = 0;
      if (typeof match$1 === "number") {
        exit = match$1 ? 1 : 2;
      } else {
        switch (match$1.tag | 0) {
          case 0 : 
              exit = 2;
              break;
          case 5 : 
              if (is_absent(match$1[0], match$1[2])) {
                return /* Unused */1;
              } else {
                exit = 1;
              }
              break;
          case 8 : 
              if (match$1[0][/* pat_loc */1][/* loc_ghost */2] && match$1[1][/* pat_loc */1][/* loc_ghost */2]) {
                _qs = push_no_or(qs);
                _pss = List.map(push_no_or, pss);
                continue ;
                
              } else {
                _qs = push_or(qs);
                _pss = List.map(push_or, pss);
                continue ;
                
              }
              break;
          default:
            exit = 1;
        }
      }
      switch (exit) {
        case 1 : 
            var q0 = discr_pat$1(q, pss);
            _qs = /* record */[
              /* no_ors */qs[/* no_ors */0],
              /* ors */qs[/* ors */1],
              /* active */Pervasives.$at(simple_match_args(q0, q), match[1])
            ];
            _pss = filter_one$1(q0, pss);
            continue ;
            case 2 : 
            if (is_var_column(pss)) {
              _qs = remove(qs);
              _pss = List.map(remove, pss);
              continue ;
              
            } else {
              _qs = push_no_or(qs);
              _pss = List.map(push_no_or, pss);
              continue ;
              
            }
            break;
        
      }
    } else {
      var match$2 = qs[/* ors */1];
      if (match$2) {
        return List.fold_right2((function (pss, qs, r) {
                      var exit = 0;
                      if (typeof r === "number") {
                        if (r !== 0) {
                          return /* Unused */1;
                        } else {
                          exit = 1;
                        }
                      } else {
                        exit = 1;
                      }
                      if (exit === 1) {
                        var match = qs[/* active */2];
                        if (match) {
                          if (match[1]) {
                            throw [
                                  Caml_builtin_exceptions.assert_failure,
                                  [
                                    "parmatch.ml",
                                    1394,
                                    23
                                  ]
                                ];
                          } else {
                            var match$1 = or_args(match[0]);
                            var r_loc = every_both(pss, qs, match$1[0], match$1[1]);
                            var r1 = r;
                            var r2 = r_loc;
                            var exit$1 = 0;
                            if (typeof r1 === "number") {
                              if (r1 !== 0) {
                                return /* Unused */1;
                              } else {
                                exit$1 = 1;
                              }
                            } else if (typeof r2 === "number") {
                              if (r2 !== 0) {
                                exit$1 = 1;
                              } else {
                                return r1;
                              }
                            } else {
                              return /* Upartial */[Pervasives.$at(r1[0], r2[0])];
                            }
                            if (exit$1 === 1) {
                              if (typeof r2 === "number" && r2 !== 0) {
                                return /* Unused */1;
                              } else {
                                return r2;
                              }
                            }
                            
                          }
                        } else {
                          throw [
                                Caml_builtin_exceptions.assert_failure,
                                [
                                  "parmatch.ml",
                                  1394,
                                  23
                                ]
                              ];
                        }
                      }
                      
                    }), extract_columns(pss, qs), extract_elements(qs), /* Used */0);
      } else if (satisfiable(List.map(make_vector, pss), qs[/* no_ors */0])) {
        return /* Used */0;
      } else {
        return /* Unused */1;
      }
    }
  };
}

function every_both(pss, qs, q1, q2) {
  var qs1_000 = /* no_ors */qs[/* no_ors */0];
  var qs1_001 = /* ors */qs[/* ors */1];
  var qs1_002 = /* active : :: */[
    q1,
    /* [] */0
  ];
  var qs1 = /* record */[
    qs1_000,
    qs1_001,
    qs1_002
  ];
  var qs2_000 = /* no_ors */qs[/* no_ors */0];
  var qs2_001 = /* ors */qs[/* ors */1];
  var qs2_002 = /* active : :: */[
    q2,
    /* [] */0
  ];
  var qs2 = /* record */[
    qs2_000,
    qs2_001,
    qs2_002
  ];
  var r1 = every_satisfiables(pss, qs1);
  var r2 = every_satisfiables(compat(q1, q2) ? /* :: */[
          qs1,
          pss
        ] : pss, qs2);
  if (typeof r1 === "number") {
    if (r1 !== 0) {
      if (typeof r2 === "number") {
        if (r2 !== 0) {
          return /* Unused */1;
        } else {
          return /* Upartial */[/* :: */[
                    q1,
                    /* [] */0
                  ]];
        }
      } else {
        return /* Upartial */[/* :: */[
                  q1,
                  r2[0]
                ]];
      }
    } else if (typeof r2 === "number" && r2 !== 0) {
      return /* Upartial */[/* :: */[
                q2,
                /* [] */0
              ]];
    } else {
      return r2;
    }
  } else {
    var u1 = r1[0];
    if (typeof r2 === "number") {
      if (r2 !== 0) {
        return /* Upartial */[Pervasives.$at(u1, /* :: */[
                      q2,
                      /* [] */0
                    ])];
      } else {
        return r1;
      }
    } else {
      return /* Upartial */[Pervasives.$at(u1, r2[0])];
    }
  }
}

function le_pat(_p, _q) {
  while(true) {
    var q = _q;
    var p = _p;
    var match = p[/* pat_desc */0];
    var match$1 = q[/* pat_desc */0];
    var exit = 0;
    var exit$1 = 0;
    if (typeof match === "number") {
      return /* true */1;
    } else {
      switch (match.tag | 0) {
        case 0 : 
            return /* true */1;
        case 1 : 
            _p = match[0];
            continue ;
            case 2 : 
            if (typeof match$1 === "number") {
              exit = 1;
            } else {
              switch (match$1.tag | 0) {
                case 1 : 
                    exit$1 = 2;
                    break;
                case 2 : 
                    return +(const_compare(match[0], match$1[0]) === 0);
                default:
                  exit = 1;
              }
            }
            break;
        case 3 : 
            if (typeof match$1 === "number") {
              exit = 1;
            } else {
              switch (match$1.tag | 0) {
                case 1 : 
                    exit$1 = 2;
                    break;
                case 3 : 
                    return le_pats(match[0], match$1[0]);
                default:
                  exit = 1;
              }
            }
            break;
        case 4 : 
            if (typeof match$1 === "number") {
              exit = 1;
            } else {
              switch (match$1.tag | 0) {
                case 1 : 
                    exit$1 = 2;
                    break;
                case 4 : 
                    if (equal_tag(match[1][/* cstr_tag */5], match$1[1][/* cstr_tag */5])) {
                      return le_pats(match[2], match$1[2]);
                    } else {
                      return /* false */0;
                    }
                default:
                  exit = 1;
              }
            }
            break;
        case 5 : 
            var match$2 = match[1];
            var l1 = match[0];
            if (match$2) {
              if (typeof match$1 === "number") {
                exit = 1;
              } else {
                switch (match$1.tag | 0) {
                  case 1 : 
                      exit$1 = 2;
                      break;
                  case 5 : 
                      var match$3 = match$1[1];
                      if (match$3) {
                        if (l1 === match$1[0]) {
                          _q = match$3[0];
                          _p = match$2[0];
                          continue ;
                          
                        } else {
                          return /* false */0;
                        }
                      } else {
                        return /* false */0;
                      }
                      break;
                  default:
                    exit = 1;
                }
              }
            } else if (typeof match$1 === "number") {
              exit = 1;
            } else {
              switch (match$1.tag | 0) {
                case 1 : 
                    exit$1 = 2;
                    break;
                case 5 : 
                    if (match$1[1]) {
                      return /* false */0;
                    } else {
                      return +(l1 === match$1[0]);
                    }
                default:
                  exit = 1;
              }
            }
            break;
        case 6 : 
            if (typeof match$1 === "number") {
              exit = 1;
            } else {
              switch (match$1.tag | 0) {
                case 1 : 
                    exit$1 = 2;
                    break;
                case 6 : 
                    var match$4 = records_args(match[0], match$1[0]);
                    return le_pats(match$4[0], match$4[1]);
                default:
                  exit = 1;
              }
            }
            break;
        case 7 : 
            var ps = match[0];
            if (typeof match$1 === "number") {
              exit = 1;
            } else {
              switch (match$1.tag | 0) {
                case 1 : 
                    exit$1 = 2;
                    break;
                case 7 : 
                    var qs = match$1[0];
                    if (List.length(ps) === List.length(qs)) {
                      return le_pats(ps, qs);
                    } else {
                      return /* false */0;
                    }
                default:
                  exit = 1;
              }
            }
            break;
        case 8 : 
            exit$1 = 2;
            break;
        case 9 : 
            if (typeof match$1 === "number") {
              exit = 1;
            } else {
              switch (match$1.tag | 0) {
                case 1 : 
                    exit$1 = 2;
                    break;
                case 9 : 
                    _q = match$1[0];
                    _p = match[0];
                    continue ;
                    default:
                  exit = 1;
              }
            }
            break;
        
      }
    }
    if (exit$1 === 2) {
      if (typeof match$1 === "number") {
        exit = 1;
      } else if (match$1.tag === 1) {
        _q = match$1[0];
        continue ;
        
      } else {
        exit = 1;
      }
    }
    if (exit === 1) {
      return 1 - satisfiable(/* :: */[
                  /* :: */[
                    p,
                    /* [] */0
                  ],
                  /* [] */0
                ], /* :: */[
                  q,
                  /* [] */0
                ]);
    }
    
  };
}

function le_pats(_ps, _qs) {
  while(true) {
    var qs = _qs;
    var ps = _ps;
    if (ps) {
      if (qs) {
        if (le_pat(ps[0], qs[0])) {
          _qs = qs[1];
          _ps = ps[1];
          continue ;
          
        } else {
          return /* false */0;
        }
      } else {
        return /* true */1;
      }
    } else {
      return /* true */1;
    }
  };
}

function get_mins(le, ps) {
  var select_rec = function (_r, _param) {
    while(true) {
      var param = _param;
      var r = _r;
      if (param) {
        var ps = param[1];
        var p = param[0];
        if (List.exists((function(p){
              return function (p0) {
                return Curry._2(le, p0, p);
              }
              }(p)), ps)) {
          _param = ps;
          continue ;
          
        } else {
          _param = ps;
          _r = /* :: */[
            p,
            r
          ];
          continue ;
          
        }
      } else {
        return r;
      }
    };
  };
  return select_rec(/* [] */0, select_rec(/* [] */0, ps));
}

function pressure_variants$1(tdefs, patl) {
  var pss = List.map((function (p) {
          return /* :: */[
                  p,
                  /* :: */[
                    omega,
                    /* [] */0
                  ]
                ];
        }), patl);
  pressure_variants(/* Some */[tdefs], pss);
  return /* () */0;
}

function initial_matrix(_param) {
  while(true) {
    var param = _param;
    if (param) {
      var match = param[0];
      if (match[/* c_guard */1]) {
        _param = param[1];
        continue ;
        
      } else {
        return /* :: */[
                /* :: */[
                  match[/* c_lhs */0],
                  /* [] */0
                ],
                initial_matrix(param[1])
              ];
      }
    } else {
      return /* [] */0;
    }
  };
}

var NoGuard = Caml_exceptions.create("Ocaml_typedtree_test.Parmatch.NoGuard");

function initial_all(no_guard, param) {
  if (param) {
    var match = param[0];
    var pat = match[/* c_lhs */0];
    return /* :: */[
            /* tuple */[
              /* :: */[
                pat,
                /* [] */0
              ],
              pat[/* pat_loc */1]
            ],
            initial_all(no_guard && +(match[/* c_guard */1] === /* None */0), param[1])
          ];
  } else if (no_guard) {
    throw NoGuard;
  } else {
    return /* [] */0;
  }
}

function do_filter_var(param) {
  if (param) {
    var match = param[0];
    var match$1 = match[0];
    if (match$1) {
      return /* :: */[
              /* tuple */[
                match$1[1],
                match[1]
              ],
              do_filter_var(param[1])
            ];
    } else {
      return /* [] */0;
    }
  } else {
    return /* [] */0;
  }
}

function do_filter_one(q, pss) {
  var filter_rec = function (_param) {
    while(true) {
      var param = _param;
      if (param) {
        var match = param[0];
        var match$1 = match[0];
        if (match$1) {
          var p = match$1[0];
          var match$2 = p[/* pat_desc */0];
          var exit = 0;
          if (typeof match$2 === "number") {
            exit = 1;
          } else {
            switch (match$2.tag | 0) {
              case 1 : 
                  _param = /* :: */[
                    /* tuple */[
                      /* :: */[
                        match$2[0],
                        match$1[1]
                      ],
                      match[1]
                    ],
                    param[1]
                  ];
                  continue ;
                  case 8 : 
                  var loc = match[1];
                  var ps = match$1[1];
                  _param = /* :: */[
                    /* tuple */[
                      /* :: */[
                        match$2[0],
                        ps
                      ],
                      loc
                    ],
                    /* :: */[
                      /* tuple */[
                        /* :: */[
                          match$2[1],
                          ps
                        ],
                        loc
                      ],
                      param[1]
                    ]
                  ];
                  continue ;
                  default:
                exit = 1;
            }
          }
          if (exit === 1) {
            var pss = param[1];
            if (simple_match(q, p)) {
              return /* :: */[
                      /* tuple */[
                        Pervasives.$at(simple_match_args(q, p), match$1[1]),
                        match[1]
                      ],
                      filter_rec(pss)
                    ];
            } else {
              _param = pss;
              continue ;
              
            }
          }
          
        } else {
          return /* [] */0;
        }
      } else {
        return /* [] */0;
      }
    };
  };
  return filter_rec(pss);
}

function do_match(_pss, _qs) {
  while(true) {
    var qs = _qs;
    var pss = _pss;
    if (qs) {
      var q = qs[0];
      var match = q[/* pat_desc */0];
      var qs$1 = qs[1];
      if (typeof match === "number") {
        if (match) {
          var q0 = normalize_pat(q);
          _qs = Pervasives.$at(simple_match_args(q0, q), qs$1);
          _pss = do_filter_one(q0, pss);
          continue ;
          
        } else {
          _qs = qs$1;
          _pss = do_filter_var(pss);
          continue ;
          
        }
      } else if (match.tag === 8) {
        var r = do_match(pss, /* :: */[
              match[0],
              qs$1
            ]);
        if (r) {
          return r;
        } else {
          _qs = /* :: */[
            match[1],
            qs$1
          ];
          continue ;
          
        }
      } else {
        var q0 = normalize_pat(q);
        _qs = Pervasives.$at(simple_match_args(q0, q), qs$1);
        _pss = do_filter_one(q0, pss);
        continue ;
        
      }
    } else if (pss) {
      var match$1 = pss[0];
      if (match$1[0]) {
        return /* None */0;
      } else {
        return /* Some */[match$1[1]];
      }
    } else {
      return /* None */0;
    }
  };
}

function check_partial_all(v, casel) {
  try {
    var pss = initial_all(/* true */1, casel);
    return do_match(pss, /* :: */[
                v,
                /* [] */0
              ]);
  }
  catch (exn){
    if (exn === NoGuard) {
      return /* None */0;
    } else {
      throw exn;
    }
  }
}

function get_first(f, _param) {
  while(true) {
    var param = _param;
    if (param) {
      var x = Curry._1(f, param[0]);
      if (x) {
        return x;
      } else {
        _param = param[1];
        continue ;
        
      }
    } else {
      return /* None */0;
    }
  };
}

function mkpat$1(desc) {
  return mk$1(/* None */0, /* None */0, desc);
}

function select(param) {
  if (param) {
    var xs = param[0];
    if (param[1]) {
      if (xs) {
        var ys = param[1];
        var x = xs[0];
        return Pervasives.$at(List.map((function (lst) {
                          return /* :: */[
                                  x,
                                  lst
                                ];
                        }), select(ys)), select(/* :: */[
                        xs[1],
                        ys
                      ]));
      } else {
        return /* [] */0;
      }
    } else {
      return List.map((function (y) {
                    return /* :: */[
                            y,
                            /* [] */0
                          ];
                  }), xs);
    }
  } else {
    return /* [] */0;
  }
}

var name_counter$1 = [0];

function fresh(name) {
  var current = name_counter$1[0];
  name_counter$1[0] = name_counter$1[0] + 1 | 0;
  return "#$" + (name + current);
}

function conv(typed) {
  var constrs = Hashtbl.create(/* None */0, 0);
  var labels = Hashtbl.create(/* None */0, 0);
  var loop = function (_pat) {
    while(true) {
      var pat = _pat;
      var match = pat[/* pat_desc */0];
      if (typeof match === "number") {
        return /* :: */[
                mkpat$1(/* Ppat_any */0),
                /* [] */0
              ];
      } else {
        switch (match.tag | 0) {
          case 1 : 
              _pat = match[0];
              continue ;
              case 3 : 
              var results = select(List.map(loop, match[0]));
              return List.map((function (lst) {
                            return mkpat$1(/* Ppat_tuple */Block.__(4, [lst]));
                          }), results);
          case 4 : 
              var lst = match[2];
              var cstr = match[1];
              var id = fresh(cstr[/* cstr_name */0]);
              var lid_000 = /* txt : Lident */Block.__(0, [id]);
              var lid_001 = /* loc */match[0][/* loc */1];
              var lid = /* record */[
                lid_000,
                lid_001
              ];
              Hashtbl.add(constrs, id, cstr);
              var results$1 = select(List.map(loop, lst));
              if (lst) {
                return List.map((function(lid){
                          return function (lst) {
                            var arg;
                            if (lst) {
                              arg = lst[1] ? /* Some */[mkpat$1(/* Ppat_tuple */Block.__(4, [lst]))] : /* Some */[lst[0]];
                            } else {
                              throw [
                                    Caml_builtin_exceptions.assert_failure,
                                    [
                                      "parmatch.ml",
                                      1729,
                                      28
                                    ]
                                  ];
                            }
                            return mkpat$1(/* Ppat_construct */Block.__(5, [
                                          lid,
                                          arg
                                        ]));
                          }
                          }(lid)), results$1);
              } else {
                return /* :: */[
                        mkpat$1(/* Ppat_construct */Block.__(5, [
                                lid,
                                /* None */0
                              ])),
                        /* [] */0
                      ];
              }
          case 5 : 
              var p_opt = match[1];
              var label = match[0];
              if (p_opt) {
                var results$2 = loop(p_opt[0]);
                return List.map((function(label){
                          return function (p) {
                            return mkpat$1(/* Ppat_variant */Block.__(6, [
                                          label,
                                          /* Some */[p]
                                        ]));
                          }
                          }(label)), results$2);
              } else {
                return /* :: */[
                        mkpat$1(/* Ppat_variant */Block.__(6, [
                                label,
                                /* None */0
                              ])),
                        /* [] */0
                      ];
              }
              break;
          case 6 : 
              var subpatterns = match[0];
              var pats = select(List.map((function (param) {
                          return loop(param[2]);
                        }), subpatterns));
              var label_idents = List.map((function (param) {
                      var lbl = param[1];
                      var id = fresh(lbl[/* lbl_name */0]);
                      Hashtbl.add(labels, id, lbl);
                      return /* Lident */Block.__(0, [id]);
                    }), subpatterns);
              return List.map((function(label_idents){
                        return function (lst) {
                          var lst$1 = List.map2((function (lid, pat) {
                                  return /* tuple */[
                                          /* record */[
                                            /* txt */lid,
                                            /* loc */none
                                          ],
                                          pat
                                        ];
                                }), label_idents, lst);
                          return mkpat$1(/* Ppat_record */Block.__(7, [
                                        lst$1,
                                        /* Open */1
                                      ]));
                        }
                        }(label_idents)), pats);
          case 7 : 
              var results$3 = select(List.map(loop, match[0]));
              return List.map((function (lst) {
                            return mkpat$1(/* Ppat_array */Block.__(8, [lst]));
                          }), results$3);
          case 8 : 
              return Pervasives.$at(loop(match[0]), loop(match[1]));
          case 9 : 
              var results$4 = loop(match[0]);
              return List.map((function (p) {
                            return mkpat$1(/* Ppat_lazy */Block.__(12, [p]));
                          }), results$4);
          default:
            return /* :: */[
                    mkpat$1(/* Ppat_any */0),
                    /* [] */0
                  ];
        }
      }
    };
  };
  var ps = loop(typed);
  return /* tuple */[
          ps,
          constrs,
          labels
        ];
}

function do_check_partial(pred, exhaust, loc, casel, pss) {
  if (pss) {
    var match = Curry._3(exhaust, /* None */0, pss, List.length(pss[0]));
    if (match) {
      var match$1 = match[0];
      if (match$1) {
        if (match$1[1]) {
          return fatal_error("Parmatch.check_partial");
        } else {
          var u = match$1[0];
          var v;
          if (pred) {
            var match$2 = conv(u);
            v = get_first(Curry._2(pred[0], match$2[1], match$2[2]), match$2[0]);
          } else {
            v = /* Some */[u];
          }
          if (v) {
            var v$1 = v[0];
            var match$3 = v$1[/* pat_desc */0];
            var errmsg;
            var exit = 0;
            if (typeof match$3 === "number" || !(match$3.tag === 4 && match$3[1][/* cstr_name */0] === "*extension*")) {
              exit = 1;
            } else {
              errmsg = "_\nMatching over values of extensible variant types must include\na wild card pattern in order to be exhaustive.";
            }
            if (exit === 1) {
              try {
                var buf = Buffer.create(16);
                var fmt = Format.formatter_of_buffer(buf);
                top_pretty(fmt, v$1);
                var match$4 = check_partial_all(v$1, casel);
                if (match$4) {
                  Buffer.add_string(buf, "\n(However, some guarded clause may match this value.)");
                }
                errmsg = Buffer.contents(buf);
              }
              catch (exn){
                errmsg = "";
              }
            }
            prerr_warning(loc, /* Partial_match */Block.__(3, [errmsg]));
            return /* Partial */0;
          } else {
            return /* Total */1;
          }
        }
      } else {
        return fatal_error("Parmatch.check_partial");
      }
    } else {
      return /* Total */1;
    }
  } else {
    if (casel) {
      prerr_warning(loc, /* All_clauses_guarded */12);
    }
    return /* Partial */0;
  }
}

function do_check_partial_normal(loc, casel, pss) {
  return do_check_partial(/* None */0, exhaust, loc, casel, pss);
}

function add_path(path, paths) {
  if (paths) {
    var x = paths[0];
    if (same(path, x)) {
      return paths;
    } else {
      return /* :: */[
              x,
              add_path(path, paths[1])
            ];
    }
  } else {
    return /* :: */[
            path,
            /* [] */0
          ];
  }
}

function extendable_path(path) {
  return 1 - (same(path, path_bool) || same(path, path_list) || same(path, path_unit) || same(path, path_option));
}

function collect_paths_from_pat(_r, _p) {
  while(true) {
    var p = _p;
    var r = _r;
    var match = p[/* pat_desc */0];
    if (typeof match === "number") {
      return r;
    } else {
      switch (match.tag | 0) {
        case 4 : 
            var exit = 0;
            switch (match[1][/* cstr_tag */5].tag | 0) {
              case 0 : 
              case 1 : 
                  exit = 1;
                  break;
              case 2 : 
                  return List.fold_left(collect_paths_from_pat, r, match[2]);
              
            }
            if (exit === 1) {
              var path = get_type_path(p[/* pat_type */3], p[/* pat_env */4]);
              return List.fold_left(collect_paths_from_pat, extendable_path(path) ? add_path(path, r) : r, match[2]);
            }
            break;
        case 5 : 
            var match$1 = match[1];
            if (match$1) {
              _p = match$1[0];
              continue ;
              
            } else {
              return r;
            }
            break;
        case 6 : 
            return List.fold_left((function (r, param) {
                          return collect_paths_from_pat(r, param[2]);
                        }), r, match[0]);
        case 3 : 
        case 7 : 
            return List.fold_left(collect_paths_from_pat, r, match[0]);
        case 8 : 
            _p = match[1];
            _r = collect_paths_from_pat(r, match[0]);
            continue ;
            case 1 : 
        case 9 : 
            _p = match[0];
            continue ;
            default:
          return r;
      }
    }
  };
}

function do_check_fragile_param(exhaust, loc, casel, pss) {
  var exts = List.fold_left((function (r, c) {
          return collect_paths_from_pat(r, c[/* c_lhs */0]);
        }), /* [] */0, casel);
  if (exts) {
    if (pss) {
      var ps = pss[0];
      return List.iter((function (ext) {
                    var match = Curry._3(exhaust, /* Some */[ext], pss, List.length(ps));
                    if (match) {
                      return /* () */0;
                    } else {
                      return prerr_warning(loc, /* Fragile_match */Block.__(1, [name(/* None */0, ext)]));
                    }
                  }), exts);
    } else {
      return /* () */0;
    }
  } else {
    return /* () */0;
  }
}

function do_check_fragile_normal(param, param$1, param$2) {
  return do_check_fragile_param(exhaust, param, param$1, param$2);
}

function do_check_fragile_gadt(param, param$1, param$2) {
  return do_check_fragile_param(exhaust_gadt$1, param, param$1, param$2);
}

function check_partial_param(do_check_partial, do_check_fragile, loc, casel) {
  if (is_active(/* Partial_match */Block.__(3, [""]))) {
    var pss = initial_matrix(casel);
    var pss$1 = get_mins(le_pats, pss);
    var total = Curry._3(do_check_partial, loc, casel, pss$1);
    if (total === /* Total */1 && is_active(/* Fragile_match */Block.__(1, [""]))) {
      Curry._3(do_check_fragile, loc, casel, pss$1);
    }
    return total;
  } else {
    return /* Partial */0;
  }
}

function check_partial(param, param$1) {
  return check_partial_param(do_check_partial_normal, do_check_fragile_normal, param, param$1);
}

var Already_bound = Caml_exceptions.create("Ocaml_typedtree_test.Typetexp.Already_bound");

var $$Error$6 = Caml_exceptions.create("Ocaml_typedtree_test.Typetexp.Error");

var Error_forward = Caml_exceptions.create("Ocaml_typedtree_test.Typetexp.Error_forward");

function string_of_payload(param) {
  switch (param.tag | 0) {
    case 0 : 
        var match = param[0];
        if (match) {
          var match$1 = match[0][/* pstr_desc */0];
          if (match$1.tag) {
            return /* None */0;
          } else {
            var match$2 = match$1[0][/* pexp_desc */0];
            if (match$2.tag === 1 && !match[1]) {
              var param$1 = match$2[0];
              if (param$1.tag === 2) {
                return /* Some */[param$1[0]];
              } else {
                return /* None */0;
              }
            } else {
              return /* None */0;
            }
          }
        } else {
          return /* None */0;
        }
        break;
    case 1 : 
    case 2 : 
        return /* None */0;
    
  }
}

function error_of_extension(ext) {
  var match = ext[0];
  var txt = match[/* txt */0];
  var exit = 0;
  switch (txt) {
    case "error" : 
    case "ocaml.error" : 
        exit = 1;
        break;
    default:
      return Curry._1(errorf(/* Some */[match[/* loc */1]], /* None */0, /* None */0, /* Format */[
                      /* String_literal */Block.__(11, [
                          "Uninterpreted extension '",
                          /* String */Block.__(2, [
                              /* No_padding */0,
                              /* String_literal */Block.__(11, [
                                  "'.",
                                  /* End_of_format */0
                                ])
                            ])
                        ]),
                      "Uninterpreted extension '%s'."
                    ]), txt);
  }
  if (exit === 1) {
    var p = ext[1];
    var loc = match[/* loc */1];
    var sub_from = function (inner) {
      if (inner) {
        var match = inner[0][/* pstr_desc */0];
        if (match.tag === 14) {
          return /* :: */[
                  error_of_extension(match[0]),
                  sub_from(inner[1])
                ];
        } else {
          return /* :: */[
                  Curry._1(errorf(/* Some */[loc], /* None */0, /* None */0, /* Format */[
                            /* String_literal */Block.__(11, [
                                "Invalid syntax for sub-error of extension '",
                                /* String */Block.__(2, [
                                    /* No_padding */0,
                                    /* String_literal */Block.__(11, [
                                        "'.",
                                        /* End_of_format */0
                                      ])
                                  ])
                              ]),
                            "Invalid syntax for sub-error of extension '%s'."
                          ]), txt),
                  sub_from(inner[1])
                ];
        }
      } else {
        return /* [] */0;
      }
    };
    var exit$1 = 0;
    switch (p.tag | 0) {
      case 0 : 
          var match$1 = p[0];
          if (match$1) {
            var match$2 = match$1[0][/* pstr_desc */0];
            if (match$2.tag) {
              exit$1 = 2;
            } else {
              var match$3 = match$2[0][/* pexp_desc */0];
              if (match$3.tag === 1) {
                var match$4 = match$3[0];
                if (match$4.tag === 2) {
                  var inner = match$1[1];
                  var msg = match$4[0];
                  var exit$2 = 0;
                  if (inner) {
                    var match$5 = inner[0][/* pstr_desc */0];
                    if (match$5.tag) {
                      exit$2 = 3;
                    } else {
                      var match$6 = match$5[0][/* pexp_desc */0];
                      if (match$6.tag === 1) {
                        var match$7 = match$6[0];
                        if (match$7.tag === 2) {
                          return error(/* Some */[loc], /* Some */[sub_from(inner[1])], /* Some */[match$7[0]], msg);
                        } else {
                          exit$2 = 3;
                        }
                      } else {
                        exit$2 = 3;
                      }
                    }
                  } else {
                    exit$2 = 3;
                  }
                  if (exit$2 === 3) {
                    return error(/* Some */[loc], /* Some */[sub_from(inner)], /* None */0, msg);
                  }
                  
                } else {
                  exit$1 = 2;
                }
              } else {
                exit$1 = 2;
              }
            }
          } else {
            exit$1 = 2;
          }
          break;
      case 1 : 
      case 2 : 
          exit$1 = 2;
          break;
      
    }
    if (exit$1 === 2) {
      return Curry._1(errorf(/* Some */[loc], /* None */0, /* None */0, /* Format */[
                      /* String_literal */Block.__(11, [
                          "Invalid syntax for extension '",
                          /* String */Block.__(2, [
                              /* No_padding */0,
                              /* String_literal */Block.__(11, [
                                  "'.",
                                  /* End_of_format */0
                                ])
                            ])
                        ]),
                      "Invalid syntax for extension '%s'."
                    ]), txt);
    }
    
  }
  
}

function check_deprecated(loc, attrs, s) {
  return List.iter((function (param) {
                var exit = 0;
                switch (param[0][/* txt */0]) {
                  case "deprecated" : 
                  case "ocaml.deprecated" : 
                      exit = 1;
                      break;
                  default:
                    return /* () */0;
                }
                if (exit === 1) {
                  var match = string_of_payload(param[1]);
                  if (match) {
                    var txt = match[0];
                    if (bs_vscode) {
                      return prerr_warning(loc, /* Deprecated */Block.__(0, [s + (" " + txt)]));
                    } else {
                      return prerr_warning(loc, /* Deprecated */Block.__(0, [s + ("\n" + txt)]));
                    }
                  } else {
                    return prerr_warning(loc, /* Deprecated */Block.__(0, [s]));
                  }
                }
                
              }), attrs);
}

var newrecord$3 = default_mapper.slice();

newrecord$3[/* attribute */0] = (function (_, a) {
    var exit = 0;
    switch (a[0][/* txt */0]) {
      case "ocaml.ppwarning" : 
      case "ppwarning" : 
          exit = 1;
          break;
      default:
        
    }
    if (exit === 1) {
      var match = a[1];
      switch (match.tag | 0) {
        case 0 : 
            var match$1 = match[0];
            if (match$1) {
              var match$2 = match$1[0];
              var match$3 = match$2[/* pstr_desc */0];
              if (!match$3.tag) {
                var match$4 = match$3[0][/* pexp_desc */0];
                if (match$4.tag === 1) {
                  var match$5 = match$4[0];
                  if (match$5.tag === 2) {
                    if (!match$1[1]) {
                      prerr_warning(match$2[/* pstr_loc */1], /* Preprocessor */Block.__(10, [match$5[0]]));
                    }
                    
                  }
                  
                }
                
              }
              
            }
            break;
        case 1 : 
        case 2 : 
            break;
        
      }
    }
    return a;
  });

var warning_scope = [/* [] */0];

function warning_enter_scope() {
  warning_scope[0] = /* :: */[
    current[0],
    warning_scope[0]
  ];
  return /* () */0;
}

function warning_leave_scope() {
  var match = warning_scope[0];
  if (match) {
    current[0] = match[0];
    warning_scope[0] = match[1];
    return /* () */0;
  } else {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "typetexp.ml",
            146,
            10
          ]
        ];
  }
}

function warning_attribute(attrs) {
  var $$process = function (loc, txt, errflag, payload) {
    var match = string_of_payload(payload);
    if (match) {
      try {
        return parse_options(errflag, match[0]);
      }
      catch (raw_exn){
        var exn = Js_exn.internalToOCamlException(raw_exn);
        if (exn[0] === Arg.Bad) {
          return prerr_warning(loc, /* Attribute_payload */Block.__(30, [
                        txt,
                        "Ill-formed list of warnings"
                      ]));
        } else {
          throw exn;
        }
      }
    } else {
      return prerr_warning(loc, /* Attribute_payload */Block.__(30, [
                    txt,
                    "A single string literal is expected"
                  ]));
    }
  };
  return List.iter((function (param) {
                var match = param[0];
                var txt = match[/* txt */0];
                var exit = 0;
                switch (txt) {
                  case "ocaml.warnerror" : 
                  case "warnerror" : 
                      exit = 2;
                      break;
                  case "ocaml.warning" : 
                  case "warning" : 
                      exit = 1;
                      break;
                  default:
                    return /* () */0;
                }
                switch (exit) {
                  case 1 : 
                      return $$process(match[/* loc */1], txt, /* false */0, param[1]);
                  case 2 : 
                      return $$process(match[/* loc */1], txt, /* true */1, param[1]);
                  
                }
              }), attrs);
}

function narrow_unbound_lid_error(env, loc, lid, make_error) {
  var check_module = function (mlid) {
    try {
      lookup_module(/* true */1, mlid, env);
      return /* () */0;
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        return narrow_unbound_lid_error(env, loc, mlid, (function (lid) {
                      return /* Unbound_module */Block.__(20, [lid]);
                    }));
      } else if (exn === Recmodule) {
        throw [
              $$Error$6,
              loc,
              env,
              /* Illegal_reference_to_recursive_module */1
            ];
      } else {
        throw exn;
      }
    }
  };
  switch (lid.tag | 0) {
    case 0 : 
        break;
    case 1 : 
        var mlid = lid[0];
        check_module(mlid);
        var md = find_module(/* false */0, lookup_module(/* true */1, mlid, env), env);
        var match = scrape_alias(env, /* None */0, md[/* md_type */0]);
        if (match.tag === 2) {
          throw [
                $$Error$6,
                loc,
                env,
                /* Access_functor_as_structure */Block.__(25, [mlid])
              ];
        }
        break;
    case 2 : 
        check_module(lid[0]);
        check_module(lid[1]);
        throw [
              $$Error$6,
              loc,
              env,
              /* Ill_typed_functor_application */Block.__(24, [lid])
            ];
    
  }
  throw [
        $$Error$6,
        loc,
        env,
        Curry._1(make_error, lid)
      ];
}

function find_component(lookup, make_error, env, loc, lid) {
  try {
    switch (lid.tag | 0) {
      case 1 : 
          var match = lid[0];
          switch (match.tag | 0) {
            case 0 : 
                if (match[0] === "*predef*") {
                  return Curry._2(lookup, /* Lident */Block.__(0, [lid[1]]), initial_safe_string);
                } else {
                  return Curry._2(lookup, lid, env);
                }
                break;
            case 1 : 
            case 2 : 
                return Curry._2(lookup, lid, env);
            
          }
          break;
      case 0 : 
      case 2 : 
          return Curry._2(lookup, lid, env);
      
    }
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return narrow_unbound_lid_error(env, loc, lid, make_error);
    } else if (exn === Recmodule) {
      throw [
            $$Error$6,
            loc,
            env,
            /* Illegal_reference_to_recursive_module */1
          ];
    } else {
      throw exn;
    }
  }
}

function find_type(env, loc, lid) {
  var r = find_component(lookup_type$1, (function (lid) {
          return /* Unbound_type_constructor */Block.__(1, [lid]);
        }), env, loc, lid);
  check_deprecated(loc, r[1][/* type_attributes */8], name(/* None */0, r[0]));
  return r;
}

function find_constructor(param, param$1, param$2) {
  return find_component(lookup_constructor, (function (lid) {
                return /* Unbound_constructor */Block.__(18, [lid]);
              }), param, param$1, param$2);
}

function find_all_constructors(param, param$1, param$2) {
  return find_component(lookup_all_constructors$1, (function (lid) {
                return /* Unbound_constructor */Block.__(18, [lid]);
              }), param, param$1, param$2);
}

function find_all_labels(param, param$1, param$2) {
  return find_component(lookup_all_labels$1, (function (lid) {
                return /* Unbound_label */Block.__(19, [lid]);
              }), param, param$1, param$2);
}

function find_class$1(env, loc, lid) {
  var r = find_component(lookup_class$1, (function (lid) {
          return /* Unbound_class */Block.__(21, [lid]);
        }), env, loc, lid);
  check_deprecated(loc, r[1][/* cty_attributes */6], name(/* None */0, r[0]));
  return r;
}

function find_value$1(env, loc, lid) {
  check_value_name(last$1(lid), loc);
  var r = find_component(lookup_value$1, (function (lid) {
          return /* Unbound_value */Block.__(17, [lid]);
        }), env, loc, lid);
  check_deprecated(loc, r[1][/* val_attributes */3], name(/* None */0, r[0]));
  return r;
}

function lookup_module$1($staropt$star, env, loc, lid) {
  var load = $staropt$star ? $staropt$star[0] : /* false */0;
  return find_component((function (lid, env) {
                  return /* tuple */[
                          lookup_module(load, lid, env),
                          /* () */0
                        ];
                }), (function (lid) {
                  return /* Unbound_module */Block.__(20, [lid]);
                }), env, loc, lid)[0];
}

function find_module$1(env, loc, lid) {
  var path = lookup_module$1(/* Some */[/* true */1], env, loc, lid);
  var decl = find_module(/* false */0, path, env);
  check_deprecated(loc, decl[/* md_attributes */1], name(/* None */0, path));
  return /* tuple */[
          path,
          decl
        ];
}

function find_modtype$1(env, loc, lid) {
  var r = find_component(lookup_modtype, (function (lid) {
          return /* Unbound_modtype */Block.__(22, [lid]);
        }), env, loc, lid);
  check_deprecated(loc, r[1][/* mtd_attributes */1], name(/* None */0, r[0]));
  return r;
}

function find_class_type(env, loc, lid) {
  var r = find_component(lookup_cltype$1, (function (lid) {
          return /* Unbound_cltype */Block.__(23, [lid]);
        }), env, loc, lid);
  check_deprecated(loc, r[1][/* clty_attributes */5], name(/* None */0, r[0]));
  return r;
}

function unbound_constructor_error(env, lid) {
  return narrow_unbound_lid_error(env, lid[/* loc */1], lid[/* txt */0], (function (lid) {
                return /* Unbound_constructor */Block.__(18, [lid]);
              }));
}

function unbound_label_error(env, lid) {
  return narrow_unbound_lid_error(env, lid[/* loc */1], lid[/* txt */0], (function (lid) {
                return /* Unbound_label */Block.__(19, [lid]);
              }));
}

var transl_modtype_longident = [(function () {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "typetexp.ml",
              293,
              45
            ]
          ];
    })];

var transl_modtype = [(function () {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "typetexp.ml",
              294,
              35
            ]
          ];
    })];

function create_package_mty(fake, loc, env, param) {
  var l = List.sort((function (param, param$1) {
          var s2 = param$1[0];
          var s1 = param[0];
          if (Caml_obj.caml_equal(s1[/* txt */0], s2[/* txt */0])) {
            throw [
                  $$Error$6,
                  loc,
                  env,
                  /* Multiple_constraints_on_type */Block.__(15, [s1[/* txt */0]])
                ];
          }
          return Caml_obj.caml_compare(s1[/* txt */0], s2[/* txt */0]);
        }), param[1]);
  return /* tuple */[
          l,
          List.fold_left((function (mty, param) {
                  var s = param[0];
                  var d_000 = /* ptype_name : record */[
                    /* txt */last$1(s[/* txt */0]),
                    /* loc */s[/* loc */1]
                  ];
                  var d_005 = /* ptype_manifest */fake ? /* None */0 : /* Some */[param[1]];
                  var d = /* record */[
                    d_000,
                    /* ptype_params : [] */0,
                    /* ptype_cstrs : [] */0,
                    /* ptype_kind : Ptype_abstract */0,
                    /* ptype_private : Public */1,
                    d_005,
                    /* ptype_attributes : [] */0,
                    /* ptype_loc */loc
                  ];
                  return mk$3(/* Some */[loc], /* None */0, /* Pmty_with */Block.__(3, [
                                mty,
                                /* :: */[
                                  /* Pwith_type */Block.__(0, [
                                      /* record */[
                                        /* txt */s[/* txt */0],
                                        /* loc */loc
                                      ],
                                      d
                                    ]),
                                  /* [] */0
                                ]
                              ]));
                }), mk$3(/* Some */[loc], /* None */0, /* Pmty_ident */Block.__(0, [param[0]])), l)
        ];
}

var type_variables = [/* Empty */0];

var univars = [/* [] */0];

var pre_univars = [/* [] */0];

var used_variables = [/* Empty */0];

function reset_type_variables() {
  reset_global_level(/* () */0);
  type_variables[0] = /* Empty */0;
  return /* () */0;
}

function narrow() {
  return /* tuple */[
          increase_global_level(/* () */0),
          type_variables[0]
        ];
}

function widen(param) {
  global_level[0] = param[0];
  type_variables[0] = param[1];
  return /* () */0;
}

function strict_lowercase(c) {
  if (c === /* "_" */95) {
    return /* true */1;
  } else if (c >= /* "a" */97) {
    return +(c <= /* "z" */122);
  } else {
    return /* false */0;
  }
}

function validate_name(s) {
  if (s) {
    var name = s[0];
    if (name !== "" && strict_lowercase(Caml_string.get(name, 0))) {
      return s;
    } else {
      return /* None */0;
    }
  } else {
    return /* None */0;
  }
}

function new_global_var(name, _) {
  var name$1 = validate_name(name);
  return newty2(global_level[0], /* Tvar */Block.__(0, [name$1]));
}

function newvar$1(name, _) {
  return newvar(validate_name(name), /* () */0);
}

function transl_type_param(env, styp) {
  var loc = styp[/* ptyp_loc */1];
  var match = styp[/* ptyp_desc */0];
  if (typeof match === "number") {
    if (match) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "typetexp.ml",
              379,
              9
            ]
          ];
    } else {
      var ty = new_global_var(/* Some */["_"], /* () */0);
      return /* record */[
              /* ctyp_desc : Ttyp_any */0,
              /* ctyp_type */ty,
              /* ctyp_env */env,
              /* ctyp_loc */loc,
              /* ctyp_attributes */styp[/* ptyp_attributes */2]
            ];
    }
  } else if (match.tag) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "typetexp.ml",
            379,
            9
          ]
        ];
  } else {
    var name = match[0];
    var ty$1;
    try {
      if (name !== "" && Caml_string.get(name, 0) === /* "_" */95) {
        throw [
              $$Error$6,
              loc,
              empty,
              /* Invalid_variable_name */Block.__(13, ["'" + name])
            ];
      }
      find$2(name, type_variables[0]);
      throw Already_bound;
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        var v = new_global_var(/* Some */[name], /* () */0);
        type_variables[0] = add$5(name, v, type_variables[0]);
        ty$1 = v;
      } else {
        throw exn;
      }
    }
    return /* record */[
            /* ctyp_desc : Ttyp_var */Block.__(0, [name]),
            /* ctyp_type */ty$1,
            /* ctyp_env */env,
            /* ctyp_loc */loc,
            /* ctyp_attributes */styp[/* ptyp_attributes */2]
          ];
  }
}

function new_pre_univar(name, _) {
  var v = newvar$1(name, /* () */0);
  pre_univars[0] = /* :: */[
    v,
    pre_univars[0]
  ];
  return v;
}

function swap_list(l) {
  if (l) {
    var match = l[1];
    if (match) {
      return /* :: */[
              match[0],
              /* :: */[
                l[0],
                swap_list(match[1])
              ]
            ];
    } else {
      return l;
    }
  } else {
    return l;
  }
}

function transl_type(env, policy, styp) {
  var loc = styp[/* ptyp_loc */1];
  var ctyp = function (ctyp_desc, ctyp_type) {
    return /* record */[
            /* ctyp_desc */ctyp_desc,
            /* ctyp_type */ctyp_type,
            /* ctyp_env */env,
            /* ctyp_loc */loc,
            /* ctyp_attributes */styp[/* ptyp_attributes */2]
          ];
  };
  var match = styp[/* ptyp_desc */0];
  if (typeof match === "number") {
    var ty;
    if (policy === /* Univars */2) {
      ty = new_pre_univar(/* None */0, /* () */0);
    } else if (policy) {
      ty = newvar$1(/* None */0, /* () */0);
    } else {
      throw [
            $$Error$6,
            styp[/* ptyp_loc */1],
            env,
            /* Unbound_type_variable */Block.__(0, ["_"])
          ];
    }
    return ctyp(/* Ttyp_any */0, ty);
  } else {
    switch (match.tag | 0) {
      case 0 : 
          var name = match[0];
          if (name !== "" && Caml_string.get(name, 0) === /* "_" */95) {
            throw [
                  $$Error$6,
                  styp[/* ptyp_loc */1],
                  env,
                  /* Invalid_variable_name */Block.__(13, ["'" + name])
                ];
          }
          var ty$1;
          try {
            ty$1 = instance(/* None */0, env, List.assoc(name, univars[0]));
          }
          catch (exn){
            if (exn === Caml_builtin_exceptions.not_found) {
              try {
                ty$1 = instance(/* None */0, env, find$2(name, used_variables[0])[0]);
              }
              catch (exn$1){
                if (exn$1 === Caml_builtin_exceptions.not_found) {
                  var v = policy === /* Univars */2 ? new_pre_univar(/* Some */[name], /* () */0) : newvar$1(/* Some */[name], /* () */0);
                  used_variables[0] = add$5(name, /* tuple */[
                        v,
                        styp[/* ptyp_loc */1]
                      ], used_variables[0]);
                  ty$1 = v;
                } else {
                  throw exn$1;
                }
              }
            } else {
              throw exn;
            }
          }
          return ctyp(/* Ttyp_var */Block.__(0, [name]), ty$1);
      case 1 : 
          var l = match[0];
          var cty1 = transl_type(env, policy, match[1]);
          var cty2 = transl_type(env, policy, match[2]);
          var ty$2 = newty2(current_level[0], /* Tarrow */Block.__(1, [
                  l,
                  cty1[/* ctyp_type */1],
                  cty2[/* ctyp_type */1],
                  /* Cok */0
                ]));
          return ctyp(/* Ttyp_arrow */Block.__(1, [
                        l,
                        cty1,
                        cty2
                      ]), ty$2);
      case 2 : 
          var stl = match[0];
          if (List.length(stl) < 2) {
            ill_formed_ast(loc, "Tuples must have at least 2 components.");
          }
          var ctys = List.map((function (param) {
                  return transl_type(env, policy, param);
                }), stl);
          var desc = /* Ttuple */Block.__(2, [List.map((function (ctyp) {
                      return ctyp[/* ctyp_type */1];
                    }), ctys)]);
          var ty$3 = newty2(current_level[0], desc);
          return ctyp(/* Ttyp_tuple */Block.__(2, [ctys]), ty$3);
      case 3 : 
          var stl$1 = match[1];
          var lid = match[0];
          var match$1 = find_type(env, styp[/* ptyp_loc */1], lid[/* txt */0]);
          var decl = match$1[1];
          var path = match$1[0];
          var stl$2;
          if (stl$1) {
            var t = stl$1[0];
            stl$2 = typeof t[/* ptyp_desc */0] === "number" && !(stl$1[1] || decl[/* type_arity */1] <= 1) ? List.map((function () {
                      return t;
                    }), decl[/* type_params */0]) : stl$1;
          } else {
            stl$2 = stl$1;
          }
          if (List.length(stl$2) !== decl[/* type_arity */1]) {
            throw [
                  $$Error$6,
                  styp[/* ptyp_loc */1],
                  env,
                  /* Type_arity_mismatch */Block.__(3, [
                      lid[/* txt */0],
                      decl[/* type_arity */1],
                      List.length(stl$2)
                    ])
                ];
          }
          var args = List.map((function (param) {
                  return transl_type(env, policy, param);
                }), stl$2);
          var params = instance_list(empty, decl[/* type_params */0]);
          var match$2 = decl[/* type_manifest */4];
          var unify_param = match$2 && repr(match$2[0])[/* level */1] !== 100000000 ? unify$2 : unify_var;
          List.iter2((function (param, ty$prime) {
                  try {
                    return Curry._3(unify_param, env, ty$prime, param[1][/* ctyp_type */1]);
                  }
                  catch (raw_exn){
                    var exn = Js_exn.internalToOCamlException(raw_exn);
                    if (exn[0] === Unify) {
                      throw [
                            $$Error$6,
                            param[0][/* ptyp_loc */1],
                            env,
                            /* Type_mismatch */Block.__(6, [swap_list(exn[1])])
                          ];
                    } else {
                      throw exn;
                    }
                  }
                }), List.combine(stl$2, args), params);
          var constr = newconstr(path, List.map((function (ctyp) {
                      return ctyp[/* ctyp_type */1];
                    }), args));
          try {
            enforce_constraints(env, constr);
          }
          catch (raw_exn){
            var exn$2 = Js_exn.internalToOCamlException(raw_exn);
            if (exn$2[0] === Unify) {
              throw [
                    $$Error$6,
                    styp[/* ptyp_loc */1],
                    env,
                    /* Type_mismatch */Block.__(6, [exn$2[1]])
                  ];
            } else {
              throw exn$2;
            }
          }
          return ctyp(/* Ttyp_constr */Block.__(3, [
                        path,
                        lid,
                        args
                      ]), constr);
      case 4 : 
          var o = match[1];
          var fields = List.map((function (param) {
                  return /* tuple */[
                          param[0],
                          param[1],
                          transl_poly_type(env, policy, param[2])
                        ];
                }), match[0]);
          var ty$4 = newobj(transl_fields(loc, env, policy, /* [] */0, o, fields));
          return ctyp(/* Ttyp_object */Block.__(4, [
                        fields,
                        o
                      ]), ty$4);
      case 5 : 
          var stl$3 = match[1];
          var lid$1 = match[0];
          var match$3;
          try {
            var match$4 = lookup_type$1(lid$1[/* txt */0], env);
            var decl$1 = match$4[1];
            var check = function (_decl) {
              while(true) {
                var decl = _decl;
                var match = decl[/* type_manifest */4];
                if (match) {
                  var match$1 = repr(match[0])[/* desc */0];
                  if (typeof match$1 === "number") {
                    throw Caml_builtin_exceptions.not_found;
                  } else {
                    switch (match$1.tag | 0) {
                      case 3 : 
                          _decl = find_type_full(match$1[0], env)[0];
                          continue ;
                          case 8 : 
                          if (static_row(match$1[0])) {
                            return /* () */0;
                          } else {
                            throw Caml_builtin_exceptions.not_found;
                          }
                          break;
                      default:
                        throw Caml_builtin_exceptions.not_found;
                    }
                  }
                } else {
                  throw Caml_builtin_exceptions.not_found;
                }
              };
            };
            check(decl$1);
            prerr_warning(styp[/* ptyp_loc */1], /* Deprecated */Block.__(0, ["old syntax for polymorphic variant type"]));
            match$3 = /* tuple */[
              match$4[0],
              decl$1,
              /* true */1
            ];
          }
          catch (exn$3){
            if (exn$3 === Caml_builtin_exceptions.not_found) {
              try {
                var match$5 = lid$1[/* txt */0];
                var lid2;
                switch (match$5.tag | 0) {
                  case 0 : 
                      lid2 = /* Lident */Block.__(0, ["#" + match$5[0]]);
                      break;
                  case 1 : 
                      lid2 = /* Ldot */Block.__(1, [
                          match$5[0],
                          "#" + match$5[1]
                        ]);
                      break;
                  case 2 : 
                      lid2 = fatal_error("Typetexp.transl_type");
                      break;
                  
                }
                var match$6 = lookup_type$1(lid2, env);
                match$3 = /* tuple */[
                  match$6[0],
                  match$6[1],
                  /* false */0
                ];
              }
              catch (exn$4){
                if (exn$4 === Caml_builtin_exceptions.not_found) {
                  find_class$1(env, styp[/* ptyp_loc */1], lid$1[/* txt */0]);
                  throw [
                        Caml_builtin_exceptions.assert_failure,
                        [
                          "typetexp.ml",
                          505,
                          57
                        ]
                      ];
                } else {
                  throw exn$4;
                }
              }
            } else {
              throw exn$3;
            }
          }
          var decl$2 = match$3[1];
          var path$1 = match$3[0];
          if (List.length(stl$3) !== decl$2[/* type_arity */1]) {
            throw [
                  $$Error$6,
                  styp[/* ptyp_loc */1],
                  env,
                  /* Type_arity_mismatch */Block.__(3, [
                      lid$1[/* txt */0],
                      decl$2[/* type_arity */1],
                      List.length(stl$3)
                    ])
                ];
          }
          var args$1 = List.map((function (param) {
                  return transl_type(env, policy, param);
                }), stl$3);
          var params$1 = instance_list(empty, decl$2[/* type_params */0]);
          List.iter2((function (param, ty$prime) {
                  try {
                    return unify_var(env, ty$prime, param[1][/* ctyp_type */1]);
                  }
                  catch (raw_exn){
                    var exn = Js_exn.internalToOCamlException(raw_exn);
                    if (exn[0] === Unify) {
                      throw [
                            $$Error$6,
                            param[0][/* ptyp_loc */1],
                            env,
                            /* Type_mismatch */Block.__(6, [swap_list(exn[1])])
                          ];
                    } else {
                      throw exn;
                    }
                  }
                }), List.combine(stl$3, args$1), params$1);
          var ty_args = List.map((function (ctyp) {
                  return ctyp[/* ctyp_type */1];
                }), args$1);
          var ty$5;
          try {
            ty$5 = expand_head(env, newconstr(path$1, ty_args));
          }
          catch (raw_exn$1){
            var exn$5 = Js_exn.internalToOCamlException(raw_exn$1);
            if (exn$5[0] === Unify) {
              throw [
                    $$Error$6,
                    styp[/* ptyp_loc */1],
                    env,
                    /* Type_mismatch */Block.__(6, [exn$5[1]])
                  ];
            } else {
              throw exn$5;
            }
          }
          var match$7 = ty$5[/* desc */0];
          var ty$6;
          if (typeof match$7 === "number") {
            throw [
                  Caml_builtin_exceptions.assert_failure,
                  [
                    "typetexp.ml",
                    553,
                    10
                  ]
                ];
          } else {
            switch (match$7.tag | 0) {
              case 4 : 
                  var match$8 = flatten_fields(match$7[0]);
                  if (policy === /* Univars */2) {
                    pre_univars[0] = /* :: */[
                      match$8[1],
                      pre_univars[0]
                    ];
                  }
                  ty$6 = ty$5;
                  break;
              case 8 : 
                  var row = row_repr_aux(/* [] */0, match$7[0]);
                  var fields$1 = List.map((function (param) {
                          var f = param[1];
                          var match = row_field_repr_aux(/* [] */0, f);
                          var $js;
                          if (typeof match === "number") {
                            $js = f;
                          } else if (match.tag) {
                            $js = f;
                          } else {
                            var match$1 = match[0];
                            $js = match$1 ? /* Reither */Block.__(1, [
                                  /* false */0,
                                  /* :: */[
                                    match$1[0],
                                    /* [] */0
                                  ],
                                  /* false */0,
                                  [/* None */0]
                                ]) : /* Reither */Block.__(1, [
                                  /* true */1,
                                  /* [] */0,
                                  /* false */0,
                                  [/* None */0]
                                ]);
                          }
                          return /* tuple */[
                                  param[0],
                                  $js
                                ];
                        }), row[/* row_fields */0]);
                  var row_001 = /* row_more */newvar$1(/* None */0, /* () */0);
                  var row_005 = /* row_name : Some */[/* tuple */[
                      path$1,
                      ty_args
                    ]];
                  var row$1 = /* record */[
                    /* row_fields */fields$1,
                    row_001,
                    /* row_bound : () */0,
                    /* row_closed : true */1,
                    /* row_fixed : false */0,
                    row_005
                  ];
                  var $$static = static_row(row$1);
                  var row$2;
                  if ($$static) {
                    var newrecord = row$1.slice();
                    newrecord[/* row_more */1] = newty2(current_level[0], /* Tnil */0);
                    row$2 = newrecord;
                  } else if (policy !== /* Univars */2) {
                    row$2 = row$1;
                  } else {
                    var newrecord$1 = row$1.slice();
                    newrecord$1[/* row_more */1] = new_pre_univar(/* None */0, /* () */0);
                    row$2 = newrecord$1;
                  }
                  ty$6 = newty2(current_level[0], /* Tvariant */Block.__(8, [row$2]));
                  break;
              default:
                throw [
                      Caml_builtin_exceptions.assert_failure,
                      [
                        "typetexp.ml",
                        553,
                        10
                      ]
                    ];
            }
          }
          return ctyp(/* Ttyp_class */Block.__(5, [
                        path$1,
                        lid$1,
                        args$1
                      ]), ty$6);
      case 6 : 
          var alias = match[1];
          var st = match[0];
          var cty;
          try {
            var t$1;
            try {
              t$1 = List.assoc(alias, univars[0]);
            }
            catch (exn$6){
              if (exn$6 === Caml_builtin_exceptions.not_found) {
                t$1 = instance(/* None */0, env, find$2(alias, used_variables[0])[0]);
              } else {
                throw exn$6;
              }
            }
            var ty$7 = transl_type(env, policy, st);
            try {
              unify_var(env, t$1, ty$7[/* ctyp_type */1]);
            }
            catch (raw_exn$2){
              var exn$7 = Js_exn.internalToOCamlException(raw_exn$2);
              if (exn$7[0] === Unify) {
                var trace = swap_list(exn$7[1]);
                throw [
                      $$Error$6,
                      styp[/* ptyp_loc */1],
                      env,
                      /* Alias_type_mismatch */Block.__(7, [trace])
                    ];
              } else {
                throw exn$7;
              }
            }
            cty = ty$7;
          }
          catch (exn$8){
            if (exn$8 === Caml_builtin_exceptions.not_found) {
              if (principal[0]) {
                begin_def(/* () */0);
              }
              var t$2 = newvar$1(/* None */0, /* () */0);
              used_variables[0] = add$5(alias, /* tuple */[
                    t$2,
                    styp[/* ptyp_loc */1]
                  ], used_variables[0]);
              var ty$8 = transl_type(env, policy, st);
              try {
                unify_var(env, t$2, ty$8[/* ctyp_type */1]);
              }
              catch (raw_exn$3){
                var exn$9 = Js_exn.internalToOCamlException(raw_exn$3);
                if (exn$9[0] === Unify) {
                  var trace$1 = swap_list(exn$9[1]);
                  throw [
                        $$Error$6,
                        styp[/* ptyp_loc */1],
                        env,
                        /* Alias_type_mismatch */Block.__(7, [trace$1])
                      ];
                } else {
                  throw exn$9;
                }
              }
              if (principal[0]) {
                end_def(/* () */0);
                generalize_structure$1(current_level[0], t$2);
              }
              var t$3 = instance(/* None */0, env, t$2);
              var px = proxy(t$3);
              var match$9 = px[/* desc */0];
              if (typeof match$9 !== "number") {
                switch (match$9.tag | 0) {
                  case 0 : 
                      if (!match$9[0]) {
                        log_type(px);
                        px[/* desc */0] = /* Tvar */Block.__(0, [/* Some */[alias]]);
                      }
                      break;
                  case 9 : 
                      if (!match$9[0]) {
                        log_type(px);
                        px[/* desc */0] = /* Tunivar */Block.__(9, [/* Some */[alias]]);
                      }
                      break;
                  default:
                    
                }
              }
              cty = /* record */[
                /* ctyp_desc */ty$8[/* ctyp_desc */0],
                /* ctyp_type */t$3,
                /* ctyp_env */ty$8[/* ctyp_env */2],
                /* ctyp_loc */ty$8[/* ctyp_loc */3],
                /* ctyp_attributes */ty$8[/* ctyp_attributes */4]
              ];
            } else {
              throw exn$8;
            }
          }
          return ctyp(/* Ttyp_alias */Block.__(6, [
                        cty,
                        alias
                      ]), cty[/* ctyp_type */1]);
      case 7 : 
          var present = match[2];
          var closed = match[1];
          var name$1 = [/* None */0];
          var mkfield = function (l, f) {
            var desc = /* Tvariant */Block.__(8, [/* record */[
                  /* row_fields : :: */[
                    /* tuple */[
                      l,
                      f
                    ],
                    /* [] */0
                  ],
                  /* row_more */newvar$1(/* None */0, /* () */0),
                  /* row_bound : () */0,
                  /* row_closed : true */1,
                  /* row_fixed : false */0,
                  /* row_name : None */0
                ]]);
            return newty2(current_level[0], desc);
          };
          var hfields = Hashtbl.create(/* None */0, 17);
          var add_typed_field = function (loc, l, f) {
            var h = hash_variant(l);
            try {
              var match = Hashtbl.find(hfields, h);
              var l$prime = match[0];
              if (l !== l$prime) {
                throw [
                      $$Error$6,
                      styp[/* ptyp_loc */1],
                      env,
                      /* Variant_tags */Block.__(12, [
                          l,
                          l$prime
                        ])
                    ];
              }
              var ty = mkfield(l, f);
              var ty$prime = mkfield(l, match[1]);
              if (equal$4(env, /* false */0, /* :: */[
                      ty,
                      /* [] */0
                    ], /* :: */[
                      ty$prime,
                      /* [] */0
                    ])) {
                return /* () */0;
              } else {
                try {
                  return unify$2(env, ty, ty$prime);
                }
                catch (raw_exn){
                  var exn = Js_exn.internalToOCamlException(raw_exn);
                  if (exn[0] === Unify) {
                    throw [
                          $$Error$6,
                          loc,
                          env,
                          /* Constructor_mismatch */Block.__(10, [
                              ty,
                              ty$prime
                            ])
                        ];
                  } else {
                    throw exn;
                  }
                }
              }
            }
            catch (exn$1){
              if (exn$1 === Caml_builtin_exceptions.not_found) {
                return Hashtbl.add(hfields, h, /* tuple */[
                            l,
                            f
                          ]);
              } else {
                throw exn$1;
              }
            }
          };
          var add_field = function (param) {
            if (param.tag) {
              var sty = param[0];
              var cty = transl_type(env, policy, sty);
              var ty = cty[/* ctyp_type */1];
              var match = repr(cty[/* ctyp_type */1]);
              var match$1 = match[/* desc */0];
              var nm;
              nm = typeof match$1 === "number" || match$1.tag !== 3 ? /* None */0 : /* Some */[/* tuple */[
                    match$1[0],
                    match$1[1]
                  ]];
              try {
                Hashtbl.iter((function (_, _$1) {
                        throw Pervasives.Exit;
                      }), hfields);
                name$1[0] = nm;
              }
              catch (exn){
                if (exn === Pervasives.Exit) {
                  name$1[0] = /* None */0;
                } else {
                  throw exn;
                }
              }
              var match$2 = expand_head(env, cty[/* ctyp_type */1]);
              var match$3 = match$2[/* desc */0];
              var fl;
              var exit = 0;
              if (typeof match$3 === "number") {
                exit = 1;
              } else {
                switch (match$3.tag | 0) {
                  case 0 : 
                      if (nm) {
                        throw [
                              $$Error$6,
                              sty[/* ptyp_loc */1],
                              env,
                              /* Unbound_type_constructor_2 */Block.__(2, [nm[0][0]])
                            ];
                      } else {
                        exit = 1;
                      }
                      break;
                  case 8 : 
                      var row = match$3[0];
                      if (static_row(row)) {
                        fl = row_repr_aux(/* [] */0, row)[/* row_fields */0];
                      } else {
                        exit = 1;
                      }
                      break;
                  default:
                    exit = 1;
                }
              }
              if (exit === 1) {
                throw [
                      $$Error$6,
                      sty[/* ptyp_loc */1],
                      env,
                      /* Not_a_variant */Block.__(11, [ty])
                    ];
              }
              List.iter((function (param) {
                      var f = param[1];
                      var l = param[0];
                      var f$1;
                      if (present) {
                        if (List.mem(l, present[0])) {
                          f$1 = f;
                        } else if (typeof f === "number") {
                          throw [
                                Caml_builtin_exceptions.assert_failure,
                                [
                                  "typetexp.ml",
                                  666,
                                  24
                                ]
                              ];
                        } else if (f.tag) {
                          throw [
                                Caml_builtin_exceptions.assert_failure,
                                [
                                  "typetexp.ml",
                                  666,
                                  24
                                ]
                              ];
                        } else {
                          var match = f[0];
                          f$1 = match ? /* Reither */Block.__(1, [
                                /* false */0,
                                /* :: */[
                                  match[0],
                                  /* [] */0
                                ],
                                /* false */0,
                                [/* None */0]
                              ]) : /* Reither */Block.__(1, [
                                /* true */1,
                                /* [] */0,
                                /* false */0,
                                [/* None */0]
                              ]);
                        }
                      } else {
                        f$1 = f;
                      }
                      return add_typed_field(sty[/* ptyp_loc */1], l, f$1);
                    }), fl);
              return /* Tinherit */Block.__(1, [cty]);
            } else {
              var stl = param[3];
              var c = param[2];
              var l = param[0];
              name$1[0] = /* None */0;
              var tl = List.map((function (param) {
                      return transl_type(env, policy, param);
                    }), stl);
              var f;
              var exit$1 = 0;
              if (present) {
                if (List.mem(l, present[0])) {
                  exit$1 = 1;
                } else {
                  var ty_tl = List.map((function (cty) {
                          return cty[/* ctyp_type */1];
                        }), tl);
                  f = /* Reither */Block.__(1, [
                      c,
                      ty_tl,
                      /* false */0,
                      [/* None */0]
                    ]);
                }
              } else {
                exit$1 = 1;
              }
              if (exit$1 === 1) {
                if (List.length(stl) > 1 || c && stl !== /* [] */0) {
                  throw [
                        $$Error$6,
                        styp[/* ptyp_loc */1],
                        env,
                        /* Present_has_conjunction */Block.__(8, [l])
                      ];
                }
                f = tl ? /* Rpresent */Block.__(0, [/* Some */[tl[0][/* ctyp_type */1]]]) : /* Rpresent */Block.__(0, [/* None */0]);
              }
              add_typed_field(styp[/* ptyp_loc */1], l, f);
              return /* Ttag */Block.__(0, [
                        l,
                        param[1],
                        c,
                        tl
                      ]);
            }
          };
          var tfields = List.map(add_field, match[0]);
          var fields$2 = Hashtbl.fold((function (_, p, l) {
                  return /* :: */[
                          p,
                          l
                        ];
                }), hfields, /* [] */0);
          if (present) {
            List.iter((function (l) {
                    if (List.mem_assoc(l, fields$2)) {
                      return 0;
                    } else {
                      throw [
                            $$Error$6,
                            styp[/* ptyp_loc */1],
                            env,
                            /* Present_has_no_type */Block.__(9, [l])
                          ];
                    }
                  }), present[0]);
          }
          var row_000 = /* row_fields */List.rev(fields$2);
          var row_001$1 = /* row_more */newvar$1(/* None */0, /* () */0);
          var row_003 = /* row_closed */+(closed === /* Closed */0);
          var row_005$1 = /* row_name */name$1[0];
          var row$3 = /* record */[
            row_000,
            row_001$1,
            /* row_bound : () */0,
            row_003,
            /* row_fixed : false */0,
            row_005$1
          ];
          var $$static$1 = static_row(row$3);
          var row$4;
          if ($$static$1) {
            var newrecord$2 = row$3.slice();
            newrecord$2[/* row_more */1] = newty2(current_level[0], /* Tnil */0);
            row$4 = newrecord$2;
          } else if (policy !== /* Univars */2) {
            row$4 = row$3;
          } else {
            var newrecord$3 = row$3.slice();
            newrecord$3[/* row_more */1] = new_pre_univar(/* None */0, /* () */0);
            row$4 = newrecord$3;
          }
          var ty$9 = newty2(current_level[0], /* Tvariant */Block.__(8, [row$4]));
          return ctyp(/* Ttyp_variant */Block.__(7, [
                        tfields,
                        closed,
                        present
                      ]), ty$9);
      case 8 : 
          var vars = match[0];
          begin_def(/* () */0);
          var new_univars = List.map((function (name) {
                  return /* tuple */[
                          name,
                          newvar$1(/* Some */[name], /* () */0)
                        ];
                }), vars);
          var old_univars = univars[0];
          univars[0] = Pervasives.$at(new_univars, univars[0]);
          var cty$1 = transl_type(env, policy, match[1]);
          var ty$10 = cty$1[/* ctyp_type */1];
          univars[0] = old_univars;
          end_def(/* () */0);
          iter_generalize$1([/* [] */0], ty$10);
          var ty_list = List.fold_left((function (tyl, param) {
                  var v = proxy(param[1]);
                  if (deep_occur(v, ty$10)) {
                    var match = v[/* desc */0];
                    var exit = 0;
                    if (typeof match === "number") {
                      exit = 1;
                    } else if (match.tag) {
                      exit = 1;
                    } else if (v[/* level */1] === 100000000) {
                      v[/* desc */0] = /* Tunivar */Block.__(9, [match[0]]);
                      return /* :: */[
                              v,
                              tyl
                            ];
                    } else {
                      exit = 1;
                    }
                    if (exit === 1) {
                      throw [
                            $$Error$6,
                            styp[/* ptyp_loc */1],
                            env,
                            /* Cannot_quantify */Block.__(14, [
                                param[0],
                                v
                              ])
                          ];
                    }
                    
                  } else {
                    return tyl;
                  }
                }), /* [] */0, new_univars);
          var ty$prime = newty2(100000000, /* Tpoly */Block.__(10, [
                  ty$10,
                  List.rev(ty_list)
                ]));
          unify_var(env, newvar$1(/* None */0, /* () */0), ty$prime);
          return ctyp(/* Ttyp_poly */Block.__(8, [
                        vars,
                        cty$1
                      ]), ty$prime);
      case 9 : 
          var match$10 = match[0];
          var p = match$10[0];
          var match$11 = create_package_mty(/* true */1, styp[/* ptyp_loc */1], env, /* tuple */[
                p,
                match$10[1]
              ]);
          var l$1 = match$11[0];
          var z = narrow(/* () */0);
          var mty = Curry._2(transl_modtype[0], env, match$11[1]);
          widen(z);
          var ptys = List.map((function (param) {
                  return /* tuple */[
                          param[0],
                          transl_type(env, policy, param[1])
                        ];
                }), l$1);
          var path$2 = Curry._3(transl_modtype_longident[0], styp[/* ptyp_loc */1], env, p[/* txt */0]);
          var desc_001 = List.map((function (param) {
                  return param[0][/* txt */0];
                }), l$1);
          var desc_002 = List.map((function (param) {
                  return param[1][/* ctyp_type */1];
                }), ptys);
          var desc$1 = /* Tpackage */Block.__(11, [
              path$2,
              desc_001,
              desc_002
            ]);
          var ty$11 = newty2(current_level[0], desc$1);
          return ctyp(/* Ttyp_package */Block.__(9, [/* record */[
                          /* pack_path */path$2,
                          /* pack_fields */ptys,
                          /* pack_type */mty[/* mty_type */1],
                          /* pack_txt */p
                        ]]), ty$11);
      case 10 : 
          throw [
                Error_forward,
                error_of_extension(match[0])
              ];
      
    }
  }
}

function transl_poly_type(env, policy, t) {
  return transl_type(env, policy, force_poly(t));
}

function transl_fields(loc, env, policy, seen, o, param) {
  if (param) {
    var match = param[0];
    var s = match[0];
    if (List.mem(s, seen)) {
      throw [
            $$Error$6,
            loc,
            env,
            /* Repeated_method_label */Block.__(16, [s])
          ];
    }
    var ty2 = transl_fields(loc, env, policy, /* :: */[
          s,
          seen
        ], o, param[1]);
    return newty2(current_level[0], /* Tfield */Block.__(5, [
                  s,
                  /* Fpresent */0,
                  match[2][/* ctyp_type */1],
                  ty2
                ]));
  } else if (o !== 0) {
    if (policy >= 2) {
      return new_pre_univar(/* None */0, /* () */0);
    } else {
      return newvar$1(/* None */0, /* () */0);
    }
  } else {
    return newty2(current_level[0], /* Tnil */0);
  }
}

function make_fixed_univars(ty) {
  var ty$1 = repr(ty);
  if (ty$1[/* level */1] >= 0) {
    mark_type_node(ty$1);
    var match = ty$1[/* desc */0];
    if (typeof match === "number") {
      return iter_type_expr(make_fixed_univars, ty$1);
    } else if (match.tag === 8) {
      var row = row_repr_aux(/* [] */0, match[0]);
      if (is_Tunivar(row_more(row))) {
        ty$1[/* desc */0] = /* Tvariant */Block.__(8, [/* record */[
              /* row_fields */List.map((function (p) {
                      var match = row_field_repr_aux(/* [] */0, p[1]);
                      if (typeof match === "number" || !match.tag) {
                        return p;
                      } else {
                        return /* tuple */[
                                p[0],
                                /* Reither */Block.__(1, [
                                    match[0],
                                    match[1],
                                    /* true */1,
                                    match[3]
                                  ])
                              ];
                      }
                    }), row[/* row_fields */0]),
              /* row_more */row[/* row_more */1],
              /* row_bound */row[/* row_bound */2],
              /* row_closed */row[/* row_closed */3],
              /* row_fixed : true */1,
              /* row_name */row[/* row_name */5]
            ]]);
      }
      return iter_row(make_fixed_univars, row);
    } else {
      return iter_type_expr(make_fixed_univars, ty$1);
    }
  } else {
    return 0;
  }
}

function make_fixed_univars$1(ty) {
  make_fixed_univars(ty);
  return unmark_type(ty);
}

function globalize_used_variables(env, fixed) {
  var r = [/* [] */0];
  iter$2((function (name, param) {
          var loc = param[1];
          var ty = param[0];
          var v = new_global_var(/* None */0, /* () */0);
          var snap = snapshot(/* () */0);
          var $js;
          try {
            unify$2(env, v, ty);
            $js = /* true */1;
          }
          catch (exn){
            backtrack(snap);
            $js = /* false */0;
          }
          if ($js) {
            try {
              r[0] = /* :: */[
                /* tuple */[
                  loc,
                  v,
                  find$2(name, type_variables[0])
                ],
                r[0]
              ];
              return /* () */0;
            }
            catch (exn$1){
              if (exn$1 === Caml_builtin_exceptions.not_found) {
                if (fixed && is_Tvar(repr(ty))) {
                  throw [
                        $$Error$6,
                        loc,
                        env,
                        /* Unbound_type_variable */Block.__(0, ["'" + name])
                      ];
                }
                var v2 = new_global_var(/* None */0, /* () */0);
                r[0] = /* :: */[
                  /* tuple */[
                    loc,
                    v,
                    v2
                  ],
                  r[0]
                ];
                type_variables[0] = add$5(name, v2, type_variables[0]);
                return /* () */0;
              } else {
                throw exn$1;
              }
            }
          } else {
            return 0;
          }
        }), used_variables[0]);
  used_variables[0] = /* Empty */0;
  return (function () {
      return List.iter((function (param) {
                    try {
                      return unify$2(env, param[1], param[2]);
                    }
                    catch (raw_exn){
                      var exn = Js_exn.internalToOCamlException(raw_exn);
                      if (exn[0] === Unify) {
                        throw [
                              $$Error$6,
                              param[0],
                              env,
                              /* Type_mismatch */Block.__(6, [exn[1]])
                            ];
                      } else {
                        throw exn;
                      }
                    }
                  }), r[0]);
    });
}

function transl_simple_type(env, fixed, styp) {
  univars[0] = /* [] */0;
  used_variables[0] = /* Empty */0;
  var typ = transl_type(env, fixed ? /* Fixed */0 : /* Extensible */1, styp);
  globalize_used_variables(env, fixed)(/* () */0);
  make_fixed_univars$1(typ[/* ctyp_type */1]);
  return typ;
}

function transl_simple_type_univars(env, styp) {
  univars[0] = /* [] */0;
  used_variables[0] = /* Empty */0;
  pre_univars[0] = /* [] */0;
  begin_def(/* () */0);
  var typ = transl_type(env, /* Univars */2, styp);
  var new_variables = used_variables[0];
  used_variables[0] = /* Empty */0;
  iter$2((function (name, p) {
          if (mem$4(name, type_variables[0])) {
            used_variables[0] = add$5(name, p, used_variables[0]);
            return /* () */0;
          } else {
            return 0;
          }
        }), new_variables);
  globalize_used_variables(env, /* false */0)(/* () */0);
  end_def(/* () */0);
  iter_generalize$1([/* [] */0], typ[/* ctyp_type */1]);
  var univs = List.fold_left((function (acc, v) {
          var v$1 = repr(v);
          var match = v$1[/* desc */0];
          if (typeof match === "number" || !(!match.tag && v$1[/* level */1] === 100000000)) {
            return acc;
          } else {
            v$1[/* desc */0] = /* Tunivar */Block.__(9, [match[0]]);
            return /* :: */[
                    v$1,
                    acc
                  ];
          }
        }), /* [] */0, pre_univars[0]);
  make_fixed_univars$1(typ[/* ctyp_type */1]);
  return /* record */[
          /* ctyp_desc */typ[/* ctyp_desc */0],
          /* ctyp_type */instance(/* None */0, env, newty2(100000000, /* Tpoly */Block.__(10, [
                      typ[/* ctyp_type */1],
                      univs
                    ]))),
          /* ctyp_env */typ[/* ctyp_env */2],
          /* ctyp_loc */typ[/* ctyp_loc */3],
          /* ctyp_attributes */typ[/* ctyp_attributes */4]
        ];
}

function transl_simple_type_delayed(env, styp) {
  univars[0] = /* [] */0;
  used_variables[0] = /* Empty */0;
  var typ = transl_type(env, /* Extensible */1, styp);
  make_fixed_univars$1(typ[/* ctyp_type */1]);
  return /* tuple */[
          typ,
          globalize_used_variables(env, /* false */0)
        ];
}

function transl_type_scheme(env, styp) {
  reset_type_variables(/* () */0);
  begin_def(/* () */0);
  var typ = transl_simple_type(env, /* false */0, styp);
  end_def(/* () */0);
  iter_generalize$1([/* [] */0], typ[/* ctyp_type */1]);
  return typ;
}

function spellcheck(ppf, fold, env, lid) {
  var match = last$1(lid).length;
  var switcher = match - 1 | 0;
  var cutoff = switcher > 3 || switcher < 0 ? (
      switcher === 5 || switcher === 4 ? 2 : 3
    ) : (
      switcher >= 2 ? 1 : 0
    );
  var compare = function (target, head, acc) {
    var best_dist = acc[1];
    var best_choice = acc[0];
    var match = edit_distance(target, head, cutoff);
    if (match) {
      var dist = match[0];
      var choice = dist < best_dist ? /* :: */[
          head,
          /* [] */0
        ] : (
          dist === best_dist ? /* :: */[
              head,
              best_choice
            ] : best_choice
        );
      return /* tuple */[
              choice,
              Pervasives.min(dist, best_dist)
            ];
    } else {
      return /* tuple */[
              best_choice,
              best_dist
            ];
    }
  };
  var init = /* tuple */[
    /* [] */0,
    Pervasives.max_int
  ];
  var handle = function (param) {
    var match = List.rev(param[0]);
    if (match) {
      var rev_rest = match[1];
      return Curry._3(Format.fprintf(ppf, /* Format */[
                      /* Formatting_lit */Block.__(17, [
                          /* Force_newline */3,
                          /* String_literal */Block.__(11, [
                              "Hint: Did you mean ",
                              /* String */Block.__(2, [
                                  /* No_padding */0,
                                  /* String */Block.__(2, [
                                      /* No_padding */0,
                                      /* String */Block.__(2, [
                                          /* No_padding */0,
                                          /* Char_literal */Block.__(12, [
                                              /* "?" */63,
                                              /* End_of_format */0
                                            ])
                                        ])
                                    ])
                                ])
                            ])
                        ]),
                      "@\nHint: Did you mean %s%s%s?"
                    ]), $$String.concat(", ", List.rev(rev_rest)), rev_rest ? " or " : "", match[0]);
    } else {
      return /* () */0;
    }
  };
  Format.fprintf(ppf, /* Format */[
        /* Formatting_lit */Block.__(17, [
            /* FFlush */2,
            /* End_of_format */0
          ]),
        "@?"
      ]);
  switch (lid.tag | 0) {
    case 0 : 
        var s = lid[0];
        return handle(Curry._4(fold, (function (param, param$1) {
                          return compare(s, param, param$1);
                        }), /* None */0, env, init));
    case 1 : 
        var s$1 = lid[1];
        return handle(Curry._4(fold, (function (param, param$1) {
                          return compare(s$1, param, param$1);
                        }), /* Some */[lid[0]], env, init));
    case 2 : 
        return /* () */0;
    
  }
}

function spellcheck_simple(ppf, fold, extr) {
  return (function (param, param$1) {
      return spellcheck(ppf, (function (f) {
                    return Curry._1(fold, (function (decl, x) {
                                  return Curry._2(f, Curry._1(extr, decl), x);
                                }));
                  }), param, param$1);
    });
}

function spellcheck$1(ppf, fold) {
  return (function (param, param$1) {
      return spellcheck(ppf, (function (f) {
                    return Curry._1(fold, (function (s, _, _$1, x) {
                                  return Curry._2(f, s, x);
                                }));
                  }), param, param$1);
    });
}

register_error_of_exn((function (param) {
        if (param[0] === $$Error$6) {
          var env = param[2];
          return /* Some */[error_of_printer(param[1], (function (param, param$1) {
                          var env$1 = env;
                          var ppf = param;
                          var param$2 = param$1;
                          if (typeof param$2 === "number") {
                            if (param$2) {
                              return Format.fprintf(ppf, /* Format */[
                                          /* String_literal */Block.__(11, [
                                              "Illegal recursive module reference",
                                              /* End_of_format */0
                                            ]),
                                          "Illegal recursive module reference"
                                        ]);
                            } else {
                              return Format.fprintf(ppf, /* Format */[
                                          /* String_literal */Block.__(11, [
                                              "This type is recursive",
                                              /* End_of_format */0
                                            ]),
                                          "This type is recursive"
                                        ]);
                            }
                          } else {
                            switch (param$2.tag | 0) {
                              case 0 : 
                                  return Curry._1(Format.fprintf(ppf, /* Format */[
                                                  /* String_literal */Block.__(11, [
                                                      "Unbound type parameter ",
                                                      /* String */Block.__(2, [
                                                          /* No_padding */0,
                                                          /* Formatting_lit */Block.__(17, [
                                                              /* Flush_newline */4,
                                                              /* End_of_format */0
                                                            ])
                                                        ])
                                                    ]),
                                                  "Unbound type parameter %s@."
                                                ]), param$2[0]);
                              case 1 : 
                                  var lid = param$2[0];
                                  Curry._2(Format.fprintf(ppf, /* Format */[
                                            /* String_literal */Block.__(11, [
                                                "Unbound type constructor ",
                                                /* Alpha */Block.__(15, [/* End_of_format */0])
                                              ]),
                                            "Unbound type constructor %a"
                                          ]), longident, lid);
                                  return spellcheck$1(ppf, fold_types)(env$1, lid);
                              case 2 : 
                                  return Curry._2(Format.fprintf(ppf, /* Format */[
                                                  /* String_literal */Block.__(11, [
                                                      "The type constructor",
                                                      /* Formatting_lit */Block.__(17, [
                                                          /* Break */Block.__(0, [
                                                              "@ ",
                                                              1,
                                                              0
                                                            ]),
                                                          /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                  /* Break */Block.__(0, [
                                                                      "@ ",
                                                                      1,
                                                                      0
                                                                    ]),
                                                                  /* String_literal */Block.__(11, [
                                                                      "is not yet completely defined",
                                                                      /* End_of_format */0
                                                                    ])
                                                                ])])
                                                        ])
                                                    ]),
                                                  "The type constructor@ %a@ is not yet completely defined"
                                                ]), path, param$2[0]);
                              case 3 : 
                                  return Curry._4(Format.fprintf(ppf, /* Format */[
                                                  /* Formatting_gen */Block.__(18, [
                                                      /* Open_box */Block.__(1, [/* Format */[
                                                            /* End_of_format */0,
                                                            ""
                                                          ]]),
                                                      /* String_literal */Block.__(11, [
                                                          "The type constructor ",
                                                          /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                  /* Break */Block.__(0, [
                                                                      "@ ",
                                                                      1,
                                                                      0
                                                                    ]),
                                                                  /* String_literal */Block.__(11, [
                                                                      "expects ",
                                                                      /* Int */Block.__(4, [
                                                                          /* Int_i */3,
                                                                          /* No_padding */0,
                                                                          /* No_precision */0,
                                                                          /* String_literal */Block.__(11, [
                                                                              " argument(s),",
                                                                              /* Formatting_lit */Block.__(17, [
                                                                                  /* Break */Block.__(0, [
                                                                                      "@ ",
                                                                                      1,
                                                                                      0
                                                                                    ]),
                                                                                  /* String_literal */Block.__(11, [
                                                                                      "but is here applied to ",
                                                                                      /* Int */Block.__(4, [
                                                                                          /* Int_i */3,
                                                                                          /* No_padding */0,
                                                                                          /* No_precision */0,
                                                                                          /* String_literal */Block.__(11, [
                                                                                              " argument(s)",
                                                                                              /* Formatting_lit */Block.__(17, [
                                                                                                  /* Close_box */0,
                                                                                                  /* End_of_format */0
                                                                                                ])
                                                                                            ])
                                                                                        ])
                                                                                    ])
                                                                                ])
                                                                            ])
                                                                        ])
                                                                    ])
                                                                ])])
                                                        ])
                                                    ]),
                                                  "@[The type constructor %a@ expects %i argument(s),@ but is here applied to %i argument(s)@]"
                                                ]), longident, param$2[0], param$2[1], param$2[2]);
                              case 4 : 
                                  return Curry._1(Format.fprintf(ppf, /* Format */[
                                                  /* String_literal */Block.__(11, [
                                                      "Already bound type parameter '",
                                                      /* String */Block.__(2, [
                                                          /* No_padding */0,
                                                          /* End_of_format */0
                                                        ])
                                                    ]),
                                                  "Already bound type parameter '%s"
                                                ]), param$2[0]);
                              case 5 : 
                                  return Curry._2(Format.fprintf(ppf, /* Format */[
                                                  /* String_literal */Block.__(11, [
                                                      "Unbound row variable in #",
                                                      /* Alpha */Block.__(15, [/* End_of_format */0])
                                                    ]),
                                                  "Unbound row variable in #%a"
                                                ]), longident, param$2[0]);
                              case 6 : 
                                  return report_unification_error(ppf, empty, /* None */0, param$2[0], (function (ppf) {
                                                return Format.fprintf(ppf, /* Format */[
                                                            /* String_literal */Block.__(11, [
                                                                "This type",
                                                                /* End_of_format */0
                                                              ]),
                                                            "This type"
                                                          ]);
                                              }), (function (ppf) {
                                                return Format.fprintf(ppf, /* Format */[
                                                            /* String_literal */Block.__(11, [
                                                                "should be an instance of type",
                                                                /* End_of_format */0
                                                              ]),
                                                            "should be an instance of type"
                                                          ]);
                                              }));
                              case 7 : 
                                  return report_unification_error(ppf, empty, /* None */0, param$2[0], (function (ppf) {
                                                return Format.fprintf(ppf, /* Format */[
                                                            /* String_literal */Block.__(11, [
                                                                "This alias is bound to type",
                                                                /* End_of_format */0
                                                              ]),
                                                            "This alias is bound to type"
                                                          ]);
                                              }), (function (ppf) {
                                                return Format.fprintf(ppf, /* Format */[
                                                            /* String_literal */Block.__(11, [
                                                                "but is used as an instance of type",
                                                                /* End_of_format */0
                                                              ]),
                                                            "but is used as an instance of type"
                                                          ]);
                                              }));
                              case 8 : 
                                  return Curry._1(Format.fprintf(ppf, /* Format */[
                                                  /* String_literal */Block.__(11, [
                                                      "The present constructor ",
                                                      /* String */Block.__(2, [
                                                          /* No_padding */0,
                                                          /* String_literal */Block.__(11, [
                                                              " has a conjunctive type",
                                                              /* End_of_format */0
                                                            ])
                                                        ])
                                                    ]),
                                                  "The present constructor %s has a conjunctive type"
                                                ]), param$2[0]);
                              case 9 : 
                                  return Curry._1(Format.fprintf(ppf, /* Format */[
                                                  /* String_literal */Block.__(11, [
                                                      "The present constructor ",
                                                      /* String */Block.__(2, [
                                                          /* No_padding */0,
                                                          /* String_literal */Block.__(11, [
                                                              " has no type",
                                                              /* End_of_format */0
                                                            ])
                                                        ])
                                                    ]),
                                                  "The present constructor %s has no type"
                                                ]), param$2[0]);
                              case 10 : 
                                  var ty$prime = param$2[1];
                                  var ty = param$2[0];
                                  return wrap_printing_env(env$1, (function () {
                                                reset_and_mark_loops_list(/* :: */[
                                                      ty,
                                                      /* :: */[
                                                        ty$prime,
                                                        /* [] */0
                                                      ]
                                                    ]);
                                                return Curry._6(Format.fprintf(ppf, /* Format */[
                                                                /* Formatting_gen */Block.__(18, [
                                                                    /* Open_box */Block.__(1, [/* Format */[
                                                                          /* String_literal */Block.__(11, [
                                                                              "<hov>",
                                                                              /* End_of_format */0
                                                                            ]),
                                                                          "<hov>"
                                                                        ]]),
                                                                    /* String */Block.__(2, [
                                                                        /* No_padding */0,
                                                                        /* Char_literal */Block.__(12, [
                                                                            /* " " */32,
                                                                            /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                                    /* Break */Block.__(0, [
                                                                                        "@ ",
                                                                                        1,
                                                                                        0
                                                                                      ]),
                                                                                    /* String */Block.__(2, [
                                                                                        /* No_padding */0,
                                                                                        /* Formatting_lit */Block.__(17, [
                                                                                            /* Break */Block.__(0, [
                                                                                                "@ ",
                                                                                                1,
                                                                                                0
                                                                                              ]),
                                                                                            /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                                                    /* Close_box */0,
                                                                                                    /* End_of_format */0
                                                                                                  ])])
                                                                                          ])
                                                                                      ])
                                                                                  ])])
                                                                          ])
                                                                      ])
                                                                  ]),
                                                                "@[<hov>%s %a@ %s@ %a@]"
                                                              ]), "This variant type contains a constructor", type_expr$1, ty, "which should be", type_expr$1, ty$prime);
                                              }));
                              case 11 : 
                                  var ty$1 = param$2[0];
                                  reset(/* () */0);
                                  mark_loops(ty$1);
                                  return Curry._2(Format.fprintf(ppf, /* Format */[
                                                  /* Formatting_gen */Block.__(18, [
                                                      /* Open_box */Block.__(1, [/* Format */[
                                                            /* End_of_format */0,
                                                            ""
                                                          ]]),
                                                      /* String_literal */Block.__(11, [
                                                          "The type ",
                                                          /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                  /* Break */Block.__(0, [
                                                                      "@ ",
                                                                      1,
                                                                      0
                                                                    ]),
                                                                  /* String_literal */Block.__(11, [
                                                                      "is not a polymorphic variant type",
                                                                      /* Formatting_lit */Block.__(17, [
                                                                          /* Close_box */0,
                                                                          /* End_of_format */0
                                                                        ])
                                                                    ])
                                                                ])])
                                                        ])
                                                    ]),
                                                  "@[The type %a@ is not a polymorphic variant type@]"
                                                ]), type_expr$1, ty$1);
                              case 12 : 
                                  return Curry._3(Format.fprintf(ppf, /* Format */[
                                                  /* Formatting_gen */Block.__(18, [
                                                      /* Open_box */Block.__(1, [/* Format */[
                                                            /* End_of_format */0,
                                                            ""
                                                          ]]),
                                                      /* String_literal */Block.__(11, [
                                                          "Variant tags `",
                                                          /* String */Block.__(2, [
                                                              /* No_padding */0,
                                                              /* Formatting_lit */Block.__(17, [
                                                                  /* Break */Block.__(0, [
                                                                      "@ ",
                                                                      1,
                                                                      0
                                                                    ]),
                                                                  /* String_literal */Block.__(11, [
                                                                      "and `",
                                                                      /* String */Block.__(2, [
                                                                          /* No_padding */0,
                                                                          /* String_literal */Block.__(11, [
                                                                              " have the same hash value.",
                                                                              /* Formatting_lit */Block.__(17, [
                                                                                  /* Break */Block.__(0, [
                                                                                      "@ ",
                                                                                      1,
                                                                                      0
                                                                                    ]),
                                                                                  /* String */Block.__(2, [
                                                                                      /* No_padding */0,
                                                                                      /* Formatting_lit */Block.__(17, [
                                                                                          /* Close_box */0,
                                                                                          /* End_of_format */0
                                                                                        ])
                                                                                    ])
                                                                                ])
                                                                            ])
                                                                        ])
                                                                    ])
                                                                ])
                                                            ])
                                                        ])
                                                    ]),
                                                  "@[Variant tags `%s@ and `%s have the same hash value.@ %s@]"
                                                ]), param$2[0], param$2[1], "Change one of them.");
                              case 13 : 
                                  return Curry._1(Format.fprintf(ppf, /* Format */[
                                                  /* String_literal */Block.__(11, [
                                                      "The type variable name ",
                                                      /* String */Block.__(2, [
                                                          /* No_padding */0,
                                                          /* String_literal */Block.__(11, [
                                                              " is not allowed in programs",
                                                              /* End_of_format */0
                                                            ])
                                                        ])
                                                    ]),
                                                  "The type variable name %s is not allowed in programs"
                                                ]), param$2[0]);
                              case 14 : 
                                  var v = param$2[1];
                                  return Curry._2(Format.fprintf(ppf, /* Format */[
                                                  /* Formatting_gen */Block.__(18, [
                                                      /* Open_box */Block.__(1, [/* Format */[
                                                            /* String_literal */Block.__(11, [
                                                                "<hov>",
                                                                /* End_of_format */0
                                                              ]),
                                                            "<hov>"
                                                          ]]),
                                                      /* String_literal */Block.__(11, [
                                                          "The universal type variable '",
                                                          /* String */Block.__(2, [
                                                              /* No_padding */0,
                                                              /* String_literal */Block.__(11, [
                                                                  " cannot be generalized:",
                                                                  /* Formatting_lit */Block.__(17, [
                                                                      /* Break */Block.__(0, [
                                                                          "@ ",
                                                                          1,
                                                                          0
                                                                        ]),
                                                                      /* String */Block.__(2, [
                                                                          /* No_padding */0,
                                                                          /* Char_literal */Block.__(12, [
                                                                              /* "." */46,
                                                                              /* Formatting_lit */Block.__(17, [
                                                                                  /* Close_box */0,
                                                                                  /* End_of_format */0
                                                                                ])
                                                                            ])
                                                                        ])
                                                                    ])
                                                                ])
                                                            ])
                                                        ])
                                                    ]),
                                                  "@[<hov>The universal type variable '%s cannot be generalized:@ %s.@]"
                                                ]), param$2[0], is_Tvar(v) ? "it escapes its scope" : (
                                                is_Tunivar(v) ? "it is already bound to another variable" : "it is not a variable"
                                              ));
                              case 15 : 
                                  return Curry._2(Format.fprintf(ppf, /* Format */[
                                                  /* String_literal */Block.__(11, [
                                                      "Multiple constraints for type ",
                                                      /* Alpha */Block.__(15, [/* End_of_format */0])
                                                    ]),
                                                  "Multiple constraints for type %a"
                                                ]), longident, param$2[0]);
                              case 16 : 
                                  return Curry._2(Format.fprintf(ppf, /* Format */[
                                                  /* Formatting_gen */Block.__(18, [
                                                      /* Open_box */Block.__(1, [/* Format */[
                                                            /* End_of_format */0,
                                                            ""
                                                          ]]),
                                                      /* String_literal */Block.__(11, [
                                                          "This is the second method `",
                                                          /* String */Block.__(2, [
                                                              /* No_padding */0,
                                                              /* String_literal */Block.__(11, [
                                                                  "' of this object type.",
                                                                  /* Formatting_lit */Block.__(17, [
                                                                      /* Break */Block.__(0, [
                                                                          "@ ",
                                                                          1,
                                                                          0
                                                                        ]),
                                                                      /* String */Block.__(2, [
                                                                          /* No_padding */0,
                                                                          /* Formatting_lit */Block.__(17, [
                                                                              /* Close_box */0,
                                                                              /* End_of_format */0
                                                                            ])
                                                                        ])
                                                                    ])
                                                                ])
                                                            ])
                                                        ])
                                                    ]),
                                                  "@[This is the second method `%s' of this object type.@ %s@]"
                                                ]), param$2[0], "Multiple occurences are not allowed.");
                              case 17 : 
                                  var lid$1 = param$2[0];
                                  Curry._2(Format.fprintf(ppf, /* Format */[
                                            /* String_literal */Block.__(11, [
                                                "Unbound value ",
                                                /* Alpha */Block.__(15, [/* End_of_format */0])
                                              ]),
                                            "Unbound value %a"
                                          ]), longident, lid$1);
                                  return spellcheck$1(ppf, fold_values)(env$1, lid$1);
                              case 18 : 
                                  var lid$2 = param$2[0];
                                  Curry._2(Format.fprintf(ppf, /* Format */[
                                            /* String_literal */Block.__(11, [
                                                "Unbound constructor ",
                                                /* Alpha */Block.__(15, [/* End_of_format */0])
                                              ]),
                                            "Unbound constructor %a"
                                          ]), longident, lid$2);
                                  return spellcheck_simple(ppf, fold_constructors, (function (d) {
                                                  return d[/* cstr_name */0];
                                                }))(env$1, lid$2);
                              case 19 : 
                                  var lid$3 = param$2[0];
                                  Curry._2(Format.fprintf(ppf, /* Format */[
                                            /* String_literal */Block.__(11, [
                                                "Unbound record field ",
                                                /* Alpha */Block.__(15, [/* End_of_format */0])
                                              ]),
                                            "Unbound record field %a"
                                          ]), longident, lid$3);
                                  return spellcheck_simple(ppf, fold_labels, (function (d) {
                                                  return d[/* lbl_name */0];
                                                }))(env$1, lid$3);
                              case 20 : 
                                  var lid$4 = param$2[0];
                                  Curry._2(Format.fprintf(ppf, /* Format */[
                                            /* String_literal */Block.__(11, [
                                                "Unbound module ",
                                                /* Alpha */Block.__(15, [/* End_of_format */0])
                                              ]),
                                            "Unbound module %a"
                                          ]), longident, lid$4);
                                  return spellcheck$1(ppf, fold_modules)(env$1, lid$4);
                              case 21 : 
                                  var lid$5 = param$2[0];
                                  Curry._2(Format.fprintf(ppf, /* Format */[
                                            /* String_literal */Block.__(11, [
                                                "Unbound class ",
                                                /* Alpha */Block.__(15, [/* End_of_format */0])
                                              ]),
                                            "Unbound class %a"
                                          ]), longident, lid$5);
                                  return spellcheck$1(ppf, fold_classs)(env$1, lid$5);
                              case 22 : 
                                  var lid$6 = param$2[0];
                                  Curry._2(Format.fprintf(ppf, /* Format */[
                                            /* String_literal */Block.__(11, [
                                                "Unbound module type ",
                                                /* Alpha */Block.__(15, [/* End_of_format */0])
                                              ]),
                                            "Unbound module type %a"
                                          ]), longident, lid$6);
                                  return spellcheck$1(ppf, fold_modtypes)(env$1, lid$6);
                              case 23 : 
                                  var lid$7 = param$2[0];
                                  Curry._2(Format.fprintf(ppf, /* Format */[
                                            /* String_literal */Block.__(11, [
                                                "Unbound class type ",
                                                /* Alpha */Block.__(15, [/* End_of_format */0])
                                              ]),
                                            "Unbound class type %a"
                                          ]), longident, lid$7);
                                  return spellcheck$1(ppf, fold_cltypes)(env$1, lid$7);
                              case 24 : 
                                  return Curry._2(Format.fprintf(ppf, /* Format */[
                                                  /* String_literal */Block.__(11, [
                                                      "Ill-typed functor application ",
                                                      /* Alpha */Block.__(15, [/* End_of_format */0])
                                                    ]),
                                                  "Ill-typed functor application %a"
                                                ]), longident, param$2[0]);
                              case 25 : 
                                  return Curry._2(Format.fprintf(ppf, /* Format */[
                                                  /* String_literal */Block.__(11, [
                                                      "The module ",
                                                      /* Alpha */Block.__(15, [/* String_literal */Block.__(11, [
                                                              " is a functor, not a structure",
                                                              /* End_of_format */0
                                                            ])])
                                                    ]),
                                                  "The module %a is a functor, not a structure"
                                                ]), longident, param$2[0]);
                              
                            }
                          }
                        }), param[3])];
        } else if (param[0] === Error_forward) {
          return /* Some */[param[1]];
        } else {
          return /* None */0;
        }
      }));

var $$Error$7 = Caml_exceptions.create("Ocaml_typedtree_test.Typecore.Error");

var Error_forward$1 = Caml_exceptions.create("Ocaml_typedtree_test.Typecore.Error_forward");

var type_module = [(function (_, _$1) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "typecore.ml",
              77,
              22
            ]
          ];
    })];

var type_open = [(function () {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "typecore.ml",
              83,
              16
            ]
          ];
    })];

var type_package = [(function () {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "typecore.ml",
              88,
              16
            ]
          ];
    })];

var type_object = [(function (_, _$1) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "typecore.ml",
              92,
              20
            ]
          ];
    })];

function re(node) {
  add_saved_type(/* Partial_expression */Block.__(2, [node]));
  record$2(/* Ti_expr */Block.__(1, [node]));
  return node;
}

function rp(node) {
  add_saved_type(/* Partial_pattern */Block.__(3, [node]));
  record$2(/* Ti_pat */Block.__(0, [node]));
  return node;
}

function snd3(param) {
  return param[1];
}

function iter_expression(f, e) {
  var expr = function (_e) {
    while(true) {
      var e = _e;
      Curry._1(f, e);
      var match = e[/* pexp_desc */0];
      var exit = 0;
      switch (match.tag | 0) {
        case 2 : 
            expr(match[2]);
            return List.iter(binding, match[1]);
        case 3 : 
            return List.iter($$case, match[0]);
        case 4 : 
            may(expr, match[1]);
            _e = match[3];
            continue ;
            case 5 : 
            expr(match[0]);
            return List.iter((function (param) {
                          return expr(param[1]);
                        }), match[1]);
        case 6 : 
        case 7 : 
            exit = 1;
            break;
        case 9 : 
        case 10 : 
            return may(expr, match[1]);
        case 11 : 
            may(expr, match[1]);
            return List.iter((function (param) {
                          return expr(param[1]);
                        }), match[0]);
        case 13 : 
            expr(match[0]);
            _e = match[2];
            continue ;
            case 8 : 
        case 14 : 
            return List.iter(expr, match[0]);
        case 15 : 
            expr(match[0]);
            expr(match[1]);
            return may(expr, match[2]);
        case 16 : 
        case 17 : 
            expr(match[0]);
            _e = match[1];
            continue ;
            case 18 : 
            expr(match[1]);
            expr(match[2]);
            _e = match[4];
            continue ;
            case 24 : 
            return List.iter((function (param) {
                          return expr(param[1]);
                        }), match[0]);
        case 25 : 
            expr(match[2]);
            return module_expr(match[1]);
        case 29 : 
            return List.iter(class_field, match[0][/* pcstr_fields */1]);
        case 23 : 
        case 30 : 
            _e = match[1];
            continue ;
            case 31 : 
            return module_expr(match[0]);
        case 32 : 
            _e = match[2];
            continue ;
            case 0 : 
        case 1 : 
        case 22 : 
        case 33 : 
            return /* () */0;
        default:
          _e = match[0];
          continue ;
          
      }
      if (exit === 1) {
        expr(match[0]);
        return List.iter($$case, match[1]);
      }
      
    };
  };
  var $$case = function (param) {
    may(expr, param[/* pc_guard */1]);
    return expr(param[/* pc_rhs */2]);
  };
  var binding = function (x) {
    return expr(x[/* pvb_expr */1]);
  };
  var module_expr = function (_me) {
    while(true) {
      var me = _me;
      var match = me[/* pmod_desc */0];
      switch (match.tag | 0) {
        case 1 : 
            return List.iter(structure_item, match[0]);
        case 2 : 
            _me = match[2];
            continue ;
            case 3 : 
            module_expr(match[0]);
            _me = match[1];
            continue ;
            case 4 : 
            _me = match[0];
            continue ;
            case 5 : 
            return expr(match[0]);
        case 0 : 
        case 6 : 
            return /* () */0;
        
      }
    };
  };
  var structure_item = function (str) {
    var match = str[/* pstr_desc */0];
    switch (match.tag | 0) {
      case 0 : 
          return expr(match[0]);
      case 1 : 
          return List.iter(binding, match[1]);
      case 6 : 
          return module_expr(match[0][/* pmb_expr */1]);
      case 7 : 
          return List.iter((function (x) {
                        return module_expr(x[/* pmb_expr */1]);
                      }), match[0]);
      case 10 : 
          return List.iter((function (c) {
                        return class_expr(c[/* pci_expr */3]);
                      }), match[0]);
      case 12 : 
          return module_expr(match[0][/* pincl_mod */0]);
      default:
        return /* () */0;
    }
  };
  var class_expr = function (_ce) {
    while(true) {
      var ce = _ce;
      var match = ce[/* pcl_desc */0];
      switch (match.tag | 0) {
        case 1 : 
            return List.iter(class_field, match[0][/* pcstr_fields */1]);
        case 2 : 
            may(expr, match[1]);
            _ce = match[3];
            continue ;
            case 3 : 
            class_expr(match[0]);
            return List.iter((function (param) {
                          return expr(param[1]);
                        }), match[1]);
        case 4 : 
            List.iter(binding, match[1]);
            _ce = match[2];
            continue ;
            case 5 : 
            _ce = match[0];
            continue ;
            case 0 : 
        case 6 : 
            return /* () */0;
        
      }
    };
  };
  var class_field = function (cf) {
    var match = cf[/* pcf_desc */0];
    var exit = 0;
    switch (match.tag | 0) {
      case 0 : 
          return class_expr(match[1]);
      case 1 : 
      case 2 : 
          exit = 1;
          break;
      case 4 : 
          return expr(match[0]);
      case 3 : 
      case 5 : 
      case 6 : 
          return /* () */0;
      
    }
    if (exit === 1) {
      var match$1 = match[0][2];
      if (match$1.tag) {
        return expr(match$1[1]);
      } else {
        return /* () */0;
      }
    }
    
  };
  return expr(e);
}

function all_idents_cases(el) {
  var idents = Hashtbl.create(/* None */0, 8);
  var f = function (param) {
    var match = param[/* pexp_desc */0];
    if (match.tag) {
      return /* () */0;
    } else {
      var match$1 = match[0][/* txt */0];
      switch (match$1.tag | 0) {
        case 0 : 
            return Hashtbl.replace(idents, match$1[0], /* () */0);
        case 1 : 
        case 2 : 
            return /* () */0;
        
      }
    }
  };
  List.iter((function (cp) {
          may((function (param) {
                  return iter_expression(f, param);
                }), cp[/* pc_guard */1]);
          return iter_expression(f, cp[/* pc_rhs */2]);
        }), el);
  return Hashtbl.fold((function (x, _, rest) {
                return /* :: */[
                        x,
                        rest
                      ];
              }), idents, /* [] */0);
}

function type_constant(param) {
  switch (param.tag | 0) {
    case 0 : 
        return instance_def(type_int);
    case 1 : 
        return instance_def(type_char);
    case 2 : 
        return instance_def(type_string);
    case 3 : 
        return instance_def(type_float);
    case 4 : 
        return instance_def(type_int32);
    case 5 : 
        return instance_def(type_int64);
    case 6 : 
        return instance_def(type_nativeint);
    
  }
}

function type_option$1(ty) {
  return newty2(current_level[0], /* Tconstr */Block.__(3, [
                path_option,
                /* :: */[
                  ty,
                  /* [] */0
                ],
                [/* Mnil */0]
              ]));
}

function mkexp$1(exp_desc, exp_type, exp_loc, exp_env) {
  return /* record */[
          /* exp_desc */exp_desc,
          /* exp_loc */exp_loc,
          /* exp_extra : [] */0,
          /* exp_type */exp_type,
          /* exp_env */exp_env,
          /* exp_attributes : [] */0
        ];
}

function option_none(ty, loc) {
  var lid = /* Lident */Block.__(0, ["None"]);
  var cnone = lookup_constructor(lid, initial_safe_string);
  return mkexp$1(/* Texp_construct */Block.__(8, [
                /* record */[
                  /* txt */lid,
                  /* loc */none
                ],
                cnone,
                /* [] */0
              ]), ty, loc, initial_safe_string);
}

function option_some(texp) {
  var lid = /* Lident */Block.__(0, ["Some"]);
  var csome = lookup_constructor(lid, initial_safe_string);
  return mkexp$1(/* Texp_construct */Block.__(8, [
                /* record */[
                  /* txt */lid,
                  /* loc */none
                ],
                csome,
                /* :: */[
                  texp,
                  /* [] */0
                ]
              ]), type_option$1(texp[/* exp_type */3]), texp[/* exp_loc */1], texp[/* exp_env */4]);
}

function extract_option_type(env, ty) {
  var match = expand_head(env, ty);
  var match$1 = match[/* desc */0];
  var exit = 0;
  if (typeof match$1 === "number") {
    exit = 1;
  } else if (match$1.tag === 3) {
    var match$2 = match$1[1];
    if (match$2) {
      if (match$2[1]) {
        exit = 1;
      } else if (same(match$1[0], path_option)) {
        return match$2[0];
      } else {
        exit = 1;
      }
    } else {
      exit = 1;
    }
  } else {
    exit = 1;
  }
  if (exit === 1) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "typecore.ml",
            275,
            9
          ]
        ];
  }
  
}

function extract_concrete_record(env, ty) {
  var match = extract_concrete_typedecl(env, ty);
  var match$1 = match[2][/* type_kind */2];
  if (typeof match$1 === "number") {
    throw Caml_builtin_exceptions.not_found;
  } else if (match$1.tag) {
    throw Caml_builtin_exceptions.not_found;
  } else {
    return /* tuple */[
            match[0],
            match[1],
            match$1[0]
          ];
  }
}

function extract_concrete_variant(env, ty) {
  var match = extract_concrete_typedecl(env, ty);
  var match$1 = match[2][/* type_kind */2];
  var p = match[1];
  var p0 = match[0];
  if (typeof match$1 === "number") {
    if (match$1) {
      return /* tuple */[
              p0,
              p,
              /* [] */0
            ];
    } else {
      throw Caml_builtin_exceptions.not_found;
    }
  } else if (match$1.tag) {
    return /* tuple */[
            p0,
            p,
            match$1[0]
          ];
  } else {
    throw Caml_builtin_exceptions.not_found;
  }
}

function extract_label_names(_, env, ty) {
  try {
    var match = extract_concrete_record(env, ty);
    return List.map((function (l) {
                  return l[/* ld_id */0];
                }), match[2]);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "typecore.ml",
              293,
              4
            ]
          ];
    } else {
      throw exn;
    }
  }
}

function explicit_arity(param) {
  return List.exists((function (param) {
                switch (param[0][/* txt */0]) {
                  case "explicit_arity" : 
                  case "ocaml.explicit_arity" : 
                      return /* true */1;
                  default:
                    return /* false */0;
                }
              }), param);
}

function unify_pat_types(loc, env, ty, ty$prime) {
  try {
    return unify$2(env, ty, ty$prime);
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === Unify) {
      throw [
            $$Error$7,
            loc,
            env,
            /* Pattern_type_clash */Block.__(3, [exn[1]])
          ];
    } else if (exn[0] === Tags) {
      throw [
            $$Error$6,
            loc,
            env,
            /* Variant_tags */Block.__(12, [
                exn[1],
                exn[2]
              ])
          ];
    } else {
      throw exn;
    }
  }
}

function unify_exp_types(loc, env, ty, expected_ty) {
  try {
    return unify$2(env, ty, expected_ty);
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === Unify) {
      throw [
            $$Error$7,
            loc,
            env,
            /* Expr_type_clash */Block.__(7, [exn[1]])
          ];
    } else if (exn[0] === Tags) {
      throw [
            $$Error$6,
            loc,
            env,
            /* Variant_tags */Block.__(12, [
                exn[1],
                exn[2]
              ])
          ];
    } else {
      throw exn;
    }
  }
}

var newtype_level$1 = [/* None */0];

function get_newtype_level$1() {
  var match = newtype_level$1[0];
  if (match) {
    return match[0];
  } else {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "typecore.ml",
            331,
            12
          ]
        ];
  }
}

function unify_pat_types_gadt(loc, env, ty, ty$prime) {
  var match = newtype_level$1[0];
  var newtype_level$2;
  if (match) {
    newtype_level$2 = match[0];
  } else {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "typecore.ml",
            336,
            14
          ]
        ];
  }
  try {
    var lev = newtype_level$2;
    var env$1 = env;
    var ty1 = ty;
    var ty2 = ty$prime;
    try {
      univar_pairs[0] = /* [] */0;
      newtype_level[0] = /* Some */[lev];
      set_mode_pattern(/* true */1, /* true */1, (function () {
              return unify$1(env$1, ty1, ty2);
            }));
      newtype_level[0] = /* None */0;
      return Curry._1(TypePairs[/* clear */1], unify_eq_set);
    }
    catch (raw_e){
      var e = Js_exn.internalToOCamlException(raw_e);
      Curry._1(TypePairs[/* clear */1], unify_eq_set);
      if (e[0] === Unify) {
        throw [
              Unify,
              e[1]
            ];
      } else {
        newtype_level[0] = /* None */0;
        throw e;
      }
    }
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === Unify) {
      throw [
            $$Error$7,
            loc,
            env[0],
            /* Pattern_type_clash */Block.__(3, [exn[1]])
          ];
    } else if (exn[0] === Tags) {
      throw [
            $$Error$6,
            loc,
            env[0],
            /* Variant_tags */Block.__(12, [
                exn[1],
                exn[2]
              ])
          ];
    } else if (exn[0] === Unification_recursive_abbrev) {
      throw [
            $$Error$7,
            loc,
            env[0],
            /* Recursive_local_constraint */Block.__(33, [exn[1]])
          ];
    } else {
      throw exn;
    }
  }
}

function unify_pat(env, pat, expected_ty) {
  return unify_pat_types(pat[/* pat_loc */1], env, pat[/* pat_type */3], expected_ty);
}

function finalize_variant(pat) {
  var match = pat[/* pat_desc */0];
  if (typeof match === "number") {
    return /* () */0;
  } else if (match.tag === 5) {
    var opat = match[1];
    var match$1 = expand_head(pat[/* pat_env */4], pat[/* pat_type */3]);
    var match$2 = match$1[/* desc */0];
    var row;
    if (typeof match$2 === "number") {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "typecore.ml",
              362,
              15
            ]
          ];
    } else if (match$2.tag === 8) {
      var row$1 = match$2[0];
      match[2][0] = row$1;
      row = row_repr_aux(/* [] */0, row$1);
    } else {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "typecore.ml",
              362,
              15
            ]
          ];
    }
    var match$3 = row_field(match[0], row);
    if (typeof match$3 === "number") {
      return /* () */0;
    } else if (match$3.tag) {
      var c = match$3[0];
      var exit = 0;
      if (c !== 0) {
        if (match$3[1]) {
          exit = 1;
        } else if (row[/* row_closed */3]) {
          exit = 1;
        } else {
          return set_row_field(match$3[3], /* Rpresent */Block.__(0, [/* None */0]));
        }
      } else {
        var match$4 = match$3[1];
        if (match$4) {
          if (row[/* row_closed */3]) {
            exit = 1;
          } else {
            var ty = match$4[0];
            set_row_field(match$3[3], /* Rpresent */Block.__(0, [/* Some */[ty]]));
            if (opat) {
              var pat$1 = opat[0];
              var partial_arg = pat$1[/* pat_env */4];
              return List.iter((function (param) {
                            return unify_pat(partial_arg, pat$1, param);
                          }), /* :: */[
                          ty,
                          match$4[1]
                        ]);
            } else {
              throw [
                    Caml_builtin_exceptions.assert_failure,
                    [
                      "typecore.ml",
                      370,
                      40
                    ]
                  ];
            }
          }
        } else {
          exit = 1;
        }
      }
      if (exit === 1) {
        if (match$3[2] !== 0 && !row_fixed(row)) {
          return set_row_field(match$3[3], /* Reither */Block.__(1, [
                        c,
                        /* [] */0,
                        /* false */0,
                        [/* None */0]
                      ]));
        } else {
          return /* () */0;
        }
      }
      
    } else {
      return /* () */0;
    }
  } else {
    return /* () */0;
  }
}

function iter_pattern(f, p) {
  Curry._1(f, p);
  return iter_pattern_desc((function (param) {
                return iter_pattern(f, param);
              }), p[/* pat_desc */0]);
}

function has_variants(p) {
  try {
    iter_pattern((function (param) {
            var $js = param[/* pat_desc */0];
            if (typeof $js === "number") {
              return /* () */0;
            } else if ($js.tag === 5) {
              throw Pervasives.Exit;
            } else {
              return /* () */0;
            }
          }), p);
    return /* false */0;
  }
  catch (exn){
    if (exn === Pervasives.Exit) {
      return /* true */1;
    } else {
      throw exn;
    }
  }
}

var pattern_variables = [/* [] */0];

var pattern_force = [/* [] */0];

var pattern_scope = [/* None */0];

var allow_modules = [/* false */0];

var module_variables = [/* [] */0];

function reset_pattern(scope, allow) {
  pattern_variables[0] = /* [] */0;
  pattern_force[0] = /* [] */0;
  pattern_scope[0] = scope;
  allow_modules[0] = allow;
  module_variables[0] = /* [] */0;
  return /* () */0;
}

function enter_variable($staropt$star, $staropt$star$1, loc, name, ty) {
  var is_module = $staropt$star ? $staropt$star[0] : /* false */0;
  var is_as_variable = $staropt$star$1 ? $staropt$star$1[0] : /* false */0;
  if (List.exists((function (param) {
            return +(param[0][/* name */1] === name[/* txt */0]);
          }), pattern_variables[0])) {
    throw [
          $$Error$7,
          loc,
          empty,
          /* Multiply_bound_variable */Block.__(5, [name[/* txt */0]])
        ];
  }
  var id = create(name[/* txt */0]);
  pattern_variables[0] = /* :: */[
    /* tuple */[
      id,
      ty,
      name,
      loc,
      is_as_variable
    ],
    pattern_variables[0]
  ];
  if (is_module) {
    if (!allow_modules[0]) {
      throw [
            $$Error$7,
            loc,
            empty,
            /* Modules_not_allowed */2
          ];
    }
    module_variables[0] = /* :: */[
      /* tuple */[
        name,
        loc
      ],
      module_variables[0]
    ];
  } else {
    may((function (s) {
            return record$2(/* An_ident */Block.__(5, [
                          name[/* loc */1],
                          name[/* txt */0],
                          s
                        ]));
          }), pattern_scope[0]);
  }
  return id;
}

function sort_pattern_variables(vs) {
  return List.sort((function (param, param$1) {
                return Caml_string.caml_string_compare(param[0][/* name */1], param$1[0][/* name */1]);
              }), vs);
}

function enter_orpat_variables(loc, env, p1_vs, p2_vs) {
  var p1_vs$1 = sort_pattern_variables(p1_vs);
  var p2_vs$1 = sort_pattern_variables(p2_vs);
  var unify_vars = function (_p1_vs, _p2_vs) {
    while(true) {
      var p2_vs = _p2_vs;
      var p1_vs = _p1_vs;
      if (p1_vs) {
        var match = p1_vs[0];
        var x1 = match[0];
        if (p2_vs) {
          var rem2 = p2_vs[1];
          var match$1 = p2_vs[0];
          var x2 = match$1[0];
          var rem1 = p1_vs[1];
          if (equal(x1, x2)) {
            if (x1 === x2) {
              _p2_vs = rem2;
              _p1_vs = rem1;
              continue ;
              
            } else {
              try {
                unify$2(env, match[1], match$1[1]);
              }
              catch (raw_exn){
                var exn = Js_exn.internalToOCamlException(raw_exn);
                if (exn[0] === Unify) {
                  throw [
                        $$Error$7,
                        loc,
                        env,
                        /* Or_pattern_type_clash */Block.__(4, [
                            x1,
                            exn[1]
                          ])
                      ];
                } else {
                  throw exn;
                }
              }
              return /* :: */[
                      /* tuple */[
                        x2,
                        x1
                      ],
                      unify_vars(rem1, rem2)
                    ];
            }
          } else {
            var min_var = x1[/* name */1] < x2[/* name */1] ? x1 : x2;
            throw [
                  $$Error$7,
                  loc,
                  env,
                  /* Orpat_vars */Block.__(6, [min_var])
                ];
          }
        } else {
          throw [
                $$Error$7,
                loc,
                env,
                /* Orpat_vars */Block.__(6, [x1])
              ];
        }
      } else if (p2_vs) {
        throw [
              $$Error$7,
              loc,
              env,
              /* Orpat_vars */Block.__(6, [p2_vs[0][0]])
            ];
      } else {
        return /* [] */0;
      }
    };
  };
  return unify_vars(p1_vs$1, p2_vs$1);
}

function build_as_type(env, _p) {
  while(true) {
    var p = _p;
    var match = p[/* pat_desc */0];
    if (typeof match === "number") {
      return p[/* pat_type */3];
    } else {
      switch (match.tag | 0) {
        case 1 : 
            _p = match[0];
            continue ;
            case 3 : 
            var tyl = List.map((function (param) {
                    return build_as_type(env, param);
                  }), match[0]);
            return newty2(current_level[0], /* Ttuple */Block.__(2, [tyl]));
        case 4 : 
            var pl = match[2];
            var cstr = match[1];
            var keep = +(cstr[/* cstr_private */10] === /* Private */0 || cstr[/* cstr_existentials */2] !== /* [] */0);
            if (keep) {
              return p[/* pat_type */3];
            } else {
              var tyl$1 = List.map((function (param) {
                      return build_as_type(env, param);
                    }), pl);
              var match$1 = instance_constructor(/* None */0, cstr);
              List.iter2((function (param) {
                      var newrecord = param[0].slice();
                      newrecord[/* pat_type */3] = param[1];
                      var partial_arg = newrecord;
                      return (function (param) {
                          return unify_pat(env, partial_arg, param);
                        });
                    }), List.combine(pl, tyl$1), match$1[0]);
              return match$1[1];
            }
            break;
        case 5 : 
            var ty = may_map((function (param) {
                    return build_as_type(env, param);
                  }), match[1]);
            var desc = /* Tvariant */Block.__(8, [/* record */[
                  /* row_fields : :: */[
                    /* tuple */[
                      match[0],
                      /* Rpresent */Block.__(0, [ty])
                    ],
                    /* [] */0
                  ],
                  /* row_more */newvar(/* None */0, /* () */0),
                  /* row_bound : () */0,
                  /* row_closed : false */0,
                  /* row_fixed : false */0,
                  /* row_name : None */0
                ]]);
            return newty2(current_level[0], desc);
        case 6 : 
            var lpl = match[0];
            var lbl = snd3(List.hd(lpl));
            if (lbl[/* lbl_private */7]) {
              var ty$1 = newvar(/* None */0, /* () */0);
              var ppl = List.map((function (param) {
                      return /* tuple */[
                              param[1][/* lbl_pos */4],
                              param[2]
                            ];
                    }), lpl);
              var do_label = (function(p,ty$1,ppl){
              return function do_label(lbl) {
                var match = instance_label(/* false */0, lbl);
                var ty_arg = match[1];
                var newrecord = p.slice();
                unify_pat(env, (newrecord[/* pat_type */3] = ty$1, newrecord), match[2]);
                var match$1 = repr(lbl[/* lbl_arg */2])[/* desc */0];
                var $js;
                $js = typeof match$1 === "number" || match$1.tag !== 10 ? /* true */1 : /* false */0;
                var refinable = +(lbl[/* lbl_mut */3] === /* Immutable */0) && List.mem_assoc(lbl[/* lbl_pos */4], ppl) && $js;
                if (refinable) {
                  var arg = List.assoc(lbl[/* lbl_pos */4], ppl);
                  var newrecord$1 = arg.slice();
                  return unify_pat(env, (newrecord$1[/* pat_type */3] = build_as_type(env, arg), newrecord$1), ty_arg);
                } else {
                  var match$2 = instance_label(/* false */0, lbl);
                  unify$2(env, ty_arg, match$2[1]);
                  return unify_pat(env, p, match$2[2]);
                }
              }
              }(p,ty$1,ppl));
              $$Array.iter(do_label, lbl[/* lbl_all */5]);
              return ty$1;
            } else {
              return p[/* pat_type */3];
            }
            break;
        case 8 : 
            var row = match[2];
            var p2 = match[1];
            if (row) {
              var row$1 = row_repr_aux(/* [] */0, row[0]);
              var desc$1 = /* Tvariant */Block.__(8, [/* record */[
                    /* row_fields */row$1[/* row_fields */0],
                    /* row_more */newvar(/* None */0, /* () */0),
                    /* row_bound */row$1[/* row_bound */2],
                    /* row_closed : false */0,
                    /* row_fixed */row$1[/* row_fixed */4],
                    /* row_name */row$1[/* row_name */5]
                  ]]);
              return newty2(current_level[0], desc$1);
            } else {
              var ty1 = build_as_type(env, match[0]);
              var ty2 = build_as_type(env, p2);
              var newrecord = p2.slice();
              unify_pat(env, (newrecord[/* pat_type */3] = ty2, newrecord), ty1);
              return ty1;
            }
            break;
        default:
          return p[/* pat_type */3];
      }
    }
  };
}

function build_or_pat(env, loc, lid) {
  var match = find_type(env, loc, lid);
  var path = match[0];
  var tyl = List.map((function () {
          return newvar(/* None */0, /* () */0);
        }), match[1][/* type_params */0]);
  var ty = expand_head(env, newty2(current_level[0], /* Tconstr */Block.__(3, [
              path,
              tyl,
              [/* Mnil */0]
            ])));
  var match$1 = ty[/* desc */0];
  var row0;
  var exit = 0;
  if (typeof match$1 === "number") {
    exit = 1;
  } else if (match$1.tag === 8) {
    var row = match$1[0];
    if (static_row(row)) {
      row0 = row;
    } else {
      exit = 1;
    }
  } else {
    exit = 1;
  }
  if (exit === 1) {
    throw [
          $$Error$7,
          loc,
          env,
          /* Not_a_variant_type */Block.__(30, [lid])
        ];
  }
  var match$2 = List.fold_left((function (param, param$1) {
          var l = param$1[0];
          var fields = param[1];
          var pats = param[0];
          var match = row_field_repr_aux(/* [] */0, param$1[1]);
          if (typeof match === "number") {
            return /* tuple */[
                    pats,
                    fields
                  ];
          } else if (match.tag) {
            return /* tuple */[
                    pats,
                    fields
                  ];
          } else {
            var match$1 = match[0];
            if (match$1) {
              var ty = match$1[0];
              return /* tuple */[
                      /* :: */[
                        /* tuple */[
                          l,
                          /* Some */[/* record */[
                              /* pat_desc : Tpat_any */0,
                              /* pat_loc */none,
                              /* pat_extra : [] */0,
                              /* pat_type */ty,
                              /* pat_env */env,
                              /* pat_attributes : [] */0
                            ]]
                        ],
                        pats
                      ],
                      /* :: */[
                        /* tuple */[
                          l,
                          /* Reither */Block.__(1, [
                              /* false */0,
                              /* :: */[
                                ty,
                                /* [] */0
                              ],
                              /* true */1,
                              [/* None */0]
                            ])
                        ],
                        fields
                      ]
                    ];
            } else {
              return /* tuple */[
                      /* :: */[
                        /* tuple */[
                          l,
                          /* None */0
                        ],
                        pats
                      ],
                      /* :: */[
                        /* tuple */[
                          l,
                          /* Reither */Block.__(1, [
                              /* true */1,
                              /* [] */0,
                              /* true */1,
                              [/* None */0]
                            ])
                        ],
                        fields
                      ]
                    ];
            }
          }
        }), /* tuple */[
        /* [] */0,
        /* [] */0
      ], row_repr_aux(/* [] */0, row0)[/* row_fields */0]);
  var row_000 = /* row_fields */List.rev(match$2[1]);
  var row_001 = /* row_more */newvar(/* None */0, /* () */0);
  var row_005 = /* row_name : Some */[/* tuple */[
      path,
      tyl
    ]];
  var row$1 = /* record */[
    row_000,
    row_001,
    /* row_bound : () */0,
    /* row_closed : false */0,
    /* row_fixed : false */0,
    row_005
  ];
  var ty$1 = newty2(current_level[0], /* Tvariant */Block.__(8, [row$1]));
  var gloc_000 = /* loc_start */loc[/* loc_start */0];
  var gloc_001 = /* loc_end */loc[/* loc_end */1];
  var gloc = /* record */[
    gloc_000,
    gloc_001,
    /* loc_ghost : true */1
  ];
  var newrecord = row$1.slice();
  var row$prime = [(newrecord[/* row_more */1] = newvar(/* None */0, /* () */0), newrecord)];
  var pats = List.map((function (param) {
          return /* record */[
                  /* pat_desc : Tpat_variant */Block.__(5, [
                      param[0],
                      param[1],
                      row$prime
                    ]),
                  /* pat_loc */gloc,
                  /* pat_extra : [] */0,
                  /* pat_type */ty$1,
                  /* pat_env */env,
                  /* pat_attributes : [] */0
                ];
        }), match$2[0]);
  if (pats) {
    var r = List.fold_left((function (pat, pat0) {
            return /* record */[
                    /* pat_desc : Tpat_or */Block.__(8, [
                        pat0,
                        pat,
                        /* Some */[row0]
                      ]),
                    /* pat_loc */gloc,
                    /* pat_extra : [] */0,
                    /* pat_type */ty$1,
                    /* pat_env */env,
                    /* pat_attributes : [] */0
                  ];
          }), pats[0], pats[1]);
    var newrecord$1 = r.slice();
    return /* tuple */[
            path,
            rp((newrecord$1[/* pat_loc */1] = loc, newrecord$1)),
            ty$1
          ];
  } else {
    throw [
          $$Error$7,
          loc,
          env,
          /* Not_a_variant_type */Block.__(30, [lid])
        ];
  }
}

function expand_path(env, _p) {
  while(true) {
    var p = _p;
    var decl;
    try {
      decl = /* Some */[find_type_full(p, env)[0]];
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        decl = /* None */0;
      } else {
        throw exn;
      }
    }
    var exit = 0;
    if (decl) {
      var match = decl[0][/* type_manifest */4];
      if (match) {
        var match$1 = repr(match[0]);
        var match$2 = match$1[/* desc */0];
        if (typeof match$2 === "number") {
          return p;
        } else if (match$2.tag === 3) {
          _p = match$2[0];
          continue ;
          
        } else {
          return p;
        }
      } else {
        exit = 1;
      }
    } else {
      exit = 1;
    }
    if (exit === 1) {
      var p$prime = normalize_path$1(/* None */0, env, p);
      if (same(p, p$prime)) {
        return p;
      } else {
        _p = p$prime;
        continue ;
        
      }
    }
    
  };
}

function compare_type_path(env, tpath1, tpath2) {
  return same(expand_path(env, tpath1), expand_path(env, tpath2));
}

function wrap_disambiguate(kind, ty, f, x) {
  try {
    return Curry._1(f, x);
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === $$Error$7) {
      var match = exn[3];
      if (typeof match === "number") {
        throw exn;
      } else if (match.tag === 13) {
        throw [
              $$Error$7,
              exn[1],
              exn[2],
              /* Wrong_name */Block.__(13, [
                  kind,
                  ty,
                  match[2],
                  match[3],
                  match[4]
                ])
            ];
      } else {
        throw exn;
      }
    } else {
      throw exn;
    }
  }
}

var type_kind = "record";

function get_type_path$1(_, d) {
  var match = d[/* lbl_res */1][/* desc */0];
  var exit = 0;
  if (typeof match === "number") {
    exit = 1;
  } else if (match.tag === 3) {
    return match[0];
  } else {
    exit = 1;
  }
  if (exit === 1) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "typecore.ml",
            602,
            11
          ]
        ];
  }
  
}

function lookup_from_type(env, tpath, lid) {
  var descrs = find_type_full(tpath, env)[1][1];
  mark_type_used(env, last(tpath), find_type_full(tpath, env)[0]);
  var match = lid[/* txt */0];
  switch (match.tag | 0) {
    case 0 : 
        var s = match[0];
        try {
          return List.find((function (nd) {
                        return +(nd[/* lbl_name */0] === s);
                      }), descrs);
        }
        catch (exn){
          if (exn === Caml_builtin_exceptions.not_found) {
            throw [
                  $$Error$7,
                  lid[/* loc */1],
                  env,
                  /* Wrong_name */Block.__(13, [
                      "",
                      newvar(/* None */0, /* () */0),
                      type_kind,
                      tpath,
                      lid[/* txt */0]
                    ])
                ];
          } else {
            throw exn;
          }
        }
        break;
    case 1 : 
    case 2 : 
        throw Caml_builtin_exceptions.not_found;
    
  }
}

function unique(eq, _acc, _param) {
  while(true) {
    var param = _param;
    var acc = _acc;
    if (param) {
      var rem = param[1];
      var x = param[0];
      if (List.exists(Curry._1(eq, x), acc)) {
        _param = rem;
        continue ;
        
      } else {
        _param = rem;
        _acc = /* :: */[
          x,
          acc
        ];
        continue ;
        
      }
    } else {
      return List.rev(acc);
    }
  };
}

function ambiguous_types(env, lbl, others) {
  var tpath = get_type_path$1(env, lbl);
  var others$1 = List.map((function (param) {
          return get_type_path$1(env, param[0]);
        }), others);
  var tpaths = unique((function (param, param$1) {
          return compare_type_path(env, param, param$1);
        }), /* :: */[
        tpath,
        /* [] */0
      ], others$1);
  if (tpaths) {
    if (tpaths[1]) {
      return List.map(string_of_path, tpaths);
    } else {
      return /* [] */0;
    }
  } else {
    return List.map(string_of_path, tpaths);
  }
}

function disambiguate_by_type(env, tpath, lbls) {
  var check_type = function (param) {
    var lbl_tpath = get_type_path$1(env, param[0]);
    return compare_type_path(env, tpath, lbl_tpath);
  };
  return List.find(check_type, lbls);
}

function disambiguate($staropt$star, $staropt$star$1, scope, lid, env, opath, lbls) {
  var warn = $staropt$star ? $staropt$star[0] : prerr_warning;
  var check_lk = $staropt$star$1 ? $staropt$star$1[0] : (function (_, _$1) {
        return /* () */0;
      });
  var scope$1 = scope ? scope[0] : lbls;
  var lbl;
  if (opath) {
    var match = opath[0];
    var pr = match[2];
    var tpath = match[1];
    var warn_pr = function () {
      var kind = type_kind === "record" ? "field" : "constructor";
      return Curry._2(warn, lid[/* loc */1], /* Not_principal */Block.__(8, ["this type-based " + (kind + " disambiguation")]));
    };
    try {
      var match$1 = disambiguate_by_type(env, tpath, scope$1);
      var lbl$1 = match$1[0];
      Curry._1(match$1[1], /* () */0);
      if (!pr) {
        if (lbls) {
          var lbl_tpath = get_type_path$1(env, lbls[0][0]);
          if (compare_type_path(env, tpath, lbl_tpath)) {
            var paths = ambiguous_types(env, lbl$1, lbls[1]);
            if (paths !== /* [] */0) {
              Curry._2(warn, lid[/* loc */1], /* Ambiguous_name */Block.__(24, [
                      /* :: */[
                        last$1(lid[/* txt */0]),
                        /* [] */0
                      ],
                      paths,
                      /* false */0
                    ]));
            }
            
          } else {
            warn_pr(/* () */0);
          }
        } else {
          warn_pr(/* () */0);
        }
      }
      lbl = lbl$1;
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        try {
          var lbl$2 = lookup_from_type(env, tpath, lid);
          Curry._2(check_lk, tpath, lbl$2);
          var s = string_of_out_ident(tree_of_path(tpath));
          Curry._2(warn, lid[/* loc */1], /* Name_out_of_scope */Block.__(23, [
                  s,
                  /* :: */[
                    last$1(lid[/* txt */0]),
                    /* [] */0
                  ],
                  /* false */0
                ]));
          if (!pr) {
            warn_pr(/* () */0);
          }
          lbl = lbl$2;
        }
        catch (exn$1){
          if (exn$1 === Caml_builtin_exceptions.not_found) {
            if (lbls) {
              var tp_000 = match[0];
              var tp_001 = expand_path(env, tpath);
              var tp = /* tuple */[
                tp_000,
                tp_001
              ];
              var tpl = List.map((function (param) {
                      var tp0 = get_type_path$1(env, param[0]);
                      var tp = expand_path(env, tp0);
                      return /* tuple */[
                              tp0,
                              tp
                            ];
                    }), lbls);
              throw [
                    $$Error$7,
                    lid[/* loc */1],
                    env,
                    /* Name_type_mismatch */Block.__(14, [
                        type_kind,
                        lid[/* txt */0],
                        tp,
                        tpl
                      ])
                  ];
            } else {
              lbl = unbound_label_error(env, lid);
            }
          } else {
            throw exn$1;
          }
        }
      } else {
        throw exn;
      }
    }
  } else if (lbls) {
    var match$2 = lbls[0];
    var lbl$3 = match$2[0];
    Curry._1(match$2[1], /* () */0);
    var paths$1 = ambiguous_types(env, lbl$3, lbls[1]);
    if (paths$1 !== /* [] */0) {
      Curry._2(warn, lid[/* loc */1], /* Ambiguous_name */Block.__(24, [
              /* :: */[
                last$1(lid[/* txt */0]),
                /* [] */0
              ],
              paths$1,
              /* false */0
            ]));
    }
    lbl = lbl$3;
  } else {
    lbl = unbound_label_error(env, lid);
  }
  var exit = 0;
  if (scope$1) {
    if (scope$1[0][0] !== lbl) {
      exit = 1;
    }
    
  } else {
    exit = 1;
  }
  if (exit === 1) {
    prerr_warning(lid[/* loc */1], /* Disambiguated_name */Block.__(25, [lbl[/* lbl_name */0]]));
  }
  return lbl;
}

function disambiguate_label_by_ids(keep, _, closed, ids, labels) {
  var check_ids = function (param) {
    var lbls = Hashtbl.create(/* None */0, 8);
    $$Array.iter((function (lbl) {
            return Hashtbl.add(lbls, lbl[/* lbl_name */0], /* () */0);
          }), param[0][/* lbl_all */5]);
    return List.for_all((function (param) {
                  return Hashtbl.mem(lbls, param);
                }), ids);
  };
  var check_closed = function (param) {
    if (closed) {
      return +(List.length(ids) === param[0][/* lbl_all */5].length);
    } else {
      return /* true */1;
    }
  };
  var labels$prime = List.filter(check_ids)(labels);
  if (keep && labels$prime === /* [] */0) {
    return /* tuple */[
            /* false */0,
            labels
          ];
  } else {
    var labels$prime$prime = List.filter(check_closed)(labels$prime);
    if (keep && labels$prime$prime === /* [] */0) {
      return /* tuple */[
              /* false */0,
              labels$prime
            ];
    } else {
      return /* tuple */[
              /* true */1,
              labels$prime$prime
            ];
    }
  }
}

function disambiguate_lid_a_list(loc, closed, env, opath, lid_a_list) {
  var ids = List.map((function (param) {
          return last$1(param[0][/* txt */0]);
        }), lid_a_list);
  var w_pr = [/* false */0];
  var w_amb = [/* [] */0];
  var w_scope = [/* [] */0];
  var w_scope_ty = [""];
  var warn = function (loc, msg) {
    if (typeof msg === "number") {
      return prerr_warning(loc, msg);
    } else {
      switch (msg.tag | 0) {
        case 8 : 
            w_pr[0] = /* true */1;
            return /* () */0;
        case 23 : 
            var match = msg[1];
            if (match && !match[1]) {
              w_scope[0] = /* :: */[
                match[0],
                w_scope[0]
              ];
              w_scope_ty[0] = msg[0];
              return /* () */0;
            } else {
              return prerr_warning(loc, msg);
            }
        case 24 : 
            var match$1 = msg[0];
            if (match$1 && !match$1[1]) {
              w_amb[0] = /* :: */[
                /* tuple */[
                  match$1[0],
                  msg[1]
                ],
                w_amb[0]
              ];
              return /* () */0;
            } else {
              return prerr_warning(loc, msg);
            }
        default:
          return prerr_warning(loc, msg);
      }
    }
  };
  var process_label = function (lid) {
    var scope = find_all_labels(env, lid[/* loc */1], lid[/* txt */0]);
    if (opath === /* None */0 && scope === /* [] */0) {
      unbound_label_error(env, lid);
    }
    var match;
    var exit = 0;
    if (opath && opath[0][2] !== 0) {
      match = /* tuple */[
        /* true */1,
        scope
      ];
    } else {
      exit = 1;
    }
    if (exit === 1) {
      match = disambiguate_label_by_ids(+(opath === /* None */0), env, closed, ids, scope);
    }
    var labels = match[1];
    if (match[0]) {
      return disambiguate(/* Some */[warn], /* None */0, /* Some */[scope], lid, env, opath, labels);
    } else {
      return List.hd(labels)[0];
    }
  };
  var lbl_a_list = List.map((function (param) {
          var lid = param[0];
          return /* tuple */[
                  lid,
                  process_label(lid),
                  param[1]
                ];
        }), lid_a_list);
  if (w_pr[0]) {
    prerr_warning(loc, /* Not_principal */Block.__(8, ["this type-based record disambiguation"]));
  } else {
    var amb = List.rev(w_amb[0]);
    if (amb) {
      var paths = List.map((function (param) {
              return get_type_path$1(env, param[1]);
            }), lbl_a_list);
      var path = List.hd(paths);
      if (List.for_all((function (param) {
                return compare_type_path(env, path, param);
              }), List.tl(paths))) {
        prerr_warning(loc, /* Ambiguous_name */Block.__(24, [
                List.map((function (prim) {
                        return prim[0];
                      }), amb),
                amb[0][1],
                /* true */1
              ]));
      } else {
        List.iter((function (param) {
                return prerr_warning(loc, /* Ambiguous_name */Block.__(24, [
                              /* :: */[
                                param[0],
                                /* [] */0
                              ],
                              param[1],
                              /* false */0
                            ]));
              }), amb);
      }
    }
    
  }
  if (w_scope[0] !== /* [] */0) {
    prerr_warning(loc, /* Name_out_of_scope */Block.__(23, [
            w_scope_ty[0],
            List.rev(w_scope[0]),
            /* true */1
          ]));
  }
  return lbl_a_list;
}

function find_record_qual(_param) {
  while(true) {
    var param = _param;
    if (param) {
      var match = param[0][0][/* txt */0];
      switch (match.tag | 0) {
        case 1 : 
            return /* Some */[match[0]];
        case 0 : 
        case 2 : 
            _param = param[1];
            continue ;
            
      }
    } else {
      return /* None */0;
    }
  };
}

function type_label_a_list(labels, loc, closed, env, type_lbl_a, opath, lid_a_list) {
  var lbl_a_list;
  var exit = 0;
  if (lid_a_list) {
    var match = lid_a_list[0][0][/* txt */0];
    switch (match.tag | 0) {
      case 0 : 
          if (labels) {
            var labels$1 = labels[0];
            if (Hashtbl.mem(labels$1, match[0])) {
              lbl_a_list = List.map((function (param) {
                      var lid = param[0];
                      var match = lid[/* txt */0];
                      switch (match.tag | 0) {
                        case 0 : 
                            return /* tuple */[
                                    lid,
                                    Hashtbl.find(labels$1, match[0]),
                                    param[1]
                                  ];
                        case 1 : 
                        case 2 : 
                            throw [
                                  Caml_builtin_exceptions.assert_failure,
                                  [
                                    "typecore.ml",
                                    819,
                                    17
                                  ]
                                ];
                        
                      }
                    }), lid_a_list);
            } else {
              exit = 1;
            }
          } else {
            exit = 1;
          }
          break;
      case 1 : 
      case 2 : 
          exit = 1;
          break;
      
    }
  } else {
    exit = 1;
  }
  if (exit === 1) {
    var match$1 = find_record_qual(lid_a_list);
    var lid_a_list$1;
    if (match$1) {
      var modname = match$1[0];
      lid_a_list$1 = List.map((function (lid_a) {
              var lid = lid_a[0];
              var match = lid[/* txt */0];
              switch (match.tag | 0) {
                case 0 : 
                    return /* tuple */[
                            /* record */[
                              /* txt : Ldot */Block.__(1, [
                                  modname,
                                  match[0]
                                ]),
                              /* loc */lid[/* loc */1]
                            ],
                            lid_a[1]
                          ];
                case 1 : 
                case 2 : 
                    return lid_a;
                
              }
            }), lid_a_list);
    } else {
      lid_a_list$1 = lid_a_list;
    }
    lbl_a_list = disambiguate_lid_a_list(loc, closed, env, opath, lid_a_list$1);
  }
  var lbl_a_list$1 = List.sort((function (param, param$1) {
          return Caml_obj.caml_int_compare(param[1][/* lbl_pos */4], param$1[1][/* lbl_pos */4]);
        }), lbl_a_list);
  return List.map(type_lbl_a, lbl_a_list$1);
}

function check_recordpat_labels(loc, lbl_pat_list, closed) {
  if (lbl_pat_list) {
    var all = lbl_pat_list[0][1][/* lbl_all */5];
    var defined = Caml_array.caml_make_vect(all.length, /* false */0);
    var check_defined = function (param) {
      var label = param[1];
      if (Caml_array.caml_array_get(defined, label[/* lbl_pos */4])) {
        throw [
              $$Error$7,
              loc,
              empty,
              /* Label_multiply_defined */Block.__(10, [label[/* lbl_name */0]])
            ];
      } else {
        return Caml_array.caml_array_set(defined, label[/* lbl_pos */4], /* true */1);
      }
    };
    List.iter(check_defined, lbl_pat_list);
    if (closed === /* Closed */0 && is_active(/* Non_closed_record_pattern */Block.__(4, [""]))) {
      var $$undefined = /* [] */0;
      for(var i = 0 ,i_finish = all.length - 1 | 0; i <= i_finish; ++i){
        if (!Caml_array.caml_array_get(defined, i)) {
          $$undefined = /* :: */[
            Caml_array.caml_array_get(all, i)[/* lbl_name */0],
            $$undefined
          ];
        }
        
      }
      if ($$undefined !== /* [] */0) {
        var u = $$String.concat(", ", List.rev($$undefined));
        return prerr_warning(loc, /* Non_closed_record_pattern */Block.__(4, [u]));
      } else {
        return 0;
      }
    } else {
      return 0;
    }
  } else {
    return /* () */0;
  }
}

var type_kind$1 = "variant";

function get_type_path$2(_, d) {
  var match = d[/* cstr_res */1][/* desc */0];
  var exit = 0;
  if (typeof match === "number") {
    exit = 1;
  } else if (match.tag === 3) {
    return match[0];
  } else {
    exit = 1;
  }
  if (exit === 1) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "typecore.ml",
            602,
            11
          ]
        ];
  }
  
}

function lookup_from_type$1(env, tpath, lid) {
  var descrs = find_type_full(tpath, env)[1][0];
  mark_type_used(env, last(tpath), find_type_full(tpath, env)[0]);
  var match = lid[/* txt */0];
  switch (match.tag | 0) {
    case 0 : 
        var s = match[0];
        try {
          return List.find((function (nd) {
                        return +(nd[/* cstr_name */0] === s);
                      }), descrs);
        }
        catch (exn){
          if (exn === Caml_builtin_exceptions.not_found) {
            throw [
                  $$Error$7,
                  lid[/* loc */1],
                  env,
                  /* Wrong_name */Block.__(13, [
                      "",
                      newvar(/* None */0, /* () */0),
                      type_kind$1,
                      tpath,
                      lid[/* txt */0]
                    ])
                ];
          } else {
            throw exn;
          }
        }
        break;
    case 1 : 
    case 2 : 
        throw Caml_builtin_exceptions.not_found;
    
  }
}

function unique$1(eq, _acc, _param) {
  while(true) {
    var param = _param;
    var acc = _acc;
    if (param) {
      var rem = param[1];
      var x = param[0];
      if (List.exists(Curry._1(eq, x), acc)) {
        _param = rem;
        continue ;
        
      } else {
        _param = rem;
        _acc = /* :: */[
          x,
          acc
        ];
        continue ;
        
      }
    } else {
      return List.rev(acc);
    }
  };
}

function ambiguous_types$1(env, lbl, others) {
  var tpath = get_type_path$2(env, lbl);
  var others$1 = List.map((function (param) {
          return get_type_path$2(env, param[0]);
        }), others);
  var tpaths = unique$1((function (param, param$1) {
          return compare_type_path(env, param, param$1);
        }), /* :: */[
        tpath,
        /* [] */0
      ], others$1);
  if (tpaths) {
    if (tpaths[1]) {
      return List.map(string_of_path, tpaths);
    } else {
      return /* [] */0;
    }
  } else {
    return List.map(string_of_path, tpaths);
  }
}

function disambiguate_by_type$1(env, tpath, lbls) {
  var check_type = function (param) {
    var lbl_tpath = get_type_path$2(env, param[0]);
    return compare_type_path(env, tpath, lbl_tpath);
  };
  return List.find(check_type, lbls);
}

function disambiguate$1($staropt$star, $staropt$star$1, scope, lid, env, opath, lbls) {
  var warn = $staropt$star ? $staropt$star[0] : prerr_warning;
  var check_lk = $staropt$star$1 ? $staropt$star$1[0] : (function (_, _$1) {
        return /* () */0;
      });
  var scope$1 = scope ? scope[0] : lbls;
  var lbl;
  if (opath) {
    var match = opath[0];
    var pr = match[2];
    var tpath = match[1];
    var warn_pr = function () {
      var kind = type_kind$1 === "record" ? "field" : "constructor";
      return Curry._2(warn, lid[/* loc */1], /* Not_principal */Block.__(8, ["this type-based " + (kind + " disambiguation")]));
    };
    try {
      var match$1 = disambiguate_by_type$1(env, tpath, scope$1);
      var lbl$1 = match$1[0];
      Curry._1(match$1[1], /* () */0);
      if (!pr) {
        if (lbls) {
          var lbl_tpath = get_type_path$2(env, lbls[0][0]);
          if (compare_type_path(env, tpath, lbl_tpath)) {
            var paths = ambiguous_types$1(env, lbl$1, lbls[1]);
            if (paths !== /* [] */0) {
              Curry._2(warn, lid[/* loc */1], /* Ambiguous_name */Block.__(24, [
                      /* :: */[
                        last$1(lid[/* txt */0]),
                        /* [] */0
                      ],
                      paths,
                      /* false */0
                    ]));
            }
            
          } else {
            warn_pr(/* () */0);
          }
        } else {
          warn_pr(/* () */0);
        }
      }
      lbl = lbl$1;
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        try {
          var lbl$2 = lookup_from_type$1(env, tpath, lid);
          Curry._2(check_lk, tpath, lbl$2);
          var s = string_of_out_ident(tree_of_path(tpath));
          Curry._2(warn, lid[/* loc */1], /* Name_out_of_scope */Block.__(23, [
                  s,
                  /* :: */[
                    last$1(lid[/* txt */0]),
                    /* [] */0
                  ],
                  /* false */0
                ]));
          if (!pr) {
            warn_pr(/* () */0);
          }
          lbl = lbl$2;
        }
        catch (exn$1){
          if (exn$1 === Caml_builtin_exceptions.not_found) {
            if (lbls) {
              var tp_000 = match[0];
              var tp_001 = expand_path(env, tpath);
              var tp = /* tuple */[
                tp_000,
                tp_001
              ];
              var tpl = List.map((function (param) {
                      var tp0 = get_type_path$2(env, param[0]);
                      var tp = expand_path(env, tp0);
                      return /* tuple */[
                              tp0,
                              tp
                            ];
                    }), lbls);
              throw [
                    $$Error$7,
                    lid[/* loc */1],
                    env,
                    /* Name_type_mismatch */Block.__(14, [
                        type_kind$1,
                        lid[/* txt */0],
                        tp,
                        tpl
                      ])
                  ];
            } else {
              lbl = unbound_constructor_error(env, lid);
            }
          } else {
            throw exn$1;
          }
        }
      } else {
        throw exn;
      }
    }
  } else if (lbls) {
    var match$2 = lbls[0];
    var lbl$3 = match$2[0];
    Curry._1(match$2[1], /* () */0);
    var paths$1 = ambiguous_types$1(env, lbl$3, lbls[1]);
    if (paths$1 !== /* [] */0) {
      Curry._2(warn, lid[/* loc */1], /* Ambiguous_name */Block.__(24, [
              /* :: */[
                last$1(lid[/* txt */0]),
                /* [] */0
              ],
              paths$1,
              /* false */0
            ]));
    }
    lbl = lbl$3;
  } else {
    lbl = unbound_constructor_error(env, lid);
  }
  var exit = 0;
  if (scope$1) {
    if (scope$1[0][0] !== lbl) {
      exit = 1;
    }
    
  } else {
    exit = 1;
  }
  if (exit === 1) {
    prerr_warning(lid[/* loc */1], /* Disambiguated_name */Block.__(25, [lbl[/* cstr_name */0]]));
  }
  return lbl;
}

function unify_head_only(loc, env, ty, constr) {
  var match = instance_constructor(/* None */0, constr);
  var ty_res = match[1];
  var match$1 = repr(ty_res)[/* desc */0];
  if (typeof match$1 === "number") {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "typecore.ml",
            892,
            9
          ]
        ];
  } else if (match$1.tag === 3) {
    ty_res[/* desc */0] = /* Tconstr */Block.__(3, [
        match$1[0],
        List.map((function () {
                return newvar(/* None */0, /* () */0);
              }), match$1[1]),
        match$1[2]
      ]);
    enforce_constraints(env, ty_res);
    return unify_pat_types(loc, env, ty_res, ty);
  } else {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "typecore.ml",
            892,
            9
          ]
        ];
  }
}

function type_pat(constrs, labels, no_existentials, mode, env, sp, expected_ty) {
  var type_pat$1 = function ($staropt$star, $staropt$star$1) {
    var mode$1 = $staropt$star ? $staropt$star[0] : mode;
    var env$1 = $staropt$star$1 ? $staropt$star$1[0] : env;
    return (function (param, param$1) {
        return type_pat(constrs, labels, no_existentials, mode$1, env$1, param, param$1);
      });
  };
  var loc = sp[/* ppat_loc */1];
  var match = sp[/* ppat_desc */0];
  if (typeof match === "number") {
    return rp(/* record */[
                /* pat_desc : Tpat_any */0,
                /* pat_loc */loc,
                /* pat_extra : [] */0,
                /* pat_type */expected_ty,
                /* pat_env */env[0],
                /* pat_attributes */sp[/* ppat_attributes */2]
              ]);
  } else {
    switch (match.tag | 0) {
      case 0 : 
          var name = match[0];
          var id = enter_variable(/* None */0, /* None */0, loc, name, expected_ty);
          return rp(/* record */[
                      /* pat_desc : Tpat_var */Block.__(0, [
                          id,
                          name
                        ]),
                      /* pat_loc */loc,
                      /* pat_extra : [] */0,
                      /* pat_type */expected_ty,
                      /* pat_env */env[0],
                      /* pat_attributes */sp[/* ppat_attributes */2]
                    ]);
      case 1 : 
          var name$1 = match[1];
          var q = type_pat$1(/* None */0, /* None */0)(match[0], expected_ty);
          begin_def(/* () */0);
          var ty_var = build_as_type(env[0], q);
          end_def(/* () */0);
          iter_generalize$1([/* [] */0], ty_var);
          var id$1 = enter_variable(/* None */0, /* Some */[/* true */1], loc, name$1, ty_var);
          return rp(/* record */[
                      /* pat_desc : Tpat_alias */Block.__(1, [
                          q,
                          id$1,
                          name$1
                        ]),
                      /* pat_loc */loc,
                      /* pat_extra : [] */0,
                      /* pat_type */q[/* pat_type */3],
                      /* pat_env */env[0],
                      /* pat_attributes */sp[/* ppat_attributes */2]
                    ]);
      case 2 : 
          var cst = match[0];
          unify_pat_types(loc, env[0], type_constant(cst), expected_ty);
          return rp(/* record */[
                      /* pat_desc : Tpat_constant */Block.__(2, [cst]),
                      /* pat_loc */loc,
                      /* pat_extra : [] */0,
                      /* pat_type */expected_ty,
                      /* pat_env */env[0],
                      /* pat_attributes */sp[/* ppat_attributes */2]
                    ]);
      case 3 : 
          var match$1 = match[0];
          if (match$1.tag === 1) {
            var match$2 = match[1];
            if (match$2.tag === 1) {
              var c2 = match$2[0];
              var c1 = match$1[0];
              var gloc_000 = /* loc_start */loc[/* loc_start */0];
              var gloc_001 = /* loc_end */loc[/* loc_end */1];
              var gloc = /* record */[
                gloc_000,
                gloc_001,
                /* loc_ghost : true */1
              ];
              var loop = function (c1, c2) {
                if (c1 === c2) {
                  return constant(/* Some */[gloc], /* None */0, /* Const_char */Block.__(1, [c1]));
                } else {
                  return or_(/* Some */[gloc], /* None */0, constant(/* Some */[gloc], /* None */0, /* Const_char */Block.__(1, [c1])), loop(Char.chr(c1 + 1 | 0), c2));
                }
              };
              var p = c1 <= c2 ? loop(c1, c2) : loop(c2, c1);
              var p_000 = /* ppat_desc */p[/* ppat_desc */0];
              var p_002 = /* ppat_attributes */p[/* ppat_attributes */2];
              var p$1 = /* record */[
                p_000,
                /* ppat_loc */loc,
                p_002
              ];
              return type_pat$1(/* None */0, /* None */0)(p$1, expected_ty);
            } else {
              throw [
                    $$Error$7,
                    loc,
                    env[0],
                    /* Invalid_interval */5
                  ];
            }
          } else {
            throw [
                  $$Error$7,
                  loc,
                  env[0],
                  /* Invalid_interval */5
                ];
          }
          break;
      case 4 : 
          var spl = match[0];
          if (List.length(spl) < 2) {
            ill_formed_ast(loc, "Tuples must have at least 2 components.");
          }
          var spl_ann = List.map((function (p) {
                  return /* tuple */[
                          p,
                          newvar(/* None */0, /* () */0)
                        ];
                }), spl);
          var desc = /* Ttuple */Block.__(2, [List.map((function (prim) {
                      return prim[1];
                    }), spl_ann)]);
          var ty = newty2(current_level[0], desc);
          unify_pat_types(loc, env[0], ty, expected_ty);
          var pl = List.map((function (param) {
                  return type_pat$1(/* None */0, /* None */0)(param[0], param[1]);
                }), spl_ann);
          return rp(/* record */[
                      /* pat_desc : Tpat_tuple */Block.__(3, [pl]),
                      /* pat_loc */loc,
                      /* pat_extra : [] */0,
                      /* pat_type */expected_ty,
                      /* pat_env */env[0],
                      /* pat_attributes */sp[/* ppat_attributes */2]
                    ]);
      case 5 : 
          var sarg = match[1];
          var lid = match[0];
          var opath;
          try {
            var match$3 = extract_concrete_variant(env[0], expected_ty);
            opath = /* Some */[/* tuple */[
                match$3[0],
                match$3[1],
                /* true */1
              ]];
          }
          catch (exn){
            if (exn === Caml_builtin_exceptions.not_found) {
              opath = /* None */0;
            } else {
              throw exn;
            }
          }
          var match$4 = lid[/* txt */0];
          var constrs$1;
          var exit = 0;
          switch (match$4.tag | 0) {
            case 0 : 
                if (constrs) {
                  var constrs$2 = constrs[0];
                  var s = match$4[0];
                  if (Hashtbl.mem(constrs$2, s)) {
                    constrs$1 = /* :: */[
                      /* tuple */[
                        Hashtbl.find(constrs$2, s),
                        (function () {
                            return /* () */0;
                          })
                      ],
                      /* [] */0
                    ];
                  } else {
                    exit = 1;
                  }
                } else {
                  exit = 1;
                }
                break;
            case 1 : 
            case 2 : 
                exit = 1;
                break;
            
          }
          if (exit === 1) {
            constrs$1 = find_all_constructors(env[0], lid[/* loc */1], lid[/* txt */0]);
          }
          var check_lk = function (tpath, constr) {
            if (constr[/* cstr_generalized */9]) {
              throw [
                    $$Error$7,
                    lid[/* loc */1],
                    env[0],
                    /* Unqualified_gadt_pattern */Block.__(34, [
                        tpath,
                        constr[/* cstr_name */0]
                      ])
                  ];
            } else {
              return 0;
            }
          };
          var partial_arg = env[0];
          var partial_arg$1 = /* Some */[check_lk];
          var constr = wrap_disambiguate("This variant pattern is expected to have", expected_ty, (function (param) {
                  return disambiguate$1(/* None */0, partial_arg$1, /* None */0, lid, partial_arg, opath, param);
                }), constrs$1);
          mark_constructor(/* Pattern */1, env[0], last$1(lid[/* txt */0]), constr);
          check_deprecated(loc, constr[/* cstr_attributes */12], constr[/* cstr_name */0]);
          if (no_existentials && constr[/* cstr_existentials */2] !== /* [] */0) {
            throw [
                  $$Error$7,
                  loc,
                  env[0],
                  /* Unexpected_existential */4
                ];
          }
          if (constr[/* cstr_generalized */9]) {
            unify_head_only(loc, env[0], expected_ty, constr);
          }
          var sargs;
          if (sarg) {
            var sp$1 = sarg[0];
            var match$5 = sp$1[/* ppat_desc */0];
            if (typeof match$5 === "number") {
              if (match$5) {
                sargs = /* :: */[
                  sp$1,
                  /* [] */0
                ];
              } else if (constr[/* cstr_arity */4] !== 1) {
                if (!constr[/* cstr_arity */4]) {
                  prerr_warning(sp$1[/* ppat_loc */1], /* Wildcard_arg_to_constant_constr */13);
                }
                sargs = replicate_list(sp$1, constr[/* cstr_arity */4]);
              } else {
                sargs = /* :: */[
                  sp$1,
                  /* [] */0
                ];
              }
            } else {
              sargs = match$5.tag === 4 ? (
                  constr[/* cstr_arity */4] > 1 || explicit_arity(sp[/* ppat_attributes */2]) ? match$5[0] : /* :: */[
                      sp$1,
                      /* [] */0
                    ]
                ) : /* :: */[
                  sp$1,
                  /* [] */0
                ];
            }
          } else {
            sargs = /* [] */0;
          }
          if (List.length(sargs) !== constr[/* cstr_arity */4]) {
            throw [
                  $$Error$7,
                  loc,
                  env[0],
                  /* Constructor_arity_mismatch */Block.__(1, [
                      lid[/* txt */0],
                      constr[/* cstr_arity */4],
                      List.length(sargs)
                    ])
                ];
          }
          var match$6 = instance_constructor(/* Some */[/* tuple */[
                  env,
                  get_newtype_level$1(/* () */0)
                ]], constr);
          var ty_res = match$6[1];
          if (constr[/* cstr_generalized */9] && mode === /* Normal */0) {
            unify_pat_types_gadt(loc, env, ty_res, expected_ty);
          } else {
            unify_pat_types(loc, env[0], ty_res, expected_ty);
          }
          var args = List.map2((function (p, t) {
                  return type_pat$1(/* None */0, /* None */0)(p, t);
                }), sargs, match$6[0]);
          return rp(/* record */[
                      /* pat_desc : Tpat_construct */Block.__(4, [
                          lid,
                          constr,
                          args
                        ]),
                      /* pat_loc */loc,
                      /* pat_extra : [] */0,
                      /* pat_type */expected_ty,
                      /* pat_env */env[0],
                      /* pat_attributes */sp[/* ppat_attributes */2]
                    ]);
      case 6 : 
          var sarg$1 = match[1];
          var l = match[0];
          var arg_type = sarg$1 ? /* :: */[
              newvar(/* None */0, /* () */0),
              /* [] */0
            ] : /* [] */0;
          var row_000 = /* row_fields : :: */[
            /* tuple */[
              l,
              /* Reither */Block.__(1, [
                  +(sarg$1 === /* None */0),
                  arg_type,
                  /* true */1,
                  [/* None */0]
                ])
            ],
            /* [] */0
          ];
          var row_001 = /* row_more */newvar(/* None */0, /* () */0);
          var row = /* record */[
            row_000,
            row_001,
            /* row_bound : () */0,
            /* row_closed : false */0,
            /* row_fixed : false */0,
            /* row_name : None */0
          ];
          unify_pat_types(loc, env[0], newty2(current_level[0], /* Tvariant */Block.__(8, [row])), expected_ty);
          var arg = sarg$1 && arg_type && !arg_type[1] ? /* Some */[type_pat$1(/* None */0, /* None */0)(sarg$1[0], arg_type[0])] : /* None */0;
          var newrecord = row.slice();
          return rp(/* record */[
                      /* pat_desc : Tpat_variant */Block.__(5, [
                          l,
                          arg,
                          [(newrecord[/* row_more */1] = newvar(/* None */0, /* () */0), newrecord)]
                        ]),
                      /* pat_loc */loc,
                      /* pat_extra : [] */0,
                      /* pat_type */expected_ty,
                      /* pat_env */env[0],
                      /* pat_attributes */sp[/* ppat_attributes */2]
                    ]);
      case 7 : 
          var closed = match[1];
          var lid_sp_list = match[0];
          if (!lid_sp_list) {
            ill_formed_ast(loc, "Records cannot be empty.");
          }
          var match$7;
          try {
            var match$8 = extract_concrete_record(env[0], expected_ty);
            match$7 = /* tuple */[
              /* Some */[/* tuple */[
                  match$8[0],
                  match$8[1],
                  /* true */1
                ]],
              expected_ty
            ];
          }
          catch (exn$1){
            if (exn$1 === Caml_builtin_exceptions.not_found) {
              match$7 = /* tuple */[
                /* None */0,
                newvar(/* None */0, /* () */0)
              ];
            } else {
              throw exn$1;
            }
          }
          var record_ty = match$7[1];
          var opath$1 = match$7[0];
          var type_label_pat = function (param) {
            var label = param[1];
            var label_lid = param[0];
            begin_def(/* () */0);
            var match = instance_label(/* false */0, label);
            var ty_arg = match[1];
            var vars = match[0];
            if (!vars) {
              end_def(/* () */0);
            }
            try {
              unify_pat_types(loc, env[0], match[2], record_ty);
            }
            catch (raw_exn){
              var exn = Js_exn.internalToOCamlException(raw_exn);
              if (exn[0] === Unify) {
                throw [
                      $$Error$7,
                      label_lid[/* loc */1],
                      env[0],
                      /* Label_mismatch */Block.__(2, [
                          label_lid[/* txt */0],
                          exn[1]
                        ])
                    ];
              } else {
                throw exn;
              }
            }
            var arg = type_pat$1(/* None */0, /* None */0)(param[2], ty_arg);
            if (vars !== /* [] */0) {
              end_def(/* () */0);
              iter_generalize$1([/* [] */0], ty_arg);
              List.iter(generalize, vars);
              var instantiated = function (tv) {
                var tv$1 = expand_head(env[0], tv);
                if (is_Tvar(tv$1)) {
                  return +(tv$1[/* level */1] !== 100000000);
                } else {
                  return /* true */1;
                }
              };
              if (List.exists(instantiated, vars)) {
                throw [
                      $$Error$7,
                      label_lid[/* loc */1],
                      env[0],
                      /* Polymorphic_label */Block.__(0, [label_lid[/* txt */0]])
                    ];
              }
              
            }
            return /* tuple */[
                    label_lid,
                    label,
                    arg
                  ];
          };
          var partial_arg$2 = env[0];
          var lbl_pat_list = wrap_disambiguate("This record pattern is expected to have", expected_ty, (function (param) {
                  return type_label_a_list(labels, loc, /* false */0, partial_arg$2, type_label_pat, opath$1, param);
                }), lid_sp_list);
          check_recordpat_labels(loc, lbl_pat_list, closed);
          unify_pat_types(loc, env[0], record_ty, expected_ty);
          return rp(/* record */[
                      /* pat_desc : Tpat_record */Block.__(6, [
                          lbl_pat_list,
                          closed
                        ]),
                      /* pat_loc */loc,
                      /* pat_extra : [] */0,
                      /* pat_type */expected_ty,
                      /* pat_env */env[0],
                      /* pat_attributes */sp[/* ppat_attributes */2]
                    ]);
      case 8 : 
          var ty_elt = newvar(/* None */0, /* () */0);
          unify_pat_types(loc, env[0], instance_def(type_array(ty_elt)), expected_ty);
          var spl_ann$1 = List.map((function (p) {
                  return /* tuple */[
                          p,
                          newvar(/* None */0, /* () */0)
                        ];
                }), match[0]);
          var pl$1 = List.map((function (param) {
                  return type_pat$1(/* None */0, /* None */0)(param[0], ty_elt);
                }), spl_ann$1);
          return rp(/* record */[
                      /* pat_desc : Tpat_array */Block.__(7, [pl$1]),
                      /* pat_loc */loc,
                      /* pat_extra : [] */0,
                      /* pat_type */expected_ty,
                      /* pat_env */env[0],
                      /* pat_attributes */sp[/* ppat_attributes */2]
                    ]);
      case 9 : 
          var initial_pattern_variables = pattern_variables[0];
          var p1 = type_pat$1(/* Some */[/* Inside_or */1], /* None */0)(match[0], expected_ty);
          var p1_variables = pattern_variables[0];
          pattern_variables[0] = initial_pattern_variables;
          var p2 = type_pat$1(/* Some */[/* Inside_or */1], /* None */0)(match[1], expected_ty);
          var p2_variables = pattern_variables[0];
          var alpha_env = enter_orpat_variables(loc, env[0], p1_variables, p2_variables);
          pattern_variables[0] = p1_variables;
          return rp(/* record */[
                      /* pat_desc : Tpat_or */Block.__(8, [
                          p1,
                          alpha_pat(alpha_env, p2),
                          /* None */0
                        ]),
                      /* pat_loc */loc,
                      /* pat_extra : [] */0,
                      /* pat_type */expected_ty,
                      /* pat_env */env[0],
                      /* pat_attributes */sp[/* ppat_attributes */2]
                    ]);
      case 10 : 
          var sp$2 = match[0];
          var match$9 = sp$2[/* ppat_desc */0];
          var exit$1 = 0;
          if (typeof match$9 === "number") {
            exit$1 = 1;
          } else if (match$9.tag) {
            exit$1 = 1;
          } else {
            var sty = match[1];
            var $js = sty[/* ptyp_desc */0];
            if (typeof $js === "number") {
              exit$1 = 1;
            } else if ($js.tag === 8) {
              var lloc = sp$2[/* ppat_loc */1];
              var name$2 = match$9[0];
              var match$10 = transl_simple_type_delayed(env[0], sty);
              var cty = match$10[0];
              var ty$1 = cty[/* ctyp_type */1];
              unify_pat_types(lloc, env[0], ty$1, expected_ty);
              pattern_force[0] = /* :: */[
                match$10[1],
                pattern_force[0]
              ];
              var match$11 = ty$1[/* desc */0];
              if (typeof match$11 === "number") {
                throw [
                      Caml_builtin_exceptions.assert_failure,
                      [
                        "typecore.ml",
                        955,
                        13
                      ]
                    ];
              } else if (match$11.tag === 10) {
                begin_def(/* () */0);
                var match$12 = instance_poly(/* Some */[/* true */1], /* false */0, match$11[1], match$11[0]);
                var ty$prime = match$12[1];
                end_def(/* () */0);
                iter_generalize$1([/* [] */0], ty$prime);
                var id$2 = enter_variable(/* None */0, /* None */0, lloc, name$2, ty$prime);
                return rp(/* record */[
                            /* pat_desc : Tpat_var */Block.__(0, [
                                id$2,
                                name$2
                              ]),
                            /* pat_loc */lloc,
                            /* pat_extra : :: */[
                              /* tuple */[
                                /* Tpat_constraint */Block.__(0, [cty]),
                                loc,
                                sp[/* ppat_attributes */2]
                              ],
                              /* [] */0
                            ],
                            /* pat_type */ty$1,
                            /* pat_env */env[0],
                            /* pat_attributes : [] */0
                          ]);
              } else {
                throw [
                      Caml_builtin_exceptions.assert_failure,
                      [
                        "typecore.ml",
                        955,
                        13
                      ]
                    ];
              }
            } else {
              exit$1 = 1;
            }
          }
          if (exit$1 === 1) {
            begin_def(/* () */0);
            var match$13 = transl_simple_type_delayed(env[0], match[1]);
            var cty$1 = match$13[0];
            var ty$2 = cty$1[/* ctyp_type */1];
            end_def(/* () */0);
            generalize_structure$1(current_level[0], ty$2);
            var match_000 = instance(/* None */0, env[0], ty$2);
            var match_001 = instance(/* None */0, env[0], ty$2);
            var ty$3 = match_000;
            unify_pat_types(loc, env[0], ty$3, expected_ty);
            var p$2 = type_pat$1(/* None */0, /* None */0)(sp$2, match_001);
            pattern_force[0] = /* :: */[
              match$13[1],
              pattern_force[0]
            ];
            var extra_000 = /* Tpat_constraint */Block.__(0, [cty$1]);
            var extra_002 = sp$2[/* ppat_attributes */2];
            var extra = /* tuple */[
              extra_000,
              loc,
              extra_002
            ];
            var match$14 = p$2[/* pat_desc */0];
            var exit$2 = 0;
            if (typeof match$14 === "number") {
              exit$2 = 2;
            } else if (match$14.tag) {
              exit$2 = 2;
            } else {
              return /* record */[
                      /* pat_desc : Tpat_alias */Block.__(1, [
                          /* record */[
                            /* pat_desc : Tpat_any */0,
                            /* pat_loc */p$2[/* pat_loc */1],
                            /* pat_extra */p$2[/* pat_extra */2],
                            /* pat_type */p$2[/* pat_type */3],
                            /* pat_env */p$2[/* pat_env */4],
                            /* pat_attributes : [] */0
                          ],
                          match$14[0],
                          match$14[1]
                        ]),
                      /* pat_loc */p$2[/* pat_loc */1],
                      /* pat_extra : :: */[
                        extra,
                        /* [] */0
                      ],
                      /* pat_type */ty$3,
                      /* pat_env */p$2[/* pat_env */4],
                      /* pat_attributes */p$2[/* pat_attributes */5]
                    ];
            }
            if (exit$2 === 2) {
              return /* record */[
                      /* pat_desc */p$2[/* pat_desc */0],
                      /* pat_loc */p$2[/* pat_loc */1],
                      /* pat_extra : :: */[
                        extra,
                        p$2[/* pat_extra */2]
                      ],
                      /* pat_type */ty$3,
                      /* pat_env */p$2[/* pat_env */4],
                      /* pat_attributes */p$2[/* pat_attributes */5]
                    ];
            }
            
          }
          break;
      case 11 : 
          var lid$1 = match[0];
          var match$15 = build_or_pat(env[0], loc, lid$1[/* txt */0]);
          var p$3 = match$15[1];
          unify_pat_types(loc, env[0], match$15[2], expected_ty);
          var newrecord$1 = p$3.slice();
          newrecord$1[/* pat_extra */2] = /* :: */[
            /* tuple */[
              /* Tpat_type */Block.__(1, [
                  match$15[0],
                  lid$1
                ]),
              loc,
              sp[/* ppat_attributes */2]
            ],
            p$3[/* pat_extra */2]
          ];
          return newrecord$1;
      case 12 : 
          var nv = newvar(/* None */0, /* () */0);
          unify_pat_types(loc, env[0], instance_def(type_lazy_t(nv)), expected_ty);
          var p1$1 = type_pat$1(/* None */0, /* None */0)(match[0], nv);
          return rp(/* record */[
                      /* pat_desc : Tpat_lazy */Block.__(9, [p1$1]),
                      /* pat_loc */loc,
                      /* pat_extra : [] */0,
                      /* pat_type */expected_ty,
                      /* pat_env */env[0],
                      /* pat_attributes */sp[/* ppat_attributes */2]
                    ]);
      case 13 : 
          var name$3 = match[0];
          var id$3 = enter_variable(/* Some */[/* true */1], /* None */0, loc, name$3, expected_ty);
          return rp(/* record */[
                      /* pat_desc : Tpat_var */Block.__(0, [
                          id$3,
                          name$3
                        ]),
                      /* pat_loc */sp[/* ppat_loc */1],
                      /* pat_extra : :: */[
                        /* tuple */[
                          /* Tpat_unpack */0,
                          loc,
                          sp[/* ppat_attributes */2]
                        ],
                        /* [] */0
                      ],
                      /* pat_type */expected_ty,
                      /* pat_env */env[0],
                      /* pat_attributes : [] */0
                    ]);
      case 14 : 
          throw [
                $$Error$7,
                loc,
                env[0],
                /* Exception_pattern_below_toplevel */8
              ];
      case 15 : 
          throw [
                Error_forward$1,
                error_of_extension(match[0])
              ];
      
    }
  }
}

function type_pat$1($staropt$star, constrs, labels, $staropt$star$1, env, sp, expected_ty) {
  var allow_existentials = $staropt$star ? $staropt$star[0] : /* false */0;
  var lev = $staropt$star$1 ? $staropt$star$1[0] : current_level[0];
  newtype_level$1[0] = /* Some */[lev];
  try {
    var r = type_pat(constrs, labels, 1 - allow_existentials, /* Normal */0, env, sp, expected_ty);
    iter_pattern((function (p) {
            p[/* pat_env */4] = env[0];
            return /* () */0;
          }), r);
    newtype_level$1[0] = /* None */0;
    return r;
  }
  catch (e){
    newtype_level$1[0] = /* None */0;
    throw e;
  }
}

function partial_pred(lev, env, expected_ty, constrs, labels, p) {
  var snap = snapshot(/* () */0);
  try {
    reset_pattern(/* None */0, /* true */1);
    var typed_p = type_pat$1(/* Some */[/* true */1], /* Some */[constrs], /* Some */[labels], /* Some */[lev], [env], p, expected_ty);
    backtrack(snap);
    return /* Some */[typed_p];
  }
  catch (exn){
    backtrack(snap);
    return /* None */0;
  }
}

function check_partial$1($staropt$star, env, expected_ty) {
  var lev = $staropt$star ? $staropt$star[0] : current_level[0];
  return (function (param, param$1) {
      var pred = function (param, param$1, param$2) {
        return partial_pred(lev, env, expected_ty, param, param$1, param$2);
      };
      var loc = param;
      var casel = param$1;
      var first_check = check_partial(loc, casel);
      if (first_check !== 0) {
        return check_partial_param((function (param, param$1, param$2) {
                      var pred$1 = pred;
                      var loc = param;
                      var casel = param$1;
                      var pss = param$2;
                      return do_check_partial(/* Some */[pred$1], exhaust_gadt$1, loc, casel, pss);
                    }), do_check_fragile_gadt, loc, casel);
      } else {
        return /* Partial */0;
      }
    });
}

function add_pattern_variables(check, check_as, env) {
  var pv = get_ref(pattern_variables);
  return /* tuple */[
          List.fold_right((function (param, env) {
                  var check$1 = param[4] ? check_as : check;
                  return add_value(check$1, param[0], /* record */[
                              /* val_type */param[1],
                              /* val_kind : Val_reg */0,
                              /* val_loc */param[3],
                              /* val_attributes : [] */0
                            ], env);
                }), pv, env),
          get_ref(module_variables)
        ];
}

function type_pattern(lev, env, spat, scope, expected_ty) {
  reset_pattern(scope, /* true */1);
  var new_env = [env];
  var pat = type_pat$1(/* Some */[/* true */1], /* None */0, /* None */0, /* Some */[lev], new_env, spat, expected_ty);
  var match = add_pattern_variables(/* Some */[(function (s) {
            return /* Unused_var_strict */Block.__(13, [s]);
          })], /* Some */[(function (s) {
            return /* Unused_var */Block.__(12, [s]);
          })], new_env[0]);
  return /* tuple */[
          pat,
          match[0],
          get_ref(pattern_force),
          match[1]
        ];
}

function type_pattern_list(env, spatl, scope, expected_tys, allow) {
  reset_pattern(scope, allow);
  var new_env = [env];
  var patl = List.map2((function (param, param$1) {
          return type_pat$1(/* None */0, /* None */0, /* None */0, /* None */0, new_env, param, param$1);
        }), spatl, expected_tys);
  var match = add_pattern_variables(/* None */0, /* None */0, new_env[0]);
  return /* tuple */[
          patl,
          match[0],
          get_ref(pattern_force),
          match[1]
        ];
}

function type_class_arg_pattern(cl_num, val_env, met_env, l, spat) {
  reset_pattern(/* None */0, /* false */0);
  var nv = newvar(/* None */0, /* () */0);
  var pat = type_pat$1(/* None */0, /* None */0, /* None */0, /* None */0, [val_env], spat, nv);
  if (has_variants(pat)) {
    pressure_variants$1(val_env, /* :: */[
          pat,
          /* [] */0
        ]);
    iter_pattern(finalize_variant, pat);
  }
  List.iter((function (f) {
          return Curry._1(f, /* () */0);
        }), get_ref(pattern_force));
  if (is_optional(l)) {
    unify_pat(val_env, pat, type_option$1(newvar(/* None */0, /* () */0)));
  }
  var match = List.fold_right((function (param, param$1) {
          var as_var = param[4];
          var ty = param[1];
          var id = param[0];
          var check = function (s) {
            if (as_var) {
              return /* Unused_var */Block.__(12, [s]);
            } else {
              return /* Unused_var_strict */Block.__(13, [s]);
            }
          };
          var id$prime = create(id[/* name */1]);
          return /* tuple */[
                  /* :: */[
                    /* tuple */[
                      id$prime,
                      param[2],
                      id,
                      ty
                    ],
                    param$1[0]
                  ],
                  add_value(/* Some */[check], id$prime, /* record */[
                        /* val_type */ty,
                        /* val_kind : Val_ivar */Block.__(1, [
                            /* Immutable */0,
                            cl_num
                          ]),
                        /* val_loc */param[3],
                        /* val_attributes : [] */0
                      ], param$1[1])
                ];
        }), pattern_variables[0], /* tuple */[
        /* [] */0,
        met_env
      ]);
  var match$1 = add_pattern_variables(/* None */0, /* None */0, val_env);
  return /* tuple */[
          pat,
          match[0],
          match$1[0],
          match[1]
        ];
}

function type_self_pattern(cl_num, privty, val_env, met_env, par_env, spat) {
  var spat$1 = mk$1(/* None */0, /* None */0, /* Ppat_alias */Block.__(1, [
          mk$1(/* None */0, /* None */0, /* Ppat_alias */Block.__(1, [
                  spat,
                  /* record */[
                    /* txt */"selfpat-*",
                    /* loc */none
                  ]
                ])),
          /* record */[
            /* txt */"selfpat-" + cl_num,
            /* loc */none
          ]
        ]));
  reset_pattern(/* None */0, /* false */0);
  var nv = newvar(/* None */0, /* () */0);
  var pat = type_pat$1(/* None */0, /* None */0, /* None */0, /* None */0, [val_env], spat$1, nv);
  List.iter((function (f) {
          return Curry._1(f, /* () */0);
        }), get_ref(pattern_force));
  var meths = [/* Empty */0];
  var vars = [/* Empty */0];
  var pv = pattern_variables[0];
  pattern_variables[0] = /* [] */0;
  var match = List.fold_right((function (param, param$1) {
          var as_var = param[4];
          var loc = param[3];
          var ty = param[1];
          var id = param[0];
          return /* tuple */[
                  add_value(/* None */0, id, /* record */[
                        /* val_type */ty,
                        /* val_kind : Val_unbound */1,
                        /* val_loc */loc,
                        /* val_attributes : [] */0
                      ], param$1[0]),
                  add_value(/* Some */[(function (s) {
                            if (as_var) {
                              return /* Unused_var */Block.__(12, [s]);
                            } else {
                              return /* Unused_var_strict */Block.__(13, [s]);
                            }
                          })], id, /* record */[
                        /* val_type */ty,
                        /* val_kind : Val_self */Block.__(2, [
                            meths,
                            vars,
                            cl_num,
                            privty
                          ]),
                        /* val_loc */loc,
                        /* val_attributes : [] */0
                      ], param$1[1]),
                  add_value(/* None */0, id, /* record */[
                        /* val_type */ty,
                        /* val_kind : Val_unbound */1,
                        /* val_loc */loc,
                        /* val_attributes : [] */0
                      ], param$1[2])
                ];
        }), pv, /* tuple */[
        val_env,
        met_env,
        par_env
      ]);
  return /* tuple */[
          pat,
          meths,
          vars,
          match[0],
          match[1],
          match[2]
        ];
}

var delayed_checks = [/* [] */0];

function add_delayed_check(f) {
  delayed_checks[0] = /* :: */[
    /* tuple */[
      f,
      current[0]
    ],
    delayed_checks[0]
  ];
  return /* () */0;
}

function force_delayed_checks() {
  var snap = snapshot(/* () */0);
  var w_old = current[0];
  List.iter((function (param) {
          current[0] = param[1];
          return Curry._1(param[0], /* () */0);
        }), List.rev(delayed_checks[0]));
  current[0] = w_old;
  delayed_checks[0] = /* [] */0;
  return backtrack(snap);
}

function final_subexpression(_sexp) {
  while(true) {
    var sexp = _sexp;
    var match = sexp[/* pexp_desc */0];
    switch (match.tag | 0) {
      case 2 : 
          _sexp = match[2];
          continue ;
          case 6 : 
          var match$1 = match[1];
          if (match$1) {
            _sexp = match$1[0][/* pc_rhs */2];
            continue ;
            
          } else {
            return sexp;
          }
          break;
      case 7 : 
          _sexp = match[0];
          continue ;
          case 15 : 
      case 16 : 
          _sexp = match[1];
          continue ;
          default:
        return sexp;
    }
  };
}

function is_nonexpansive(_exp) {
  while(true) {
    var exp = _exp;
    var match = exp[/* exp_desc */0];
    switch (match.tag | 0) {
      case 2 : 
          if (List.for_all((function (vb) {
                    return is_nonexpansive(vb[/* vb_expr */1]);
                  }), match[1])) {
            _exp = match[2];
            continue ;
            
          } else {
            return /* false */0;
          }
          break;
      case 0 : 
      case 1 : 
      case 3 : 
          return /* true */1;
      case 4 : 
          var match$1 = match[1];
          if (match$1 && !(match$1[0][1] || !is_nonexpansive(match[0]))) {
            return List.for_all(is_nonexpansive_opt, List.map(snd3, match$1[1]));
          } else {
            return /* false */0;
          }
      case 5 : 
          if (match[2] || !is_nonexpansive(match[0])) {
            return /* false */0;
          } else {
            return List.for_all((function (param) {
                          if (is_nonexpansive_opt(param[/* c_guard */1])) {
                            return is_nonexpansive(param[/* c_rhs */2]);
                          } else {
                            return /* false */0;
                          }
                        }), match[1]);
          }
      case 7 : 
          return List.for_all(is_nonexpansive, match[0]);
      case 8 : 
          return List.for_all(is_nonexpansive, match[2]);
      case 9 : 
          return is_nonexpansive_opt(match[1]);
      case 10 : 
          if (List.for_all((function (param) {
                    return param[1][/* lbl_mut */3] ? /* false */0 : is_nonexpansive(param[2]);
                  }), match[0])) {
            return is_nonexpansive_opt(match[1]);
          } else {
            return /* false */0;
          }
      case 13 : 
          if (match[0]) {
            return /* false */0;
          } else {
            return /* true */1;
          }
      case 14 : 
          if (is_nonexpansive(match[1])) {
            return is_nonexpansive_opt(match[2]);
          } else {
            return /* false */0;
          }
      case 15 : 
          _exp = match[1];
          continue ;
          case 19 : 
          if (class_type_arity(match[2][/* cty_type */1]) > 0) {
            return /* true */1;
          } else {
            return /* false */0;
          }
      case 23 : 
          if (is_nonexpansive_mod(match[2])) {
            _exp = match[3];
            continue ;
            
          } else {
            return /* false */0;
          }
          break;
      case 11 : 
      case 25 : 
          _exp = match[0];
          continue ;
          case 26 : 
          var match$2 = match[0];
          var count = [0];
          if (List.for_all((function(count){
                return function (field) {
                  var match = field[/* cf_desc */0];
                  switch (match.tag | 0) {
                    case 0 : 
                        return /* false */0;
                    case 1 : 
                        var match$1 = match[3];
                        count[0] = count[0] + 1 | 0;
                        return match$1.tag ? is_nonexpansive(match$1[1]) : /* true */1;
                        break;
                    case 4 : 
                        return is_nonexpansive(match[0]);
                    default:
                      return /* true */1;
                  }
                }
                }(count)), match$2[/* cstr_fields */1]) && fold((function(count){
                return function (_, param, b) {
                  count[0] = count[0] - 1 | 0;
                  return b ? +(param[0] === /* Immutable */0) : /* false */0;
                }
                }(count)), match$2[/* cstr_type */2][/* csig_vars */1], /* true */1)) {
            return +(count[0] === 0);
          } else {
            return /* false */0;
          }
      case 27 : 
          return is_nonexpansive_mod(match[0]);
      default:
        return /* false */0;
    }
  };
}

function is_nonexpansive_mod(_mexp) {
  while(true) {
    var mexp = _mexp;
    var match = mexp[/* mod_desc */0];
    switch (match.tag | 0) {
      case 1 : 
          return List.for_all((function (item) {
                        var match = item[/* str_desc */0];
                        switch (match.tag | 0) {
                          case 1 : 
                              return List.for_all((function (vb) {
                                            return is_nonexpansive(vb[/* vb_expr */1]);
                                          }), match[1]);
                          case 4 : 
                              return List.for_all((function (param) {
                                            if (param[/* ext_kind */3].tag) {
                                              return /* true */1;
                                            } else {
                                              return /* false */0;
                                            }
                                          }), match[0][/* tyext_constructors */3]);
                          case 5 : 
                              if (match[0][/* ext_kind */3].tag) {
                                return /* true */1;
                              } else {
                                return /* false */0;
                              }
                              break;
                          case 6 : 
                              return is_nonexpansive_mod(match[0][/* mb_expr */2]);
                          case 7 : 
                              return List.for_all((function (param) {
                                            return is_nonexpansive_mod(param[/* mb_expr */2]);
                                          }), match[0]);
                          case 10 : 
                              return /* false */0;
                          case 12 : 
                              return is_nonexpansive_mod(match[0][/* incl_mod */0]);
                          case 13 : 
                              return /* true */1;
                          default:
                            return /* true */1;
                        }
                      }), match[0][/* str_items */0]);
      case 0 : 
      case 2 : 
          return /* true */1;
      case 3 : 
          return /* false */0;
      case 4 : 
          _mexp = match[0];
          continue ;
          case 5 : 
          return is_nonexpansive(match[0]);
      
    }
  };
}

function is_nonexpansive_opt(param) {
  if (param) {
    return is_nonexpansive(param[0]);
  } else {
    return /* true */1;
  }
}

function approx_type(env, _sty) {
  while(true) {
    var sty = _sty;
    var match = sty[/* ptyp_desc */0];
    if (typeof match === "number") {
      return newvar(/* None */0, /* () */0);
    } else {
      switch (match.tag | 0) {
        case 1 : 
            var p = match[0];
            var ty1 = is_optional(p) ? type_option$1(newvar(/* None */0, /* () */0)) : newvar(/* None */0, /* () */0);
            var desc_002 = approx_type(env, match[2]);
            var desc = /* Tarrow */Block.__(1, [
                p,
                ty1,
                desc_002,
                /* Cok */0
              ]);
            return newty2(current_level[0], desc);
        case 2 : 
            var desc$1 = /* Ttuple */Block.__(2, [List.map((function (param) {
                        return approx_type(env, param);
                      }), match[0])]);
            return newty2(current_level[0], desc$1);
        case 3 : 
            var ctl = match[1];
            try {
              var match$1 = lookup_type$1(match[0][/* txt */0], env);
              if (List.length(ctl) !== match$1[1][/* type_arity */1]) {
                throw Caml_builtin_exceptions.not_found;
              }
              var tyl = List.map((function (param) {
                      return approx_type(env, param);
                    }), ctl);
              return newconstr(match$1[0], tyl);
            }
            catch (exn){
              if (exn === Caml_builtin_exceptions.not_found) {
                return newvar(/* None */0, /* () */0);
              } else {
                throw exn;
              }
            }
            break;
        case 8 : 
            _sty = match[1];
            continue ;
            default:
          return newvar(/* None */0, /* () */0);
      }
    }
  };
}

function type_approx(env, _sexp) {
  while(true) {
    var sexp = _sexp;
    var match = sexp[/* pexp_desc */0];
    switch (match.tag | 0) {
      case 2 : 
          _sexp = match[2];
          continue ;
          case 3 : 
          var match$1 = match[0];
          if (match$1) {
            var desc_001 = newvar(/* None */0, /* () */0);
            var desc_002 = type_approx(env, match$1[0][/* pc_rhs */2]);
            var desc = /* Tarrow */Block.__(1, [
                "",
                desc_001,
                desc_002,
                /* Cok */0
              ]);
            return newty2(current_level[0], desc);
          } else {
            return newvar(/* None */0, /* () */0);
          }
          break;
      case 4 : 
          var e = match[3];
          var p = match[0];
          if (is_optional(p)) {
            var desc_001$1 = type_option$1(newvar(/* None */0, /* () */0));
            var desc_002$1 = type_approx(env, e);
            var desc$1 = /* Tarrow */Block.__(1, [
                p,
                desc_001$1,
                desc_002$1,
                /* Cok */0
              ]);
            return newty2(current_level[0], desc$1);
          } else {
            var desc_001$2 = newvar(/* None */0, /* () */0);
            var desc_002$2 = type_approx(env, e);
            var desc$2 = /* Tarrow */Block.__(1, [
                p,
                desc_001$2,
                desc_002$2,
                /* Cok */0
              ]);
            return newty2(current_level[0], desc$2);
          }
          break;
      case 6 : 
          var match$2 = match[1];
          if (match$2) {
            _sexp = match$2[0][/* pc_rhs */2];
            continue ;
            
          } else {
            return newvar(/* None */0, /* () */0);
          }
          break;
      case 7 : 
          _sexp = match[0];
          continue ;
          case 8 : 
          var desc$3 = /* Ttuple */Block.__(2, [List.map((function (param) {
                      return type_approx(env, param);
                    }), match[0])]);
          return newty2(current_level[0], desc$3);
      case 15 : 
      case 16 : 
          _sexp = match[1];
          continue ;
          case 19 : 
          var ty = type_approx(env, match[0]);
          var ty1 = approx_type(env, match[1]);
          try {
            unify$2(env, ty, ty1);
          }
          catch (raw_exn){
            var exn = Js_exn.internalToOCamlException(raw_exn);
            if (exn[0] === Unify) {
              throw [
                    $$Error$7,
                    sexp[/* pexp_loc */1],
                    env,
                    /* Expr_type_clash */Block.__(7, [exn[1]])
                  ];
            } else {
              throw exn;
            }
          }
          return ty1;
      case 20 : 
          var approx_ty_opt = function (param) {
            if (param) {
              return approx_type(env, param[0]);
            } else {
              return newvar(/* None */0, /* () */0);
            }
          };
          var ty$1 = type_approx(env, match[0]);
          var ty1$1 = approx_ty_opt(match[1]);
          var ty2 = approx_type(env, match[2]);
          try {
            unify$2(env, ty$1, ty1$1);
          }
          catch (raw_exn$1){
            var exn$1 = Js_exn.internalToOCamlException(raw_exn$1);
            if (exn$1[0] === Unify) {
              throw [
                    $$Error$7,
                    sexp[/* pexp_loc */1],
                    env,
                    /* Expr_type_clash */Block.__(7, [exn$1[1]])
                  ];
            } else {
              throw exn$1;
            }
          }
          return ty2;
      default:
        return newvar(/* None */0, /* () */0);
    }
  };
}

function list_labels(env, ty) {
  return wrap_trace_gadt_instances(env, (function (param) {
                var env$1 = env;
                var _visited = /* [] */0;
                var _ls = /* [] */0;
                var _ty_fun = param;
                while(true) {
                  var ty_fun = _ty_fun;
                  var ls = _ls;
                  var visited = _visited;
                  var ty = expand_head(env$1, ty_fun);
                  if (List.memq(ty, visited)) {
                    return /* tuple */[
                            List.rev(ls),
                            /* false */0
                          ];
                  } else {
                    var match = ty[/* desc */0];
                    if (typeof match === "number") {
                      return /* tuple */[
                              List.rev(ls),
                              is_Tvar(ty)
                            ];
                    } else if (match.tag === 1) {
                      _ty_fun = match[2];
                      _ls = /* :: */[
                        match[0],
                        ls
                      ];
                      _visited = /* :: */[
                        ty,
                        visited
                      ];
                      continue ;
                      
                    } else {
                      return /* tuple */[
                              List.rev(ls),
                              is_Tvar(ty)
                            ];
                    }
                  }
                };
              }), ty);
}

function check_univars(env, expans, kind, exp, ty_expected, vars) {
  if (expans && !is_nonexpansive(exp)) {
    generalize_expansive$1(env, exp[/* exp_type */3]);
  }
  var vars$1 = List.map((function (param) {
          return expand_head(env, param);
        }), vars);
  var vars$2 = List.map((function (param) {
          return expand_head(env, param);
        }), vars$1);
  var vars$prime = List.filter((function (t) {
            var t$1 = repr(t);
            iter_generalize$1([/* [] */0], t$1);
            var match = t$1[/* desc */0];
            if (typeof match === "number" || !(!match.tag && t$1[/* level */1] === 100000000)) {
              return /* false */0;
            } else {
              log_type(t$1);
              t$1[/* desc */0] = /* Tunivar */Block.__(9, [match[0]]);
              return /* true */1;
            }
          }))(vars$2);
  if (List.length(vars$2) === List.length(vars$prime)) {
    return /* () */0;
  } else {
    var ty = newty2(100000000, /* Tpoly */Block.__(10, [
            repr(exp[/* exp_type */3]),
            vars$prime
          ]));
    var ty_expected$1 = repr(ty_expected);
    throw [
          $$Error$7,
          exp[/* exp_loc */1],
          env,
          /* Less_general */Block.__(31, [
              kind,
              /* :: */[
                /* tuple */[
                  ty,
                  ty
                ],
                /* :: */[
                  /* tuple */[
                    ty_expected$1,
                    ty_expected$1
                  ],
                  /* [] */0
                ]
              ]
            ])
        ];
  }
}

function check_application_result(env, statement, exp) {
  var loc = exp[/* exp_loc */1];
  var match = expand_head(env, exp[/* exp_type */3])[/* desc */0];
  var exit = 0;
  if (typeof match === "number") {
    exit = 1;
  } else {
    switch (match.tag | 0) {
      case 0 : 
          return /* () */0;
      case 1 : 
          return prerr_warning(exp[/* exp_loc */1], /* Partial_application */2);
      case 3 : 
          if (same(match[0], path_unit)) {
            return /* () */0;
          } else {
            exit = 1;
          }
          break;
      default:
        exit = 1;
    }
  }
  if (exit === 1) {
    if (statement) {
      return prerr_warning(loc, /* Statement_type */4);
    } else {
      return 0;
    }
  }
  
}

function generalizable(level, ty) {
  var check = function (ty) {
    var ty$1 = repr(ty);
    if (ty$1[/* level */1] < 0) {
      return /* () */0;
    } else if (ty$1[/* level */1] <= level) {
      throw Pervasives.Exit;
    } else {
      mark_type_node(ty$1);
      return iter_type_expr(check, ty$1);
    }
  };
  try {
    check(ty);
    unmark_type(ty);
    return /* true */1;
  }
  catch (exn){
    if (exn === Pervasives.Exit) {
      unmark_type(ty);
      return /* false */0;
    } else {
      throw exn;
    }
  }
}

var self_coercion = [/* [] */0];

function wrap_unpacks(sexp, unpacks) {
  return List.fold_left((function (sexp, param) {
                var name = param[0];
                return Curry._5(Ast_helper_004[/* letmodule */27], /* Some */[sexp[/* pexp_loc */1]], /* None */0, name, unpack$1(/* Some */[param[1]], /* None */0, Curry._3(Ast_helper_004[/* ident */2], /* Some */[name[/* loc */1]], /* None */0, /* record */[
                                    /* txt : Lident */Block.__(0, [name[/* txt */0]]),
                                    /* loc */name[/* loc */1]
                                  ])), sexp);
              }), sexp, unpacks);
}

function contains_variant_either(ty) {
  var loop = function (ty) {
    var ty$1 = repr(ty);
    if (ty$1[/* level */1] >= 0) {
      mark_type_node(ty$1);
      var match = ty$1[/* desc */0];
      if (typeof match === "number") {
        return iter_type_expr(loop, ty$1);
      } else if (match.tag === 8) {
        var row = row_repr_aux(/* [] */0, match[0]);
        if (!row[/* row_fixed */4]) {
          List.iter((function (param) {
                  var match = row_field_repr_aux(/* [] */0, param[1]);
                  if (typeof match === "number") {
                    return /* () */0;
                  } else if (match.tag) {
                    throw Pervasives.Exit;
                  } else {
                    return /* () */0;
                  }
                }), row[/* row_fields */0]);
        }
        return iter_row(loop, row);
      } else {
        return iter_type_expr(loop, ty$1);
      }
    } else {
      return 0;
    }
  };
  try {
    loop(ty);
    unmark_type(ty);
    return /* false */0;
  }
  catch (exn){
    if (exn === Pervasives.Exit) {
      unmark_type(ty);
      return /* true */1;
    } else {
      throw exn;
    }
  }
}

function iter_ppat(f, p) {
  var match = p[/* ppat_desc */0];
  if (typeof match === "number") {
    return /* () */0;
  } else {
    switch (match.tag | 0) {
      case 5 : 
      case 6 : 
          return may(f, match[1]);
      case 7 : 
          return List.iter((function (param) {
                        return Curry._1(f, param[1]);
                      }), match[0]);
      case 4 : 
      case 8 : 
          return List.iter(f, match[0]);
      case 9 : 
          Curry._1(f, match[0]);
          return Curry._1(f, match[1]);
      case 1 : 
      case 10 : 
      case 12 : 
      case 14 : 
          return Curry._1(f, match[0]);
      default:
        return /* () */0;
    }
  }
}

function contains_polymorphic_variant(p) {
  var loop = function (p) {
    var match = p[/* ppat_desc */0];
    if (typeof match === "number") {
      return iter_ppat(loop, p);
    } else {
      switch (match.tag | 0) {
        case 6 : 
        case 11 : 
            throw Pervasives.Exit;
        default:
          return iter_ppat(loop, p);
      }
    }
  };
  try {
    loop(p);
    return /* false */0;
  }
  catch (exn){
    if (exn === Pervasives.Exit) {
      return /* true */1;
    } else {
      throw exn;
    }
  }
}

function contains_gadt(env, p) {
  var loop = function (p) {
    var match = p[/* ppat_desc */0];
    if (typeof match === "number") {
      return iter_ppat(loop, p);
    } else if (match.tag === 5) {
      try {
        var cstrs = lookup_all_constructors$1(match[0][/* txt */0], env);
        List.iter((function (param) {
                if (param[0][/* cstr_generalized */9]) {
                  throw Pervasives.Exit;
                } else {
                  return 0;
                }
              }), cstrs);
      }
      catch (exn){
        if (exn !== Caml_builtin_exceptions.not_found) {
          throw exn;
        }
        
      }
      return iter_ppat(loop, p);
    } else {
      return iter_ppat(loop, p);
    }
  };
  try {
    loop(p);
    return /* false */0;
  }
  catch (exn){
    if (exn === Pervasives.Exit) {
      return /* true */1;
    } else {
      throw exn;
    }
  }
}

function check_absent_variant(env) {
  return (function (param) {
      return iter_pattern((function (pat) {
                    var match = pat[/* pat_desc */0];
                    if (typeof match === "number") {
                      return /* () */0;
                    } else if (match.tag === 5) {
                      var arg = match[1];
                      var s = match[0];
                      var row = row_repr_aux(/* [] */0, match[2][0]);
                      if (List.exists((function (param) {
                                if (s === param[0]) {
                                  return +(row_field_repr_aux(/* [] */0, param[1]) !== /* Rabsent */0);
                                } else {
                                  return /* false */0;
                                }
                              }), row[/* row_fields */0]) || !row[/* row_fixed */4] && !static_row(row)) {
                        return /* () */0;
                      } else {
                        var ty_arg = arg ? /* :: */[
                            duplicate_type(arg[0][/* pat_type */3]),
                            /* [] */0
                          ] : /* [] */0;
                        var row$prime_000 = /* row_fields : :: */[
                          /* tuple */[
                            s,
                            /* Reither */Block.__(1, [
                                +(arg === /* None */0),
                                ty_arg,
                                /* true */1,
                                [/* None */0]
                              ])
                          ],
                          /* [] */0
                        ];
                        var row$prime_001 = /* row_more */newvar(/* None */0, /* () */0);
                        var row$prime = /* record */[
                          row$prime_000,
                          row$prime_001,
                          /* row_bound : () */0,
                          /* row_closed : false */0,
                          /* row_fixed : false */0,
                          /* row_name : None */0
                        ];
                        var newrecord = pat.slice();
                        return unify_pat(env, (newrecord[/* pat_type */3] = newty2(current_level[0], /* Tvariant */Block.__(8, [row$prime])), newrecord), duplicate_type(pat[/* pat_type */3]));
                      }
                    } else {
                      return /* () */0;
                    }
                  }), param);
    });
}

function duplicate_ident_types(_, caselist, env) {
  var caselist$1 = List.filter((function (param) {
            return contains_gadt(env, param[/* pc_lhs */0]);
          }))(caselist);
  var idents = all_idents_cases(caselist$1);
  return List.fold_left((function (env, s) {
                try {
                  var match = lookup_value$1(/* Lident */Block.__(0, [s]), env);
                  var desc = match[1];
                  var path = match[0];
                  switch (path.tag | 0) {
                    case 0 : 
                        var desc_000 = /* val_type */duplicate_type(desc[/* val_type */0]);
                        var desc_001 = /* val_kind */desc[/* val_kind */1];
                        var desc_002 = /* val_loc */desc[/* val_loc */2];
                        var desc_003 = /* val_attributes */desc[/* val_attributes */3];
                        var desc$1 = /* record */[
                          desc_000,
                          desc_001,
                          desc_002,
                          desc_003
                        ];
                        return add_value(/* None */0, path[0], desc$1, env);
                    case 1 : 
                    case 2 : 
                        return env;
                    
                  }
                }
                catch (exn){
                  if (exn === Caml_builtin_exceptions.not_found) {
                    return env;
                  } else {
                    throw exn;
                  }
                }
              }), env, idents);
}

function unify_exp(env, exp, expected_ty) {
  return unify_exp_types(exp[/* exp_loc */1], env, exp[/* exp_type */3], expected_ty);
}

function type_exp(env, sexp) {
  return type_expect(/* None */0, env, sexp, newvar(/* None */0, /* () */0));
}

function type_expect(in_function, env, sexp, ty_expected) {
  var previous_saved_types = saved_types[0];
  warning_enter_scope(/* () */0);
  warning_attribute(sexp[/* pexp_attributes */2]);
  var exp = type_expect_(in_function, env, sexp, ty_expected);
  warning_leave_scope(/* () */0);
  saved_types[0] = /* :: */[
    /* Partial_expression */Block.__(2, [exp]),
    previous_saved_types
  ];
  return exp;
}

function type_expect_(in_function, env, sexp, ty_expected) {
  var loc = sexp[/* pexp_loc */1];
  var rue = function (exp) {
    unify_exp(env, re(exp), instance(/* None */0, env, ty_expected));
    return exp;
  };
  var match = sexp[/* pexp_desc */0];
  switch (match.tag | 0) {
    case 0 : 
        var lid = match[0];
        var match$1 = find_value$1(env, loc, lid[/* txt */0]);
        var desc = match$1[1];
        var path = match$1[0];
        if (annotations[0]) {
          var dloc = desc[/* val_loc */2];
          var annot = dloc[/* loc_ghost */2] ? /* Iref_external */0 : /* Iref_internal */Block.__(0, [dloc]);
          var name$1 = name(/* Some */[parenthesized_ident], path);
          record$2(/* An_ident */Block.__(5, [
                  loc,
                  name$1,
                  annot
                ]));
        }
        var match$2 = desc[/* val_kind */1];
        var $js;
        if (typeof match$2 === "number") {
          if (match$2 === 1) {
            throw [
                  $$Error$7,
                  loc,
                  env,
                  /* Masked_instance_variable */Block.__(29, [lid[/* txt */0]])
                ];
          } else {
            $js = /* Texp_ident */Block.__(0, [
                path,
                lid,
                desc
              ]);
          }
        } else {
          switch (match$2.tag | 0) {
            case 1 : 
                var match$3 = lookup_value$1(/* Lident */Block.__(0, ["self-" + match$2[1]]), env);
                var match$4 = lid[/* txt */0];
                var $js$1;
                switch (match$4.tag | 0) {
                  case 0 : 
                      $js$1 = /* record */[
                        /* txt */match$4[0],
                        /* loc */lid[/* loc */1]
                      ];
                      break;
                  case 1 : 
                  case 2 : 
                      throw [
                            Caml_builtin_exceptions.assert_failure,
                            [
                              "typecore.ml",
                              1773,
                              38
                            ]
                          ];
                  
                }
                $js = /* Texp_instvar */Block.__(20, [
                    match$3[0],
                    path,
                    $js$1
                  ]);
                break;
            case 2 : 
                var match$5 = lookup_value$1(/* Lident */Block.__(0, ["self-" + match$2[2]]), env);
                $js = /* Texp_ident */Block.__(0, [
                    match$5[0],
                    lid,
                    desc
                  ]);
                break;
            default:
              $js = /* Texp_ident */Block.__(0, [
                  path,
                  lid,
                  desc
                ]);
          }
        }
        return rue(/* record */[
                    /* exp_desc */$js,
                    /* exp_loc */loc,
                    /* exp_extra : [] */0,
                    /* exp_type */instance(/* None */0, env, desc[/* val_type */0]),
                    /* exp_env */env,
                    /* exp_attributes */sexp[/* pexp_attributes */2]
                  ]);
    case 1 : 
        var cst = match[0];
        if (cst.tag === 2) {
          var ty_exp = expand_head(env, ty_expected);
          var fmt6_path_000 = /* Pident */Block.__(0, [/* record */[
                /* stamp */0,
                /* name */"CamlinternalFormatBasics",
                /* flags */1
              ]]);
          var fmt6_path = /* Pdot */Block.__(1, [
              fmt6_path_000,
              "format6",
              0
            ]);
          var match$6 = ty_exp[/* desc */0];
          var is_format;
          if (typeof match$6 === "number") {
            is_format = /* false */0;
          } else if (match$6.tag === 3) {
            if (same(match$6[0], fmt6_path)) {
              if (principal[0] && ty_exp[/* level */1] !== 100000000) {
                prerr_warning(loc, /* Not_principal */Block.__(8, ["this coercion to format6"]));
              }
              is_format = /* true */1;
            } else {
              is_format = /* false */0;
            }
          } else {
            is_format = /* false */0;
          }
          if (is_format) {
            var init = type_format(loc, cst[0], env);
            var format_parsetree_000 = /* pexp_desc */init[/* pexp_desc */0];
            var format_parsetree_001 = /* pexp_loc */sexp[/* pexp_loc */1];
            var format_parsetree_002 = /* pexp_attributes */init[/* pexp_attributes */2];
            var format_parsetree = /* record */[
              format_parsetree_000,
              format_parsetree_001,
              format_parsetree_002
            ];
            return type_expect(in_function, env, format_parsetree, ty_expected);
          } else {
            return rue(/* record */[
                        /* exp_desc : Texp_constant */Block.__(1, [cst]),
                        /* exp_loc */loc,
                        /* exp_extra : [] */0,
                        /* exp_type */instance_def(type_string),
                        /* exp_env */env,
                        /* exp_attributes */sexp[/* pexp_attributes */2]
                      ]);
          }
        } else {
          return rue(/* record */[
                      /* exp_desc : Texp_constant */Block.__(1, [cst]),
                      /* exp_loc */loc,
                      /* exp_extra : [] */0,
                      /* exp_type */type_constant(cst),
                      /* exp_env */env,
                      /* exp_attributes */sexp[/* pexp_attributes */2]
                    ]);
        }
        break;
    case 2 : 
        var rec_flag = match[0];
        var exit = 0;
        if (rec_flag !== 0) {
          exit = 1;
        } else {
          var match$7 = match[1];
          if (match$7) {
            var match$8 = match$7[0];
            if (match$8[/* pvb_attributes */2]) {
              exit = 1;
            } else if (match$7[1]) {
              exit = 1;
            } else {
              var spat = match$8[/* pvb_pat */0];
              if (contains_gadt(env, spat)) {
                return type_expect(in_function, env, /* record */[
                            /* pexp_desc : Pexp_match */Block.__(6, [
                                match$8[/* pvb_expr */1],
                                /* :: */[
                                  Curry._3(Ast_helper_004[/* case */36], spat, /* None */0, match[2]),
                                  /* [] */0
                                ]
                              ]),
                            /* pexp_loc */sexp[/* pexp_loc */1],
                            /* pexp_attributes */sexp[/* pexp_attributes */2]
                          ], ty_expected);
              } else {
                exit = 1;
              }
            }
          } else {
            exit = 1;
          }
        }
        if (exit === 1) {
          var sbody = match[2];
          var match$9 = sexp[/* pexp_attributes */2];
          var scp;
          var exit$1 = 0;
          if (match$9 && match$9[0][0][/* txt */0] === "#default" && !match$9[1]) {
            scp = /* None */0;
          } else {
            exit$1 = 2;
          }
          if (exit$1 === 2) {
            scp = rec_flag !== 0 ? /* Some */[/* Idef */Block.__(1, [loc])] : /* Some */[/* Idef */Block.__(1, [sbody[/* pexp_loc */1]])];
          }
          var match$10 = type_let(/* None */0, /* None */0, env, rec_flag, match[1], scp, /* true */1);
          var body = type_expect(/* None */0, match$10[1], wrap_unpacks(sbody, match$10[2]), ty_expected);
          return re(/* record */[
                      /* exp_desc : Texp_let */Block.__(2, [
                          rec_flag,
                          match$10[0],
                          body
                        ]),
                      /* exp_loc */loc,
                      /* exp_extra : [] */0,
                      /* exp_type */body[/* exp_type */3],
                      /* exp_env */env,
                      /* exp_attributes */sexp[/* pexp_attributes */2]
                    ]);
        }
        break;
    case 3 : 
        return type_function(in_function, loc, sexp[/* pexp_attributes */2], env, ty_expected, "", match[0]);
    case 4 : 
        var match$11 = match[1];
        var l = match[0];
        if (match$11) {
          var $$default = match$11[0];
          if (!is_optional(l)) {
            throw [
                  Caml_builtin_exceptions.assert_failure,
                  [
                    "typecore.ml",
                    1852,
                    6
                  ]
                ];
          }
          var default_loc = $$default[/* pexp_loc */1];
          var scases_000 = Curry._3(Ast_helper_004[/* case */36], construct(/* Some */[default_loc], /* None */0, /* record */[
                    /* txt : Ldot */Block.__(1, [
                        /* Lident */Block.__(0, ["*predef*"]),
                        "Some"
                      ]),
                    /* loc */none
                  ], /* Some */[$$var$1(/* Some */[default_loc], /* None */0, /* record */[
                          /* txt */"*sth*",
                          /* loc */none
                        ])]), /* None */0, Curry._3(Ast_helper_004[/* ident */2], /* Some */[default_loc], /* None */0, /* record */[
                    /* txt : Lident */Block.__(0, ["*sth*"]),
                    /* loc */none
                  ]));
          var scases_001 = /* :: */[
            Curry._3(Ast_helper_004[/* case */36], construct(/* Some */[default_loc], /* None */0, /* record */[
                      /* txt : Ldot */Block.__(1, [
                          /* Lident */Block.__(0, ["*predef*"]),
                          "None"
                        ]),
                      /* loc */none
                    ], /* None */0), /* None */0, $$default),
            /* [] */0
          ];
          var scases = /* :: */[
            scases_000,
            scases_001
          ];
          var smatch = Curry._4(Ast_helper_004[/* match_ */8], /* Some */[loc], /* None */0, Curry._3(Ast_helper_004[/* ident */2], /* Some */[loc], /* None */0, /* record */[
                    /* txt : Lident */Block.__(0, ["*opt*"]),
                    /* loc */none
                  ]), scases);
          var sfun = Curry._6(Ast_helper_004[/* fun_ */5], /* Some */[loc], /* None */0, l, /* None */0, $$var$1(/* Some */[loc], /* None */0, /* record */[
                    /* txt */"*opt*",
                    /* loc */none
                  ]), Curry._5(Ast_helper_004[/* let_ */4], /* Some */[loc], /* Some */[/* :: */[
                      /* tuple */[
                        /* record */[
                          /* txt */"#default",
                          /* loc */none
                        ],
                        /* PStr */Block.__(0, [/* [] */0])
                      ],
                      /* [] */0
                    ]], /* Nonrecursive */0, /* :: */[
                    mk$17(/* None */0, /* None */0, /* None */0, /* None */0, match[2], smatch),
                    /* [] */0
                  ], match[3]));
          return type_expect(in_function, env, sfun, ty_expected);
        } else {
          var sexp$1 = match[3];
          return type_function(in_function, loc, sexp$1[/* pexp_attributes */2], env, ty_expected, l, /* :: */[
                      /* record */[
                        /* pc_lhs */match[2],
                        /* pc_guard : None */0,
                        /* pc_rhs */sexp$1
                      ],
                      /* [] */0
                    ]);
        }
        break;
    case 5 : 
        var sargs = match[1];
        if (!sargs) {
          ill_formed_ast(loc, "Function application with no argument.");
        }
        begin_def(/* () */0);
        if (principal[0]) {
          begin_def(/* () */0);
        }
        var funct = type_exp(env, match[0]);
        if (principal[0]) {
          end_def(/* () */0);
          generalize_structure$1(current_level[0], funct[/* exp_type */3]);
        }
        var ty = instance(/* None */0, env, funct[/* exp_type */3]);
        end_def(/* () */0);
        wrap_trace_gadt_instances(env, (function (param) {
                var _seen = /* [] */0;
                var _ty_fun = param;
                while(true) {
                  var ty_fun = _ty_fun;
                  var seen = _seen;
                  var ty = expand_head(env, ty_fun);
                  if (List.memq(ty, seen)) {
                    return /* () */0;
                  } else {
                    var match = ty[/* desc */0];
                    if (typeof match === "number") {
                      return /* () */0;
                    } else if (match.tag === 1) {
                      try {
                        unify_var(env, newvar(/* None */0, /* () */0), match[1]);
                      }
                      catch (raw_exn){
                        var exn = Js_exn.internalToOCamlException(raw_exn);
                        if (exn[0] === Unify) {
                          throw [
                                Caml_builtin_exceptions.assert_failure,
                                [
                                  "typecore.ml",
                                  1903,
                                  65
                                ]
                              ];
                        } else {
                          throw exn;
                        }
                      }
                      _ty_fun = match[2];
                      _seen = /* :: */[
                        ty,
                        seen
                      ];
                      continue ;
                      
                    } else {
                      return /* () */0;
                    }
                  }
                };
              }), ty);
        begin_def(/* () */0);
        var match$12 = type_application(env, funct, sargs);
        end_def(/* () */0);
        unify_var(env, newvar(/* None */0, /* () */0), funct[/* exp_type */3]);
        return rue(/* record */[
                    /* exp_desc : Texp_apply */Block.__(4, [
                        funct,
                        match$12[0]
                      ]),
                    /* exp_loc */loc,
                    /* exp_extra : [] */0,
                    /* exp_type */match$12[1],
                    /* exp_env */env,
                    /* exp_attributes */sexp[/* pexp_attributes */2]
                  ]);
    case 6 : 
        begin_def(/* () */0);
        var arg = type_exp(env, match[0]);
        end_def(/* () */0);
        if (is_nonexpansive(arg)) {
          iter_generalize$1([/* [] */0], arg[/* exp_type */3]);
        } else {
          generalize_expansive$1(env, arg[/* exp_type */3]);
        }
        var split_cases = function (_vc, _ec, _param) {
          while(true) {
            var param = _param;
            var ec = _ec;
            var vc = _vc;
            if (param) {
              var c = param[0];
              var match = c[/* pc_lhs */0][/* ppat_desc */0];
              var exit = 0;
              if (typeof match === "number") {
                exit = 1;
              } else if (match.tag === 14) {
                _param = param[1];
                _ec = /* :: */[
                  /* record */[
                    /* pc_lhs */match[0],
                    /* pc_guard */c[/* pc_guard */1],
                    /* pc_rhs */c[/* pc_rhs */2]
                  ],
                  ec
                ];
                continue ;
                
              } else {
                exit = 1;
              }
              if (exit === 1) {
                _param = param[1];
                _vc = /* :: */[
                  c,
                  vc
                ];
                continue ;
                
              }
              
            } else {
              return /* tuple */[
                      List.rev(vc),
                      List.rev(ec)
                    ];
            }
          };
        };
        var match$13 = split_cases(/* [] */0, /* [] */0, match[1]);
        var exn_caselist = match$13[1];
        var val_caselist = match$13[0];
        if (val_caselist === /* [] */0 && exn_caselist !== /* [] */0) {
          throw [
                $$Error$7,
                loc,
                env,
                /* No_value_clauses */7
              ];
        }
        var match$14 = type_cases(/* None */0, env, arg[/* exp_type */3], ty_expected, /* true */1, loc, val_caselist);
        var match$15 = type_cases(/* None */0, env, type_exn, ty_expected, /* false */0, loc, exn_caselist);
        return re(/* record */[
                    /* exp_desc : Texp_match */Block.__(5, [
                        arg,
                        match$14[0],
                        match$15[0],
                        match$14[1]
                      ]),
                    /* exp_loc */loc,
                    /* exp_extra : [] */0,
                    /* exp_type */instance(/* None */0, env, ty_expected),
                    /* exp_env */env,
                    /* exp_attributes */sexp[/* pexp_attributes */2]
                  ]);
    case 7 : 
        var body$1 = type_expect(/* None */0, env, match[0], ty_expected);
        var match$16 = type_cases(/* None */0, env, type_exn, ty_expected, /* false */0, loc, match[1]);
        return re(/* record */[
                    /* exp_desc : Texp_try */Block.__(6, [
                        body$1,
                        match$16[0]
                      ]),
                    /* exp_loc */loc,
                    /* exp_extra : [] */0,
                    /* exp_type */body$1[/* exp_type */3],
                    /* exp_env */env,
                    /* exp_attributes */sexp[/* pexp_attributes */2]
                  ]);
    case 8 : 
        var sexpl = match[0];
        if (List.length(sexpl) < 2) {
          ill_formed_ast(loc, "Tuples must have at least 2 components.");
        }
        var subtypes = List.map((function () {
                return newty2(100000000, /* Tvar */Block.__(0, [/* None */0]));
              }), sexpl);
        var to_unify = newty2(100000000, /* Ttuple */Block.__(2, [subtypes]));
        unify_exp_types(loc, env, to_unify, ty_expected);
        var expl = List.map2((function (body, ty) {
                return type_expect(/* None */0, env, body, ty);
              }), sexpl, subtypes);
        var desc$1 = /* Ttuple */Block.__(2, [List.map((function (e) {
                    return e[/* exp_type */3];
                  }), expl)]);
        return re(/* record */[
                    /* exp_desc : Texp_tuple */Block.__(7, [expl]),
                    /* exp_loc */loc,
                    /* exp_extra : [] */0,
                    /* exp_type */newty2(current_level[0], desc$1),
                    /* exp_env */env,
                    /* exp_attributes */sexp[/* pexp_attributes */2]
                  ]);
    case 9 : 
        var env$1 = env;
        var loc$1 = loc;
        var lid$1 = match[0];
        var sarg = match[1];
        var ty_expected$1 = ty_expected;
        var attrs = sexp[/* pexp_attributes */2];
        var opath;
        try {
          var match$17 = extract_concrete_variant(env$1, ty_expected$1);
          opath = /* Some */[/* tuple */[
              match$17[0],
              match$17[1],
              +(ty_expected$1[/* level */1] === 100000000) || 1 - principal[0]
            ]];
        }
        catch (exn){
          if (exn === Caml_builtin_exceptions.not_found) {
            opath = /* None */0;
          } else {
            throw exn;
          }
        }
        var constrs = find_all_constructors(env$1, lid$1[/* loc */1], lid$1[/* txt */0]);
        var constr = wrap_disambiguate("This variant expression is expected to have", ty_expected$1, (function (param) {
                return disambiguate$1(/* None */0, /* None */0, /* None */0, lid$1, env$1, opath, param);
              }), constrs);
        mark_constructor(/* Positive */0, env$1, last$1(lid$1[/* txt */0]), constr);
        check_deprecated(loc$1, constr[/* cstr_attributes */12], constr[/* cstr_name */0]);
        var sargs$1;
        if (sarg) {
          var se = sarg[0];
          var match$18 = se[/* pexp_desc */0];
          sargs$1 = match$18.tag === 8 ? (
              constr[/* cstr_arity */4] > 1 || explicit_arity(attrs) ? match$18[0] : /* :: */[
                  se,
                  /* [] */0
                ]
            ) : /* :: */[
              se,
              /* [] */0
            ];
        } else {
          sargs$1 = /* [] */0;
        }
        if (List.length(sargs$1) !== constr[/* cstr_arity */4]) {
          throw [
                $$Error$7,
                loc$1,
                env$1,
                /* Constructor_arity_mismatch */Block.__(1, [
                    lid$1[/* txt */0],
                    constr[/* cstr_arity */4],
                    List.length(sargs$1)
                  ])
              ];
        }
        var separate = principal[0] || env$1[/* local_constraints */11];
        if (separate) {
          begin_def(/* () */0);
          begin_def(/* () */0);
        }
        var match$19 = instance_constructor(/* None */0, constr);
        var ty_res = match$19[1];
        var ty_args = match$19[0];
        var texp = re(/* record */[
              /* exp_desc : Texp_construct */Block.__(8, [
                  lid$1,
                  constr,
                  /* [] */0
                ]),
              /* exp_loc */loc$1,
              /* exp_extra : [] */0,
              /* exp_type */ty_res,
              /* exp_env */env$1,
              /* exp_attributes */attrs
            ]);
        if (separate) {
          end_def(/* () */0);
          generalize_structure$1(current_level[0], ty_res);
          var newrecord = texp.slice();
          unify_exp(env$1, (newrecord[/* exp_type */3] = instance_def(ty_res), newrecord), instance(/* None */0, env$1, ty_expected$1));
          end_def(/* () */0);
          List.iter(generalize_structure$2, ty_args);
          generalize_structure$1(current_level[0], ty_res);
        }
        var match$20 = instance_list(env$1, /* :: */[
              ty_res,
              ty_args
            ]);
        var match$21;
        if (match$20) {
          match$21 = /* tuple */[
            match$20[1],
            match$20[0]
          ];
        } else {
          throw [
                Caml_builtin_exceptions.assert_failure,
                [
                  "typecore.ml",
                  3373,
                  11
                ]
              ];
        }
        var ty_res$1 = match$21[1];
        var newrecord$1 = texp.slice();
        newrecord$1[/* exp_type */3] = ty_res$1;
        if (!separate) {
          unify_exp(env$1, newrecord$1, instance(/* None */0, env$1, ty_expected$1));
        }
        var args = List.map2((function (e, param) {
                return type_argument(env$1, e, param[0], param[1]);
              }), sargs$1, List.combine(ty_args, match$21[0]));
        if (!constr[/* cstr_private */10]) {
          throw [
                $$Error$7,
                loc$1,
                env$1,
                /* Private_type */Block.__(19, [ty_res$1])
              ];
        }
        var newrecord$2 = newrecord$1.slice();
        newrecord$2[/* exp_desc */0] = /* Texp_construct */Block.__(8, [
            lid$1,
            constr,
            args
          ]);
        return newrecord$2;
    case 10 : 
        var sarg$1 = match[1];
        var l$1 = match[0];
        var ty_expected0 = instance(/* None */0, env, ty_expected);
        try {
          var match$22 = expand_head(env, ty_expected);
          var match$23 = expand_head(env, ty_expected0);
          if (sarg$1) {
            var match$24 = match$22[/* desc */0];
            if (typeof match$24 === "number") {
              throw Caml_builtin_exceptions.not_found;
            } else if (match$24.tag === 8) {
              var match$25 = match$23[/* desc */0];
              if (typeof match$25 === "number") {
                throw Caml_builtin_exceptions.not_found;
              } else if (match$25.tag === 8) {
                var row = row_repr_aux(/* [] */0, match$24[0]);
                var match$26 = row_field_repr_aux(/* [] */0, List.assoc(l$1, row[/* row_fields */0]));
                var match$27 = row_field_repr_aux(/* [] */0, List.assoc(l$1, match$25[0][/* row_fields */0]));
                if (typeof match$26 === "number") {
                  throw Caml_builtin_exceptions.not_found;
                } else if (match$26.tag) {
                  throw Caml_builtin_exceptions.not_found;
                } else {
                  var match$28 = match$26[0];
                  if (match$28) {
                    if (typeof match$27 === "number") {
                      throw Caml_builtin_exceptions.not_found;
                    } else if (match$27.tag) {
                      throw Caml_builtin_exceptions.not_found;
                    } else {
                      var match$29 = match$27[0];
                      if (match$29) {
                        var arg$1 = type_argument(env, sarg$1[0], match$28[0], match$29[0]);
                        return re(/* record */[
                                    /* exp_desc : Texp_variant */Block.__(9, [
                                        l$1,
                                        /* Some */[arg$1]
                                      ]),
                                    /* exp_loc */loc,
                                    /* exp_extra : [] */0,
                                    /* exp_type */ty_expected0,
                                    /* exp_env */env,
                                    /* exp_attributes */sexp[/* pexp_attributes */2]
                                  ]);
                      } else {
                        throw Caml_builtin_exceptions.not_found;
                      }
                    }
                  } else {
                    throw Caml_builtin_exceptions.not_found;
                  }
                }
              } else {
                throw Caml_builtin_exceptions.not_found;
              }
            } else {
              throw Caml_builtin_exceptions.not_found;
            }
          } else {
            throw Caml_builtin_exceptions.not_found;
          }
        }
        catch (exn$1){
          if (exn$1 === Caml_builtin_exceptions.not_found) {
            var arg$2 = may_map((function (param) {
                    return type_exp(env, param);
                  }), sarg$1);
            var arg_type = may_map((function (arg) {
                    return arg[/* exp_type */3];
                  }), arg$2);
            var desc$2 = /* Tvariant */Block.__(8, [/* record */[
                  /* row_fields : :: */[
                    /* tuple */[
                      l$1,
                      /* Rpresent */Block.__(0, [arg_type])
                    ],
                    /* [] */0
                  ],
                  /* row_more */newvar(/* None */0, /* () */0),
                  /* row_bound : () */0,
                  /* row_closed : false */0,
                  /* row_fixed : false */0,
                  /* row_name : None */0
                ]]);
            return rue(/* record */[
                        /* exp_desc : Texp_variant */Block.__(9, [
                            l$1,
                            arg$2
                          ]),
                        /* exp_loc */loc,
                        /* exp_extra : [] */0,
                        /* exp_type */newty2(current_level[0], desc$2),
                        /* exp_env */env,
                        /* exp_attributes */sexp[/* pexp_attributes */2]
                      ]);
          } else {
            throw exn$1;
          }
        }
        break;
    case 11 : 
        var opt_sexp = match[1];
        var lid_sexp_list = match[0];
        if (!lid_sexp_list) {
          ill_formed_ast(loc, "Records cannot be empty.");
        }
        var opt_exp;
        if (opt_sexp) {
          if (principal[0]) {
            begin_def(/* () */0);
          }
          var exp = type_exp(env, opt_sexp[0]);
          if (principal[0]) {
            end_def(/* () */0);
            generalize_structure$1(current_level[0], exp[/* exp_type */3]);
          }
          opt_exp = /* Some */[exp];
        } else {
          opt_exp = /* None */0;
        }
        var get_path = function (ty) {
          try {
            var match = extract_concrete_record(env, ty);
            return /* Some */[/* tuple */[
                      match[0],
                      match[1],
                      +(ty[/* level */1] === 100000000) || 1 - principal[0]
                    ]];
          }
          catch (exn){
            if (exn === Caml_builtin_exceptions.not_found) {
              return /* None */0;
            } else {
              throw exn;
            }
          }
        };
        var op = get_path(ty_expected);
        var match$30;
        if (op) {
          match$30 = /* tuple */[
            ty_expected,
            op
          ];
        } else if (opt_exp) {
          var op$1 = get_path(opt_exp[0][/* exp_type */3]);
          if (op$1) {
            var p$prime = op$1[0][1];
            var decl = find_type_full(p$prime, env)[0];
            begin_def(/* () */0);
            var ty$1 = newconstr(p$prime, instance_list(env, decl[/* type_params */0]));
            end_def(/* () */0);
            generalize_structure$1(current_level[0], ty$1);
            match$30 = /* tuple */[
              ty$1,
              op$1
            ];
          } else {
            match$30 = /* tuple */[
              newvar(/* None */0, /* () */0),
              /* None */0
            ];
          }
        } else {
          match$30 = /* tuple */[
            newvar(/* None */0, /* () */0),
            /* None */0
          ];
        }
        var opath$1 = match$30[1];
        var ty_record = match$30[0];
        var closed = +(opt_sexp === /* None */0);
        var lbl_exp_list = wrap_disambiguate("This record expression is expected to have", ty_record, (function (param) {
                return type_label_a_list(/* None */0, loc, closed, env, (function (param) {
                              return type_label_exp(/* true */1, env, loc, ty_record, param);
                            }), opath$1, param);
              }), lid_sexp_list);
        unify_exp_types(loc, env, ty_record, instance(/* None */0, env, ty_expected));
        var check_duplicates = function (_param) {
          while(true) {
            var param = _param;
            if (param) {
              var rem = param[1];
              var lbl1 = param[0][1];
              if (rem) {
                if (lbl1[/* lbl_pos */4] === rem[0][1][/* lbl_pos */4]) {
                  throw [
                        $$Error$7,
                        loc,
                        env,
                        /* Label_multiply_defined */Block.__(10, [lbl1[/* lbl_name */0]])
                      ];
                } else {
                  _param = rem;
                  continue ;
                  
                }
              } else {
                _param = rem;
                continue ;
                
              }
            } else {
              return /* () */0;
            }
          };
        };
        check_duplicates(lbl_exp_list);
        var opt_exp$1;
        if (opt_exp) {
          if (lbl_exp_list) {
            var exp$1 = opt_exp[0];
            var ty_exp$1 = instance(/* None */0, env, exp$1[/* exp_type */3]);
            var unify_kept = function (lbl) {
              if (List.for_all((function (param) {
                        return +(param[1][/* lbl_pos */4] !== lbl[/* lbl_pos */4]);
                      }), lbl_exp_list)) {
                var match = instance_label(/* false */0, lbl);
                var match$1 = instance_label(/* false */0, lbl);
                unify$2(env, match[1], match$1[1]);
                unify$2(env, instance(/* None */0, env, ty_expected), match$1[2]);
                return unify_exp_types(exp$1[/* exp_loc */1], env, ty_exp$1, match[2]);
              } else {
                return 0;
              }
            };
            $$Array.iter(unify_kept, lbl_exp_list[0][1][/* lbl_all */5]);
            var newrecord$3 = exp$1.slice();
            opt_exp$1 = /* Some */[(newrecord$3[/* exp_type */3] = ty_exp$1, newrecord$3)];
          } else {
            throw [
                  Caml_builtin_exceptions.assert_failure,
                  [
                    "typecore.ml",
                    2092,
                    15
                  ]
                ];
          }
        } else {
          opt_exp$1 = /* None */0;
        }
        var num_fields;
        if (lbl_exp_list) {
          num_fields = lbl_exp_list[0][1][/* lbl_all */5].length;
        } else {
          throw [
                Caml_builtin_exceptions.assert_failure,
                [
                  "typecore.ml",
                  2095,
                  38
                ]
              ];
        }
        if (opt_sexp === /* None */0 && List.length(lid_sexp_list) !== num_fields) {
          var present_indices = List.map((function (param) {
                  return param[1][/* lbl_pos */4];
                }), lbl_exp_list);
          var label_names = extract_label_names(sexp, env, ty_expected);
          var missing_labels = function (_n, _param) {
            while(true) {
              var param = _param;
              var n = _n;
              if (param) {
                var rem = param[1];
                if (List.mem(n, present_indices)) {
                  _param = rem;
                  _n = n + 1 | 0;
                  continue ;
                  
                } else {
                  return /* :: */[
                          param[0],
                          missing_labels(n + 1 | 0, rem)
                        ];
                }
              } else {
                return /* [] */0;
              }
            };
          };
          var missing = missing_labels(0, label_names);
          throw [
                $$Error$7,
                loc,
                env,
                /* Label_missing */Block.__(11, [missing])
              ];
        } else if (opt_sexp !== /* None */0 && List.length(lid_sexp_list) === num_fields) {
          prerr_warning(loc, /* Useless_record_with */11);
        }
        return re(/* record */[
                    /* exp_desc : Texp_record */Block.__(10, [
                        lbl_exp_list,
                        opt_exp$1
                      ]),
                    /* exp_loc */loc,
                    /* exp_extra : [] */0,
                    /* exp_type */instance(/* None */0, env, ty_expected),
                    /* exp_env */env,
                    /* exp_attributes */sexp[/* pexp_attributes */2]
                  ]);
    case 12 : 
        var lid$2 = match[1];
        var match$31 = type_label_access(env, loc, match[0], lid$2);
        var label = match$31[1];
        var record$3 = match$31[0];
        var match$32 = instance_label(/* false */0, label);
        unify_exp(env, record$3, match$32[2]);
        return rue(/* record */[
                    /* exp_desc : Texp_field */Block.__(11, [
                        record$3,
                        lid$2,
                        label
                      ]),
                    /* exp_loc */loc,
                    /* exp_extra : [] */0,
                    /* exp_type */match$32[1],
                    /* exp_env */env,
                    /* exp_attributes */sexp[/* pexp_attributes */2]
                  ]);
    case 13 : 
        var lid$3 = match[1];
        var match$33 = type_label_access(env, loc, match[0], lid$3);
        var record$4 = match$33[0];
        var ty_record$1 = match$33[2] ? record$4[/* exp_type */3] : newvar(/* None */0, /* () */0);
        var match$34 = type_label_exp(/* false */0, env, loc, ty_record$1, /* tuple */[
              lid$3,
              match$33[1],
              match[2]
            ]);
        var label$1 = match$34[1];
        unify_exp(env, record$4, ty_record$1);
        if (!label$1[/* lbl_mut */3]) {
          throw [
                $$Error$7,
                loc,
                env,
                /* Label_not_mutable */Block.__(12, [lid$3[/* txt */0]])
              ];
        }
        return rue(/* record */[
                    /* exp_desc : Texp_setfield */Block.__(12, [
                        record$4,
                        match$34[0],
                        label$1,
                        match$34[2]
                      ]),
                    /* exp_loc */loc,
                    /* exp_extra : [] */0,
                    /* exp_type */instance_def(type_unit),
                    /* exp_env */env,
                    /* exp_attributes */sexp[/* pexp_attributes */2]
                  ]);
    case 14 : 
        var ty$2 = newty2(100000000, /* Tvar */Block.__(0, [/* None */0]));
        var to_unify$1 = type_array(ty$2);
        unify_exp_types(loc, env, to_unify$1, ty_expected);
        var argl = List.map((function (sarg) {
                return type_expect(/* None */0, env, sarg, ty$2);
              }), match[0]);
        return re(/* record */[
                    /* exp_desc : Texp_array */Block.__(13, [argl]),
                    /* exp_loc */loc,
                    /* exp_extra : [] */0,
                    /* exp_type */instance(/* None */0, env, ty_expected),
                    /* exp_env */env,
                    /* exp_attributes */sexp[/* pexp_attributes */2]
                  ]);
    case 15 : 
        var sifnot = match[2];
        var sifso = match[1];
        var cond = type_expect(/* None */0, env, match[0], type_bool);
        if (sifnot) {
          var ifso = type_expect(/* None */0, env, sifso, ty_expected);
          var ifnot = type_expect(/* None */0, env, sifnot[0], ty_expected);
          unify_exp(env, ifnot, ifso[/* exp_type */3]);
          return re(/* record */[
                      /* exp_desc : Texp_ifthenelse */Block.__(14, [
                          cond,
                          ifso,
                          /* Some */[ifnot]
                        ]),
                      /* exp_loc */loc,
                      /* exp_extra : [] */0,
                      /* exp_type */ifso[/* exp_type */3],
                      /* exp_env */env,
                      /* exp_attributes */sexp[/* pexp_attributes */2]
                    ]);
        } else {
          var ifso$1 = type_expect(/* None */0, env, sifso, type_unit);
          return rue(/* record */[
                      /* exp_desc : Texp_ifthenelse */Block.__(14, [
                          cond,
                          ifso$1,
                          /* None */0
                        ]),
                      /* exp_loc */loc,
                      /* exp_extra : [] */0,
                      /* exp_type */ifso$1[/* exp_type */3],
                      /* exp_env */env,
                      /* exp_attributes */sexp[/* pexp_attributes */2]
                    ]);
        }
        break;
    case 16 : 
        var exp1 = type_statement(env, match[0]);
        var exp2 = type_expect(/* None */0, env, match[1], ty_expected);
        return re(/* record */[
                    /* exp_desc : Texp_sequence */Block.__(15, [
                        exp1,
                        exp2
                      ]),
                    /* exp_loc */loc,
                    /* exp_extra : [] */0,
                    /* exp_type */exp2[/* exp_type */3],
                    /* exp_env */env,
                    /* exp_attributes */sexp[/* pexp_attributes */2]
                  ]);
    case 17 : 
        var cond$1 = type_expect(/* None */0, env, match[0], type_bool);
        var body$2 = type_statement(env, match[1]);
        return rue(/* record */[
                    /* exp_desc : Texp_while */Block.__(16, [
                        cond$1,
                        body$2
                      ]),
                    /* exp_loc */loc,
                    /* exp_extra : [] */0,
                    /* exp_type */instance_def(type_unit),
                    /* exp_env */env,
                    /* exp_attributes */sexp[/* pexp_attributes */2]
                  ]);
    case 18 : 
        var param = match[0];
        var low = type_expect(/* None */0, env, match[1], type_int);
        var high = type_expect(/* None */0, env, match[2], type_int);
        var match$35 = param[/* ppat_desc */0];
        var match$36;
        if (typeof match$35 === "number") {
          if (match$35) {
            throw [
                  $$Error$7,
                  param[/* ppat_loc */1],
                  env,
                  /* Invalid_for_loop_index */6
                ];
          } else {
            match$36 = /* tuple */[
              create("_for"),
              env
            ];
          }
        } else if (match$35.tag) {
          throw [
                $$Error$7,
                param[/* ppat_loc */1],
                env,
                /* Invalid_for_loop_index */6
              ];
        } else {
          var partial_arg = /* Some */[(function (s) {
                return /* Unused_for_index */Block.__(19, [s]);
              })];
          var partial_arg$1 = function (param, param$1, param$2, param$3, param$4, param$5) {
            return store_value(partial_arg, param, param$1, param$2, param$3, param$4, param$5);
          };
          match$36 = (function (param, param$1, param$2) {
                return enter(partial_arg$1, param, param$1, param$2);
              })(match$35[0][/* txt */0], /* record */[
                /* val_type */instance_def(type_int),
                /* val_kind : Val_reg */0,
                /* val_loc */loc,
                /* val_attributes : [] */0
              ], env);
        }
        var body$3 = type_statement(match$36[1], match[4]);
        return rue(/* record */[
                    /* exp_desc : Texp_for */Block.__(17, [
                        match$36[0],
                        param,
                        low,
                        high,
                        match[3],
                        body$3
                      ]),
                    /* exp_loc */loc,
                    /* exp_extra : [] */0,
                    /* exp_type */instance_def(type_unit),
                    /* exp_env */env,
                    /* exp_attributes */sexp[/* pexp_attributes */2]
                  ]);
    case 19 : 
        var sarg$2 = match[0];
        begin_def(/* () */0);
        var cty = transl_simple_type(env, /* false */0, match[1]);
        var ty$3 = cty[/* ctyp_type */1];
        end_def(/* () */0);
        generalize_structure$1(current_level[0], ty$3);
        var match_000 = type_argument(env, sarg$2, ty$3, instance(/* None */0, env, ty$3));
        var match_001 = instance(/* None */0, env, ty$3);
        var arg$3 = match_000;
        return rue(/* record */[
                    /* exp_desc */arg$3[/* exp_desc */0],
                    /* exp_loc */arg$3[/* exp_loc */1],
                    /* exp_extra : :: */[
                      /* tuple */[
                        /* Texp_constraint */Block.__(0, [cty]),
                        loc,
                        sexp[/* pexp_attributes */2]
                      ],
                      arg$3[/* exp_extra */2]
                    ],
                    match_001,
                    /* exp_env */env,
                    /* exp_attributes */arg$3[/* exp_attributes */5]
                  ]);
    case 20 : 
        var sty$prime = match[2];
        var sty = match[1];
        var sarg$3 = match[0];
        var match$37;
        if (sty) {
          begin_def(/* () */0);
          var match$38 = transl_simple_type_delayed(env, sty[0]);
          var cty$1 = match$38[0];
          var match$39 = transl_simple_type_delayed(env, sty$prime);
          var cty$prime = match$39[0];
          var ty$4 = cty$1[/* ctyp_type */1];
          var ty$prime = cty$prime[/* ctyp_type */1];
          try {
            var force$prime$prime = subtype(env, ty$4, ty$prime);
            Curry._1(match$38[1], /* () */0);
            Curry._1(match$39[1], /* () */0);
            Curry._1(force$prime$prime, /* () */0);
          }
          catch (raw_exn){
            var exn$2 = Js_exn.internalToOCamlException(raw_exn);
            if (exn$2[0] === Subtype) {
              throw [
                    $$Error$7,
                    loc,
                    env,
                    /* Not_subtype */Block.__(23, [
                        exn$2[1],
                        exn$2[2]
                      ])
                  ];
            } else {
              throw exn$2;
            }
          }
          end_def(/* () */0);
          generalize_structure$1(current_level[0], ty$4);
          generalize_structure$1(current_level[0], ty$prime);
          match$37 = /* tuple */[
            type_argument(env, sarg$3, ty$4, instance(/* None */0, env, ty$4)),
            instance(/* None */0, env, ty$prime),
            /* Some */[cty$1],
            cty$prime
          ];
        } else {
          var match$40 = transl_simple_type_delayed(env, sty$prime);
          var force = match$40[1];
          var cty$prime$1 = match$40[0];
          var ty$prime$1 = cty$prime$1[/* ctyp_type */1];
          begin_def(/* () */0);
          var arg$4 = type_exp(env, sarg$3);
          end_def(/* () */0);
          var tv = newvar(/* None */0, /* () */0);
          var gen = generalizable(tv[/* level */1], arg$4[/* exp_type */3]);
          unify_var(env, tv, arg$4[/* exp_type */3]);
          var gen$1 = gen;
          var match$41 = arg$4[/* exp_desc */0];
          var match$42 = self_coercion[0];
          var match$43 = repr(ty$prime$1)[/* desc */0];
          var exit$2 = 0;
          if (match$41.tag) {
            exit$2 = 1;
          } else {
            var $js$2 = match$41[2][/* val_kind */1];
            if (typeof $js$2 === "number") {
              exit$2 = 1;
            } else if ($js$2.tag === 2) {
              if (match$42) {
                if (typeof match$43 === "number") {
                  exit$2 = 1;
                } else if (match$43.tag === 3) {
                  var match$44 = match$42[0];
                  var r = match$44[1];
                  if (same(match$44[0], match$43[0])) {
                    r[0] = /* :: */[
                      loc,
                      r[0]
                    ];
                    Curry._1(force, /* () */0);
                  } else {
                    exit$2 = 1;
                  }
                } else {
                  exit$2 = 1;
                }
              } else {
                exit$2 = 1;
              }
            } else {
              exit$2 = 1;
            }
          }
          if (exit$2 === 1) {
            if (free_variables$1(/* Some */[env], arg$4[/* exp_type */3]) === /* [] */0 && free_variables$1(/* Some */[env], ty$prime$1) === /* [] */0) {
              var snap = snapshot(/* () */0);
              var match$45 = enlarge_type(env, ty$prime$1);
              var $js$3;
              try {
                Curry._1(force, /* () */0);
                unify$2(env, arg$4[/* exp_type */3], match$45[0]);
                $js$3 = /* true */1;
              }
              catch (raw_exn$1){
                var exn$3 = Js_exn.internalToOCamlException(raw_exn$1);
                if (exn$3[0] === Unify) {
                  backtrack(snap);
                  $js$3 = /* false */0;
                } else {
                  throw exn$3;
                }
              }
              if (!(!gen$1 && $js$3)) {
                try {
                  var force$prime = subtype(env, arg$4[/* exp_type */3], ty$prime$1);
                  Curry._1(force, /* () */0);
                  Curry._1(force$prime, /* () */0);
                  if (!gen$1) {
                    prerr_warning(loc, /* Not_principal */Block.__(8, ["this ground coercion"]));
                  }
                  
                }
                catch (raw_exn$2){
                  var exn$4 = Js_exn.internalToOCamlException(raw_exn$2);
                  if (exn$4[0] === Subtype) {
                    throw [
                          $$Error$7,
                          loc,
                          env,
                          /* Not_subtype */Block.__(23, [
                              exn$4[1],
                              exn$4[2]
                            ])
                        ];
                  } else {
                    throw exn$4;
                  }
                }
              }
              
            } else {
              var match$46 = enlarge_type(env, ty$prime$1);
              Curry._1(force, /* () */0);
              try {
                unify$2(env, arg$4[/* exp_type */3], match$46[0]);
              }
              catch (raw_exn$3){
                var exn$5 = Js_exn.internalToOCamlException(raw_exn$3);
                if (exn$5[0] === Unify) {
                  throw [
                        $$Error$7,
                        sarg$3[/* pexp_loc */1],
                        env,
                        /* Coercion_failure */Block.__(25, [
                            ty$prime$1,
                            full_expand(env, ty$prime$1),
                            exn$5[1],
                            match$46[1]
                          ])
                      ];
                } else {
                  throw exn$5;
                }
              }
            }
          }
          match$37 = /* tuple */[
            arg$4,
            ty$prime$1,
            /* None */0,
            cty$prime$1
          ];
        }
        var arg$5 = match$37[0];
        return rue(/* record */[
                    /* exp_desc */arg$5[/* exp_desc */0],
                    /* exp_loc */arg$5[/* exp_loc */1],
                    /* exp_extra : :: */[
                      /* tuple */[
                        /* Texp_coerce */Block.__(1, [
                            match$37[2],
                            match$37[3]
                          ]),
                        loc,
                        sexp[/* pexp_attributes */2]
                      ],
                      arg$5[/* exp_extra */2]
                    ],
                    /* exp_type */match$37[1],
                    /* exp_env */env,
                    /* exp_attributes */arg$5[/* exp_attributes */5]
                  ]);
    case 21 : 
        var met = match[1];
        var e = match[0];
        if (principal[0]) {
          begin_def(/* () */0);
        }
        var obj = type_exp(env, e);
        try {
          var match$47 = obj[/* exp_desc */0];
          var match$48;
          var exit$3 = 0;
          if (match$47.tag) {
            exit$3 = 1;
          } else {
            var match$49 = match$47[2][/* val_kind */1];
            var lid$4 = match$47[1];
            if (typeof match$49 === "number") {
              exit$3 = 1;
            } else {
              switch (match$49.tag | 0) {
                case 2 : 
                    var match$50 = filter_self_method(env, met, /* Private */0, match$49[0], match$49[3]);
                    var typ = match$50[1];
                    if (is_Tvar(repr(typ))) {
                      prerr_warning(loc, /* Undeclared_virtual_method */Block.__(7, [met]));
                    }
                    match$48 = /* tuple */[
                      /* Tmeth_val */Block.__(1, [match$50[0]]),
                      /* None */0,
                      typ
                    ];
                    break;
                case 3 : 
                    var cl_num = match$49[1];
                    var method_id;
                    try {
                      method_id = List.assoc(met, match$49[0]);
                    }
                    catch (exn$6){
                      if (exn$6 === Caml_builtin_exceptions.not_found) {
                        throw [
                              $$Error$7,
                              e[/* pexp_loc */1],
                              env,
                              /* Undefined_inherited_method */Block.__(17, [met])
                            ];
                      } else {
                        throw exn$6;
                      }
                    }
                    var match$51 = lookup_value$1(/* Lident */Block.__(0, ["selfpat-" + cl_num]), env);
                    var match$52 = lookup_value$1(/* Lident */Block.__(0, ["self-" + cl_num]), env);
                    var desc$3 = match$51[1];
                    var match$53 = desc$3[/* val_kind */1];
                    if (typeof match$53 === "number") {
                      throw [
                            Caml_builtin_exceptions.assert_failure,
                            [
                              "typecore.ml",
                              2384,
                              18
                            ]
                          ];
                    } else if (match$53.tag === 2) {
                      var match$54 = filter_self_method(env, met, /* Private */0, match$53[0], match$53[3]);
                      var typ$1 = match$54[1];
                      var method_type = newvar(/* None */0, /* () */0);
                      var match$55 = filter_arrow(env, method_type, "");
                      unify$2(env, match$55[0], desc$3[/* val_type */0]);
                      unify$2(env, match$55[1], instance(/* None */0, env, typ$1));
                      var exp_000 = /* record */[
                        /* exp_desc : Texp_ident */Block.__(0, [
                            /* Pident */Block.__(0, [method_id]),
                            lid$4,
                            /* record */[
                              /* val_type */method_type,
                              /* val_kind : Val_reg */0,
                              /* val_loc */none,
                              /* val_attributes : [] */0
                            ]
                          ]),
                        /* exp_loc */loc,
                        /* exp_extra : [] */0,
                        /* exp_type */method_type,
                        /* exp_env */env,
                        /* exp_attributes : [] */0
                      ];
                      var exp_001 = /* :: */[
                        /* tuple */[
                          "",
                          /* Some */[/* record */[
                              /* exp_desc : Texp_ident */Block.__(0, [
                                  match$52[0],
                                  lid$4,
                                  desc$3
                                ]),
                              /* exp_loc */obj[/* exp_loc */1],
                              /* exp_extra : [] */0,
                              /* exp_type */desc$3[/* val_type */0],
                              /* exp_env */env,
                              /* exp_attributes : [] */0
                            ]],
                          /* Required */0
                        ],
                        /* [] */0
                      ];
                      var exp$2 = /* Texp_apply */Block.__(4, [
                          exp_000,
                          exp_001
                        ]);
                      match$48 = /* tuple */[
                        /* Tmeth_name */Block.__(0, [met]),
                        /* Some */[re(/* record */[
                                /* exp_desc */exp$2,
                                /* exp_loc */loc,
                                /* exp_extra : [] */0,
                                /* exp_type */typ$1,
                                /* exp_env */env,
                                /* exp_attributes : [] */0
                              ])],
                        typ$1
                      ];
                    } else {
                      throw [
                            Caml_builtin_exceptions.assert_failure,
                            [
                              "typecore.ml",
                              2384,
                              18
                            ]
                          ];
                    }
                    break;
                default:
                  exit$3 = 1;
              }
            }
          }
          if (exit$3 === 1) {
            match$48 = /* tuple */[
              /* Tmeth_name */Block.__(0, [met]),
              /* None */0,
              filter_method(env, met, /* Public */1, obj[/* exp_type */3])
            ];
          }
          var typ$2 = match$48[2];
          if (principal[0]) {
            end_def(/* () */0);
            generalize_structure$1(current_level[0], typ$2);
          }
          var ty$5 = repr(typ$2);
          var match$56 = ty$5[/* desc */0];
          var typ$3;
          if (typeof match$56 === "number") {
            throw [
                  Caml_builtin_exceptions.assert_failure,
                  [
                    "typecore.ml",
                    2410,
                    14
                  ]
                ];
          } else {
            switch (match$56.tag | 0) {
              case 0 : 
                  var ty$prime$2 = newvar(/* None */0, /* () */0);
                  unify$2(env, instance_def(ty$5), newty2(current_level[0], /* Tpoly */Block.__(10, [
                              ty$prime$2,
                              /* [] */0
                            ])));
                  typ$3 = ty$prime$2;
                  break;
              case 10 : 
                  var tl = match$56[1];
                  var ty$6 = match$56[0];
                  if (tl) {
                    var l$2 = ty$5[/* level */1];
                    if (principal[0] && l$2 !== 100000000) {
                      prerr_warning(loc, /* Not_principal */Block.__(8, ["this use of a polymorphic method"]));
                    }
                    typ$3 = instance_poly(/* None */0, /* false */0, tl, ty$6)[1];
                  } else {
                    typ$3 = instance(/* None */0, env, ty$6);
                  }
                  break;
              default:
                throw [
                      Caml_builtin_exceptions.assert_failure,
                      [
                        "typecore.ml",
                        2410,
                        14
                      ]
                    ];
            }
          }
          return rue(/* record */[
                      /* exp_desc : Texp_send */Block.__(18, [
                          obj,
                          match$48[0],
                          match$48[1]
                        ]),
                      /* exp_loc */loc,
                      /* exp_extra : [] */0,
                      /* exp_type */typ$3,
                      /* exp_env */env,
                      /* exp_attributes */sexp[/* pexp_attributes */2]
                    ]);
        }
        catch (raw_exn$4){
          var exn$7 = Js_exn.internalToOCamlException(raw_exn$4);
          if (exn$7[0] === Unify) {
            throw [
                  $$Error$7,
                  e[/* pexp_loc */1],
                  env,
                  /* Undefined_method */Block.__(16, [
                      obj[/* exp_type */3],
                      met
                    ])
                ];
          } else {
            throw exn$7;
          }
        }
        break;
    case 22 : 
        var cl = match[0];
        var match$57 = find_class$1(env, loc, cl[/* txt */0]);
        var cl_decl = match$57[1];
        var match$58 = cl_decl[/* cty_new */3];
        if (match$58) {
          return rue(/* record */[
                      /* exp_desc : Texp_new */Block.__(19, [
                          match$57[0],
                          cl,
                          cl_decl
                        ]),
                      /* exp_loc */loc,
                      /* exp_extra : [] */0,
                      /* exp_type */instance_def(match$58[0]),
                      /* exp_env */env,
                      /* exp_attributes */sexp[/* pexp_attributes */2]
                    ]);
        } else {
          throw [
                $$Error$7,
                loc,
                env,
                /* Virtual_class */Block.__(18, [cl[/* txt */0]])
              ];
        }
        break;
    case 23 : 
        var lab = match[0];
        try {
          var match$59 = lookup_value$1(/* Lident */Block.__(0, [lab[/* txt */0]]), env);
          var desc$4 = match$59[1];
          var match$60 = desc$4[/* val_kind */1];
          var exit$4 = 0;
          if (typeof match$60 === "number") {
            exit$4 = 1;
          } else if (match$60.tag === 1) {
            if (match$60[0] !== 0) {
              var newval = type_expect(/* None */0, env, match[1], instance(/* None */0, env, desc$4[/* val_type */0]));
              var match$61 = lookup_value$1(/* Lident */Block.__(0, ["self-" + match$60[1]]), env);
              return rue(/* record */[
                          /* exp_desc : Texp_setinstvar */Block.__(21, [
                              match$61[0],
                              match$59[0],
                              lab,
                              newval
                            ]),
                          /* exp_loc */loc,
                          /* exp_extra : [] */0,
                          /* exp_type */instance_def(type_unit),
                          /* exp_env */env,
                          /* exp_attributes */sexp[/* pexp_attributes */2]
                        ]);
            } else {
              throw [
                    $$Error$7,
                    loc,
                    env,
                    /* Instance_variable_not_mutable */Block.__(22, [
                        /* true */1,
                        lab[/* txt */0]
                      ])
                  ];
            }
          } else {
            exit$4 = 1;
          }
          if (exit$4 === 1) {
            throw [
                  $$Error$7,
                  loc,
                  env,
                  /* Instance_variable_not_mutable */Block.__(22, [
                      /* false */0,
                      lab[/* txt */0]
                    ])
                ];
          }
          
        }
        catch (exn$8){
          if (exn$8 === Caml_builtin_exceptions.not_found) {
            throw [
                  $$Error$7,
                  loc,
                  env,
                  /* Unbound_instance_variable */Block.__(21, [lab[/* txt */0]])
                ];
          } else {
            throw exn$8;
          }
        }
        break;
    case 24 : 
        var lst = match[0];
        List.fold_right((function (param, l) {
                var lab = param[0];
                if (List.exists((function (l) {
                          return +(l[/* txt */0] === lab[/* txt */0]);
                        }), l)) {
                  throw [
                        $$Error$7,
                        loc,
                        env,
                        /* Value_multiply_overridden */Block.__(24, [lab[/* txt */0]])
                      ];
                }
                return /* :: */[
                        lab,
                        l
                      ];
              }), lst, /* [] */0);
        var match$62;
        try {
          match$62 = /* tuple */[
            lookup_value$1(/* Lident */Block.__(0, ["selfpat-*"]), env),
            lookup_value$1(/* Lident */Block.__(0, ["self-*"]), env)
          ];
        }
        catch (exn$9){
          if (exn$9 === Caml_builtin_exceptions.not_found) {
            throw [
                  $$Error$7,
                  loc,
                  env,
                  /* Outside_class */0
                ];
          } else {
            throw exn$9;
          }
        }
        var match$63 = match$62[0][1];
        var match$64 = match$63[/* val_kind */1];
        if (typeof match$64 === "number") {
          throw [
                Caml_builtin_exceptions.assert_failure,
                [
                  "typecore.ml",
                  2494,
                  10
                ]
              ];
        } else if (match$64.tag === 2) {
          var vars = match$64[1];
          var type_override = function (param) {
            var lab = param[0];
            try {
              var match = find(lab[/* txt */0], vars[0]);
              return /* tuple */[
                      /* Pident */Block.__(0, [match[0]]),
                      lab,
                      type_expect(/* None */0, env, param[1], instance(/* None */0, env, match[3]))
                    ];
            }
            catch (exn){
              if (exn === Caml_builtin_exceptions.not_found) {
                throw [
                      $$Error$7,
                      loc,
                      env,
                      /* Unbound_instance_variable */Block.__(21, [lab[/* txt */0]])
                    ];
              } else {
                throw exn;
              }
            }
          };
          var modifs = List.map(type_override, lst);
          return rue(/* record */[
                      /* exp_desc : Texp_override */Block.__(22, [
                          match$62[1][0],
                          modifs
                        ]),
                      /* exp_loc */loc,
                      /* exp_extra : [] */0,
                      /* exp_type */match$63[/* val_type */0],
                      /* exp_env */env,
                      /* exp_attributes */sexp[/* pexp_attributes */2]
                    ]);
        } else {
          throw [
                Caml_builtin_exceptions.assert_failure,
                [
                  "typecore.ml",
                  2494,
                  10
                ]
              ];
        }
        break;
    case 25 : 
        var name$2 = match[0];
        var ty$7 = newvar(/* None */0, /* () */0);
        begin_def(/* () */0);
        set_current_time(ty$7[/* level */1]);
        var context = narrow(/* () */0);
        var modl = Curry._2(type_module[0], env, match[1]);
        var match$65 = enter_module(/* None */0, name$2[/* txt */0], modl[/* mod_type */2], env);
        var new_env = match$65[1];
        init_def(currentstamp[0]);
        widen(context);
        var body$4 = type_expect(/* None */0, new_env, match[2], ty_expected);
        end_def(/* () */0);
        try {
          unify_var(new_env, ty$7, body$4[/* exp_type */3]);
        }
        catch (raw_exn$5){
          var exn$10 = Js_exn.internalToOCamlException(raw_exn$5);
          if (exn$10[0] === Unify) {
            throw [
                  $$Error$7,
                  loc,
                  env,
                  /* Scoping_let_module */Block.__(28, [
                      name$2[/* txt */0],
                      body$4[/* exp_type */3]
                    ])
                ];
          } else {
            throw exn$10;
          }
        }
        return re(/* record */[
                    /* exp_desc : Texp_letmodule */Block.__(23, [
                        match$65[0],
                        name$2,
                        modl,
                        body$4
                      ]),
                    /* exp_loc */loc,
                    /* exp_extra : [] */0,
                    /* exp_type */ty$7,
                    /* exp_env */env,
                    /* exp_attributes */sexp[/* pexp_attributes */2]
                  ]);
    case 26 : 
        var cond$2 = type_expect(/* None */0, env, match[0], type_bool);
        var match$66 = cond$2[/* exp_desc */0];
        var exp_type;
        exp_type = match$66.tag === 8 && match$66[1][/* cstr_name */0] === "false" ? instance(/* None */0, env, ty_expected) : instance_def(type_unit);
        return rue(/* record */[
                    /* exp_desc : Texp_assert */Block.__(24, [cond$2]),
                    /* exp_loc */loc,
                    /* exp_extra : [] */0,
                    /* exp_type */exp_type,
                    /* exp_env */env,
                    /* exp_attributes */sexp[/* pexp_attributes */2]
                  ]);
    case 27 : 
        var ty$8 = newty2(100000000, /* Tvar */Block.__(0, [/* None */0]));
        var to_unify$2 = type_lazy_t(ty$8);
        unify_exp_types(loc, env, to_unify$2, ty_expected);
        var arg$6 = type_expect(/* None */0, env, match[0], ty$8);
        return re(/* record */[
                    /* exp_desc : Texp_lazy */Block.__(25, [arg$6]),
                    /* exp_loc */loc,
                    /* exp_extra : [] */0,
                    /* exp_type */instance(/* None */0, env, ty_expected),
                    /* exp_env */env,
                    /* exp_attributes */sexp[/* pexp_attributes */2]
                  ]);
    case 28 : 
        var sty$1 = match[1];
        var sbody$1 = match[0];
        if (principal[0]) {
          begin_def(/* () */0);
        }
        var match$67;
        if (sty$1) {
          var sty$2 = force_poly(sty$1[0]);
          var cty$2 = transl_simple_type(env, /* false */0, sty$2);
          match$67 = /* tuple */[
            repr(cty$2[/* ctyp_type */1]),
            /* Some */[cty$2]
          ];
        } else {
          match$67 = /* tuple */[
            repr(ty_expected),
            /* None */0
          ];
        }
        var ty$9 = match$67[0];
        if (principal[0]) {
          end_def(/* () */0);
          generalize_structure$1(current_level[0], ty$9);
        }
        if (sty$1 !== /* None */0) {
          unify_exp_types(loc, env, instance(/* None */0, env, ty$9), instance(/* None */0, env, ty_expected));
        }
        var match$68 = expand_head(env, ty$9)[/* desc */0];
        var exp$3;
        if (typeof match$68 === "number") {
          throw [
                Caml_builtin_exceptions.assert_failure,
                [
                  "typecore.ml",
                  2600,
                  15
                ]
              ];
        } else {
          switch (match$68.tag | 0) {
            case 0 : 
                var exp$4 = type_exp(env, sbody$1);
                var newrecord$4 = exp$4.slice();
                newrecord$4[/* exp_type */3] = newty2(current_level[0], /* Tpoly */Block.__(10, [
                        exp$4[/* exp_type */3],
                        /* [] */0
                      ]));
                unify_exp(env, newrecord$4, ty$9);
                exp$3 = newrecord$4;
                break;
            case 10 : 
                var tl$1 = match$68[1];
                var ty$prime$3 = match$68[0];
                if (tl$1) {
                  begin_def(/* () */0);
                  if (principal[0]) {
                    begin_def(/* () */0);
                  }
                  var match$69 = instance_poly(/* None */0, /* true */1, tl$1, ty$prime$3);
                  var ty$prime$prime = match$69[1];
                  if (principal[0]) {
                    end_def(/* () */0);
                    generalize_structure$1(current_level[0], ty$prime$prime);
                  }
                  var exp$5 = type_expect(/* None */0, env, sbody$1, ty$prime$prime);
                  end_def(/* () */0);
                  check_univars(env, /* false */0, "method", exp$5, ty_expected, match$69[0]);
                  var newrecord$5 = exp$5.slice();
                  newrecord$5[/* exp_type */3] = instance(/* None */0, env, ty$9);
                  exp$3 = newrecord$5;
                } else {
                  var exp$6 = type_expect(/* None */0, env, sbody$1, ty$prime$3);
                  var newrecord$6 = exp$6.slice();
                  newrecord$6[/* exp_type */3] = instance(/* None */0, env, ty$9);
                  exp$3 = newrecord$6;
                }
                break;
            default:
              throw [
                    Caml_builtin_exceptions.assert_failure,
                    [
                      "typecore.ml",
                      2600,
                      15
                    ]
                  ];
          }
        }
        var newrecord$7 = exp$3.slice();
        return re((newrecord$7[/* exp_extra */2] = /* :: */[
                      /* tuple */[
                        /* Texp_poly */Block.__(3, [match$67[1]]),
                        loc,
                        sexp[/* pexp_attributes */2]
                      ],
                      exp$3[/* exp_extra */2]
                    ], newrecord$7));
    case 29 : 
        var match$70 = Curry._3(type_object[0], env, loc, match[0]);
        return rue(/* record */[
                    /* exp_desc : Texp_object */Block.__(26, [
                        match$70[0],
                        match$70[2]
                      ]),
                    /* exp_loc */loc,
                    /* exp_extra : [] */0,
                    /* exp_type */match$70[1][/* csig_self */0],
                    /* exp_env */env,
                    /* exp_attributes */sexp[/* pexp_attributes */2]
                  ]);
    case 30 : 
        var name$3 = match[0];
        var ty$10 = newvar(/* None */0, /* () */0);
        begin_def(/* () */0);
        var level = current_level[0];
        var decl_006 = /* type_newtype_level : Some */[/* tuple */[
            level,
            level
          ]];
        var decl$1 = /* record */[
          /* type_params : [] */0,
          /* type_arity */0,
          /* type_kind : Type_abstract */0,
          /* type_private : Public */1,
          /* type_manifest : None */0,
          /* type_variance : [] */0,
          decl_006,
          /* type_loc */loc,
          /* type_attributes : [] */0
        ];
        set_current_time(ty$10[/* level */1]);
        var match$71 = enter_type(name$3, decl$1, env);
        var id = match$71[0];
        init_def(currentstamp[0]);
        var body$5 = type_exp(match$71[1], match[1]);
        var seen = Hashtbl.create(/* None */0, 8);
        var replace = function (t) {
          if (Hashtbl.mem(seen, t[/* id */2])) {
            return /* () */0;
          } else {
            Hashtbl.add(seen, t[/* id */2], /* () */0);
            var match = t[/* desc */0];
            if (typeof match === "number") {
              return iter_type_expr(replace, t);
            } else if (match.tag === 3) {
              var match$1 = match[0];
              switch (match$1.tag | 0) {
                case 0 : 
                    if (id === match$1[0]) {
                      return link_type(t, ty$10);
                    } else {
                      return iter_type_expr(replace, t);
                    }
                case 1 : 
                case 2 : 
                    return iter_type_expr(replace, t);
                
              }
            } else {
              return iter_type_expr(replace, t);
            }
          }
        };
        var ety = type_expr(identity, body$5[/* exp_type */3]);
        replace(ety);
        end_def(/* () */0);
        return rue(/* record */[
                    /* exp_desc */body$5[/* exp_desc */0],
                    /* exp_loc */loc,
                    /* exp_extra : :: */[
                      /* tuple */[
                        /* Texp_newtype */Block.__(4, [name$3]),
                        loc,
                        sexp[/* pexp_attributes */2]
                      ],
                      body$5[/* exp_extra */2]
                    ],
                    /* exp_type */ety,
                    /* exp_env */body$5[/* exp_env */4],
                    /* exp_attributes */body$5[/* exp_attributes */5]
                  ]);
    case 31 : 
        var match$72 = expand_head(env, instance(/* None */0, env, ty_expected));
        var match$73 = match$72[/* desc */0];
        var match$74;
        if (typeof match$73 === "number") {
          throw [
                $$Error$7,
                loc,
                env,
                /* Not_a_packed_module */Block.__(32, [ty_expected])
              ];
        } else {
          switch (match$73.tag | 0) {
            case 0 : 
                throw [
                      $$Error$7,
                      loc,
                      env,
                      /* Cannot_infer_signature */3
                    ];
            case 11 : 
                if (principal[0] && expand_head(env, ty_expected)[/* level */1] < 100000000) {
                  prerr_warning(loc, /* Not_principal */Block.__(8, ["this module packing"]));
                }
                match$74 = /* tuple */[
                  match$73[0],
                  match$73[1],
                  match$73[2]
                ];
                break;
            default:
              throw [
                    $$Error$7,
                    loc,
                    env,
                    /* Not_a_packed_module */Block.__(32, [ty_expected])
                  ];
          }
        }
        var nl = match$74[1];
        var p = match$74[0];
        var match$75 = Curry._5(type_package[0], env, match[0], p, nl, match$74[2]);
        return rue(/* record */[
                    /* exp_desc : Texp_pack */Block.__(27, [match$75[0]]),
                    /* exp_loc */loc,
                    /* exp_extra : [] */0,
                    /* exp_type */newty2(current_level[0], /* Tpackage */Block.__(11, [
                            p,
                            nl,
                            match$75[1]
                          ])),
                    /* exp_env */env,
                    /* exp_attributes */sexp[/* pexp_attributes */2]
                  ]);
    case 32 : 
        var lid$5 = match[1];
        var ovf = match[0];
        var match$76 = Curry._4(type_open[0], ovf, env, sexp[/* pexp_loc */1], lid$5);
        var newenv = match$76[1];
        var exp$7 = type_expect(/* None */0, newenv, match[2], ty_expected);
        var newrecord$8 = exp$7.slice();
        newrecord$8[/* exp_extra */2] = /* :: */[
          /* tuple */[
            /* Texp_open */Block.__(2, [
                ovf,
                match$76[0],
                lid$5,
                newenv
              ]),
            loc,
            sexp[/* pexp_attributes */2]
          ],
          exp$7[/* exp_extra */2]
        ];
        return newrecord$8;
    case 33 : 
        throw [
              Error_forward$1,
              error_of_extension(match[0])
            ];
    
  }
}

function type_function(in_function, loc, attrs, env, ty_expected, l, caselist) {
  var match = in_function ? in_function[0] : /* tuple */[
      loc,
      instance(/* None */0, env, ty_expected)
    ];
  var ty_fun = match[1];
  var loc_fun = match[0];
  var separate = principal[0] || env[/* local_constraints */11];
  if (separate) {
    begin_def(/* () */0);
  }
  var match$1;
  try {
    match$1 = filter_arrow(env, instance(/* None */0, env, ty_expected), l);
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === Unify) {
      var ty = expand_head(env, ty_expected);
      var match$2 = ty[/* desc */0];
      var exit = 0;
      if (typeof match$2 === "number") {
        exit = 1;
      } else if (match$2.tag === 1) {
        throw [
              $$Error$7,
              loc,
              env,
              /* Abstract_wrong_label */Block.__(27, [
                  l,
                  ty
                ])
            ];
      } else {
        exit = 1;
      }
      if (exit === 1) {
        throw [
              $$Error$7,
              loc_fun,
              env,
              /* Too_many_arguments */Block.__(26, [
                  +(in_function !== /* None */0),
                  ty_fun
                ])
            ];
      }
      
    } else {
      throw exn;
    }
  }
  var ty_res = match$1[1];
  var ty_arg = match$1[0];
  var ty_arg$1;
  if (is_optional(l)) {
    var tv = newvar(/* None */0, /* () */0);
    try {
      unify$2(env, ty_arg, type_option$1(tv));
    }
    catch (raw_exn$1){
      var exn$1 = Js_exn.internalToOCamlException(raw_exn$1);
      if (exn$1[0] === Unify) {
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "typecore.ml",
                2706,
                24
              ]
            ];
      } else {
        throw exn$1;
      }
    }
    ty_arg$1 = type_option$1(tv);
  } else {
    ty_arg$1 = ty_arg;
  }
  if (separate) {
    end_def(/* () */0);
    generalize_structure$1(current_level[0], ty_arg$1);
    generalize_structure$1(current_level[0], ty_res);
  }
  var match$3 = type_cases(/* Some */[/* tuple */[
          loc_fun,
          ty_fun
        ]], env, ty_arg$1, ty_res, /* true */1, loc, caselist);
  var cases = match$3[0];
  var not_function = function (ty) {
    var match = list_labels(env, ty);
    if (match[0]) {
      return /* false */0;
    } else {
      return 1 - match[1];
    }
  };
  if (is_optional(l) && not_function(ty_res)) {
    prerr_warning(List.hd(cases)[/* c_lhs */0][/* pat_loc */1], /* Unerasable_optional_argument */8);
  }
  return re(/* record */[
              /* exp_desc : Texp_function */Block.__(3, [
                  l,
                  cases,
                  match$3[1]
                ]),
              /* exp_loc */loc,
              /* exp_extra : [] */0,
              /* exp_type */instance(/* None */0, env, newty2(100000000, /* Tarrow */Block.__(1, [
                          l,
                          ty_arg$1,
                          ty_res,
                          /* Cok */0
                        ]))),
              /* exp_env */env,
              /* exp_attributes */attrs
            ]);
}

function type_label_access(env, _, srecord, lid) {
  if (principal[0]) {
    begin_def(/* () */0);
  }
  var record = type_exp(env, srecord);
  if (principal[0]) {
    end_def(/* () */0);
    generalize_structure$1(current_level[0], record[/* exp_type */3]);
  }
  var ty_exp = record[/* exp_type */3];
  var opath;
  try {
    var match = extract_concrete_record(env, ty_exp);
    opath = /* Some */[/* tuple */[
        match[0],
        match[1],
        +(ty_exp[/* level */1] === 100000000) || 1 - principal[0]
      ]];
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      opath = /* None */0;
    } else {
      throw exn;
    }
  }
  var labels = find_all_labels(env, lid[/* loc */1], lid[/* txt */0]);
  var label = wrap_disambiguate("This expression has", ty_exp, (function (param) {
          return disambiguate(/* None */0, /* None */0, /* None */0, lid, env, opath, param);
        }), labels);
  return /* tuple */[
          record,
          label,
          opath
        ];
}

function type_format(loc, str, env) {
  var loc_000 = /* loc_start */loc[/* loc_start */0];
  var loc_001 = /* loc_end */loc[/* loc_end */1];
  var loc$1 = /* record */[
    loc_000,
    loc_001,
    /* loc_ghost : true */1
  ];
  try {
    var mk_constr = function (name, args) {
      var lid_000 = /* Lident */Block.__(0, ["CamlinternalFormatBasics"]);
      var lid = /* Ldot */Block.__(1, [
          lid_000,
          name
        ]);
      var arg = args ? (
          args[1] ? /* Some */[/* record */[
                /* pexp_desc : Pexp_tuple */Block.__(8, [args]),
                /* pexp_loc */loc$1,
                /* pexp_attributes : [] */0
              ]] : /* Some */[args[0]]
        ) : /* None */0;
      return /* record */[
              /* pexp_desc : Pexp_construct */Block.__(9, [
                  /* record */[
                    /* txt */lid,
                    /* loc */loc$1
                  ],
                  arg
                ]),
              /* pexp_loc */loc$1,
              /* pexp_attributes : [] */0
            ];
    };
    var mk_formatting_lit = function (fmting) {
      if (typeof fmting === "number") {
        switch (fmting) {
          case 0 : 
              return mk_constr("Close_box", /* [] */0);
          case 1 : 
              return mk_constr("Close_tag", /* [] */0);
          case 2 : 
              return mk_constr("FFlush", /* [] */0);
          case 3 : 
              return mk_constr("Force_newline", /* [] */0);
          case 4 : 
              return mk_constr("Flush_newline", /* [] */0);
          case 5 : 
              return mk_constr("Escaped_at", /* [] */0);
          case 6 : 
              return mk_constr("Escaped_percent", /* [] */0);
          
        }
      } else {
        switch (fmting.tag | 0) {
          case 0 : 
              return mk_constr("Break", /* :: */[
                          /* record */[
                            /* pexp_desc : Pexp_constant */Block.__(1, [/* Const_string */Block.__(2, [
                                    fmting[0],
                                    /* None */0
                                  ])]),
                            /* pexp_loc */loc$1,
                            /* pexp_attributes : [] */0
                          ],
                          /* :: */[
                            /* record */[
                              /* pexp_desc : Pexp_constant */Block.__(1, [/* Const_int */Block.__(0, [fmting[1]])]),
                              /* pexp_loc */loc$1,
                              /* pexp_attributes : [] */0
                            ],
                            /* :: */[
                              /* record */[
                                /* pexp_desc : Pexp_constant */Block.__(1, [/* Const_int */Block.__(0, [fmting[2]])]),
                                /* pexp_loc */loc$1,
                                /* pexp_attributes : [] */0
                              ],
                              /* [] */0
                            ]
                          ]
                        ]);
          case 1 : 
              return mk_constr("Magic_size", /* :: */[
                          /* record */[
                            /* pexp_desc : Pexp_constant */Block.__(1, [/* Const_string */Block.__(2, [
                                    fmting[0],
                                    /* None */0
                                  ])]),
                            /* pexp_loc */loc$1,
                            /* pexp_attributes : [] */0
                          ],
                          /* :: */[
                            /* record */[
                              /* pexp_desc : Pexp_constant */Block.__(1, [/* Const_int */Block.__(0, [fmting[1]])]),
                              /* pexp_loc */loc$1,
                              /* pexp_attributes : [] */0
                            ],
                            /* [] */0
                          ]
                        ]);
          case 2 : 
              return mk_constr("Scan_indic", /* :: */[
                          /* record */[
                            /* pexp_desc : Pexp_constant */Block.__(1, [/* Const_char */Block.__(1, [fmting[0]])]),
                            /* pexp_loc */loc$1,
                            /* pexp_attributes : [] */0
                          ],
                          /* [] */0
                        ]);
          
        }
      }
    };
    var mk_formatting_gen = function (fmting) {
      if (fmting.tag) {
        var match = fmting[0];
        return mk_constr("Open_box", /* :: */[
                    mk_format(match[0], match[1]),
                    /* [] */0
                  ]);
      } else {
        var match$1 = fmting[0];
        return mk_constr("Open_tag", /* :: */[
                    mk_format(match$1[0], match$1[1]),
                    /* [] */0
                  ]);
      }
    };
    var mk_format = function (fmt, str) {
      return mk_constr("Format", /* :: */[
                  mk_fmt(fmt),
                  /* :: */[
                    /* record */[
                      /* pexp_desc : Pexp_constant */Block.__(1, [/* Const_string */Block.__(2, [
                              str,
                              /* None */0
                            ])]),
                      /* pexp_loc */loc$1,
                      /* pexp_attributes : [] */0
                    ],
                    /* [] */0
                  ]
                ]);
    };
    var mk_side = function (side) {
      switch (side) {
        case 0 : 
            return mk_constr("Left", /* [] */0);
        case 1 : 
            return mk_constr("Right", /* [] */0);
        case 2 : 
            return mk_constr("Zeros", /* [] */0);
        
      }
    };
    var mk_iconv = function (iconv) {
      switch (iconv) {
        case 0 : 
            return mk_constr("Int_d", /* [] */0);
        case 1 : 
            return mk_constr("Int_pd", /* [] */0);
        case 2 : 
            return mk_constr("Int_sd", /* [] */0);
        case 3 : 
            return mk_constr("Int_i", /* [] */0);
        case 4 : 
            return mk_constr("Int_pi", /* [] */0);
        case 5 : 
            return mk_constr("Int_si", /* [] */0);
        case 6 : 
            return mk_constr("Int_x", /* [] */0);
        case 7 : 
            return mk_constr("Int_Cx", /* [] */0);
        case 8 : 
            return mk_constr("Int_X", /* [] */0);
        case 9 : 
            return mk_constr("Int_CX", /* [] */0);
        case 10 : 
            return mk_constr("Int_o", /* [] */0);
        case 11 : 
            return mk_constr("Int_Co", /* [] */0);
        case 12 : 
            return mk_constr("Int_u", /* [] */0);
        
      }
    };
    var mk_fconv = function (fconv) {
      switch (fconv) {
        case 0 : 
            return mk_constr("Float_f", /* [] */0);
        case 1 : 
            return mk_constr("Float_pf", /* [] */0);
        case 2 : 
            return mk_constr("Float_sf", /* [] */0);
        case 3 : 
            return mk_constr("Float_e", /* [] */0);
        case 4 : 
            return mk_constr("Float_pe", /* [] */0);
        case 5 : 
            return mk_constr("Float_se", /* [] */0);
        case 6 : 
            return mk_constr("Float_E", /* [] */0);
        case 7 : 
            return mk_constr("Float_pE", /* [] */0);
        case 8 : 
            return mk_constr("Float_sE", /* [] */0);
        case 9 : 
            return mk_constr("Float_g", /* [] */0);
        case 10 : 
            return mk_constr("Float_pg", /* [] */0);
        case 11 : 
            return mk_constr("Float_sg", /* [] */0);
        case 12 : 
            return mk_constr("Float_G", /* [] */0);
        case 13 : 
            return mk_constr("Float_pG", /* [] */0);
        case 14 : 
            return mk_constr("Float_sG", /* [] */0);
        case 15 : 
            return mk_constr("Float_F", /* [] */0);
        
      }
    };
    var mk_counter = function (cnt) {
      switch (cnt) {
        case 0 : 
            return mk_constr("Line_counter", /* [] */0);
        case 1 : 
            return mk_constr("Char_counter", /* [] */0);
        case 2 : 
            return mk_constr("Token_counter", /* [] */0);
        
      }
    };
    var mk_int_opt = function (n_opt) {
      if (n_opt) {
        var lid_loc_000 = /* txt : Lident */Block.__(0, ["Some"]);
        var lid_loc = /* record */[
          lid_loc_000,
          /* loc */loc$1
        ];
        return /* record */[
                /* pexp_desc : Pexp_construct */Block.__(9, [
                    lid_loc,
                    /* Some */[/* record */[
                        /* pexp_desc : Pexp_constant */Block.__(1, [/* Const_int */Block.__(0, [n_opt[0]])]),
                        /* pexp_loc */loc$1,
                        /* pexp_attributes : [] */0
                      ]]
                  ]),
                /* pexp_loc */loc$1,
                /* pexp_attributes : [] */0
              ];
      } else {
        var lid_loc_000$1 = /* txt : Lident */Block.__(0, ["None"]);
        var lid_loc$1 = /* record */[
          lid_loc_000$1,
          /* loc */loc$1
        ];
        return /* record */[
                /* pexp_desc : Pexp_construct */Block.__(9, [
                    lid_loc$1,
                    /* None */0
                  ]),
                /* pexp_loc */loc$1,
                /* pexp_attributes : [] */0
              ];
      }
    };
    var mk_fmtty = function (fmtty) {
      if (typeof fmtty === "number") {
        return mk_constr("End_of_fmtty", /* [] */0);
      } else {
        switch (fmtty.tag | 0) {
          case 0 : 
              return mk_constr("Char_ty", /* :: */[
                          mk_fmtty(fmtty[0]),
                          /* [] */0
                        ]);
          case 1 : 
              return mk_constr("String_ty", /* :: */[
                          mk_fmtty(fmtty[0]),
                          /* [] */0
                        ]);
          case 2 : 
              return mk_constr("Int_ty", /* :: */[
                          mk_fmtty(fmtty[0]),
                          /* [] */0
                        ]);
          case 3 : 
              return mk_constr("Int32_ty", /* :: */[
                          mk_fmtty(fmtty[0]),
                          /* [] */0
                        ]);
          case 4 : 
              return mk_constr("Nativeint_ty", /* :: */[
                          mk_fmtty(fmtty[0]),
                          /* [] */0
                        ]);
          case 5 : 
              return mk_constr("Int64_ty", /* :: */[
                          mk_fmtty(fmtty[0]),
                          /* [] */0
                        ]);
          case 6 : 
              return mk_constr("Float_ty", /* :: */[
                          mk_fmtty(fmtty[0]),
                          /* [] */0
                        ]);
          case 7 : 
              return mk_constr("Bool_ty", /* :: */[
                          mk_fmtty(fmtty[0]),
                          /* [] */0
                        ]);
          case 8 : 
              return mk_constr("Format_arg_ty", /* :: */[
                          mk_fmtty(fmtty[0]),
                          /* :: */[
                            mk_fmtty(fmtty[1]),
                            /* [] */0
                          ]
                        ]);
          case 9 : 
              return mk_constr("Format_subst_ty", /* :: */[
                          mk_fmtty(fmtty[0]),
                          /* :: */[
                            mk_fmtty(fmtty[1]),
                            /* :: */[
                              mk_fmtty(fmtty[2]),
                              /* [] */0
                            ]
                          ]
                        ]);
          case 10 : 
              return mk_constr("Alpha_ty", /* :: */[
                          mk_fmtty(fmtty[0]),
                          /* [] */0
                        ]);
          case 11 : 
              return mk_constr("Theta_ty", /* :: */[
                          mk_fmtty(fmtty[0]),
                          /* [] */0
                        ]);
          case 12 : 
              return mk_constr("Any_ty", /* :: */[
                          mk_fmtty(fmtty[0]),
                          /* [] */0
                        ]);
          case 13 : 
              return mk_constr("Reader_ty", /* :: */[
                          mk_fmtty(fmtty[0]),
                          /* [] */0
                        ]);
          case 14 : 
              return mk_constr("Ignored_reader_ty", /* :: */[
                          mk_fmtty(fmtty[0]),
                          /* [] */0
                        ]);
          
        }
      }
    };
    var mk_ignored = function (ign) {
      if (typeof ign === "number") {
        switch (ign) {
          case 0 : 
              return mk_constr("Ignored_char", /* [] */0);
          case 1 : 
              return mk_constr("Ignored_caml_char", /* [] */0);
          case 2 : 
              return mk_constr("Ignored_bool", /* [] */0);
          case 3 : 
              return mk_constr("Ignored_reader", /* [] */0);
          case 4 : 
              return mk_constr("Ignored_scan_next_char", /* [] */0);
          
        }
      } else {
        switch (ign.tag | 0) {
          case 0 : 
              return mk_constr("Ignored_string", /* :: */[
                          mk_int_opt(ign[0]),
                          /* [] */0
                        ]);
          case 1 : 
              return mk_constr("Ignored_caml_string", /* :: */[
                          mk_int_opt(ign[0]),
                          /* [] */0
                        ]);
          case 2 : 
              return mk_constr("Ignored_int", /* :: */[
                          mk_iconv(ign[0]),
                          /* :: */[
                            mk_int_opt(ign[1]),
                            /* [] */0
                          ]
                        ]);
          case 3 : 
              return mk_constr("Ignored_int32", /* :: */[
                          mk_iconv(ign[0]),
                          /* :: */[
                            mk_int_opt(ign[1]),
                            /* [] */0
                          ]
                        ]);
          case 4 : 
              return mk_constr("Ignored_nativeint", /* :: */[
                          mk_iconv(ign[0]),
                          /* :: */[
                            mk_int_opt(ign[1]),
                            /* [] */0
                          ]
                        ]);
          case 5 : 
              return mk_constr("Ignored_int64", /* :: */[
                          mk_iconv(ign[0]),
                          /* :: */[
                            mk_int_opt(ign[1]),
                            /* [] */0
                          ]
                        ]);
          case 6 : 
              return mk_constr("Ignored_float", /* :: */[
                          mk_int_opt(ign[0]),
                          /* :: */[
                            mk_int_opt(ign[1]),
                            /* [] */0
                          ]
                        ]);
          case 7 : 
              return mk_constr("Ignored_format_arg", /* :: */[
                          mk_int_opt(ign[0]),
                          /* :: */[
                            mk_fmtty(ign[1]),
                            /* [] */0
                          ]
                        ]);
          case 8 : 
              return mk_constr("Ignored_format_subst", /* :: */[
                          mk_int_opt(ign[0]),
                          /* :: */[
                            mk_fmtty(ign[1]),
                            /* [] */0
                          ]
                        ]);
          case 9 : 
              return mk_constr("Ignored_scan_char_set", /* :: */[
                          mk_int_opt(ign[0]),
                          /* :: */[
                            /* record */[
                              /* pexp_desc : Pexp_constant */Block.__(1, [/* Const_string */Block.__(2, [
                                      ign[1],
                                      /* None */0
                                    ])]),
                              /* pexp_loc */loc$1,
                              /* pexp_attributes : [] */0
                            ],
                            /* [] */0
                          ]
                        ]);
          case 10 : 
              return mk_constr("Ignored_scan_get_counter", /* :: */[
                          mk_counter(ign[0]),
                          /* [] */0
                        ]);
          
        }
      }
    };
    var mk_padding = function (pad) {
      if (typeof pad === "number") {
        return mk_constr("No_padding", /* [] */0);
      } else if (pad.tag) {
        return mk_constr("Arg_padding", /* :: */[
                    mk_side(pad[0]),
                    /* [] */0
                  ]);
      } else {
        return mk_constr("Lit_padding", /* :: */[
                    mk_side(pad[0]),
                    /* :: */[
                      /* record */[
                        /* pexp_desc : Pexp_constant */Block.__(1, [/* Const_int */Block.__(0, [pad[1]])]),
                        /* pexp_loc */loc$1,
                        /* pexp_attributes : [] */0
                      ],
                      /* [] */0
                    ]
                  ]);
      }
    };
    var mk_precision = function (prec) {
      if (typeof prec === "number") {
        if (prec !== 0) {
          return mk_constr("Arg_precision", /* [] */0);
        } else {
          return mk_constr("No_precision", /* [] */0);
        }
      } else {
        return mk_constr("Lit_precision", /* :: */[
                    /* record */[
                      /* pexp_desc : Pexp_constant */Block.__(1, [/* Const_int */Block.__(0, [prec[0]])]),
                      /* pexp_loc */loc$1,
                      /* pexp_attributes : [] */0
                    ],
                    /* [] */0
                  ]);
      }
    };
    var mk_fmt = function (fmt) {
      if (typeof fmt === "number") {
        return mk_constr("End_of_format", /* [] */0);
      } else {
        switch (fmt.tag | 0) {
          case 0 : 
              return mk_constr("Char", /* :: */[
                          mk_fmt(fmt[0]),
                          /* [] */0
                        ]);
          case 1 : 
              return mk_constr("Caml_char", /* :: */[
                          mk_fmt(fmt[0]),
                          /* [] */0
                        ]);
          case 2 : 
              return mk_constr("String", /* :: */[
                          mk_padding(fmt[0]),
                          /* :: */[
                            mk_fmt(fmt[1]),
                            /* [] */0
                          ]
                        ]);
          case 3 : 
              return mk_constr("Caml_string", /* :: */[
                          mk_padding(fmt[0]),
                          /* :: */[
                            mk_fmt(fmt[1]),
                            /* [] */0
                          ]
                        ]);
          case 4 : 
              return mk_constr("Int", /* :: */[
                          mk_iconv(fmt[0]),
                          /* :: */[
                            mk_padding(fmt[1]),
                            /* :: */[
                              mk_precision(fmt[2]),
                              /* :: */[
                                mk_fmt(fmt[3]),
                                /* [] */0
                              ]
                            ]
                          ]
                        ]);
          case 5 : 
              return mk_constr("Int32", /* :: */[
                          mk_iconv(fmt[0]),
                          /* :: */[
                            mk_padding(fmt[1]),
                            /* :: */[
                              mk_precision(fmt[2]),
                              /* :: */[
                                mk_fmt(fmt[3]),
                                /* [] */0
                              ]
                            ]
                          ]
                        ]);
          case 6 : 
              return mk_constr("Nativeint", /* :: */[
                          mk_iconv(fmt[0]),
                          /* :: */[
                            mk_padding(fmt[1]),
                            /* :: */[
                              mk_precision(fmt[2]),
                              /* :: */[
                                mk_fmt(fmt[3]),
                                /* [] */0
                              ]
                            ]
                          ]
                        ]);
          case 7 : 
              return mk_constr("Int64", /* :: */[
                          mk_iconv(fmt[0]),
                          /* :: */[
                            mk_padding(fmt[1]),
                            /* :: */[
                              mk_precision(fmt[2]),
                              /* :: */[
                                mk_fmt(fmt[3]),
                                /* [] */0
                              ]
                            ]
                          ]
                        ]);
          case 8 : 
              return mk_constr("Float", /* :: */[
                          mk_fconv(fmt[0]),
                          /* :: */[
                            mk_padding(fmt[1]),
                            /* :: */[
                              mk_precision(fmt[2]),
                              /* :: */[
                                mk_fmt(fmt[3]),
                                /* [] */0
                              ]
                            ]
                          ]
                        ]);
          case 9 : 
              return mk_constr("Bool", /* :: */[
                          mk_fmt(fmt[0]),
                          /* [] */0
                        ]);
          case 10 : 
              return mk_constr("Flush", /* :: */[
                          mk_fmt(fmt[0]),
                          /* [] */0
                        ]);
          case 11 : 
              return mk_constr("String_literal", /* :: */[
                          /* record */[
                            /* pexp_desc : Pexp_constant */Block.__(1, [/* Const_string */Block.__(2, [
                                    fmt[0],
                                    /* None */0
                                  ])]),
                            /* pexp_loc */loc$1,
                            /* pexp_attributes : [] */0
                          ],
                          /* :: */[
                            mk_fmt(fmt[1]),
                            /* [] */0
                          ]
                        ]);
          case 12 : 
              return mk_constr("Char_literal", /* :: */[
                          /* record */[
                            /* pexp_desc : Pexp_constant */Block.__(1, [/* Const_char */Block.__(1, [fmt[0]])]),
                            /* pexp_loc */loc$1,
                            /* pexp_attributes : [] */0
                          ],
                          /* :: */[
                            mk_fmt(fmt[1]),
                            /* [] */0
                          ]
                        ]);
          case 13 : 
              return mk_constr("Format_arg", /* :: */[
                          mk_int_opt(fmt[0]),
                          /* :: */[
                            mk_fmtty(fmt[1]),
                            /* :: */[
                              mk_fmt(fmt[2]),
                              /* [] */0
                            ]
                          ]
                        ]);
          case 14 : 
              return mk_constr("Format_subst", /* :: */[
                          mk_int_opt(fmt[0]),
                          /* :: */[
                            mk_fmtty(fmt[1]),
                            /* :: */[
                              mk_fmt(fmt[2]),
                              /* [] */0
                            ]
                          ]
                        ]);
          case 15 : 
              return mk_constr("Alpha", /* :: */[
                          mk_fmt(fmt[0]),
                          /* [] */0
                        ]);
          case 16 : 
              return mk_constr("Theta", /* :: */[
                          mk_fmt(fmt[0]),
                          /* [] */0
                        ]);
          case 17 : 
              return mk_constr("Formatting_lit", /* :: */[
                          mk_formatting_lit(fmt[0]),
                          /* :: */[
                            mk_fmt(fmt[1]),
                            /* [] */0
                          ]
                        ]);
          case 18 : 
              return mk_constr("Formatting_gen", /* :: */[
                          mk_formatting_gen(fmt[0]),
                          /* :: */[
                            mk_fmt(fmt[1]),
                            /* [] */0
                          ]
                        ]);
          case 19 : 
              return mk_constr("Reader", /* :: */[
                          mk_fmt(fmt[0]),
                          /* [] */0
                        ]);
          case 20 : 
              return mk_constr("Scan_char_set", /* :: */[
                          mk_int_opt(fmt[0]),
                          /* :: */[
                            /* record */[
                              /* pexp_desc : Pexp_constant */Block.__(1, [/* Const_string */Block.__(2, [
                                      fmt[1],
                                      /* None */0
                                    ])]),
                              /* pexp_loc */loc$1,
                              /* pexp_attributes : [] */0
                            ],
                            /* :: */[
                              mk_fmt(fmt[2]),
                              /* [] */0
                            ]
                          ]
                        ]);
          case 21 : 
              return mk_constr("Scan_get_counter", /* :: */[
                          mk_counter(fmt[0]),
                          /* :: */[
                            mk_fmt(fmt[1]),
                            /* [] */0
                          ]
                        ]);
          case 22 : 
              return mk_constr("Scan_next_char", /* :: */[
                          mk_fmt(fmt[0]),
                          /* [] */0
                        ]);
          case 23 : 
              return mk_constr("Ignored_param", /* :: */[
                          mk_ignored(fmt[0]),
                          /* :: */[
                            mk_fmt(fmt[1]),
                            /* [] */0
                          ]
                        ]);
          case 24 : 
              throw [
                    Caml_builtin_exceptions.assert_failure,
                    [
                      "typecore.ml",
                      2989,
                      10
                    ]
                  ];
          
        }
      }
    };
    var legacy_behavior = 1 - strict_formats[0];
    var match = CamlinternalFormat.fmt_ebb_of_string(/* Some */[legacy_behavior], str);
    return mk_constr("Format", /* :: */[
                mk_fmt(match[0]),
                /* :: */[
                  /* record */[
                    /* pexp_desc : Pexp_constant */Block.__(1, [/* Const_string */Block.__(2, [
                            str,
                            /* None */0
                          ])]),
                    /* pexp_loc */loc$1,
                    /* pexp_attributes : [] */0
                  ],
                  /* [] */0
                ]
              ]);
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === Caml_builtin_exceptions.failure) {
      throw [
            $$Error$7,
            loc$1,
            env,
            /* Invalid_format */Block.__(15, [exn[1]])
          ];
    } else {
      throw exn;
    }
  }
}

function type_label_exp(create, env, loc, ty_expected, param) {
  var sarg = param[2];
  var label = param[1];
  var lid = param[0];
  begin_def(/* () */0);
  var separate = principal[0] || env[/* local_constraints */11];
  if (separate) {
    begin_def(/* () */0);
    begin_def(/* () */0);
  }
  var match = instance_label(/* true */1, label);
  var ty_res = match[2];
  var ty_arg = match[1];
  var vars = match[0];
  if (separate) {
    end_def(/* () */0);
    generalize_structure$1(current_level[0], ty_arg);
    generalize_structure$1(current_level[0], ty_res);
  }
  try {
    unify$2(env, instance_def(ty_res), instance(/* None */0, env, ty_expected));
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === Unify) {
      throw [
            $$Error$7,
            lid[/* loc */1],
            env,
            /* Label_mismatch */Block.__(2, [
                lid[/* txt */0],
                exn[1]
              ])
          ];
    } else {
      throw exn;
    }
  }
  var ty_arg$1 = instance_def(ty_arg);
  if (separate) {
    end_def(/* () */0);
    generalize_structure$1(current_level[0], ty_arg$1);
  }
  if (!label[/* lbl_private */7]) {
    if (create) {
      throw [
            $$Error$7,
            loc,
            env,
            /* Private_type */Block.__(19, [ty_expected])
          ];
    } else {
      throw [
            $$Error$7,
            lid[/* loc */1],
            env,
            /* Private_label */Block.__(20, [
                lid[/* txt */0],
                ty_expected
              ])
          ];
    }
  }
  var snap = vars ? /* Some */[snapshot(/* () */0)] : /* None */0;
  var arg = type_argument(env, sarg, ty_arg$1, instance(/* None */0, env, ty_arg$1));
  end_def(/* () */0);
  var arg$1;
  try {
    check_univars(env, +(vars !== /* [] */0), "field value", arg, label[/* lbl_arg */2], vars);
    arg$1 = arg;
  }
  catch (exn$1){
    if (is_nonexpansive(arg)) {
      throw exn$1;
    } else {
      try {
        may(backtrack, snap);
        begin_def(/* () */0);
        var arg$2 = type_exp(env, sarg);
        end_def(/* () */0);
        generalize_expansive$1(env, arg$2[/* exp_type */3]);
        unify_exp(env, arg$2, ty_arg$1);
        check_univars(env, /* false */0, "field value", arg$2, label[/* lbl_arg */2], vars);
        arg$1 = arg$2;
      }
      catch (raw_e){
        var e = Js_exn.internalToOCamlException(raw_e);
        if (e[0] === $$Error$7) {
          var $js = e[3];
          if (typeof $js === "number") {
            throw exn$1;
          } else if ($js.tag === 31) {
            throw e;
          } else {
            throw exn$1;
          }
        } else {
          throw exn$1;
        }
      }
    }
  }
  var newrecord = arg$1.slice();
  return /* tuple */[
          lid,
          label,
          (newrecord[/* exp_type */3] = instance(/* None */0, env, arg$1[/* exp_type */3]), newrecord)
        ];
}

function type_argument(env, sarg, ty_expected$prime, ty_expected) {
  var no_labels = function (ty) {
    var match = list_labels(env, ty);
    if (match[1]) {
      return /* false */0;
    } else {
      return List.for_all((function (param) {
                    return Caml_obj.caml_equal("", param);
                  }), match[0]);
    }
  };
  var is_inferred = function (_sexp) {
    while(true) {
      var sexp = _sexp;
      var match = sexp[/* pexp_desc */0];
      switch (match.tag | 0) {
        case 15 : 
            var match$1 = match[2];
            if (match$1) {
              if (is_inferred(match[1])) {
                _sexp = match$1[0];
                continue ;
                
              } else {
                return /* false */0;
              }
            } else {
              return /* false */0;
            }
            break;
        case 16 : 
            _sexp = match[1];
            continue ;
            case 0 : 
        case 5 : 
        case 12 : 
        case 19 : 
        case 20 : 
        case 21 : 
        case 22 : 
            return /* true */1;
        case 32 : 
            _sexp = match[2];
            continue ;
            default:
          return /* false */0;
      }
    };
  };
  var match = expand_head(env, ty_expected$prime);
  var match$1 = match[/* desc */0];
  var exit = 0;
  if (typeof match$1 === "number") {
    exit = 1;
  } else if (match$1.tag === 1) {
    if (match$1[0] === "") {
      var ty_res = match$1[2];
      var lv = match[/* level */1];
      if (is_inferred(sarg)) {
        if (principal[0]) {
          begin_def(/* () */0);
        }
        var texp = type_exp(env, sarg);
        if (principal[0]) {
          end_def(/* () */0);
          generalize_structure$1(current_level[0], texp[/* exp_type */3]);
        }
        var make_args = function (_args, _ty_fun) {
          while(true) {
            var ty_fun = _ty_fun;
            var args = _args;
            var match = expand_head(env, ty_fun)[/* desc */0];
            var exit = 0;
            if (typeof match === "number") {
              exit = 1;
            } else {
              switch (match.tag | 0) {
                case 0 : 
                    return /* tuple */[
                            List.rev(args),
                            ty_fun,
                            /* false */0
                          ];
                case 1 : 
                    var ty_fun$1 = match[2];
                    var l = match[0];
                    if (is_optional(l)) {
                      var ty = option_none(instance(/* None */0, env, match[1]), sarg[/* pexp_loc */1]);
                      _ty_fun = ty_fun$1;
                      _args = /* :: */[
                        /* tuple */[
                          l,
                          /* Some */[ty],
                          /* Optional */1
                        ],
                        args
                      ];
                      continue ;
                      
                    } else if (l === "" || classic[0]) {
                      return /* tuple */[
                              List.rev(args),
                              ty_fun,
                              no_labels(ty_fun$1)
                            ];
                    } else {
                      exit = 1;
                    }
                    break;
                default:
                  exit = 1;
              }
            }
            if (exit === 1) {
              return /* tuple */[
                      /* [] */0,
                      texp[/* exp_type */3],
                      /* false */0
                    ];
            }
            
          };
        };
        var match$2 = make_args(/* [] */0, texp[/* exp_type */3]);
        var ty_fun$prime = match$2[1];
        var args = match$2[0];
        var warn = principal[0] && +(lv !== 100000000 || repr(ty_fun$prime)[/* level */1] !== 100000000);
        var newrecord = texp.slice();
        newrecord[/* exp_type */3] = instance(/* None */0, env, texp[/* exp_type */3]);
        var ty_fun = instance(/* None */0, env, ty_fun$prime);
        if (match$2[2] || no_labels(ty_res)) {
          var newrecord$1 = newrecord.slice();
          unify_exp(env, (newrecord$1[/* exp_type */3] = ty_fun, newrecord$1), ty_expected);
          if (args) {
            var var_pair = function (name, ty) {
              var id = create(name);
              return /* tuple */[
                      /* record */[
                        /* pat_desc : Tpat_var */Block.__(0, [
                            id,
                            /* record */[
                              /* txt */name,
                              /* loc */none
                            ]
                          ]),
                        /* pat_loc */none,
                        /* pat_extra : [] */0,
                        /* pat_type */ty,
                        /* pat_env */env,
                        /* pat_attributes : [] */0
                      ],
                      /* record */[
                        /* exp_desc : Texp_ident */Block.__(0, [
                            /* Pident */Block.__(0, [id]),
                            /* record */[
                              /* txt : Lident */Block.__(0, [name]),
                              /* loc */none
                            ],
                            /* record */[
                              /* val_type */ty,
                              /* val_kind : Val_reg */0,
                              /* val_loc */none,
                              /* val_attributes : [] */0
                            ]
                          ]),
                        /* exp_loc */none,
                        /* exp_extra : [] */0,
                        /* exp_type */ty,
                        /* exp_env */env,
                        /* exp_attributes : [] */0
                      ]
                    ];
            };
            var match$3 = var_pair("eta", match$1[1]);
            var eta_var = match$3[1];
            var eta_pat = match$3[0];
            var func = function (texp) {
              var e_000 = /* exp_desc : Texp_apply */Block.__(4, [
                  texp,
                  Pervasives.$at(args, /* :: */[
                        /* tuple */[
                          "",
                          /* Some */[eta_var],
                          /* Required */0
                        ],
                        /* [] */0
                      ])
                ]);
              var e_001 = /* exp_loc */texp[/* exp_loc */1];
              var e_002 = /* exp_extra */texp[/* exp_extra */2];
              var e_004 = /* exp_env */texp[/* exp_env */4];
              var e_005 = /* exp_attributes */texp[/* exp_attributes */5];
              var e = /* record */[
                e_000,
                e_001,
                e_002,
                /* exp_type */ty_res,
                e_004,
                e_005
              ];
              return /* record */[
                      /* exp_desc : Texp_function */Block.__(3, [
                          "",
                          /* :: */[
                            /* record */[
                              /* c_lhs */eta_pat,
                              /* c_guard : None */0,
                              /* c_rhs */e
                            ],
                            /* [] */0
                          ],
                          /* Total */1
                        ]),
                      /* exp_loc */texp[/* exp_loc */1],
                      /* exp_extra */texp[/* exp_extra */2],
                      /* exp_type */ty_fun,
                      /* exp_env */texp[/* exp_env */4],
                      /* exp_attributes */texp[/* exp_attributes */5]
                    ];
            };
            prerr_warning(newrecord[/* exp_loc */1], /* Eliminated_optional_arguments */Block.__(31, [List.map((function (param) {
                            return param[0];
                          }), args)]));
            if (warn) {
              prerr_warning(newrecord[/* exp_loc */1], /* Without_principality */Block.__(9, ["eliminated optional argument"]));
            }
            if (is_nonexpansive(newrecord)) {
              return func(newrecord);
            } else {
              var match$4 = var_pair("arg", newrecord[/* exp_type */3]);
              return re(/* record */[
                          /* exp_desc : Texp_let */Block.__(2, [
                              /* Nonrecursive */0,
                              /* :: */[
                                /* record */[
                                  /* vb_pat */match$4[0],
                                  /* vb_expr */newrecord,
                                  /* vb_attributes : [] */0,
                                  /* vb_loc */none
                                ],
                                /* [] */0
                              ],
                              func(match$4[1])
                            ]),
                          /* exp_loc */newrecord[/* exp_loc */1],
                          /* exp_extra */newrecord[/* exp_extra */2],
                          /* exp_type */ty_fun,
                          /* exp_env */newrecord[/* exp_env */4],
                          /* exp_attributes */newrecord[/* exp_attributes */5]
                        ]);
            }
          } else {
            return newrecord;
          }
        } else {
          unify_exp(env, newrecord, ty_expected);
          return newrecord;
        }
      } else {
        exit = 1;
      }
    } else {
      exit = 1;
    }
  } else {
    exit = 1;
  }
  if (exit === 1) {
    var texp$1 = type_expect(/* None */0, env, sarg, ty_expected$prime);
    unify_exp(env, texp$1, ty_expected);
    return texp$1;
  }
  
}

function type_application(env, funct, sargs) {
  var result_type = function (omitted, ty_fun) {
    return List.fold_left((function (ty_fun, param) {
                  return newty2(param[2], /* Tarrow */Block.__(1, [
                                param[0],
                                param[1],
                                ty_fun,
                                /* Cok */0
                              ]));
                }), ty_fun, omitted);
  };
  var has_label = function (l, ty_fun) {
    var match = list_labels(env, ty_fun);
    if (match[1]) {
      return /* true */1;
    } else {
      return List.mem(l, match[0]);
    }
  };
  var ignored = [/* [] */0];
  var match = list_labels(env, funct[/* exp_type */3]);
  var labels = List.filter((function (l) {
            return 1 - is_optional(l);
          }))(match[0]);
  var ignore_labels = classic[0] || 1 - match[1] && +(List.length(labels) === List.length(sargs)) && List.for_all((function (param) {
          return +(param[0] === "");
        }), sargs) && List.exists((function (l) {
          return +(l !== "");
        }), labels) && (prerr_warning(funct[/* exp_loc */1], /* Labels_omitted */3), /* true */1);
  var warned = [/* false */0];
  var type_args = function (_args, _omitted, _ty_fun, _ty_fun0, _ty_old, _sargs, _more_sargs) {
    while(true) {
      var more_sargs = _more_sargs;
      var sargs = _sargs;
      var ty_old = _ty_old;
      var ty_fun0 = _ty_fun0;
      var ty_fun = _ty_fun;
      var omitted = _omitted;
      var args = _args;
      var match = expand_head(env, ty_fun);
      var match$1 = expand_head(env, ty_fun0);
      var match$2 = match[/* desc */0];
      var exit = 0;
      if (typeof match$2 === "number") {
        exit = 1;
      } else if (match$2.tag === 1) {
        var ty_fun$1 = match$2[2];
        var ty = match$2[1];
        var l = match$2[0];
        var lv = match[/* level */1];
        var match$3 = match$1[/* desc */0];
        if (typeof match$3 === "number") {
          exit = 1;
        } else if (match$3.tag === 1) {
          var ty0 = match$3[1];
          if ((sargs !== /* [] */0 || more_sargs !== /* [] */0) && commu_repr(match$2[3]) === /* Cok */0) {
            var may_warn = (function(lv){
            return function may_warn(loc, w) {
              if (!warned[0] && principal[0] && lv !== 100000000) {
                warned[0] = /* true */1;
                return prerr_warning(loc, w);
              } else {
                return 0;
              }
            }
            }(lv));
            var name = label_name(l);
            var optional = is_optional(l) ? /* Optional */1 : /* Required */0;
            var match$4;
            if (ignore_labels && !is_optional(l)) {
              if (sargs) {
                var match$5 = sargs[0];
                throw [
                      $$Error$7,
                      match$5[1][/* pexp_loc */1],
                      env,
                      /* Apply_wrong_label */Block.__(9, [
                          match$5[0],
                          ty_old
                        ])
                    ];
              } else if (more_sargs) {
                var match$6 = more_sargs[0];
                var sarg0 = match$6[1];
                var l$prime = match$6[0];
                if (l !== l$prime && l$prime !== "") {
                  throw [
                        $$Error$7,
                        sarg0[/* pexp_loc */1],
                        env,
                        /* Apply_wrong_label */Block.__(9, [
                            l$prime,
                            match
                          ])
                      ];
                } else {
                  match$4 = /* tuple */[
                    /* [] */0,
                    more_sargs[1],
                    /* Some */[(function(ty,ty0,sarg0){
                      return function () {
                        return type_argument(env, sarg0, ty, ty0);
                      }
                      }(ty,ty0,sarg0))]
                  ];
                }
              } else {
                throw [
                      Caml_builtin_exceptions.assert_failure,
                      [
                        "typecore.ml",
                        3248,
                        16
                      ]
                    ];
              }
            } else {
              try {
                var match$7;
                try {
                  var match$8 = extract_label_aux(/* [] */0, name, sargs);
                  var sargs1 = match$8[2];
                  var sarg0$1 = match$8[1];
                  if (sargs1 !== /* [] */0) {
                    may_warn(sarg0$1[/* pexp_loc */1], /* Not_principal */Block.__(8, ["commuting this argument"]));
                  }
                  match$7 = /* tuple */[
                    match$8[0],
                    sarg0$1,
                    Pervasives.$at(sargs1, match$8[3]),
                    more_sargs
                  ];
                }
                catch (exn){
                  if (exn === Caml_builtin_exceptions.not_found) {
                    var match$9 = extract_label_aux(/* [] */0, name, more_sargs);
                    var sargs1$1 = match$9[2];
                    var sarg0$2 = match$9[1];
                    if (sargs1$1 !== /* [] */0 || sargs !== /* [] */0) {
                      may_warn(sarg0$2[/* pexp_loc */1], /* Not_principal */Block.__(8, ["commuting this argument"]));
                    }
                    match$7 = /* tuple */[
                      match$9[0],
                      sarg0$2,
                      Pervasives.$at(sargs, sargs1$1),
                      match$9[3]
                    ];
                  } else {
                    throw exn;
                  }
                }
                var sarg0$3 = match$7[1];
                var l$prime$1 = match$7[0];
                if (optional === /* Required */0 && is_optional(l$prime$1)) {
                  prerr_warning(sarg0$3[/* pexp_loc */1], /* Nonoptional_label */Block.__(26, [l]));
                }
                match$4 = /* tuple */[
                  match$7[2],
                  match$7[3],
                  optional === /* Required */0 || is_optional(l$prime$1) ? /* Some */[(function(ty,ty0,sarg0$3){
                      return function () {
                        return type_argument(env, sarg0$3, ty, ty0);
                      }
                      }(ty,ty0,sarg0$3))] : (may_warn(sarg0$3[/* pexp_loc */1], /* Not_principal */Block.__(8, ["using an optional argument here"])), /* Some */[(function(ty,ty0,sarg0$3){
                        return function () {
                          return option_some(type_argument(env, sarg0$3, extract_option_type(env, ty), extract_option_type(env, ty0)));
                        }
                        }(ty,ty0,sarg0$3))])
                ];
              }
              catch (exn$1){
                if (exn$1 === Caml_builtin_exceptions.not_found) {
                  match$4 = /* tuple */[
                    sargs,
                    more_sargs,
                    optional === /* Optional */1 && (List.mem_assoc("", sargs) || List.mem_assoc("", more_sargs)) ? (may_warn(funct[/* exp_loc */1], /* Without_principality */Block.__(9, ["eliminated optional argument"])), ignored[0] = /* :: */[
                          /* tuple */[
                            l,
                            ty,
                            lv
                          ],
                          ignored[0]
                        ], /* Some */[(function(ty){
                          return function () {
                            return option_none(instance(/* None */0, env, ty), none);
                          }
                          }(ty))]) : (may_warn(funct[/* exp_loc */1], /* Without_principality */Block.__(9, ["commuted an argument"])), /* None */0)
                  ];
                } else {
                  throw exn$1;
                }
              }
            }
            var arg = match$4[2];
            var sargs$1 = match$4[0];
            var omitted$1 = arg ? omitted : /* :: */[
                /* tuple */[
                  l,
                  ty,
                  lv
                ],
                omitted
              ];
            var ty_old$1 = sargs$1 ? ty_old : ty_fun$1;
            _more_sargs = match$4[1];
            _sargs = sargs$1;
            _ty_old = ty_old$1;
            _ty_fun0 = match$3[2];
            _ty_fun = ty_fun$1;
            _omitted = omitted$1;
            _args = /* :: */[
              /* tuple */[
                l,
                arg,
                optional
              ],
              args
            ];
            continue ;
            
          } else {
            exit = 1;
          }
        } else {
          exit = 1;
        }
      } else {
        exit = 1;
      }
      if (exit === 1) {
        var exit$1 = 0;
        if (sargs) {
          if (ignore_labels) {
            var match$10 = sargs[0];
            throw [
                  $$Error$7,
                  match$10[1][/* pexp_loc */1],
                  env,
                  /* Apply_wrong_label */Block.__(9, [
                      match$10[0],
                      ty_old
                    ])
                ];
          } else {
            exit$1 = 2;
          }
        } else {
          exit$1 = 2;
        }
        if (exit$1 === 2) {
          var _args$1 = args;
          var omitted$2 = omitted;
          var _ty_fun$1 = ty_fun0;
          var _param = Pervasives.$at(sargs, more_sargs);
          while(true) {
            var param = _param;
            var ty_fun$2 = _ty_fun$1;
            var args$1 = _args$1;
            if (param) {
              var match$11 = param[0];
              var sarg1 = match$11[1];
              var l1 = match$11[0];
              var ty_fun$3 = expand_head(env, ty_fun$2);
              var td = ty_fun$3[/* desc */0];
              var match$12;
              var exit$2 = 0;
              if (typeof td === "number") {
                exit$2 = 1;
              } else {
                switch (td.tag | 0) {
                  case 0 : 
                      var t1 = newvar(/* None */0, /* () */0);
                      var t2 = newvar(/* None */0, /* () */0);
                      var not_identity = function (param) {
                        if (param.tag) {
                          return /* true */1;
                        } else {
                          var match = param[2][/* val_kind */1];
                          if (typeof match === "number" || !(!match.tag && match[0][/* prim_name */0] === "%identity")) {
                            return /* true */1;
                          } else {
                            return /* false */0;
                          }
                        }
                      };
                      if (ty_fun$3[/* level */1] >= t1[/* level */1] && not_identity(funct[/* exp_desc */0])) {
                        prerr_warning(sarg1[/* pexp_loc */1], /* Unused_argument */9);
                      }
                      unify$2(env, ty_fun$3, newty2(current_level[0], /* Tarrow */Block.__(1, [
                                  l1,
                                  t1,
                                  t2,
                                  /* Clink */[[/* Cunknown */1]]
                                ])));
                      match$12 = /* tuple */[
                        t1,
                        t2
                      ];
                      break;
                  case 1 : 
                      var l$1 = td[0];
                      if (l$1 === l1 || classic[0] && l1 === "" && !is_optional(l$1)) {
                        match$12 = /* tuple */[
                          td[1],
                          td[2]
                        ];
                      } else {
                        exit$2 = 1;
                      }
                      break;
                  default:
                    exit$2 = 1;
                }
              }
              if (exit$2 === 1) {
                var ty_fun$4;
                ty_fun$4 = typeof td === "number" || td.tag !== 1 ? ty_fun$3 : newty2(current_level[0], td);
                var ty_res = result_type(Pervasives.$at(omitted$2, ignored[0]), ty_fun$4);
                var match$13 = ty_res[/* desc */0];
                var exit$3 = 0;
                if (typeof match$13 === "number") {
                  exit$3 = 2;
                } else if (match$13.tag === 1) {
                  if (classic[0] || !has_label(l1, ty_fun$4)) {
                    throw [
                          $$Error$7,
                          sarg1[/* pexp_loc */1],
                          env,
                          /* Apply_wrong_label */Block.__(9, [
                              l1,
                              ty_res
                            ])
                        ];
                  } else {
                    throw [
                          $$Error$7,
                          funct[/* exp_loc */1],
                          env,
                          /* Incoherent_label_order */1
                        ];
                  }
                } else {
                  exit$3 = 2;
                }
                if (exit$3 === 2) {
                  throw [
                        $$Error$7,
                        funct[/* exp_loc */1],
                        env,
                        /* Apply_non_function */Block.__(8, [expand_head(env, funct[/* exp_type */3])])
                      ];
                }
                
              }
              var ty1 = match$12[0];
              var optional$1 = is_optional(l1) ? /* Optional */1 : /* Required */0;
              var arg1 = (function(sarg1,ty1,optional$1){
              return function arg1() {
                var arg1$1 = type_expect(/* None */0, env, sarg1, ty1);
                if (optional$1 === /* Optional */1) {
                  unify_exp(env, arg1$1, type_option$1(newvar(/* None */0, /* () */0)));
                }
                return arg1$1;
              }
              }(sarg1,ty1,optional$1));
              _param = param[1];
              _ty_fun$1 = match$12[1];
              _args$1 = /* :: */[
                /* tuple */[
                  l1,
                  /* Some */[arg1],
                  optional$1
                ],
                args$1
              ];
              continue ;
              
            } else {
              return /* tuple */[
                      List.map((function (param) {
                              var match = param[1];
                              var l = param[0];
                              if (match) {
                                return /* tuple */[
                                        l,
                                        /* Some */[Curry._1(match[0], /* () */0)],
                                        param[2]
                                      ];
                              } else {
                                return /* tuple */[
                                        l,
                                        /* None */0,
                                        param[2]
                                      ];
                              }
                            }), List.rev(args$1)),
                      instance(/* None */0, env, result_type(omitted$2, ty_fun$2))
                    ];
            }
          };
        }
        
      }
      
    };
  };
  var match$1 = funct[/* exp_desc */0];
  var exit = 0;
  if (match$1.tag) {
    exit = 1;
  } else {
    var match$2 = match$1[2][/* val_kind */1];
    if (typeof match$2 === "number") {
      exit = 1;
    } else if (match$2.tag) {
      exit = 1;
    } else if (match$2[0][/* prim_name */0] === "%ignore") {
      if (sargs) {
        var match$3 = sargs[0];
        if (match$3[0] === "") {
          if (sargs[1]) {
            exit = 1;
          } else {
            var match$4 = filter_arrow(env, instance(/* None */0, env, funct[/* exp_type */3]), "");
            var exp = type_expect(/* None */0, env, match$3[1], match$4[0]);
            var match$5 = expand_head(env, exp[/* exp_type */3])[/* desc */0];
            if (typeof match$5 !== "number") {
              switch (match$5.tag | 0) {
                case 0 : 
                    add_delayed_check((function () {
                            return check_application_result(env, /* false */0, exp);
                          }));
                    break;
                case 1 : 
                    prerr_warning(exp[/* exp_loc */1], /* Partial_application */2);
                    break;
                default:
                  
              }
            }
            return /* tuple */[
                    /* :: */[
                      /* tuple */[
                        "",
                        /* Some */[exp],
                        /* Required */0
                      ],
                      /* [] */0
                    ],
                    match$4[1]
                  ];
          }
        } else {
          exit = 1;
        }
      } else {
        exit = 1;
      }
    } else {
      exit = 1;
    }
  }
  if (exit === 1) {
    var ty = funct[/* exp_type */3];
    if (ignore_labels) {
      return type_args(/* [] */0, /* [] */0, ty, instance(/* None */0, env, ty), ty, /* [] */0, sargs);
    } else {
      return type_args(/* [] */0, /* [] */0, ty, instance(/* None */0, env, ty), ty, sargs, /* [] */0);
    }
  }
  
}

function type_statement(env, sexp) {
  var loc = final_subexpression(sexp)[/* pexp_loc */1];
  begin_def(/* () */0);
  var exp = type_exp(env, sexp);
  end_def(/* () */0);
  if (strict_sequence[0]) {
    var expected_ty = instance_def(type_unit);
    unify_exp(env, exp, expected_ty);
    return exp;
  } else {
    var ty = expand_head(env, exp[/* exp_type */3]);
    var tv = newvar(/* None */0, /* () */0);
    var match = ty[/* desc */0];
    if (typeof match === "number") {
      prerr_warning(loc, /* Statement_type */4);
    } else {
      switch (match.tag | 0) {
        case 0 : 
            if (ty[/* level */1] > tv[/* level */1]) {
              prerr_warning(loc, /* Nonreturning_statement */10);
            } else {
              add_delayed_check((function () {
                      return check_application_result(env, /* true */1, exp);
                    }));
            }
            break;
        case 1 : 
            prerr_warning(loc, /* Partial_application */2);
            break;
        case 3 : 
            if (!same(match[0], path_unit)) {
              prerr_warning(loc, /* Statement_type */4);
            }
            break;
        default:
          prerr_warning(loc, /* Statement_type */4);
      }
    }
    unify_var(env, tv, ty);
    return exp;
  }
}

function type_cases(in_function, env, ty_arg, ty_res, partial_flag, loc, caselist) {
  var patterns = List.map((function (param) {
          return param[/* pc_lhs */0];
        }), caselist);
  var erase_either = List.exists(contains_polymorphic_variant, patterns) && contains_variant_either(ty_arg);
  var has_gadts = List.exists((function (param) {
          return contains_gadt(env, param);
        }), patterns);
  var ty_arg$1 = (has_gadts || erase_either) && !principal[0] ? duplicate_type(ty_arg) : ty_arg;
  var match = has_gadts && !principal[0] ? /* tuple */[
      duplicate_type(ty_res),
      duplicate_ident_types(loc, caselist, env)
    ] : /* tuple */[
      ty_res,
      env
    ];
  var env$1 = match[1];
  var ty_res$1 = match[0];
  var match$1;
  if (has_gadts) {
    begin_def(/* () */0);
    set_current_time(current_level[0]);
    var lev = currentstamp[0];
    init_def(lev + 1000 | 0);
    match$1 = /* tuple */[
      lev,
      add_gadt_instance_level(lev, env$1)
    ];
  } else {
    match$1 = /* tuple */[
      current_level[0],
      env$1
    ];
  }
  var env$2 = match$1[1];
  var lev$1 = match$1[0];
  begin_def(/* () */0);
  var ty_arg$prime = newvar(/* None */0, /* () */0);
  var pattern_force = [/* [] */0];
  var pat_env_list = List.map((function (param) {
          var pc_rhs = param[/* pc_rhs */2];
          var pc_guard = param[/* pc_guard */1];
          var loc;
          if (pc_guard) {
            var init = pc_rhs[/* pexp_loc */1];
            loc = /* record */[
              /* loc_start */pc_guard[0][/* pexp_loc */1][/* loc_start */0],
              /* loc_end */init[/* loc_end */1],
              /* loc_ghost */init[/* loc_ghost */2]
            ];
          } else {
            loc = pc_rhs[/* pexp_loc */1];
          }
          if (principal[0]) {
            begin_def(/* () */0);
          }
          var scope = /* Some */[/* Idef */Block.__(1, [loc])];
          var partial = principal[0] || erase_either ? /* Some */[/* false */0] : /* None */0;
          var ty_arg$2 = instance(partial, env$2, ty_arg$1);
          var match = type_pattern(lev$1, env$2, param[/* pc_lhs */0], scope, ty_arg$2);
          var pat = match[0];
          pattern_force[0] = Pervasives.$at(match[2], pattern_force[0]);
          var pat$1;
          if (principal[0]) {
            end_def(/* () */0);
            iter_pattern((function (param) {
                    return generalize_structure$1(current_level[0], param[/* pat_type */3]);
                  }), pat);
            var newrecord = pat.slice();
            newrecord[/* pat_type */3] = instance(/* None */0, env$2, pat[/* pat_type */3]);
            pat$1 = newrecord;
          } else {
            pat$1 = pat;
          }
          return /* tuple */[
                  pat$1,
                  /* tuple */[
                    match[1],
                    match[3]
                  ]
                ];
        }), caselist);
  var patl = List.map((function (prim) {
          return prim[0];
        }), pat_env_list);
  List.iter((function (pat) {
          return unify_pat(env$2, pat, ty_arg$prime);
        }), patl);
  if (List.exists(has_variants, patl)) {
    pressure_variants$1(env$2, patl);
    List.iter((function (param) {
            return iter_pattern(finalize_variant, param);
          }), patl);
  }
  List.iter((function (f) {
          return Curry._1(f, /* () */0);
        }), pattern_force[0]);
  List.iter((function (param) {
          return iter_pattern((function (param) {
                        return unify_var(env$2, param[/* pat_type */3], newvar(/* None */0, /* () */0));
                      }), param);
        }), patl);
  List.iter((function (pat) {
          return unify_pat(env$2, pat, instance(/* None */0, env$2, ty_arg$1));
        }), patl);
  end_def(/* () */0);
  List.iter((function (param) {
          return iter_pattern((function (param) {
                        return iter_generalize$1([/* [] */0], param[/* pat_type */3]);
                      }), param);
        }), patl);
  var in_function$1 = List.length(caselist) === 1 ? in_function : /* None */0;
  var cases = List.map2((function (param, param$1) {
          var pc_guard = param$1[/* pc_guard */1];
          var match = param[1];
          var unpacks = match[1];
          var ext_env = match[0];
          var sexp = wrap_unpacks(param$1[/* pc_rhs */2], unpacks);
          var ty_res$prime;
          if (principal[0]) {
            begin_def(/* () */0);
            var ty = instance(/* Some */[/* true */1], env$2, ty_res$1);
            end_def(/* () */0);
            generalize_structure$1(current_level[0], ty);
            ty_res$prime = ty;
          } else {
            ty_res$prime = contains_gadt(env$2, param$1[/* pc_lhs */0]) ? duplicate_type(ty_res$1) : ty_res$1;
          }
          var guard = pc_guard ? /* Some */[type_expect(/* None */0, ext_env, wrap_unpacks(pc_guard[0], unpacks), type_bool)] : /* None */0;
          var exp = type_expect(in_function$1, ext_env, sexp, ty_res$prime);
          var newrecord = exp.slice();
          return /* record */[
                  /* c_lhs */param[0],
                  /* c_guard */guard,
                  /* c_rhs */(newrecord[/* exp_type */3] = instance(/* None */0, env$2, ty_res$prime), newrecord)
                ];
        }), pat_env_list, caselist);
  if (principal[0] || has_gadts) {
    var ty_res$prime = instance(/* None */0, env$2, ty_res$1);
    List.iter((function (c) {
            return unify_exp(env$2, c[/* c_rhs */2], ty_res$prime);
          }), cases);
  }
  var partial = partial_flag ? check_partial$1(/* Some */[lev$1], env$2, ty_arg$1)(loc, cases) : /* Partial */0;
  add_delayed_check((function () {
          List.iter((function (param) {
                  return check_absent_variant(param[1][0])(param[0]);
                }), pat_env_list);
          var casel = cases;
          if (is_active(/* Unused_match */5)) {
            var _pref = /* [] */0;
            var _param = casel;
            while(true) {
              var param = _param;
              var pref = _pref;
              if (param) {
                var rem = param[1];
                var match = param[0];
                var q = match[/* c_lhs */0];
                var qs = /* :: */[
                  q,
                  /* [] */0
                ];
                try {
                  var pss = get_mins(le_pats, List.filter((function(qs){
                            return function (param) {
                              return compats(qs, param);
                            }
                            }(qs)))(pref));
                  var r = every_satisfiables(List.map(make_row, pss), /* record */[
                        /* no_ors : [] */0,
                        /* ors : [] */0,
                        /* active */qs
                      ]);
                  if (typeof r === "number") {
                    if (r !== 0) {
                      prerr_warning(q[/* pat_loc */1], /* Unused_match */5);
                    }
                    
                  } else {
                    List.iter((function (p) {
                            return prerr_warning(p[/* pat_loc */1], /* Unused_pat */6);
                          }), r[0]);
                  }
                }
                catch (exn){
                  var exit = 0;
                  if (exn === Empty) {
                    exit = 1;
                  } else if (exn === Caml_builtin_exceptions.not_found) {
                    exit = 1;
                  } else if (exn === NoGuard) {
                    exit = 1;
                  } else {
                    throw exn;
                  }
                  if (exit === 1) {
                    throw [
                          Caml_builtin_exceptions.assert_failure,
                          [
                            "parmatch.ml",
                            1947,
                            48
                          ]
                        ];
                  }
                  
                }
                _param = rem;
                if (match[/* c_guard */1] !== /* None */0) {
                  continue ;
                  
                } else {
                  _pref = /* :: */[
                    /* :: */[
                      q,
                      /* [] */0
                    ],
                    pref
                  ];
                  continue ;
                  
                }
              } else {
                return /* () */0;
              }
            };
          } else {
            return 0;
          }
        }));
  if (has_gadts) {
    end_def(/* () */0);
    unify_exp_types(loc, env$2, instance(/* None */0, env$2, ty_res$1), newvar(/* None */0, /* () */0));
  }
  return /* tuple */[
          cases,
          partial
        ];
}

function type_let($staropt$star, $staropt$star$1, env, rec_flag, spat_sexp_list, scope, allow) {
  var check = $staropt$star ? $staropt$star[0] : (function (s) {
        return /* Unused_var */Block.__(12, [s]);
      });
  var check_strict = $staropt$star$1 ? $staropt$star$1[0] : (function (s) {
        return /* Unused_var_strict */Block.__(13, [s]);
      });
  begin_def(/* () */0);
  if (principal[0]) {
    begin_def(/* () */0);
  }
  var is_fake_let;
  if (spat_sexp_list) {
    var match = spat_sexp_list[0][/* pvb_expr */1][/* pexp_desc */0];
    if (match.tag === 6) {
      var match$1 = match[0][/* pexp_desc */0];
      if (match$1.tag) {
        is_fake_let = /* false */0;
      } else {
        var match$2 = match$1[0][/* txt */0];
        switch (match$2.tag | 0) {
          case 0 : 
              is_fake_let = match$2[0] === "*opt*" && !spat_sexp_list[1] ? /* true */1 : /* false */0;
              break;
          case 1 : 
          case 2 : 
              is_fake_let = /* false */0;
              break;
          
        }
      }
    } else {
      is_fake_let = /* false */0;
    }
  } else {
    is_fake_let = /* false */0;
  }
  var check$1 = is_fake_let ? check_strict : check;
  var spatl = List.map((function (param) {
          var spat = param[/* pvb_pat */0];
          var match = spat[/* ppat_desc */0];
          var match$1 = param[/* pvb_expr */1][/* pexp_desc */0];
          var exit = 0;
          var sty;
          if (typeof match === "number") {
            if (match) {
              switch (match$1.tag | 0) {
                case 19 : 
                    sty = match$1[1];
                    exit = 1;
                    break;
                case 20 : 
                    sty = match$1[2];
                    exit = 1;
                    break;
                default:
                  return spat;
              }
            } else {
              return spat;
            }
          } else if (match.tag === 10) {
            return spat;
          } else {
            switch (match$1.tag | 0) {
              case 19 : 
                  sty = match$1[1];
                  exit = 1;
                  break;
              case 20 : 
                  sty = match$1[2];
                  exit = 1;
                  break;
              default:
                return spat;
            }
          }
          if (exit === 1) {
            if (principal[0]) {
              var init = spat[/* ppat_loc */1];
              return constraint_(/* Some */[/* record */[
                            /* loc_start */init[/* loc_start */0],
                            /* loc_end */init[/* loc_end */1],
                            /* loc_ghost : true */1
                          ]], /* None */0, spat, sty);
            } else {
              return spat;
            }
          }
          
        }), spat_sexp_list);
  var nvs = List.map((function () {
          return newvar(/* None */0, /* () */0);
        }), spatl);
  var match$3 = type_pattern_list(env, spatl, scope, nvs, allow);
  var unpacks = match$3[3];
  var new_env = match$3[1];
  var pat_list = match$3[0];
  var is_recursive = +(rec_flag === /* Recursive */1);
  if (is_recursive) {
    List.iter2((function (pat, binding) {
            var match = pat[/* pat_type */3][/* desc */0];
            var pat$1;
            if (typeof match === "number") {
              pat$1 = pat;
            } else if (match.tag === 10) {
              var newrecord = pat.slice();
              newrecord[/* pat_type */3] = instance_poly(/* Some */[/* true */1], /* false */0, match[1], match[0])[1];
              pat$1 = newrecord;
            } else {
              pat$1 = pat;
            }
            return unify_pat(env, pat$1, type_approx(env, binding[/* pvb_expr */1]));
          }), pat_list, spat_sexp_list);
  }
  List.iter((function (pat) {
          if (has_variants(pat)) {
            pressure_variants$1(env, /* :: */[
                  pat,
                  /* [] */0
                ]);
            return iter_pattern(finalize_variant, pat);
          } else {
            return 0;
          }
        }), pat_list);
  var pat_list$1 = principal[0] ? (end_def(/* () */0), List.map((function (pat) {
              iter_pattern((function (pat) {
                      return generalize_structure$1(current_level[0], pat[/* pat_type */3]);
                    }), pat);
              var newrecord = pat.slice();
              newrecord[/* pat_type */3] = instance(/* None */0, env, pat[/* pat_type */3]);
              return newrecord;
            }), pat_list)) : pat_list;
  List.iter((function (f) {
          return Curry._1(f, /* () */0);
        }), match$3[2]);
  var exp_env = is_recursive ? new_env : env;
  var current_slot = [/* None */0];
  var rec_needed = [/* false */0];
  var warn_unused = is_active(Curry._1(check$1, "")) || is_active(Curry._1(check_strict, "")) || is_recursive && is_active(/* Unused_rec_flag */15);
  var pat_slot_list = List.map((function (pat) {
          if (warn_unused) {
            var some_used = [/* false */0];
            var slot = [/* [] */0];
            List.iter((function (param) {
                    var id = param[0];
                    var vd = find_value(/* Pident */Block.__(0, [id]), new_env);
                    var name = id[/* name */1];
                    var used = [/* false */0];
                    if (!(name === "" || Caml_string.get(name, 0) === /* "_" */95 || Caml_string.get(name, 0) === /* "#" */35)) {
                      add_delayed_check((function () {
                              if (used[0]) {
                                return 0;
                              } else {
                                return prerr_warning(vd[/* val_loc */2], Curry._1(some_used[0] ? check_strict : check$1, name));
                              }
                            }));
                    }
                    var name$1 = name;
                    var vd$1 = vd;
                    var callback = function () {
                      var match = current_slot[0];
                      if (match) {
                        var slot$1 = match[0];
                        slot$1[0] = /* :: */[
                          /* tuple */[
                            name,
                            vd
                          ],
                          slot$1[0]
                        ];
                        rec_needed[0] = /* true */1;
                        return /* () */0;
                      } else {
                        List.iter((function (param) {
                                return mark_value_used(env, param[0], param[1]);
                              }), get_ref(slot));
                        used[0] = /* true */1;
                        some_used[0] = /* true */1;
                        return /* () */0;
                      }
                    };
                    var key_001 = vd$1[/* val_loc */2];
                    var key = /* tuple */[
                      name$1,
                      key_001
                    ];
                    try {
                      var old = Hashtbl.find(value_declarations, key);
                      return Hashtbl.replace(value_declarations, key, (function () {
                                    Curry._1(old, /* () */0);
                                    return Curry._1(callback, /* () */0);
                                  }));
                    }
                    catch (exn){
                      if (exn === Caml_builtin_exceptions.not_found) {
                        return Hashtbl.add(value_declarations, key, callback);
                      } else {
                        throw exn;
                      }
                    }
                  }), pat_bound_idents(pat));
            return /* tuple */[
                    pat,
                    /* Some */[slot]
                  ];
          } else {
            return /* tuple */[
                    pat,
                    /* None */0
                  ];
          }
        }), pat_list$1);
  var exp_list = List.map2((function (param, param$1) {
          var pat = param$1[0];
          var sexp = param[/* pvb_expr */1];
          var sexp$1 = rec_flag === /* Recursive */1 ? wrap_unpacks(sexp, unpacks) : sexp;
          if (is_recursive) {
            current_slot[0] = param$1[1];
          }
          var match = pat[/* pat_type */3][/* desc */0];
          if (typeof match === "number") {
            return type_expect(/* None */0, exp_env, sexp$1, pat[/* pat_type */3]);
          } else if (match.tag === 10) {
            begin_def(/* () */0);
            if (principal[0]) {
              begin_def(/* () */0);
            }
            var match$1 = instance_poly(/* Some */[/* true */1], /* true */1, match[1], match[0]);
            var ty$prime = match$1[1];
            if (principal[0]) {
              end_def(/* () */0);
              generalize_structure$1(current_level[0], ty$prime);
            }
            var exp = type_expect(/* None */0, exp_env, sexp$1, ty$prime);
            end_def(/* () */0);
            check_univars(env, /* true */1, "definition", exp, pat[/* pat_type */3], match$1[0]);
            var newrecord = exp.slice();
            newrecord[/* exp_type */3] = instance(/* None */0, env, exp[/* exp_type */3]);
            return newrecord;
          } else {
            return type_expect(/* None */0, exp_env, sexp$1, pat[/* pat_type */3]);
          }
        }), spat_sexp_list, pat_slot_list);
  current_slot[0] = /* None */0;
  if (is_recursive && !rec_needed[0] && is_active(/* Unused_rec_flag */15)) {
    prerr_warning(List.hd(spat_sexp_list)[/* pvb_pat */0][/* ppat_loc */1], /* Unused_rec_flag */15);
  }
  List.iter2((function (pat, exp) {
          check_partial$1(/* None */0, env, pat[/* pat_type */3])(pat[/* pat_loc */1], /* :: */[
                /* record */[
                  /* c_lhs */pat,
                  /* c_guard : None */0,
                  /* c_rhs */exp
                ],
                /* [] */0
              ]);
          return /* () */0;
        }), pat_list$1, exp_list);
  end_def(/* () */0);
  List.iter2((function (pat, exp) {
          if (is_nonexpansive(exp)) {
            return 0;
          } else {
            return iter_pattern((function (pat) {
                          return generalize_expansive$1(env, pat[/* pat_type */3]);
                        }), pat);
          }
        }), pat_list$1, exp_list);
  List.iter((function (pat) {
          return iter_pattern((function (pat) {
                        return iter_generalize$1([/* [] */0], pat[/* pat_type */3]);
                      }), pat);
        }), pat_list$1);
  var l = List.combine(pat_list$1, exp_list);
  var l$1 = List.map2((function (param, pvb) {
          return /* record */[
                  /* vb_pat */param[0],
                  /* vb_expr */param[1],
                  /* vb_attributes */pvb[/* pvb_attributes */2],
                  /* vb_loc */pvb[/* pvb_loc */3]
                ];
        }), l, spat_sexp_list);
  return /* tuple */[
          l$1,
          new_env,
          unpacks
        ];
}

function type_binding(env, rec_flag, spat_sexp_list, scope) {
  reset_type_variables(/* () */0);
  var match = type_let(/* Some */[(function (s) {
            return /* Unused_value_declaration */Block.__(16, [s]);
          })], /* Some */[(function (s) {
            return /* Unused_value_declaration */Block.__(16, [s]);
          })], env, rec_flag, spat_sexp_list, scope, /* false */0);
  return /* tuple */[
          match[0],
          match[1]
        ];
}

function type_let$1(env, rec_flag, spat_sexp_list, scope) {
  var match = type_let(/* None */0, /* None */0, env, rec_flag, spat_sexp_list, scope, /* false */0);
  return /* tuple */[
          match[0],
          match[1]
        ];
}

function type_expression(env, sexp) {
  reset_type_variables(/* () */0);
  begin_def(/* () */0);
  var exp = type_exp(env, sexp);
  end_def(/* () */0);
  if (is_nonexpansive(exp)) {
    iter_generalize$1([/* [] */0], exp[/* exp_type */3]);
  } else {
    generalize_expansive$1(env, exp[/* exp_type */3]);
  }
  var match = sexp[/* pexp_desc */0];
  if (match.tag) {
    return exp;
  } else {
    var match$1 = lookup_value$1(match[0][/* txt */0], env);
    var newrecord = exp.slice();
    newrecord[/* exp_type */3] = match$1[1][/* val_type */0];
    return newrecord;
  }
}

register_error_of_exn((function (param) {
        if (param[0] === $$Error$7) {
          var env = param[2];
          return /* Some */[error_of_printer(param[1], (function (param, param$1) {
                          var env$1 = env;
                          var ppf = param;
                          var err = param$1;
                          return wrap_printing_env(env$1, (function () {
                                        var env$2 = env$1;
                                        var ppf$1 = ppf;
                                        var param = err;
                                        if (typeof param === "number") {
                                          switch (param) {
                                            case 0 : 
                                                return Format.fprintf(ppf$1, /* Format */[
                                                            /* String_literal */Block.__(11, [
                                                                "This object duplication occurs outside a method definition",
                                                                /* End_of_format */0
                                                              ]),
                                                            "This object duplication occurs outside a method definition"
                                                          ]);
                                            case 1 : 
                                                Format.fprintf(ppf$1, /* Format */[
                                                      /* String_literal */Block.__(11, [
                                                          "This function is applied to arguments",
                                                          /* Formatting_lit */Block.__(17, [
                                                              /* Break */Block.__(0, [
                                                                  "@ ",
                                                                  1,
                                                                  0
                                                                ]),
                                                              /* End_of_format */0
                                                            ])
                                                        ]),
                                                      "This function is applied to arguments@ "
                                                    ]);
                                                Format.fprintf(ppf$1, /* Format */[
                                                      /* String_literal */Block.__(11, [
                                                          "in an order different from other calls.",
                                                          /* Formatting_lit */Block.__(17, [
                                                              /* Break */Block.__(0, [
                                                                  "@ ",
                                                                  1,
                                                                  0
                                                                ]),
                                                              /* End_of_format */0
                                                            ])
                                                        ]),
                                                      "in an order different from other calls.@ "
                                                    ]);
                                                return Format.fprintf(ppf$1, /* Format */[
                                                            /* String_literal */Block.__(11, [
                                                                "This is only allowed when the real type is known.",
                                                                /* End_of_format */0
                                                              ]),
                                                            "This is only allowed when the real type is known."
                                                          ]);
                                            case 2 : 
                                                return Format.fprintf(ppf$1, /* Format */[
                                                            /* String_literal */Block.__(11, [
                                                                "Modules are not allowed in this pattern.",
                                                                /* End_of_format */0
                                                              ]),
                                                            "Modules are not allowed in this pattern."
                                                          ]);
                                            case 3 : 
                                                return Format.fprintf(ppf$1, /* Format */[
                                                            /* String_literal */Block.__(11, [
                                                                "The signature for this packaged module couldn't be inferred.",
                                                                /* End_of_format */0
                                                              ]),
                                                            "The signature for this packaged module couldn't be inferred."
                                                          ]);
                                            case 4 : 
                                                return Format.fprintf(ppf$1, /* Format */[
                                                            /* String_literal */Block.__(11, [
                                                                "Unexpected existential",
                                                                /* End_of_format */0
                                                              ]),
                                                            "Unexpected existential"
                                                          ]);
                                            case 5 : 
                                                return Format.fprintf(ppf$1, /* Format */[
                                                            /* Formatting_gen */Block.__(18, [
                                                                /* Open_box */Block.__(1, [/* Format */[
                                                                      /* End_of_format */0,
                                                                      ""
                                                                    ]]),
                                                                /* String_literal */Block.__(11, [
                                                                    "Only character intervals are supported in patterns.",
                                                                    /* Formatting_lit */Block.__(17, [
                                                                        /* Close_box */0,
                                                                        /* End_of_format */0
                                                                      ])
                                                                  ])
                                                              ]),
                                                            "@[Only character intervals are supported in patterns.@]"
                                                          ]);
                                            case 6 : 
                                                return Format.fprintf(ppf$1, /* Format */[
                                                            /* Formatting_gen */Block.__(18, [
                                                                /* Open_box */Block.__(1, [/* Format */[
                                                                      /* End_of_format */0,
                                                                      ""
                                                                    ]]),
                                                                /* String_literal */Block.__(11, [
                                                                    "Invalid for-loop index: only variables and _ are allowed.",
                                                                    /* Formatting_lit */Block.__(17, [
                                                                        /* Close_box */0,
                                                                        /* End_of_format */0
                                                                      ])
                                                                  ])
                                                              ]),
                                                            "@[Invalid for-loop index: only variables and _ are allowed.@]"
                                                          ]);
                                            case 7 : 
                                                return Format.fprintf(ppf$1, /* Format */[
                                                            /* String_literal */Block.__(11, [
                                                                "None of the patterns in this 'match' expression match values.",
                                                                /* End_of_format */0
                                                              ]),
                                                            "None of the patterns in this 'match' expression match values."
                                                          ]);
                                            case 8 : 
                                                return Format.fprintf(ppf$1, /* Format */[
                                                            /* Formatting_gen */Block.__(18, [
                                                                /* Open_box */Block.__(1, [/* Format */[
                                                                      /* End_of_format */0,
                                                                      ""
                                                                    ]]),
                                                                /* String_literal */Block.__(11, [
                                                                    "Exception patterns must be at the top level of a match case.",
                                                                    /* Formatting_lit */Block.__(17, [
                                                                        /* Close_box */0,
                                                                        /* End_of_format */0
                                                                      ])
                                                                  ])
                                                              ]),
                                                            "@[Exception patterns must be at the top level of a match case.@]"
                                                          ]);
                                            
                                          }
                                        } else {
                                          switch (param.tag | 0) {
                                            case 0 : 
                                                return Curry._3(Format.fprintf(ppf$1, /* Format */[
                                                                /* Formatting_gen */Block.__(18, [
                                                                    /* Open_box */Block.__(1, [/* Format */[
                                                                          /* End_of_format */0,
                                                                          ""
                                                                        ]]),
                                                                    /* String_literal */Block.__(11, [
                                                                        "The record field ",
                                                                        /* Alpha */Block.__(15, [/* String_literal */Block.__(11, [
                                                                                " is polymorphic.",
                                                                                /* Formatting_lit */Block.__(17, [
                                                                                    /* Break */Block.__(0, [
                                                                                        "@ ",
                                                                                        1,
                                                                                        0
                                                                                      ]),
                                                                                    /* String */Block.__(2, [
                                                                                        /* No_padding */0,
                                                                                        /* Formatting_lit */Block.__(17, [
                                                                                            /* Close_box */0,
                                                                                            /* End_of_format */0
                                                                                          ])
                                                                                      ])
                                                                                  ])
                                                                              ])])
                                                                      ])
                                                                  ]),
                                                                "@[The record field %a is polymorphic.@ %s@]"
                                                              ]), longident, param[0], "You cannot instantiate it in a pattern.");
                                            case 1 : 
                                                return Curry._4(Format.fprintf(ppf$1, /* Format */[
                                                                /* Formatting_gen */Block.__(18, [
                                                                    /* Open_box */Block.__(1, [/* Format */[
                                                                          /* End_of_format */0,
                                                                          ""
                                                                        ]]),
                                                                    /* String_literal */Block.__(11, [
                                                                        "The constructor ",
                                                                        /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                                /* Break */Block.__(0, [
                                                                                    "@ ",
                                                                                    1,
                                                                                    0
                                                                                  ]),
                                                                                /* String_literal */Block.__(11, [
                                                                                    "expects ",
                                                                                    /* Int */Block.__(4, [
                                                                                        /* Int_i */3,
                                                                                        /* No_padding */0,
                                                                                        /* No_precision */0,
                                                                                        /* String_literal */Block.__(11, [
                                                                                            " argument(s),",
                                                                                            /* Formatting_lit */Block.__(17, [
                                                                                                /* Break */Block.__(0, [
                                                                                                    "@ ",
                                                                                                    1,
                                                                                                    0
                                                                                                  ]),
                                                                                                /* String_literal */Block.__(11, [
                                                                                                    "but is applied here to ",
                                                                                                    /* Int */Block.__(4, [
                                                                                                        /* Int_i */3,
                                                                                                        /* No_padding */0,
                                                                                                        /* No_precision */0,
                                                                                                        /* String_literal */Block.__(11, [
                                                                                                            " argument(s)",
                                                                                                            /* Formatting_lit */Block.__(17, [
                                                                                                                /* Close_box */0,
                                                                                                                /* End_of_format */0
                                                                                                              ])
                                                                                                          ])
                                                                                                      ])
                                                                                                  ])
                                                                                              ])
                                                                                          ])
                                                                                      ])
                                                                                  ])
                                                                              ])])
                                                                      ])
                                                                  ]),
                                                                "@[The constructor %a@ expects %i argument(s),@ but is applied here to %i argument(s)@]"
                                                              ]), longident, param[0], param[1], param[2]);
                                            case 2 : 
                                                var lid = param[0];
                                                return report_unification_error(ppf$1, env$2, /* None */0, param[1], (function (ppf) {
                                                              return Curry._2(Format.fprintf(ppf, /* Format */[
                                                                              /* String_literal */Block.__(11, [
                                                                                  "The record field ",
                                                                                  /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                                          /* Break */Block.__(0, [
                                                                                              "@ ",
                                                                                              1,
                                                                                              0
                                                                                            ]),
                                                                                          /* String_literal */Block.__(11, [
                                                                                              "belongs to the type",
                                                                                              /* End_of_format */0
                                                                                            ])
                                                                                        ])])
                                                                                ]),
                                                                              "The record field %a@ belongs to the type"
                                                                            ]), longident, lid);
                                                            }), (function (ppf) {
                                                              return Format.fprintf(ppf, /* Format */[
                                                                          /* String_literal */Block.__(11, [
                                                                              "but is mixed here with fields of type",
                                                                              /* End_of_format */0
                                                                            ]),
                                                                          "but is mixed here with fields of type"
                                                                        ]);
                                                            }));
                                            case 3 : 
                                                return report_unification_error(ppf$1, env$2, /* None */0, param[0], (function (ppf) {
                                                              return Format.fprintf(ppf, /* Format */[
                                                                          /* String_literal */Block.__(11, [
                                                                              "This pattern matches values of type",
                                                                              /* End_of_format */0
                                                                            ]),
                                                                          "This pattern matches values of type"
                                                                        ]);
                                                            }), (function (ppf) {
                                                              return Format.fprintf(ppf, /* Format */[
                                                                          /* String_literal */Block.__(11, [
                                                                              "but a pattern was expected which matches values of type",
                                                                              /* End_of_format */0
                                                                            ]),
                                                                          "but a pattern was expected which matches values of type"
                                                                        ]);
                                                            }));
                                            case 4 : 
                                                var id = param[0];
                                                return report_unification_error(ppf$1, env$2, /* None */0, param[1], (function (ppf) {
                                                              return Curry._1(Format.fprintf(ppf, /* Format */[
                                                                              /* String_literal */Block.__(11, [
                                                                                  "The variable ",
                                                                                  /* String */Block.__(2, [
                                                                                      /* No_padding */0,
                                                                                      /* String_literal */Block.__(11, [
                                                                                          " on the left-hand side of this or-pattern has type",
                                                                                          /* End_of_format */0
                                                                                        ])
                                                                                    ])
                                                                                ]),
                                                                              "The variable %s on the left-hand side of this or-pattern has type"
                                                                            ]), id[/* name */1]);
                                                            }), (function (ppf) {
                                                              return Format.fprintf(ppf, /* Format */[
                                                                          /* String_literal */Block.__(11, [
                                                                              "but on the right-hand side it has type",
                                                                              /* End_of_format */0
                                                                            ]),
                                                                          "but on the right-hand side it has type"
                                                                        ]);
                                                            }));
                                            case 5 : 
                                                return Curry._1(Format.fprintf(ppf$1, /* Format */[
                                                                /* String_literal */Block.__(11, [
                                                                    "Variable ",
                                                                    /* String */Block.__(2, [
                                                                        /* No_padding */0,
                                                                        /* String_literal */Block.__(11, [
                                                                            " is bound several times in this matching",
                                                                            /* End_of_format */0
                                                                          ])
                                                                      ])
                                                                  ]),
                                                                "Variable %s is bound several times in this matching"
                                                              ]), param[0]);
                                            case 6 : 
                                                return Curry._1(Format.fprintf(ppf$1, /* Format */[
                                                                /* String_literal */Block.__(11, [
                                                                    "Variable ",
                                                                    /* String */Block.__(2, [
                                                                        /* No_padding */0,
                                                                        /* String_literal */Block.__(11, [
                                                                            " must occur on both sides of this | pattern",
                                                                            /* End_of_format */0
                                                                          ])
                                                                      ])
                                                                  ]),
                                                                "Variable %s must occur on both sides of this | pattern"
                                                              ]), param[0][/* name */1]);
                                            case 7 : 
                                                return report_unification_error(ppf$1, env$2, /* None */0, param[0], (function (ppf) {
                                                              return Format.fprintf(ppf, /* Format */[
                                                                          /* String_literal */Block.__(11, [
                                                                              "This expression has type",
                                                                              /* End_of_format */0
                                                                            ]),
                                                                          "This expression has type"
                                                                        ]);
                                                            }), (function (ppf) {
                                                              return Format.fprintf(ppf, /* Format */[
                                                                          /* String_literal */Block.__(11, [
                                                                              "but an expression was expected of type",
                                                                              /* End_of_format */0
                                                                            ]),
                                                                          "but an expression was expected of type"
                                                                        ]);
                                                            }));
                                            case 8 : 
                                                var typ = param[0];
                                                reset(/* () */0);
                                                mark_loops(typ);
                                                var match = repr(typ)[/* desc */0];
                                                var exit = 0;
                                                if (typeof match === "number") {
                                                  exit = 1;
                                                } else if (match.tag === 1) {
                                                  Curry._2(Format.fprintf(ppf$1, /* Format */[
                                                            /* Formatting_gen */Block.__(18, [
                                                                /* Open_box */Block.__(1, [/* Format */[
                                                                      /* String_literal */Block.__(11, [
                                                                          "<v>",
                                                                          /* End_of_format */0
                                                                        ]),
                                                                      "<v>"
                                                                    ]]),
                                                                /* Formatting_gen */Block.__(18, [
                                                                    /* Open_box */Block.__(1, [/* Format */[
                                                                          /* String_literal */Block.__(11, [
                                                                              "<2>",
                                                                              /* End_of_format */0
                                                                            ]),
                                                                          "<2>"
                                                                        ]]),
                                                                    /* String_literal */Block.__(11, [
                                                                        "This function has type",
                                                                        /* Formatting_lit */Block.__(17, [
                                                                            /* Break */Block.__(0, [
                                                                                "@ ",
                                                                                1,
                                                                                0
                                                                              ]),
                                                                            /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                                    /* Close_box */0,
                                                                                    /* End_of_format */0
                                                                                  ])])
                                                                          ])
                                                                      ])
                                                                  ])
                                                              ]),
                                                            "@[<v>@[<2>This function has type@ %a@]"
                                                          ]), type_expr$1, typ);
                                                  return Curry._1(Format.fprintf(ppf$1, /* Format */[
                                                                  /* Formatting_lit */Block.__(17, [
                                                                      /* Break */Block.__(0, [
                                                                          "@ ",
                                                                          1,
                                                                          0
                                                                        ]),
                                                                      /* Formatting_gen */Block.__(18, [
                                                                          /* Open_box */Block.__(1, [/* Format */[
                                                                                /* End_of_format */0,
                                                                                ""
                                                                              ]]),
                                                                          /* String_literal */Block.__(11, [
                                                                              "It is applied to too many arguments;",
                                                                              /* Formatting_lit */Block.__(17, [
                                                                                  /* Break */Block.__(0, [
                                                                                      "@ ",
                                                                                      1,
                                                                                      0
                                                                                    ]),
                                                                                  /* String */Block.__(2, [
                                                                                      /* No_padding */0,
                                                                                      /* Formatting_lit */Block.__(17, [
                                                                                          /* Close_box */0,
                                                                                          /* Formatting_lit */Block.__(17, [
                                                                                              /* Close_box */0,
                                                                                              /* End_of_format */0
                                                                                            ])
                                                                                        ])
                                                                                    ])
                                                                                ])
                                                                            ])
                                                                        ])
                                                                    ]),
                                                                  "@ @[It is applied to too many arguments;@ %s@]@]"
                                                                ]), "maybe you forgot a `;'.");
                                                } else {
                                                  exit = 1;
                                                }
                                                if (exit === 1) {
                                                  return Curry._3(Format.fprintf(ppf$1, /* Format */[
                                                                  /* Formatting_gen */Block.__(18, [
                                                                      /* Open_box */Block.__(1, [/* Format */[
                                                                            /* String_literal */Block.__(11, [
                                                                                "<v>",
                                                                                /* End_of_format */0
                                                                              ]),
                                                                            "<v>"
                                                                          ]]),
                                                                      /* Formatting_gen */Block.__(18, [
                                                                          /* Open_box */Block.__(1, [/* Format */[
                                                                                /* String_literal */Block.__(11, [
                                                                                    "<2>",
                                                                                    /* End_of_format */0
                                                                                  ]),
                                                                                "<2>"
                                                                              ]]),
                                                                          /* String_literal */Block.__(11, [
                                                                              "This expression has type",
                                                                              /* Formatting_lit */Block.__(17, [
                                                                                  /* Break */Block.__(0, [
                                                                                      "@ ",
                                                                                      1,
                                                                                      0
                                                                                    ]),
                                                                                  /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                                          /* Close_box */0,
                                                                                          /* Formatting_lit */Block.__(17, [
                                                                                              /* Break */Block.__(0, [
                                                                                                  "@ ",
                                                                                                  1,
                                                                                                  0
                                                                                                ]),
                                                                                              /* String */Block.__(2, [
                                                                                                  /* No_padding */0,
                                                                                                  /* Formatting_lit */Block.__(17, [
                                                                                                      /* Close_box */0,
                                                                                                      /* End_of_format */0
                                                                                                    ])
                                                                                                ])
                                                                                            ])
                                                                                        ])])
                                                                                ])
                                                                            ])
                                                                        ])
                                                                    ]),
                                                                  "@[<v>@[<2>This expression has type@ %a@]@ %s@]"
                                                                ]), type_expr$1, typ, "This is not a function; it cannot be applied.");
                                                }
                                                break;
                                            case 9 : 
                                                var ty = param[1];
                                                var print_label = function (ppf, l) {
                                                  if (l === "") {
                                                    return Format.fprintf(ppf, /* Format */[
                                                                /* String_literal */Block.__(11, [
                                                                    "without label",
                                                                    /* End_of_format */0
                                                                  ]),
                                                                "without label"
                                                              ]);
                                                  } else {
                                                    return Curry._1(Format.fprintf(ppf, /* Format */[
                                                                    /* String_literal */Block.__(11, [
                                                                        "with label ",
                                                                        /* String */Block.__(2, [
                                                                            /* No_padding */0,
                                                                            /* End_of_format */0
                                                                          ])
                                                                      ]),
                                                                    "with label %s"
                                                                  ]), prefixed_label_name(l));
                                                  }
                                                };
                                                reset(/* () */0);
                                                mark_loops(ty);
                                                return Curry._4(Format.fprintf(ppf$1, /* Format */[
                                                                /* Formatting_gen */Block.__(18, [
                                                                    /* Open_box */Block.__(1, [/* Format */[
                                                                          /* String_literal */Block.__(11, [
                                                                              "<v>",
                                                                              /* End_of_format */0
                                                                            ]),
                                                                          "<v>"
                                                                        ]]),
                                                                    /* Formatting_gen */Block.__(18, [
                                                                        /* Open_box */Block.__(1, [/* Format */[
                                                                              /* String_literal */Block.__(11, [
                                                                                  "<2>",
                                                                                  /* End_of_format */0
                                                                                ]),
                                                                              "<2>"
                                                                            ]]),
                                                                        /* String_literal */Block.__(11, [
                                                                            "The function applied to this argument has type",
                                                                            /* Formatting_lit */Block.__(17, [
                                                                                /* Break */Block.__(0, [
                                                                                    "@ ",
                                                                                    1,
                                                                                    0
                                                                                  ]),
                                                                                /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                                        /* Close_box */0,
                                                                                        /* Formatting_lit */Block.__(17, [
                                                                                            /* Flush_newline */4,
                                                                                            /* String_literal */Block.__(11, [
                                                                                                "This argument cannot be applied ",
                                                                                                /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                                                        /* Close_box */0,
                                                                                                        /* End_of_format */0
                                                                                                      ])])
                                                                                              ])
                                                                                          ])
                                                                                      ])])
                                                                              ])
                                                                          ])
                                                                      ])
                                                                  ]),
                                                                "@[<v>@[<2>The function applied to this argument has type@ %a@]@.This argument cannot be applied %a@]"
                                                              ]), type_expr$1, ty, print_label, param[0]);
                                            case 10 : 
                                                return Curry._1(Format.fprintf(ppf$1, /* Format */[
                                                                /* String_literal */Block.__(11, [
                                                                    "The record field label ",
                                                                    /* String */Block.__(2, [
                                                                        /* No_padding */0,
                                                                        /* String_literal */Block.__(11, [
                                                                            " is defined several times",
                                                                            /* End_of_format */0
                                                                          ])
                                                                      ])
                                                                  ]),
                                                                "The record field label %s is defined several times"
                                                              ]), param[0]);
                                            case 11 : 
                                                var print_labels = function (ppf) {
                                                  return (function (param) {
                                                      return List.iter((function (lbl) {
                                                                    return Curry._1(Format.fprintf(ppf, /* Format */[
                                                                                    /* Formatting_lit */Block.__(17, [
                                                                                        /* Break */Block.__(0, [
                                                                                            "@ ",
                                                                                            1,
                                                                                            0
                                                                                          ]),
                                                                                        /* String */Block.__(2, [
                                                                                            /* No_padding */0,
                                                                                            /* End_of_format */0
                                                                                          ])
                                                                                      ]),
                                                                                    "@ %s"
                                                                                  ]), lbl[/* name */1]);
                                                                  }), param);
                                                    });
                                                };
                                                return Curry._2(Format.fprintf(ppf$1, /* Format */[
                                                                /* Formatting_gen */Block.__(18, [
                                                                    /* Open_box */Block.__(1, [/* Format */[
                                                                          /* String_literal */Block.__(11, [
                                                                              "<hov>",
                                                                              /* End_of_format */0
                                                                            ]),
                                                                          "<hov>"
                                                                        ]]),
                                                                    /* String_literal */Block.__(11, [
                                                                        "Some record fields are undefined:",
                                                                        /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                                /* Close_box */0,
                                                                                /* End_of_format */0
                                                                              ])])
                                                                      ])
                                                                  ]),
                                                                "@[<hov>Some record fields are undefined:%a@]"
                                                              ]), print_labels, param[0]);
                                            case 12 : 
                                                return Curry._2(Format.fprintf(ppf$1, /* Format */[
                                                                /* String_literal */Block.__(11, [
                                                                    "The record field ",
                                                                    /* Alpha */Block.__(15, [/* String_literal */Block.__(11, [
                                                                            " is not mutable",
                                                                            /* End_of_format */0
                                                                          ])])
                                                                  ]),
                                                                "The record field %a is not mutable"
                                                              ]), longident, param[0]);
                                            case 13 : 
                                                var lid$1 = param[4];
                                                var p = param[3];
                                                var kind = param[2];
                                                var ty$1 = param[1];
                                                reset(/* () */0);
                                                mark_loops(ty$1);
                                                Curry._3(Format.fprintf(ppf$1, /* Format */[
                                                          /* Formatting_gen */Block.__(18, [
                                                              /* Open_box */Block.__(1, [/* Format */[
                                                                    /* End_of_format */0,
                                                                    ""
                                                                  ]]),
                                                              /* Formatting_gen */Block.__(18, [
                                                                  /* Open_box */Block.__(1, [/* Format */[
                                                                        /* String_literal */Block.__(11, [
                                                                            "<2>",
                                                                            /* End_of_format */0
                                                                          ]),
                                                                        "<2>"
                                                                      ]]),
                                                                  /* String */Block.__(2, [
                                                                      /* No_padding */0,
                                                                      /* String_literal */Block.__(11, [
                                                                          " type",
                                                                          /* Formatting_lit */Block.__(17, [
                                                                              /* Break */Block.__(0, [
                                                                                  "@ ",
                                                                                  1,
                                                                                  0
                                                                                ]),
                                                                              /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                                      /* Close_box */0,
                                                                                      /* Formatting_lit */Block.__(17, [
                                                                                          /* Break */Block.__(0, [
                                                                                              "@ ",
                                                                                              1,
                                                                                              0
                                                                                            ]),
                                                                                          /* End_of_format */0
                                                                                        ])
                                                                                    ])])
                                                                            ])
                                                                        ])
                                                                    ])
                                                                ])
                                                            ]),
                                                          "@[@[<2>%s type@ %a@]@ "
                                                        ]), param[0], type_expr$1, ty$1);
                                                Curry._5(Format.fprintf(ppf$1, /* Format */[
                                                          /* String_literal */Block.__(11, [
                                                              "The ",
                                                              /* String */Block.__(2, [
                                                                  /* No_padding */0,
                                                                  /* Char_literal */Block.__(12, [
                                                                      /* " " */32,
                                                                      /* Alpha */Block.__(15, [/* String_literal */Block.__(11, [
                                                                              " does not belong to type ",
                                                                              /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                                      /* Close_box */0,
                                                                                      /* End_of_format */0
                                                                                    ])])
                                                                            ])])
                                                                    ])
                                                                ])
                                                            ]),
                                                          "The %s %a does not belong to type %a@]"
                                                        ]), kind === "record" ? "field" : "constructor", longident, lid$1, path, p);
                                                if (kind === "record") {
                                                  var ppf$2 = ppf$1;
                                                  var env$3 = env$2;
                                                  var p$1 = p;
                                                  var lid$2 = lid$1;
                                                  return spellcheck_simple(ppf$2, fold_labels, (function (d) {
                                                                  if (compare_type_path(env$3, p$1, get_type_path$1(env$3, d))) {
                                                                    return d[/* lbl_name */0];
                                                                  } else {
                                                                    return "";
                                                                  }
                                                                }))(env$3, lid$2);
                                                } else {
                                                  var ppf$3 = ppf$1;
                                                  var env$4 = env$2;
                                                  var p$2 = p;
                                                  var lid$3 = lid$1;
                                                  return spellcheck_simple(ppf$3, fold_constructors, (function (d) {
                                                                  if (compare_type_path(env$4, p$2, get_type_path$2(env$4, d))) {
                                                                    return d[/* cstr_name */0];
                                                                  } else {
                                                                    return "";
                                                                  }
                                                                }))(env$4, lid$3);
                                                }
                                            case 14 : 
                                                var lid$4 = param[1];
                                                var kind$1 = param[0];
                                                var name = kind$1 === "record" ? "field" : "constructor";
                                                var ppf$4 = ppf$1;
                                                var env$5 = env$2;
                                                var param$1 = param[2];
                                                var tpl = param[3];
                                                var txt1 = function (ppf) {
                                                  return Curry._4(Format.fprintf(ppf, /* Format */[
                                                                  /* String_literal */Block.__(11, [
                                                                      "The ",
                                                                      /* String */Block.__(2, [
                                                                          /* No_padding */0,
                                                                          /* Char_literal */Block.__(12, [
                                                                              /* " " */32,
                                                                              /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                                      /* Break */Block.__(0, [
                                                                                          "@ ",
                                                                                          1,
                                                                                          0
                                                                                        ]),
                                                                                      /* String_literal */Block.__(11, [
                                                                                          "belongs to the ",
                                                                                          /* String */Block.__(2, [
                                                                                              /* No_padding */0,
                                                                                              /* String_literal */Block.__(11, [
                                                                                                  " type",
                                                                                                  /* End_of_format */0
                                                                                                ])
                                                                                            ])
                                                                                        ])
                                                                                    ])])
                                                                            ])
                                                                        ])
                                                                    ]),
                                                                  "The %s %a@ belongs to the %s type"
                                                                ]), name, longident, lid$4, kind$1);
                                                };
                                                var txt2 = function (ppf) {
                                                  return Curry._4(Format.fprintf(ppf, /* Format */[
                                                                  /* String_literal */Block.__(11, [
                                                                      "The ",
                                                                      /* String */Block.__(2, [
                                                                          /* No_padding */0,
                                                                          /* Char_literal */Block.__(12, [
                                                                              /* " " */32,
                                                                              /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                                      /* Break */Block.__(0, [
                                                                                          "@ ",
                                                                                          1,
                                                                                          0
                                                                                        ]),
                                                                                      /* String_literal */Block.__(11, [
                                                                                          "belongs to one of the following ",
                                                                                          /* String */Block.__(2, [
                                                                                              /* No_padding */0,
                                                                                              /* String_literal */Block.__(11, [
                                                                                                  " types:",
                                                                                                  /* End_of_format */0
                                                                                                ])
                                                                                            ])
                                                                                        ])
                                                                                    ])])
                                                                            ])
                                                                        ])
                                                                    ]),
                                                                  "The %s %a@ belongs to one of the following %s types:"
                                                                ]), name, longident, lid$4, kind$1);
                                                };
                                                var txt3 = function (ppf) {
                                                  return Curry._2(Format.fprintf(ppf, /* Format */[
                                                                  /* String_literal */Block.__(11, [
                                                                      "but a ",
                                                                      /* String */Block.__(2, [
                                                                          /* No_padding */0,
                                                                          /* String_literal */Block.__(11, [
                                                                              " was expected belonging to the ",
                                                                              /* String */Block.__(2, [
                                                                                  /* No_padding */0,
                                                                                  /* String_literal */Block.__(11, [
                                                                                      " type",
                                                                                      /* End_of_format */0
                                                                                    ])
                                                                                ])
                                                                            ])
                                                                        ])
                                                                    ]),
                                                                  "but a %s was expected belonging to the %s type"
                                                                ]), name, kind$1);
                                                };
                                                var tp0$prime = param$1[1];
                                                var tp0 = param$1[0];
                                                return wrap_printing_env(env$5, (function () {
                                                              reset(/* () */0);
                                                              List.iter((function (param) {
                                                                      path_same_name(tp0, param[0]);
                                                                      return path_same_name(tp0$prime, param[1]);
                                                                    }), tpl);
                                                              if (tpl) {
                                                                if (tpl[1]) {
                                                                  return Curry._6(Format.fprintf(ppf$4, /* Format */[
                                                                                  /* Formatting_gen */Block.__(18, [
                                                                                      /* Open_box */Block.__(1, [/* Format */[
                                                                                            /* End_of_format */0,
                                                                                            ""
                                                                                          ]]),
                                                                                      /* Theta */Block.__(16, [/* Formatting_lit */Block.__(17, [
                                                                                              /* Break */Block.__(0, [
                                                                                                  "@;<1 2>",
                                                                                                  1,
                                                                                                  2
                                                                                                ]),
                                                                                              /* Formatting_gen */Block.__(18, [
                                                                                                  /* Open_box */Block.__(1, [/* Format */[
                                                                                                        /* String_literal */Block.__(11, [
                                                                                                            "<hv>",
                                                                                                            /* End_of_format */0
                                                                                                          ]),
                                                                                                        "<hv>"
                                                                                                      ]]),
                                                                                                  /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                                                          /* Close_box */0,
                                                                                                          /* Formatting_lit */Block.__(17, [
                                                                                                              /* Break */Block.__(0, [
                                                                                                                  "@ ",
                                                                                                                  1,
                                                                                                                  0
                                                                                                                ]),
                                                                                                              /* Theta */Block.__(16, [/* Formatting_lit */Block.__(17, [
                                                                                                                      /* Break */Block.__(0, [
                                                                                                                          "@;<1 2>",
                                                                                                                          1,
                                                                                                                          2
                                                                                                                        ]),
                                                                                                                      /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                                                                              /* Close_box */0,
                                                                                                                              /* End_of_format */0
                                                                                                                            ])])
                                                                                                                    ])])
                                                                                                            ])
                                                                                                        ])])
                                                                                                ])
                                                                                            ])])
                                                                                    ]),
                                                                                  "@[%t@;<1 2>@[<hv>%a@]@ %t@;<1 2>%a@]"
                                                                                ]), txt2, type_path_list, tpl, txt3, (function (param, param$1) {
                                                                                return type_path_expansion(tp0, param, param$1);
                                                                              }), tp0$prime);
                                                                } else {
                                                                  var match = tpl[0];
                                                                  var tp = match[0];
                                                                  return Curry._6(Format.fprintf(ppf$4, /* Format */[
                                                                                  /* Formatting_gen */Block.__(18, [
                                                                                      /* Open_box */Block.__(1, [/* Format */[
                                                                                            /* End_of_format */0,
                                                                                            ""
                                                                                          ]]),
                                                                                      /* Theta */Block.__(16, [/* Formatting_lit */Block.__(17, [
                                                                                              /* Break */Block.__(0, [
                                                                                                  "@;<1 2>",
                                                                                                  1,
                                                                                                  2
                                                                                                ]),
                                                                                              /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                                                      /* Break */Block.__(0, [
                                                                                                          "@ ",
                                                                                                          1,
                                                                                                          0
                                                                                                        ]),
                                                                                                      /* Theta */Block.__(16, [/* Formatting_lit */Block.__(17, [
                                                                                                              /* Break */Block.__(0, [
                                                                                                                  "@;<1 2>",
                                                                                                                  1,
                                                                                                                  2
                                                                                                                ]),
                                                                                                              /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                                                                      /* Close_box */0,
                                                                                                                      /* End_of_format */0
                                                                                                                    ])])
                                                                                                            ])])
                                                                                                    ])])
                                                                                            ])])
                                                                                    ]),
                                                                                  "@[%t@;<1 2>%a@ %t@;<1 2>%a@]"
                                                                                ]), txt1, (function (param, param$1) {
                                                                                return type_path_expansion(tp, param, param$1);
                                                                              }), match[1], txt3, (function (param, param$1) {
                                                                                return type_path_expansion(tp0, param, param$1);
                                                                              }), tp0$prime);
                                                                }
                                                              } else {
                                                                throw [
                                                                      Caml_builtin_exceptions.assert_failure,
                                                                      [
                                                                        "printtyp.ml",
                                                                        1498,
                                                                        12
                                                                      ]
                                                                    ];
                                                              }
                                                            }));
                                            case 15 : 
                                                return Curry._1(Format.fprintf(ppf$1, /* Format */[
                                                                /* String */Block.__(2, [
                                                                    /* No_padding */0,
                                                                    /* End_of_format */0
                                                                  ]),
                                                                "%s"
                                                              ]), param[0]);
                                            case 16 : 
                                                var ty$2 = param[0];
                                                reset(/* () */0);
                                                mark_loops(ty$2);
                                                return Curry._3(Format.fprintf(ppf$1, /* Format */[
                                                                /* Formatting_gen */Block.__(18, [
                                                                    /* Open_box */Block.__(1, [/* Format */[
                                                                          /* String_literal */Block.__(11, [
                                                                              "<v>",
                                                                              /* End_of_format */0
                                                                            ]),
                                                                          "<v>"
                                                                        ]]),
                                                                    /* Formatting_gen */Block.__(18, [
                                                                        /* Open_box */Block.__(1, [/* Format */[
                                                                              /* End_of_format */0,
                                                                              ""
                                                                            ]]),
                                                                        /* String_literal */Block.__(11, [
                                                                            "This expression has type",
                                                                            /* Formatting_lit */Block.__(17, [
                                                                                /* Break */Block.__(0, [
                                                                                    "@;<1 2>",
                                                                                    1,
                                                                                    2
                                                                                  ]),
                                                                                /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                                        /* Close_box */0,
                                                                                        /* Formatting_lit */Block.__(17, [
                                                                                            /* Break */Block.__(0, [
                                                                                                "@,",
                                                                                                0,
                                                                                                0
                                                                                              ]),
                                                                                            /* String_literal */Block.__(11, [
                                                                                                "It has no method ",
                                                                                                /* String */Block.__(2, [
                                                                                                    /* No_padding */0,
                                                                                                    /* Formatting_lit */Block.__(17, [
                                                                                                        /* Close_box */0,
                                                                                                        /* End_of_format */0
                                                                                                      ])
                                                                                                  ])
                                                                                              ])
                                                                                          ])
                                                                                      ])])
                                                                              ])
                                                                          ])
                                                                      ])
                                                                  ]),
                                                                "@[<v>@[This expression has type@;<1 2>%a@]@,It has no method %s@]"
                                                              ]), type_expr$1, ty$2, param[1]);
                                            case 17 : 
                                                return Curry._1(Format.fprintf(ppf$1, /* Format */[
                                                                /* String_literal */Block.__(11, [
                                                                    "This expression has no method ",
                                                                    /* String */Block.__(2, [
                                                                        /* No_padding */0,
                                                                        /* End_of_format */0
                                                                      ])
                                                                  ]),
                                                                "This expression has no method %s"
                                                              ]), param[0]);
                                            case 18 : 
                                                return Curry._2(Format.fprintf(ppf$1, /* Format */[
                                                                /* String_literal */Block.__(11, [
                                                                    "Cannot instantiate the virtual class ",
                                                                    /* Alpha */Block.__(15, [/* End_of_format */0])
                                                                  ]),
                                                                "Cannot instantiate the virtual class %a"
                                                              ]), longident, param[0]);
                                            case 19 : 
                                                return Curry._2(Format.fprintf(ppf$1, /* Format */[
                                                                /* String_literal */Block.__(11, [
                                                                    "Cannot create values of the private type ",
                                                                    /* Alpha */Block.__(15, [/* End_of_format */0])
                                                                  ]),
                                                                "Cannot create values of the private type %a"
                                                              ]), type_expr$1, param[0]);
                                            case 20 : 
                                                return Curry._4(Format.fprintf(ppf$1, /* Format */[
                                                                /* String_literal */Block.__(11, [
                                                                    "Cannot assign field ",
                                                                    /* Alpha */Block.__(15, [/* String_literal */Block.__(11, [
                                                                            " of the private type ",
                                                                            /* Alpha */Block.__(15, [/* End_of_format */0])
                                                                          ])])
                                                                  ]),
                                                                "Cannot assign field %a of the private type %a"
                                                              ]), longident, param[0], type_expr$1, param[1]);
                                            case 21 : 
                                                return Curry._1(Format.fprintf(ppf$1, /* Format */[
                                                                /* String_literal */Block.__(11, [
                                                                    "Unbound instance variable ",
                                                                    /* String */Block.__(2, [
                                                                        /* No_padding */0,
                                                                        /* End_of_format */0
                                                                      ])
                                                                  ]),
                                                                "Unbound instance variable %s"
                                                              ]), param[0]);
                                            case 22 : 
                                                var v = param[1];
                                                if (param[0]) {
                                                  return Curry._1(Format.fprintf(ppf$1, /* Format */[
                                                                  /* String_literal */Block.__(11, [
                                                                      "The instance variable ",
                                                                      /* String */Block.__(2, [
                                                                          /* No_padding */0,
                                                                          /* String_literal */Block.__(11, [
                                                                              " is not mutable",
                                                                              /* End_of_format */0
                                                                            ])
                                                                        ])
                                                                    ]),
                                                                  "The instance variable %s is not mutable"
                                                                ]), v);
                                                } else {
                                                  return Curry._1(Format.fprintf(ppf$1, /* Format */[
                                                                  /* String_literal */Block.__(11, [
                                                                      "The value ",
                                                                      /* String */Block.__(2, [
                                                                          /* No_padding */0,
                                                                          /* String_literal */Block.__(11, [
                                                                              " is not an instance variable",
                                                                              /* End_of_format */0
                                                                            ])
                                                                        ])
                                                                    ]),
                                                                  "The value %s is not an instance variable"
                                                                ]), v);
                                                }
                                            case 23 : 
                                                var ppf$5 = ppf$1;
                                                var env$6 = env$2;
                                                var tr1 = param[0];
                                                var txt1$1 = "is not a subtype of";
                                                var tr2 = param[1];
                                                return wrap_printing_env(env$6, (function () {
                                                              reset(/* () */0);
                                                              var tr1$1 = List.map(prepare_expansion, tr1);
                                                              var tr2$1 = List.map(prepare_expansion, tr2);
                                                              var partial_arg = +(tr2$1 === /* [] */0);
                                                              Curry._2(Format.fprintf(ppf$5, /* Format */[
                                                                        /* Formatting_gen */Block.__(18, [
                                                                            /* Open_box */Block.__(1, [/* Format */[
                                                                                  /* String_literal */Block.__(11, [
                                                                                      "<v>",
                                                                                      /* End_of_format */0
                                                                                    ]),
                                                                                  "<v>"
                                                                                ]]),
                                                                            /* Alpha */Block.__(15, [/* End_of_format */0])
                                                                          ]),
                                                                        "@[<v>%a"
                                                                      ]), (function (param, param$1) {
                                                                      return trace$1(/* true */1, partial_arg, txt1$1, param, param$1);
                                                                    }), tr1$1);
                                                              if (tr2$1) {
                                                                var mis = mismatch(/* true */1, tr2$1);
                                                                var partial_arg$1 = +(mis === /* None */0);
                                                                return Curry._3(Format.fprintf(ppf$5, /* Format */[
                                                                                /* Alpha */Block.__(15, [/* Theta */Block.__(16, [/* Formatting_lit */Block.__(17, [
                                                                                            /* Close_box */0,
                                                                                            /* End_of_format */0
                                                                                          ])])]),
                                                                                "%a%t@]"
                                                                              ]), (function (param, param$1) {
                                                                              return trace$1(/* false */0, partial_arg$1, "is not compatible with type", param, param$1);
                                                                            }), tr2$1, (function (param) {
                                                                              return explanation(/* true */1, mis, param);
                                                                            }));
                                                              } else {
                                                                return Format.fprintf(ppf$5, /* Format */[
                                                                            /* Formatting_lit */Block.__(17, [
                                                                                /* Close_box */0,
                                                                                /* End_of_format */0
                                                                              ]),
                                                                            "@]"
                                                                          ]);
                                                              }
                                                            }));
                                            case 24 : 
                                                return Curry._1(Format.fprintf(ppf$1, /* Format */[
                                                                /* String_literal */Block.__(11, [
                                                                    "The instance variable ",
                                                                    /* String */Block.__(2, [
                                                                        /* No_padding */0,
                                                                        /* String_literal */Block.__(11, [
                                                                            " is overridden several times",
                                                                            /* End_of_format */0
                                                                          ])
                                                                      ])
                                                                  ]),
                                                                "The instance variable %s is overridden several times"
                                                              ]), param[0]);
                                            case 25 : 
                                                var ty$prime = param[1];
                                                var ty$3 = param[0];
                                                report_unification_error(ppf$1, env$2, /* None */0, param[2], (function (ppf) {
                                                        var match = prepare_expansion(/* tuple */[
                                                              ty$3,
                                                              ty$prime
                                                            ]);
                                                        var ty$4 = match[0];
                                                        return Curry._2(Format.fprintf(ppf, /* Format */[
                                                                        /* String_literal */Block.__(11, [
                                                                            "This expression cannot be coerced to type",
                                                                            /* Formatting_lit */Block.__(17, [
                                                                                /* Break */Block.__(0, [
                                                                                    "@;<1 2>",
                                                                                    1,
                                                                                    2
                                                                                  ]),
                                                                                /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                                                                        /* ";" */59,
                                                                                        /* Formatting_lit */Block.__(17, [
                                                                                            /* Break */Block.__(0, [
                                                                                                "@ ",
                                                                                                1,
                                                                                                0
                                                                                              ]),
                                                                                            /* String_literal */Block.__(11, [
                                                                                                "it has type",
                                                                                                /* End_of_format */0
                                                                                              ])
                                                                                          ])
                                                                                      ])])
                                                                              ])
                                                                          ]),
                                                                        "This expression cannot be coerced to type@;<1 2>%a;@ it has type"
                                                                      ]), (function (param, param$1) {
                                                                      return type_expansion(ty$4, param, param$1);
                                                                    }), match[1]);
                                                      }), (function (ppf) {
                                                        return Format.fprintf(ppf, /* Format */[
                                                                    /* String_literal */Block.__(11, [
                                                                        "but is here used with type",
                                                                        /* End_of_format */0
                                                                      ]),
                                                                    "but is here used with type"
                                                                  ]);
                                                      }));
                                                if (param[3]) {
                                                  return Curry._2(Format.fprintf(ppf$1, /* Format */[
                                                                  /* Char_literal */Block.__(12, [
                                                                      /* "." */46,
                                                                      /* Formatting_lit */Block.__(17, [
                                                                          /* Flush_newline */4,
                                                                          /* Formatting_gen */Block.__(18, [
                                                                              /* Open_box */Block.__(1, [/* Format */[
                                                                                    /* String_literal */Block.__(11, [
                                                                                        "<hov>",
                                                                                        /* End_of_format */0
                                                                                      ]),
                                                                                    "<hov>"
                                                                                  ]]),
                                                                              /* String */Block.__(2, [
                                                                                  /* No_padding */0,
                                                                                  /* Formatting_lit */Block.__(17, [
                                                                                      /* Break */Block.__(0, [
                                                                                          "@ ",
                                                                                          1,
                                                                                          0
                                                                                        ]),
                                                                                      /* String */Block.__(2, [
                                                                                          /* No_padding */0,
                                                                                          /* Formatting_lit */Block.__(17, [
                                                                                              /* Close_box */0,
                                                                                              /* End_of_format */0
                                                                                            ])
                                                                                        ])
                                                                                    ])
                                                                                ])
                                                                            ])
                                                                        ])
                                                                    ]),
                                                                  ".@.@[<hov>%s@ %s@]"
                                                                ]), "This simple coercion was not fully general.", "Consider using a double coercion.");
                                                } else {
                                                  return 0;
                                                }
                                            case 26 : 
                                                var ty$4 = param[1];
                                                reset(/* () */0);
                                                mark_loops(ty$4);
                                                if (param[0]) {
                                                  Format.fprintf(ppf$1, /* Format */[
                                                        /* String_literal */Block.__(11, [
                                                            "This function expects too many arguments,",
                                                            /* Formatting_lit */Block.__(17, [
                                                                /* Break */Block.__(0, [
                                                                    "@ ",
                                                                    1,
                                                                    0
                                                                  ]),
                                                                /* End_of_format */0
                                                              ])
                                                          ]),
                                                        "This function expects too many arguments,@ "
                                                      ]);
                                                  return Curry._2(Format.fprintf(ppf$1, /* Format */[
                                                                  /* String_literal */Block.__(11, [
                                                                      "it should have type",
                                                                      /* Formatting_lit */Block.__(17, [
                                                                          /* Break */Block.__(0, [
                                                                              "@ ",
                                                                              1,
                                                                              0
                                                                            ]),
                                                                          /* Alpha */Block.__(15, [/* End_of_format */0])
                                                                        ])
                                                                    ]),
                                                                  "it should have type@ %a"
                                                                ]), type_expr$1, ty$4);
                                                } else {
                                                  Format.fprintf(ppf$1, /* Format */[
                                                        /* String_literal */Block.__(11, [
                                                            "This expression should not be a function,",
                                                            /* Formatting_lit */Block.__(17, [
                                                                /* Break */Block.__(0, [
                                                                    "@ ",
                                                                    1,
                                                                    0
                                                                  ]),
                                                                /* End_of_format */0
                                                              ])
                                                          ]),
                                                        "This expression should not be a function,@ "
                                                      ]);
                                                  return Curry._2(Format.fprintf(ppf$1, /* Format */[
                                                                  /* String_literal */Block.__(11, [
                                                                      "the expected type is",
                                                                      /* Formatting_lit */Block.__(17, [
                                                                          /* Break */Block.__(0, [
                                                                              "@ ",
                                                                              1,
                                                                              0
                                                                            ]),
                                                                          /* Alpha */Block.__(15, [/* End_of_format */0])
                                                                        ])
                                                                    ]),
                                                                  "the expected type is@ %a"
                                                                ]), type_expr$1, ty$4);
                                                }
                                            case 27 : 
                                                var ty$5 = param[1];
                                                var label_mark = function (l) {
                                                  if (l === "") {
                                                    return "but its first argument is not labelled";
                                                  } else {
                                                    return Curry._1(Format.sprintf(/* Format */[
                                                                    /* String_literal */Block.__(11, [
                                                                        "but its first argument is labelled ",
                                                                        /* String */Block.__(2, [
                                                                            /* No_padding */0,
                                                                            /* End_of_format */0
                                                                          ])
                                                                      ]),
                                                                    "but its first argument is labelled %s"
                                                                  ]), prefixed_label_name(l));
                                                  }
                                                };
                                                reset(/* () */0);
                                                mark_loops(ty$5);
                                                return Curry._3(Format.fprintf(ppf$1, /* Format */[
                                                                /* Formatting_gen */Block.__(18, [
                                                                    /* Open_box */Block.__(1, [/* Format */[
                                                                          /* String_literal */Block.__(11, [
                                                                              "<v>",
                                                                              /* End_of_format */0
                                                                            ]),
                                                                          "<v>"
                                                                        ]]),
                                                                    /* Formatting_gen */Block.__(18, [
                                                                        /* Open_box */Block.__(1, [/* Format */[
                                                                              /* String_literal */Block.__(11, [
                                                                                  "<2>",
                                                                                  /* End_of_format */0
                                                                                ]),
                                                                              "<2>"
                                                                            ]]),
                                                                        /* String_literal */Block.__(11, [
                                                                            "This function should have type",
                                                                            /* Formatting_lit */Block.__(17, [
                                                                                /* Break */Block.__(0, [
                                                                                    "@ ",
                                                                                    1,
                                                                                    0
                                                                                  ]),
                                                                                /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                                        /* Close_box */0,
                                                                                        /* Formatting_lit */Block.__(17, [
                                                                                            /* Break */Block.__(0, [
                                                                                                "@,",
                                                                                                0,
                                                                                                0
                                                                                              ]),
                                                                                            /* String */Block.__(2, [
                                                                                                /* No_padding */0,
                                                                                                /* Formatting_lit */Block.__(17, [
                                                                                                    /* Close_box */0,
                                                                                                    /* End_of_format */0
                                                                                                  ])
                                                                                              ])
                                                                                          ])
                                                                                      ])])
                                                                              ])
                                                                          ])
                                                                      ])
                                                                  ]),
                                                                "@[<v>@[<2>This function should have type@ %a@]@,%s@]"
                                                              ]), type_expr$1, ty$5, label_mark(param[0]));
                                            case 28 : 
                                                var ty$6 = param[1];
                                                reset(/* () */0);
                                                mark_loops(ty$6);
                                                Curry._2(Format.fprintf(ppf$1, /* Format */[
                                                          /* String_literal */Block.__(11, [
                                                              "This `let module' expression has type",
                                                              /* Formatting_lit */Block.__(17, [
                                                                  /* Break */Block.__(0, [
                                                                      "@ ",
                                                                      1,
                                                                      0
                                                                    ]),
                                                                  /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                          /* Break */Block.__(0, [
                                                                              "@ ",
                                                                              1,
                                                                              0
                                                                            ]),
                                                                          /* End_of_format */0
                                                                        ])])
                                                                ])
                                                            ]),
                                                          "This `let module' expression has type@ %a@ "
                                                        ]), type_expr$1, ty$6);
                                                return Curry._1(Format.fprintf(ppf$1, /* Format */[
                                                                /* String_literal */Block.__(11, [
                                                                    "In this type, the locally bound module name ",
                                                                    /* String */Block.__(2, [
                                                                        /* No_padding */0,
                                                                        /* String_literal */Block.__(11, [
                                                                            " escapes its scope",
                                                                            /* End_of_format */0
                                                                          ])
                                                                      ])
                                                                  ]),
                                                                "In this type, the locally bound module name %s escapes its scope"
                                                              ]), param[0]);
                                            case 29 : 
                                                return Curry._2(Format.fprintf(ppf$1, /* Format */[
                                                                /* String_literal */Block.__(11, [
                                                                    "The instance variable ",
                                                                    /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                            /* Break */Block.__(0, [
                                                                                "@ ",
                                                                                1,
                                                                                0
                                                                              ]),
                                                                            /* String_literal */Block.__(11, [
                                                                                "cannot be accessed from the definition of another instance variable",
                                                                                /* End_of_format */0
                                                                              ])
                                                                          ])])
                                                                  ]),
                                                                "The instance variable %a@ cannot be accessed from the definition of another instance variable"
                                                              ]), longident, param[0]);
                                            case 30 : 
                                                return Curry._2(Format.fprintf(ppf$1, /* Format */[
                                                                /* String_literal */Block.__(11, [
                                                                    "The type ",
                                                                    /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                            /* Break */Block.__(0, [
                                                                                "@ ",
                                                                                1,
                                                                                0
                                                                              ]),
                                                                            /* String_literal */Block.__(11, [
                                                                                "is not a variant type",
                                                                                /* End_of_format */0
                                                                              ])
                                                                          ])])
                                                                  ]),
                                                                "The type %a@ is not a variant type"
                                                              ]), longident, param[0]);
                                            case 31 : 
                                                var kind$2 = param[0];
                                                return report_unification_error(ppf$1, env$2, /* None */0, param[1], (function (ppf) {
                                                              return Curry._1(Format.fprintf(ppf, /* Format */[
                                                                              /* String_literal */Block.__(11, [
                                                                                  "This ",
                                                                                  /* String */Block.__(2, [
                                                                                      /* No_padding */0,
                                                                                      /* String_literal */Block.__(11, [
                                                                                          " has type",
                                                                                          /* End_of_format */0
                                                                                        ])
                                                                                    ])
                                                                                ]),
                                                                              "This %s has type"
                                                                            ]), kind$2);
                                                            }), (function (ppf) {
                                                              return Format.fprintf(ppf, /* Format */[
                                                                          /* String_literal */Block.__(11, [
                                                                              "which is less general than",
                                                                              /* End_of_format */0
                                                                            ]),
                                                                          "which is less general than"
                                                                        ]);
                                                            }));
                                            case 32 : 
                                                return Curry._2(Format.fprintf(ppf$1, /* Format */[
                                                                /* String_literal */Block.__(11, [
                                                                    "This expression is packed module, but the expected type is",
                                                                    /* Formatting_lit */Block.__(17, [
                                                                        /* Break */Block.__(0, [
                                                                            "@ ",
                                                                            1,
                                                                            0
                                                                          ]),
                                                                        /* Alpha */Block.__(15, [/* End_of_format */0])
                                                                      ])
                                                                  ]),
                                                                "This expression is packed module, but the expected type is@ %a"
                                                              ]), type_expr$1, param[0]);
                                            case 33 : 
                                                return report_unification_error(ppf$1, env$2, /* None */0, param[0], (function (ppf) {
                                                              return Format.fprintf(ppf, /* Format */[
                                                                          /* String_literal */Block.__(11, [
                                                                              "Recursive local constraint when unifying",
                                                                              /* End_of_format */0
                                                                            ]),
                                                                          "Recursive local constraint when unifying"
                                                                        ]);
                                                            }), (function (ppf) {
                                                              return Format.fprintf(ppf, /* Format */[
                                                                          /* String_literal */Block.__(11, [
                                                                              "with",
                                                                              /* End_of_format */0
                                                                            ]),
                                                                          "with"
                                                                        ]);
                                                            }));
                                            case 34 : 
                                                return Curry._4(Format.fprintf(ppf$1, /* Format */[
                                                                /* Formatting_gen */Block.__(18, [
                                                                    /* Open_box */Block.__(1, [/* Format */[
                                                                          /* End_of_format */0,
                                                                          ""
                                                                        ]]),
                                                                    /* String_literal */Block.__(11, [
                                                                        "The GADT constructor ",
                                                                        /* String */Block.__(2, [
                                                                            /* No_padding */0,
                                                                            /* String_literal */Block.__(11, [
                                                                                " of type ",
                                                                                /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                                        /* Break */Block.__(0, [
                                                                                            "@ ",
                                                                                            1,
                                                                                            0
                                                                                          ]),
                                                                                        /* String */Block.__(2, [
                                                                                            /* No_padding */0,
                                                                                            /* Char_literal */Block.__(12, [
                                                                                                /* "." */46,
                                                                                                /* Formatting_lit */Block.__(17, [
                                                                                                    /* Close_box */0,
                                                                                                    /* End_of_format */0
                                                                                                  ])
                                                                                              ])
                                                                                          ])
                                                                                      ])])
                                                                              ])
                                                                          ])
                                                                      ])
                                                                  ]),
                                                                "@[The GADT constructor %s of type %a@ %s.@]"
                                                              ]), param[1], path, param[0], "must be qualified in this pattern");
                                            
                                          }
                                        }
                                      }));
                        }), param[3])];
        } else if (param[0] === Error_forward$1) {
          return /* Some */[param[1]];
        } else {
          return /* None */0;
        }
      }));

add_delayed_check_forward[0] = add_delayed_check;

var $$Error$8 = Caml_exceptions.create("Ocaml_typedtree_test.Typedecl.Error");

function enter_type$1(env, sdecl, id) {
  var match = sdecl[/* ptype_manifest */5];
  var decl_000 = /* type_params */List.map((function () {
          return newty2(100000000, /* Tvar */Block.__(0, [/* None */0]));
        }), sdecl[/* ptype_params */1]);
  var decl_001 = /* type_arity */List.length(sdecl[/* ptype_params */1]);
  var decl_003 = /* type_private */sdecl[/* ptype_private */4];
  var decl_004 = /* type_manifest */match ? /* Some */[newvar(/* None */0, /* () */0)] : /* None */0;
  var decl_005 = /* type_variance */List.map((function () {
          return Types_003[/* full */1];
        }), sdecl[/* ptype_params */1]);
  var decl_007 = /* type_loc */sdecl[/* ptype_loc */7];
  var decl_008 = /* type_attributes */sdecl[/* ptype_attributes */6];
  var decl = /* record */[
    decl_000,
    decl_001,
    /* type_kind : Type_abstract */0,
    decl_003,
    decl_004,
    decl_005,
    /* type_newtype_level : None */0,
    decl_007,
    decl_008
  ];
  return add_type$1(/* true */1, id, decl, env);
}

function is_fixed_type(sd) {
  var match = sd[/* ptype_manifest */5];
  if (match && sd[/* ptype_kind */3] === /* Ptype_abstract */0 && !sd[/* ptype_private */4]) {
    var _sty = match[0];
    while(true) {
      var sty = _sty;
      var match$1 = sty[/* ptyp_desc */0];
      if (typeof match$1 === "number") {
        return /* false */0;
      } else {
        switch (match$1.tag | 0) {
          case 4 : 
              if (match$1[1] !== 0) {
                return /* true */1;
              } else {
                return /* false */0;
              }
          case 5 : 
              return /* true */1;
          case 6 : 
              _sty = match$1[0];
              continue ;
              case 7 : 
              if (match$1[1] !== 0 || match$1[2]) {
                return /* true */1;
              } else {
                return /* false */0;
              }
          default:
            return /* false */0;
        }
      }
    };
  } else {
    return /* false */0;
  }
}

function set_fixed_row(env, loc, p, decl) {
  var match = decl[/* type_manifest */4];
  var tm;
  if (match) {
    tm = expand_head(env, match[0]);
  } else {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "typedecl.ml",
            113,
            14
          ]
        ];
  }
  var match$1 = tm[/* desc */0];
  var rv;
  if (typeof match$1 === "number") {
    throw [
          $$Error$8,
          loc,
          /* Bad_fixed_type */Block.__(18, ["is not an object or variant"])
        ];
  } else {
    switch (match$1.tag | 0) {
      case 4 : 
          rv = flatten_fields(match$1[0])[1];
          break;
      case 8 : 
          var row = row_repr_aux(/* [] */0, match$1[0]);
          var newrecord = row.slice();
          tm[/* desc */0] = /* Tvariant */Block.__(8, [(newrecord[/* row_fixed */4] = /* true */1, newrecord)]);
          rv = static_row(row) ? newty2(100000000, /* Tnil */0) : row[/* row_more */1];
          break;
      default:
        throw [
              $$Error$8,
              loc,
              /* Bad_fixed_type */Block.__(18, ["is not an object or variant"])
            ];
    }
  }
  if (!is_Tvar(rv)) {
    throw [
          $$Error$8,
          loc,
          /* Bad_fixed_type */Block.__(18, ["has no row variable"])
        ];
  }
  rv[/* desc */0] = /* Tconstr */Block.__(3, [
      p,
      decl[/* type_params */0],
      [/* Mnil */0]
    ]);
  return /* () */0;
}

function height$10(param) {
  if (param) {
    return param[3];
  } else {
    return 0;
  }
}

function create$11(l, v, r) {
  var hl = l ? l[3] : 0;
  var hr = r ? r[3] : 0;
  return /* Node */[
          l,
          v,
          r,
          hl >= hr ? hl + 1 | 0 : hr + 1 | 0
        ];
}

function bal$10(l, v, r) {
  var hl = l ? l[3] : 0;
  var hr = r ? r[3] : 0;
  if (hl > (hr + 2 | 0)) {
    if (l) {
      var lr = l[2];
      var lv = l[1];
      var ll = l[0];
      if (height$10(ll) >= height$10(lr)) {
        return create$11(ll, lv, create$11(lr, v, r));
      } else if (lr) {
        return create$11(create$11(ll, lv, lr[0]), lr[1], create$11(lr[2], v, r));
      } else {
        throw [
              Caml_builtin_exceptions.invalid_argument,
              "Set.bal"
            ];
      }
    } else {
      throw [
            Caml_builtin_exceptions.invalid_argument,
            "Set.bal"
          ];
    }
  } else if (hr > (hl + 2 | 0)) {
    if (r) {
      var rr = r[2];
      var rv = r[1];
      var rl = r[0];
      if (height$10(rr) >= height$10(rl)) {
        return create$11(create$11(l, v, rl), rv, rr);
      } else if (rl) {
        return create$11(create$11(l, v, rl[0]), rl[1], create$11(rl[2], rv, rr));
      } else {
        throw [
              Caml_builtin_exceptions.invalid_argument,
              "Set.bal"
            ];
      }
    } else {
      throw [
            Caml_builtin_exceptions.invalid_argument,
            "Set.bal"
          ];
    }
  } else {
    return /* Node */[
            l,
            v,
            r,
            hl >= hr ? hl + 1 | 0 : hr + 1 | 0
          ];
  }
}

function add$12(x, t) {
  if (t) {
    var r = t[2];
    var v = t[1];
    var l = t[0];
    var c = Caml_string.caml_string_compare(x, v);
    if (c) {
      if (c < 0) {
        return bal$10(add$12(x, l), v, r);
      } else {
        return bal$10(l, v, add$12(x, r));
      }
    } else {
      return t;
    }
  } else {
    return /* Node */[
            /* Empty */0,
            x,
            /* Empty */0,
            1
          ];
  }
}

function mem$6(x, _param) {
  while(true) {
    var param = _param;
    if (param) {
      var c = Caml_string.caml_string_compare(x, param[1]);
      if (c) {
        _param = c < 0 ? param[0] : param[2];
        continue ;
        
      } else {
        return /* true */1;
      }
    } else {
      return /* false */0;
    }
  };
}

function make_params(env, params) {
  var make_param = function (param) {
    var sty = param[0];
    try {
      return /* tuple */[
              transl_type_param(env, sty),
              param[1]
            ];
    }
    catch (exn){
      if (exn === Already_bound) {
        throw [
              $$Error$8,
              sty[/* ptyp_loc */1],
              /* Repeated_parameter */0
            ];
      } else {
        throw exn;
      }
    }
  };
  return List.map(make_param, params);
}

function make_constructor(env, type_path, type_params, sargs, sret_type) {
  if (sret_type) {
    var sret_type$1 = sret_type[0];
    var z = narrow(/* () */0);
    reset_type_variables(/* () */0);
    var targs = List.map((function (param) {
            return transl_simple_type(env, /* false */0, param);
          }), sargs);
    var args = List.map((function (cty) {
            return cty[/* ctyp_type */1];
          }), targs);
    var tret_type = transl_simple_type(env, /* false */0, sret_type$1);
    var ret_type = tret_type[/* ctyp_type */1];
    var match = repr(ret_type)[/* desc */0];
    var exit = 0;
    if (typeof match === "number") {
      exit = 1;
    } else if (match.tag === 3) {
      if (!same(type_path, match[0])) {
        exit = 1;
      }
      
    } else {
      exit = 1;
    }
    if (exit === 1) {
      throw [
            $$Error$8,
            sret_type$1[/* ptyp_loc */1],
            /* Constraint_failed */Block.__(5, [
                ret_type,
                newconstr(type_path, type_params)
              ])
          ];
    }
    widen(z);
    return /* tuple */[
            targs,
            /* Some */[tret_type],
            args,
            /* Some */[ret_type]
          ];
  } else {
    var targs$1 = List.map((function (param) {
            return transl_simple_type(env, /* true */1, param);
          }), sargs);
    var args$1 = List.map((function (cty) {
            return cty[/* ctyp_type */1];
          }), targs$1);
    return /* tuple */[
            targs$1,
            /* None */0,
            args$1,
            /* None */0
          ];
  }
}

function generalize_decl(decl) {
  List.iter(generalize, decl[/* type_params */0]);
  var match = decl[/* type_kind */2];
  if (typeof match === "number") {
    +(match === 0);
  } else if (match.tag) {
    List.iter((function (c) {
            List.iter(generalize, c[/* cd_args */1]);
            return may(generalize, c[/* cd_res */2]);
          }), match[0]);
  } else {
    List.iter((function (l) {
            return iter_generalize$1([/* [] */0], l[/* ld_type */2]);
          }), match[0]);
  }
  var match$1 = decl[/* type_manifest */4];
  if (match$1) {
    return iter_generalize$1([/* [] */0], match$1[0]);
  } else {
    return /* () */0;
  }
}

function check_constraints_rec(env, loc, visited, _ty) {
  while(true) {
    var ty = _ty;
    var ty$1 = repr(ty);
    if (mem$3(ty$1, visited[0])) {
      return /* () */0;
    } else {
      visited[0] = add$3(ty$1, visited[0]);
      var match = ty$1[/* desc */0];
      var exit = 0;
      if (typeof match === "number") {
        exit = 1;
      } else {
        switch (match.tag | 0) {
          case 3 : 
              var args = match[1];
              var path = match[0];
              var args$prime = List.map((function () {
                      return newvar(/* None */0, /* () */0);
                    }), args);
              var ty$prime = newconstr(path, args$prime);
              try {
                enforce_constraints(env, ty$prime);
              }
              catch (raw_exn){
                var exn = Js_exn.internalToOCamlException(raw_exn);
                if (exn[0] === Unify) {
                  throw [
                        Caml_builtin_exceptions.assert_failure,
                        [
                          "typedecl.ml",
                          360,
                          28
                        ]
                      ];
                } else if (exn === Caml_builtin_exceptions.not_found) {
                  throw [
                        $$Error$8,
                        loc,
                        /* Unavailable_type_constructor */Block.__(17, [path])
                      ];
                } else {
                  throw exn;
                }
              }
              if (!matches(env, ty$1, ty$prime)) {
                throw [
                      $$Error$8,
                      loc,
                      /* Constraint_failed */Block.__(5, [
                          ty$1,
                          ty$prime
                        ])
                    ];
              }
              return List.iter((function (param) {
                            return check_constraints_rec(env, loc, visited, param);
                          }), args);
          case 10 : 
              var match$1 = instance_poly(/* None */0, /* false */0, match[1], match[0]);
              _ty = match$1[1];
              continue ;
              default:
            exit = 1;
        }
      }
      if (exit === 1) {
        return iter_type_expr((function (param) {
                      return check_constraints_rec(env, loc, visited, param);
                    }), ty$1);
      }
      
    }
  };
}

function height$11(param) {
  if (param) {
    return param[4];
  } else {
    return 0;
  }
}

function create$12(l, x, d, r) {
  var hl = height$11(l);
  var hr = height$11(r);
  return /* Node */[
          l,
          x,
          d,
          r,
          hl >= hr ? hl + 1 | 0 : hr + 1 | 0
        ];
}

function bal$11(l, x, d, r) {
  var hl = l ? l[4] : 0;
  var hr = r ? r[4] : 0;
  if (hl > (hr + 2 | 0)) {
    if (l) {
      var lr = l[3];
      var ld = l[2];
      var lv = l[1];
      var ll = l[0];
      if (height$11(ll) >= height$11(lr)) {
        return create$12(ll, lv, ld, create$12(lr, x, d, r));
      } else if (lr) {
        return create$12(create$12(ll, lv, ld, lr[0]), lr[1], lr[2], create$12(lr[3], x, d, r));
      } else {
        throw [
              Caml_builtin_exceptions.invalid_argument,
              "Map.bal"
            ];
      }
    } else {
      throw [
            Caml_builtin_exceptions.invalid_argument,
            "Map.bal"
          ];
    }
  } else if (hr > (hl + 2 | 0)) {
    if (r) {
      var rr = r[3];
      var rd = r[2];
      var rv = r[1];
      var rl = r[0];
      if (height$11(rr) >= height$11(rl)) {
        return create$12(create$12(l, x, d, rl), rv, rd, rr);
      } else if (rl) {
        return create$12(create$12(l, x, d, rl[0]), rl[1], rl[2], create$12(rl[3], rv, rd, rr));
      } else {
        throw [
              Caml_builtin_exceptions.invalid_argument,
              "Map.bal"
            ];
      }
    } else {
      throw [
            Caml_builtin_exceptions.invalid_argument,
            "Map.bal"
          ];
    }
  } else {
    return /* Node */[
            l,
            x,
            d,
            r,
            hl >= hr ? hl + 1 | 0 : hr + 1 | 0
          ];
  }
}

function add$13(x, data, param) {
  if (param) {
    var r = param[3];
    var d = param[2];
    var v = param[1];
    var l = param[0];
    var c = Caml_string.caml_string_compare(x, v);
    if (c) {
      if (c < 0) {
        return bal$11(add$13(x, data, l), v, d, r);
      } else {
        return bal$11(l, v, d, add$13(x, data, r));
      }
    } else {
      return /* Node */[
              l,
              x,
              data,
              r,
              param[4]
            ];
    }
  } else {
    return /* Node */[
            /* Empty */0,
            x,
            data,
            /* Empty */0,
            1
          ];
  }
}

function find$6(x, _param) {
  while(true) {
    var param = _param;
    if (param) {
      var c = Caml_string.caml_string_compare(x, param[1]);
      if (c) {
        _param = c < 0 ? param[0] : param[3];
        continue ;
        
      } else {
        return param[2];
      }
    } else {
      throw Caml_builtin_exceptions.not_found;
    }
  };
}

function check_coherence(env, loc, id, decl) {
  var match = decl[/* type_kind */2];
  var exit = 0;
  if (typeof match === "number") {
    if (match !== 0) {
      exit = 1;
    } else {
      return /* () */0;
    }
  } else {
    exit = 1;
  }
  if (exit === 1) {
    var match$1 = decl[/* type_manifest */4];
    if (match$1) {
      var ty = match$1[0];
      var match$2 = repr(ty)[/* desc */0];
      if (typeof match$2 === "number") {
        throw [
              $$Error$8,
              loc,
              /* Definition_mismatch */Block.__(4, [
                  ty,
                  /* [] */0
                ])
            ];
      } else if (match$2.tag === 3) {
        var args = match$2[1];
        var path = match$2[0];
        try {
          var decl$prime = find_type_full(path, env)[0];
          var err = List.length(args) !== List.length(decl[/* type_params */0]) ? /* :: */[
              /* Arity */0,
              /* [] */0
            ] : (
              equal$4(env, /* false */0, args, decl[/* type_params */0]) ? type_declarations$1(/* Some */[/* true */1], env, last(path), decl$prime, id, type_declaration(add_type(id, path, identity), decl)) : /* :: */[
                  /* Constraint */3,
                  /* [] */0
                ]
            );
          if (err !== /* [] */0) {
            throw [
                  $$Error$8,
                  loc,
                  /* Definition_mismatch */Block.__(4, [
                      ty,
                      err
                    ])
                ];
          } else {
            return 0;
          }
        }
        catch (exn){
          if (exn === Caml_builtin_exceptions.not_found) {
            throw [
                  $$Error$8,
                  loc,
                  /* Unavailable_type_constructor */Block.__(17, [path])
                ];
          } else {
            throw exn;
          }
        }
      } else {
        throw [
              $$Error$8,
              loc,
              /* Definition_mismatch */Block.__(4, [
                  ty,
                  /* [] */0
                ])
            ];
      }
    } else {
      return /* () */0;
    }
  }
  
}

function check_well_founded(env, loc, path, to_check, ty) {
  var visited = [/* Empty */0];
  var check = function (ty0, exp_nodes, ty) {
    var ty$1 = repr(ty);
    if (mem$3(ty$1, exp_nodes)) {
      var match = ty0[/* desc */0];
      var $js;
      $js = typeof match === "number" || match.tag !== 3 ? /* false */0 : same(match[0], path);
      if ($js) {
        throw [
              $$Error$8,
              loc,
              /* Recursive_abbrev */Block.__(2, [name(/* None */0, path)])
            ];
      } else {
        throw [
              $$Error$8,
              loc,
              /* Cycle_in_def */Block.__(3, [
                  name(/* None */0, path),
                  ty0
                ])
            ];
      }
    }
    var match$1;
    try {
      var prev = find$1(ty$1, visited[0]);
      match$1 = subset$1(exp_nodes, prev) ? /* tuple */[
          /* true */1,
          exp_nodes
        ] : /* tuple */[
          /* false */0,
          union$2(exp_nodes, prev)
        ];
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        match$1 = /* tuple */[
          /* false */0,
          exp_nodes
        ];
      } else {
        throw exn;
      }
    }
    var exp_nodes$1 = match$1[1];
    var snap = snapshot(/* () */0);
    if (match$1[0]) {
      return /* () */0;
    } else {
      try {
        visited[0] = add$4(ty$1, exp_nodes$1, visited[0]);
        var match$2 = ty$1[/* desc */0];
        if (typeof match$2 === "number") {
          throw Cannot_expand;
        } else if (match$2.tag === 3) {
          if (!(
              exp_nodes$1 ? /* false */0 : /* true */1
            ) || Curry._1(to_check, match$2[0])) {
            var ty$prime = try_expand_once_opt(env, ty$1);
            var ty0$1 = (
              exp_nodes$1 ? /* false */0 : /* true */1
            ) ? ty$1 : ty0;
            return check(ty0$1, add$3(ty$1, exp_nodes$1), ty$prime);
          } else {
            throw Cannot_expand;
          }
        } else {
          throw Cannot_expand;
        }
      }
      catch (raw_exn){
        var exn$1 = Js_exn.internalToOCamlException(raw_exn);
        if (exn$1 === Cannot_expand) {
          var match$3 = ty$1[/* desc */0];
          var $js$1;
          if (typeof match$3 === "number") {
            $js$1 = /* false */0;
          } else {
            switch (match$3.tag | 0) {
              case 4 : 
              case 8 : 
                  $js$1 = /* true */1;
                  break;
              default:
                $js$1 = /* false */0;
            }
          }
          var nodes = recursive_types[0] && is_contractive(env, ty$1) || $js$1 ? /* Empty */0 : exp_nodes$1;
          return iter_type_expr((function (param) {
                        return check(ty0, nodes, param);
                      }), ty$1);
        } else if (exn$1[0] === Unify) {
          return backtrack(snap);
        } else {
          throw exn$1;
        }
      }
    }
  };
  return wrap_trace_gadt_instances(env, (function (param) {
                return check(ty, /* Empty */0, param);
              }), ty);
}

function check_well_founded_decl(env, loc, path, decl, to_check) {
  var newrecord$4 = newrecord.slice();
  newrecord$4[/* it_type_expr */13] = (function () {
      return (function (param) {
          return check_well_founded(env, loc, path, to_check, param);
        });
    });
  return Curry._2(newrecord$4[/* it_type_declaration */3], newrecord$4, instance_declaration(decl));
}

function check_recursion(env, loc, path, decl, to_check) {
  if (decl[/* type_params */0]) {
    var visited = [/* [] */0];
    var check_regular = function (cpath, args, prev_exp, _ty) {
      while(true) {
        var ty = _ty;
        var ty$1 = repr(ty);
        if (List.memq(ty$1, visited[0])) {
          return 0;
        } else {
          visited[0] = /* :: */[
            ty$1,
            visited[0]
          ];
          var match = ty$1[/* desc */0];
          var exit = 0;
          if (typeof match === "number") {
            exit = 1;
          } else {
            switch (match.tag | 0) {
              case 3 : 
                  var args$prime = match[1];
                  var path$prime = match[0];
                  if (same(path, path$prime)) {
                    if (!equal$4(env, /* false */0, args, args$prime)) {
                      throw [
                            $$Error$8,
                            loc,
                            /* Parameters_differ */Block.__(8, [
                                cpath,
                                ty$1,
                                newconstr(path, args)
                              ])
                          ];
                    }
                    
                  } else if (Curry._1(to_check, path$prime) && !List.mem(path$prime, prev_exp)) {
                    try {
                      var match$1 = find_type_expansion(path$prime, env);
                      var params0 = match$1[0];
                      var match$2 = instance_parameterized_type(/* None */0, params0, match$1[1]);
                      try {
                        List.iter2((function (param, param$1) {
                                return unify$2(env, param, param$1);
                              }), match$2[0], args$prime);
                      }
                      catch (raw_exn){
                        var exn = Js_exn.internalToOCamlException(raw_exn);
                        if (exn[0] === Unify) {
                          throw [
                                $$Error$8,
                                loc,
                                /* Constraint_failed */Block.__(5, [
                                    ty$1,
                                    newconstr(path$prime, params0)
                                  ])
                              ];
                        } else {
                          throw exn;
                        }
                      }
                      check_regular(path$prime, args, /* :: */[
                            path$prime,
                            prev_exp
                          ], match$2[1]);
                    }
                    catch (exn$1){
                      if (exn$1 !== Caml_builtin_exceptions.not_found) {
                        throw exn$1;
                      }
                      
                    }
                  }
                  return List.iter((function (param) {
                                return check_regular(cpath, args, prev_exp, param);
                              }), args$prime);
              case 10 : 
                  var match$3 = instance_poly(/* Some */[/* true */1], /* false */0, match[1], match[0]);
                  _ty = match$3[1];
                  continue ;
                  default:
                exit = 1;
            }
          }
          if (exit === 1) {
            return iter_type_expr((function (param) {
                          return check_regular(cpath, args, prev_exp, param);
                        }), ty$1);
          }
          
        }
      };
    };
    return may((function (body) {
                  var match = instance_parameterized_type(/* Some */[/* true */1], decl[/* type_params */0], body);
                  return check_regular(path, match[0], /* [] */0, match[1]);
                }), decl[/* type_manifest */4]);
  } else {
    return /* () */0;
  }
}

function get_variance(ty, visited) {
  try {
    return find$1(ty, visited[0]);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return Types_003[/* null */0];
    } else {
      throw exn;
    }
  }
}

function compute_variance(env, visited, vari, ty) {
  var compute_variance_rec = function (_vari, _ty) {
    while(true) {
      var ty = _ty;
      var vari = _vari;
      var ty$1 = repr(ty);
      var vari$prime = get_variance(ty$1, visited);
      if (Curry._2(Types_003[/* subset */6], vari, vari$prime)) {
        return /* () */0;
      } else {
        var vari$1 = Curry._2(Types_003[/* union */4], vari, vari$prime);
        visited[0] = add$4(ty$1, vari$1, visited[0]);
        var compute_same = (function(vari$1){
        return function compute_same(param) {
          return compute_variance_rec(vari$1, param);
        }
        }(vari$1));
        var match = ty$1[/* desc */0];
        if (typeof match === "number") {
          return /* () */0;
        } else {
          switch (match.tag | 0) {
            case 1 : 
                var v = Curry._1(Types_003[/* conjugate */9], vari$1);
                var v1 = Curry._2(Types_003[/* mem */8], /* May_pos */0, v) || Curry._2(Types_003[/* mem */8], /* May_neg */1, v) ? Curry._3(Types_003[/* set */7], /* May_weak */2, /* true */1, v) : v;
                compute_variance_rec(v1, match[1]);
                _ty = match[2];
                _vari = vari$1;
                continue ;
                case 2 : 
                return List.iter(compute_same, match[0]);
            case 3 : 
                var tl = match[1];
                if (tl) {
                  try {
                    var decl = find_type_full(match[0], env)[0];
                    var cvari = (function(vari$1){
                    return function cvari(f) {
                      return Curry._2(Types_003[/* mem */8], f, vari$1);
                    }
                    }(vari$1));
                    return List.iter2((function(vari$1){
                              return function (ty, v) {
                                var cv = function (f) {
                                  return Curry._2(Types_003[/* mem */8], f, v);
                                };
                                var strict = cvari(/* Inv */6) && cv(/* Inj */3) || (cvari(/* Pos */4) || cvari(/* Neg */5)) && cv(/* Inv */6);
                                if (strict) {
                                  return compute_variance_rec(Types_003[/* full */1], ty);
                                } else {
                                  var p1 = Curry._2(Types_003[/* inter */5], v, vari$1);
                                  var n1 = Curry._2(Types_003[/* inter */5], v, Curry._1(Types_003[/* conjugate */9], vari$1));
                                  var v1 = Curry._2(Types_003[/* union */4], Curry._2(Types_003[/* inter */5], Types_003[/* covariant */2], Curry._2(Types_003[/* union */4], p1, Curry._1(Types_003[/* conjugate */9], p1))), Curry._2(Types_003[/* inter */5], Curry._1(Types_003[/* conjugate */9], Types_003[/* covariant */2]), Curry._2(Types_003[/* union */4], n1, Curry._1(Types_003[/* conjugate */9], n1))));
                                  var weak = cvari(/* May_weak */2) && (cv(/* May_pos */0) || cv(/* May_neg */1)) || (cvari(/* May_pos */0) || cvari(/* May_neg */1)) && cv(/* May_weak */2);
                                  var v2 = Curry._3(Types_003[/* set */7], /* May_weak */2, weak, v1);
                                  return compute_variance_rec(v2, ty);
                                }
                              }
                              }(vari$1)), tl, decl[/* type_variance */5]);
                  }
                  catch (exn){
                    if (exn === Caml_builtin_exceptions.not_found) {
                      var partial_arg = Types_003[/* may_inv */3];
                      return List.iter((function(partial_arg){
                                return function (param) {
                                  return compute_variance_rec(partial_arg, param);
                                }
                                }(partial_arg)), tl);
                    } else {
                      throw exn;
                    }
                  }
                } else {
                  return /* () */0;
                }
                break;
            case 5 : 
                compute_variance_rec(vari$1, match[2]);
                _ty = match[3];
                _vari = vari$1;
                continue ;
                case 8 : 
                var row = row_repr_aux(/* [] */0, match[0]);
                List.iter((function(vari$1){
                    return function (param) {
                      var match = row_field_repr_aux(/* [] */0, param[1]);
                      if (typeof match === "number") {
                        return /* () */0;
                      } else if (match.tag) {
                        var upper = List.fold_left((function (s, f) {
                                return Curry._3(Types_003[/* set */7], f, /* true */1, s);
                              }), Types_003[/* null */0], /* :: */[
                              /* May_pos */0,
                              /* :: */[
                                /* May_neg */1,
                                /* :: */[
                                  /* May_weak */2,
                                  /* [] */0
                                ]
                              ]
                            ]);
                        var v = Curry._2(Types_003[/* inter */5], vari$1, upper);
                        return List.iter((function (param) {
                                      return compute_variance_rec(v, param);
                                    }), match[1]);
                      } else {
                        var match$1 = match[0];
                        if (match$1) {
                          return compute_variance_rec(vari$1, match$1[0]);
                        } else {
                          return /* () */0;
                        }
                      }
                    }
                    }(vari$1)), row[/* row_fields */0]);
                _ty = row[/* row_more */1];
                _vari = vari$1;
                continue ;
                case 4 : 
            case 7 : 
            case 10 : 
                _ty = match[0];
                _vari = vari$1;
                continue ;
                case 11 : 
                var v$1 = Curry._2(Types_003[/* mem */8], /* Pos */4, vari$1) || Curry._2(Types_003[/* mem */8], /* Neg */5, vari$1) ? Types_003[/* full */1] : Types_003[/* may_inv */3];
                return List.iter((function(v$1){
                          return function (param) {
                            return compute_variance_rec(v$1, param);
                          }
                          }(v$1)), match[2]);
            default:
              return /* () */0;
          }
        }
      }
    };
  };
  return compute_variance_rec(vari, ty);
}

function make(p, n, i) {
  return Curry._3(Types_003[/* set */7], /* May_pos */0, p, Curry._3(Types_003[/* set */7], /* May_neg */1, n, Curry._3(Types_003[/* set */7], /* May_weak */2, n, Curry._3(Types_003[/* set */7], /* Inj */3, i, Types_003[/* null */0]))));
}

function compute_variance_type(env, check, param, decl, tyl) {
  var loc = param[1];
  var required = List.map((function (param) {
          var i = param[2];
          var n = param[1];
          var c = param[0];
          if (c || n) {
            return /* tuple */[
                    c,
                    n,
                    i
                  ];
          } else {
            return /* tuple */[
                    /* true */1,
                    /* true */1,
                    i
                  ];
          }
        }), param[0]);
  var params = List.map(repr, decl[/* type_params */0]);
  var tvl = [/* Empty */0];
  List.iter((function (param) {
          return compute_variance(env, tvl, param[0] ? Types_003[/* full */1] : Types_003[/* covariant */2], param[1]);
        }), tyl);
  if (check) {
    var pos = [0];
    List.iter2((function (ty, param) {
            var i = param[2];
            var n = param[1];
            var c = param[0];
            pos[0] = pos[0] + 1 | 0;
            var $$var = get_variance(ty, tvl);
            var match = Curry._1(Types_003[/* get_upper */10], $$var);
            var cn = match[1];
            var co = match[0];
            var ij = Curry._2(Types_003[/* mem */8], /* Inj */3, $$var);
            if (is_Tvar(ty) && (co && !c || cn && !n || !ij && i)) {
              throw [
                    $$Error$8,
                    loc,
                    /* Bad_variance */Block.__(16, [
                        pos[0],
                        /* tuple */[
                          co,
                          cn,
                          ij
                        ],
                        /* tuple */[
                          c,
                          n,
                          i
                        ]
                      ])
                  ];
            } else {
              return 0;
            }
          }), params, required);
    var args = newty2(100000000, /* Ttuple */Block.__(2, [params]));
    var fvl = free_variables$1(/* None */0, args);
    var fvl$1 = List.filter((function (v) {
              return 1 - List.memq(v, params);
            }))(fvl);
    if (fvl$1 !== /* [] */0) {
      var tvl2 = [/* Empty */0];
      List.iter2((function (ty, param) {
              if (is_Tvar(ty)) {
                return /* () */0;
              } else {
                var v = param[0] ? (
                    param[1] ? Types_003[/* full */1] : Types_003[/* covariant */2]
                  ) : Curry._1(Types_003[/* conjugate */9], Types_003[/* covariant */2]);
                return compute_variance(env, tvl2, v, ty);
              }
            }), params, required);
      var visited = [/* Empty */0];
      var check$1 = function (ty) {
        var ty$1 = repr(ty);
        if (mem$3(ty$1, visited[0])) {
          return /* () */0;
        } else {
          var visited$prime = add$3(ty$1, visited[0]);
          visited[0] = visited$prime;
          var v1 = get_variance(ty$1, tvl);
          var snap = snapshot(/* () */0);
          var v2 = fold$3((function (t, vt, v) {
                  if (equal$4(env, /* false */0, /* :: */[
                          ty$1,
                          /* [] */0
                        ], /* :: */[
                          t,
                          /* [] */0
                        ])) {
                    return Curry._2(Types_003[/* union */4], vt, v);
                  } else {
                    return v;
                  }
                }), tvl2[0], Types_003[/* null */0]);
          backtrack(snap);
          var match = Curry._1(Types_003[/* get_upper */10], v1);
          var n1 = match[1];
          var c1 = match[0];
          var match$1 = Curry._1(Types_003[/* get_lower */11], v2);
          var n2 = match$1[1];
          var c2 = match$1[0];
          if (c1 && !c2 || n1 && !n2) {
            if (List.memq(ty$1, fvl$1)) {
              var code = match$1[3] ? (
                  c2 || n2 ? -1 : -3
                ) : -2;
              throw [
                    $$Error$8,
                    loc,
                    /* Bad_variance */Block.__(16, [
                        code,
                        /* tuple */[
                          c1,
                          n1,
                          /* false */0
                        ],
                        /* tuple */[
                          c2,
                          n2,
                          /* false */0
                        ]
                      ])
                  ];
            } else {
              return iter_type_expr(check$1, ty$1);
            }
          } else {
            return 0;
          }
        }
      };
      List.iter((function (param) {
              return check$1(param[1]);
            }), tyl);
    }
    
  }
  return List.map2((function (ty, param) {
                var v = get_variance(ty, tvl);
                var tr = decl[/* type_private */3];
                var concr = +(decl[/* type_kind */2] !== /* Type_abstract */0);
                var match = tr === /* Private */0 || !is_Tvar(ty) ? /* tuple */[
                    param[0],
                    param[1]
                  ] : /* tuple */[
                    /* false */0,
                    /* false */0
                  ];
                var n = match[1];
                var p = match[0];
                var i = concr || param[2] && +(tr === /* Private */0);
                var v$1 = Curry._2(Types_003[/* union */4], v, make(p, n, i));
                var v$2 = concr ? (
                    Curry._2(Types_003[/* mem */8], /* Pos */4, v$1) && Curry._2(Types_003[/* mem */8], /* Neg */5, v$1) ? Types_003[/* full */1] : (
                        is_Tvar(ty) ? v$1 : Curry._2(Types_003[/* union */4], v$1, p ? (
                                  n ? Types_003[/* full */1] : Types_003[/* covariant */2]
                                ) : Curry._1(Types_003[/* conjugate */9], Types_003[/* covariant */2]))
                      )
                  ) : v$1;
                if (decl[/* type_kind */2] === /* Type_abstract */0 && tr === /* Public */1) {
                  return v$2;
                } else {
                  return Curry._3(Types_003[/* set */7], /* May_weak */2, Curry._2(Types_003[/* mem */8], /* May_neg */1, v$2), v$2);
                }
              }), params, required);
}

function add_false(param) {
  return List.map((function (ty) {
                return /* tuple */[
                        /* false */0,
                        ty
                      ];
              }), param);
}

function constrained(_, vars, ty) {
  var match = ty[/* desc */0];
  if (typeof match === "number" || match.tag) {
    return /* true */1;
  } else {
    return List.exists((function (tl) {
                  return List.memq(ty, tl);
                }), vars);
  }
}

function compute_variance_gadt(env, check, rloc, decl, param) {
  var ret_type_opt = param[1];
  var tl = param[0];
  var loc = rloc[1];
  if (ret_type_opt) {
    var match = repr(ret_type_opt[0]);
    var match$1 = match[/* desc */0];
    if (typeof match$1 === "number") {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "typedecl.ml",
              809,
              13
            ]
          ];
    } else if (match$1.tag === 3) {
      var tyl = List.map(repr, match$1[1]);
      var fvl = List.map((function (param) {
              return free_variables$1(/* None */0, param);
            }), tyl);
      List.fold_left2((function (param, ty, param$1) {
              var fv2 = param[1];
              if (fv2) {
                var fv2$1 = fv2[1];
                var fv1 = param[0];
                if ((param$1[0] || param$1[1]) && constrained(env, Pervasives.$at(fv1, fv2$1), ty)) {
                  throw [
                        $$Error$8,
                        loc,
                        /* Varying_anonymous */4
                      ];
                }
                return /* tuple */[
                        /* :: */[
                          fv2[0],
                          fv1
                        ],
                        fv2$1
                      ];
              } else {
                throw [
                      Caml_builtin_exceptions.assert_failure,
                      [
                        "typedecl.ml",
                        798,
                        37
                      ]
                    ];
              }
            }), /* tuple */[
            /* [] */0,
            fvl
          ], tyl, rloc[0]);
      var newrecord = decl.slice();
      return compute_variance_type(env, check, rloc, (newrecord[/* type_params */0] = tyl, newrecord[/* type_private */3] = /* Private */0, newrecord), add_false(tl));
    } else {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "typedecl.ml",
              809,
              13
            ]
          ];
    }
  } else {
    var newrecord$1 = decl.slice();
    return compute_variance_type(env, check, rloc, (newrecord$1[/* type_private */3] = /* Private */0, newrecord$1), add_false(tl));
  }
}

function compute_variance_extension(env, check, decl, ext, rloc) {
  var newrecord = decl.slice();
  return compute_variance_gadt(env, check, rloc, (newrecord[/* type_params */0] = ext[/* ext_type_params */1], newrecord), /* tuple */[
              ext[/* ext_args */2],
              ext[/* ext_ret_type */3]
            ]);
}

function compute_variance_decl(env, check, decl, rloc) {
  if ((decl[/* type_kind */2] === /* Type_abstract */0 || decl[/* type_kind */2] === /* Type_open */1) && decl[/* type_manifest */4] === /* None */0) {
    return List.map((function (param) {
                  return make(1 - param[1], 1 - param[0], +(decl[/* type_kind */2] !== /* Type_abstract */0) || param[2]);
                }), rloc[0]);
  } else {
    var match = decl[/* type_manifest */4];
    var mn = match ? /* :: */[
        /* tuple */[
          /* false */0,
          match[0]
        ],
        /* [] */0
      ] : /* [] */0;
    var match$1 = decl[/* type_kind */2];
    if (typeof match$1 === "number") {
      return compute_variance_type(env, check, rloc, decl, mn);
    } else if (match$1.tag) {
      var tll = match$1[0];
      if (List.for_all((function (c) {
                return +(c[/* cd_res */2] === /* None */0);
              }), tll)) {
        return compute_variance_type(env, check, rloc, decl, Pervasives.$at(mn, add_false(List.flatten(List.map((function (c) {
                                      return c[/* cd_args */1];
                                    }), tll)))));
      } else {
        var mn$1 = List.map((function (param) {
                return /* tuple */[
                        /* :: */[
                          param[1],
                          /* [] */0
                        ],
                        /* None */0
                      ];
              }), mn);
        var tll$1 = Pervasives.$at(mn$1, List.map((function (c) {
                    return /* tuple */[
                            c[/* cd_args */1],
                            c[/* cd_res */2]
                          ];
                  }), tll));
        var match$2 = List.map((function (param) {
                return compute_variance_gadt(env, check, rloc, decl, param);
              }), tll$1);
        if (match$2) {
          var partial_arg = Types_003[/* union */4];
          var varl = List.fold_left((function (param, param$1) {
                  return List.map2(partial_arg, param, param$1);
                }), match$2[0], match$2[1]);
          return List.map((function (v) {
                        if (Curry._2(Types_003[/* mem */8], /* Pos */4, v) && Curry._2(Types_003[/* mem */8], /* Neg */5, v)) {
                          return Types_003[/* full */1];
                        } else {
                          return v;
                        }
                      }), varl);
        } else {
          throw [
                Caml_builtin_exceptions.assert_failure,
                [
                  "typedecl.ml",
                  848,
                  15
                ]
              ];
        }
      }
    } else {
      return compute_variance_type(env, check, rloc, decl, Pervasives.$at(mn, List.map((function (param) {
                            return /* tuple */[
                                    +(param[/* ld_mutable */1] === /* Mutable */1),
                                    param[/* ld_type */2]
                                  ];
                          }), match$1[0])));
    }
  }
}

function is_sharp(id) {
  var s = id[/* name */1];
  if (s.length) {
    return +(Caml_string.get(s, 0) === /* "#" */35);
  } else {
    return /* false */0;
  }
}

function compute_variance_fixpoint(env, decls, required, _variances) {
  while(true) {
    var variances = _variances;
    var new_decls = List.map2((function (param, variance) {
            var newrecord = param[1].slice();
            return /* tuple */[
                    param[0],
                    (newrecord[/* type_variance */5] = variance, newrecord)
                  ];
          }), decls, variances);
    var new_env = List.fold_right((function (param, env) {
            return add_type$1(/* true */1, param[0], param[1], env);
          }), new_decls, env);
    var new_variances = List.map2((function(new_env){
        return function (param) {
          var decl = param[1];
          return (function (param) {
              return compute_variance_decl(new_env, /* false */0, decl, param);
            });
        }
        }(new_env)), new_decls, required);
    var partial_arg = Types_003[/* union */4];
    var new_variances$1 = List.map2((function(partial_arg){
        return function (param, param$1) {
          return List.map2(partial_arg, param, param$1);
        }
        }(partial_arg)), new_variances, variances);
    if (Caml_obj.caml_notequal(new_variances$1, variances)) {
      _variances = new_variances$1;
      continue ;
      
    } else {
      List.iter2((function(new_env){
          return function (param, req) {
            if (is_sharp(param[0])) {
              return 0;
            } else {
              compute_variance_decl(new_env, /* true */1, param[1], req);
              return /* () */0;
            }
          }
          }(new_env)), new_decls, required);
      return /* tuple */[
              new_decls,
              new_env
            ];
    }
  };
}

function init_variance(param) {
  return List.map((function () {
                return Types_003[/* null */0];
              }), param[1][/* type_params */0]);
}

function add_injectivity(param) {
  return List.map((function (param) {
                switch (param) {
                  case 0 : 
                      return /* tuple */[
                              /* true */1,
                              /* false */0,
                              /* false */0
                            ];
                  case 1 : 
                      return /* tuple */[
                              /* false */0,
                              /* true */1,
                              /* false */0
                            ];
                  case 2 : 
                      return /* tuple */[
                              /* false */0,
                              /* false */0,
                              /* false */0
                            ];
                  
                }
              }), param);
}

function compute_variance_decls(env, cldecls) {
  var match = List.fold_right((function (param, param$1) {
          var ci = param[5];
          var variance = List.map((function (prim) {
                  return prim[1];
                }), ci[/* ci_params */1]);
          return /* tuple */[
                  /* :: */[
                    /* tuple */[
                      param[0],
                      param[1]
                    ],
                    param$1[0]
                  ],
                  /* :: */[
                    /* tuple */[
                      add_injectivity(variance),
                      ci[/* ci_loc */10]
                    ],
                    param$1[1]
                  ]
                ];
        }), cldecls, /* tuple */[
        /* [] */0,
        /* [] */0
      ]);
  var decls = match[0];
  var variances = List.map(init_variance, decls);
  var match$1 = compute_variance_fixpoint(env, decls, match[1], variances);
  return List.map2((function (param, param$1) {
                var decl = param[1];
                var variance = decl[/* type_variance */5];
                var newrecord = param$1[2].slice();
                var newrecord$1 = param$1[3].slice();
                var newrecord$2 = param$1[4].slice();
                return /* tuple */[
                        decl,
                        (newrecord[/* type_variance */5] = variance, newrecord),
                        (newrecord$1[/* cty_variance */4] = variance, newrecord$1),
                        (newrecord$2[/* clty_variance */3] = variance, newrecord$2)
                      ];
              }), match$1[0], cldecls);
}

function check_duplicates(sdecl_list) {
  var labels = Hashtbl.create(/* None */0, 7);
  var constrs = Hashtbl.create(/* None */0, 7);
  return List.iter((function (sdecl) {
                var match = sdecl[/* ptype_kind */3];
                if (typeof match === "number") {
                  return /* () */0;
                } else if (match.tag) {
                  return List.iter((function (param) {
                                var cname = param[/* pld_name */0];
                                try {
                                  var name$prime = Hashtbl.find(labels, cname[/* txt */0]);
                                  return prerr_warning(param[/* pld_loc */3], /* Duplicate_definitions */Block.__(14, [
                                                "label",
                                                cname[/* txt */0],
                                                name$prime,
                                                sdecl[/* ptype_name */0][/* txt */0]
                                              ]));
                                }
                                catch (exn){
                                  if (exn === Caml_builtin_exceptions.not_found) {
                                    return Hashtbl.add(labels, cname[/* txt */0], sdecl[/* ptype_name */0][/* txt */0]);
                                  } else {
                                    throw exn;
                                  }
                                }
                              }), match[0]);
                } else {
                  return List.iter((function (pcd) {
                                try {
                                  var name$prime = Hashtbl.find(constrs, pcd[/* pcd_name */0][/* txt */0]);
                                  return prerr_warning(pcd[/* pcd_loc */3], /* Duplicate_definitions */Block.__(14, [
                                                "constructor",
                                                pcd[/* pcd_name */0][/* txt */0],
                                                name$prime,
                                                sdecl[/* ptype_name */0][/* txt */0]
                                              ]));
                                }
                                catch (exn){
                                  if (exn === Caml_builtin_exceptions.not_found) {
                                    return Hashtbl.add(constrs, pcd[/* pcd_name */0][/* txt */0], sdecl[/* ptype_name */0][/* txt */0]);
                                  } else {
                                    throw exn;
                                  }
                                }
                              }), match[0]);
                }
              }), sdecl_list);
}

function name_recursion(sdecl, id, decl) {
  var match = decl[/* type_kind */2];
  if (typeof match === "number") {
    if (match !== 0) {
      return decl;
    } else if (decl[/* type_private */3] !== 0) {
      return decl;
    } else {
      var match$1 = decl[/* type_manifest */4];
      if (match$1) {
        if (is_fixed_type(sdecl)) {
          var ty = repr(match$1[0]);
          var ty$prime = newty2(ty[/* level */1], ty[/* desc */0]);
          if (deep_occur(ty, ty$prime)) {
            var td_000 = /* Pident */Block.__(0, [id]);
            var td_001 = decl[/* type_params */0];
            var td_002 = [/* Mnil */0];
            var td = /* Tconstr */Block.__(3, [
                td_000,
                td_001,
                td_002
              ]);
            link_type(ty, newty2(ty[/* level */1], td));
            var newrecord = decl.slice();
            newrecord[/* type_manifest */4] = /* Some */[ty$prime];
            return newrecord;
          } else {
            return decl;
          }
        } else {
          return decl;
        }
      } else {
        return decl;
      }
    }
  } else {
    return decl;
  }
}

function transl_type_decl(env, rec_flag, sdecl_list) {
  var fixed_types = List.filter(is_fixed_type)(sdecl_list);
  var sdecl_list$1 = Pervasives.$at(List.map((function (sdecl) {
              var ptype_name_000 = /* txt */sdecl[/* ptype_name */0][/* txt */0] + "#row";
              var ptype_name_001 = /* loc */sdecl[/* ptype_name */0][/* loc */1];
              var ptype_name = /* record */[
                ptype_name_000,
                ptype_name_001
              ];
              return /* record */[
                      /* ptype_name */ptype_name,
                      /* ptype_params */sdecl[/* ptype_params */1],
                      /* ptype_cstrs */sdecl[/* ptype_cstrs */2],
                      /* ptype_kind : Ptype_abstract */0,
                      /* ptype_private */sdecl[/* ptype_private */4],
                      /* ptype_manifest : None */0,
                      /* ptype_attributes */sdecl[/* ptype_attributes */6],
                      /* ptype_loc */sdecl[/* ptype_loc */7]
                    ];
            }), fixed_types), sdecl_list);
  var id_list = List.map((function (sdecl) {
          return create(sdecl[/* ptype_name */0][/* txt */0]);
        }), sdecl_list$1);
  init_def(currentstamp[0]);
  begin_def(/* () */0);
  var temp_env = rec_flag !== 0 ? List.fold_left2(enter_type$1, env, sdecl_list$1, id_list) : env;
  var current_slot = [/* None */0];
  var warn_unused = is_active(/* Unused_type_declaration */Block.__(18, [""]));
  var id_slots = function (id) {
    if (rec_flag !== 0) {
      if (warn_unused) {
        var slot = [/* [] */0];
        var td = find_type_full(/* Pident */Block.__(0, [id]), temp_env)[0];
        var name = id[/* name */1];
        set_type_used_callback(name, td, (function (old_callback) {
                var match = current_slot[0];
                if (match) {
                  var slot$1 = match[0];
                  slot$1[0] = /* :: */[
                    /* tuple */[
                      name,
                      td
                    ],
                    slot$1[0]
                  ];
                  return /* () */0;
                } else {
                  List.iter((function (param) {
                          return mark_type_used(env, param[0], param[1]);
                        }), get_ref(slot));
                  return Curry._1(old_callback, /* () */0);
                }
              }));
        return /* tuple */[
                id,
                /* Some */[slot]
              ];
      } else {
        return /* tuple */[
                id,
                /* None */0
              ];
      }
    } else {
      return /* tuple */[
              id,
              /* None */0
            ];
    }
  };
  var transl_declaration = function (name_sdecl, param) {
    current_slot[0] = param[1];
    var env = temp_env;
    var sdecl = name_sdecl;
    var id = param[0];
    reset_type_variables(/* () */0);
    begin_def(/* () */0);
    var tparams = make_params(env, sdecl[/* ptype_params */1]);
    var params = List.map((function (param) {
            return param[0][/* ctyp_type */1];
          }), tparams);
    var cstrs = List.map((function (param) {
            return /* tuple */[
                    transl_simple_type(env, /* false */0, param[0]),
                    transl_simple_type(env, /* false */0, param[1]),
                    param[2]
                  ];
          }), sdecl[/* ptype_cstrs */2]);
    var match = sdecl[/* ptype_kind */3];
    var match$1;
    if (typeof match === "number") {
      match$1 = match ? /* tuple */[
          /* Ttype_open */1,
          /* Type_open */1
        ] : /* tuple */[
          /* Ttype_abstract */0,
          /* Type_abstract */0
        ];
    } else if (match.tag) {
      var lbls = match[0];
      if (!lbls) {
        ill_formed_ast(sdecl[/* ptype_loc */7], "Records cannot be empty.");
      }
      var all_labels = [/* Empty */0];
      List.iter((function (param) {
              var name = param[/* pld_name */0][/* txt */0];
              if (mem$6(name, all_labels[0])) {
                throw [
                      $$Error$8,
                      sdecl[/* ptype_loc */7],
                      /* Duplicate_label */Block.__(1, [name])
                    ];
              }
              all_labels[0] = add$12(name, all_labels[0]);
              return /* () */0;
            }), lbls);
      var lbls$1 = List.map((function (param) {
              var name = param[/* pld_name */0];
              var arg = force_poly(param[/* pld_type */2]);
              var cty = transl_simple_type(env, /* true */1, arg);
              return /* record */[
                      /* ld_id */create(name[/* txt */0]),
                      /* ld_name */name,
                      /* ld_mutable */param[/* pld_mutable */1],
                      /* ld_type */cty,
                      /* ld_loc */param[/* pld_loc */3],
                      /* ld_attributes */param[/* pld_attributes */4]
                    ];
            }), lbls);
      var lbls$prime = List.map((function (ld) {
              var ty = ld[/* ld_type */3][/* ctyp_type */1];
              var match = ty[/* desc */0];
              var ty$1;
              ty$1 = typeof match === "number" || !(match.tag === 10 && !match[1]) ? ty : match[0];
              return /* record */[
                      /* ld_id */ld[/* ld_id */0],
                      /* ld_mutable */ld[/* ld_mutable */2],
                      /* ld_type */ty$1,
                      /* ld_loc */ld[/* ld_loc */4],
                      /* ld_attributes */ld[/* ld_attributes */5]
                    ];
            }), lbls$1);
      var rep = List.for_all((function (l) {
              var env$1 = env;
              var ty = l[/* ld_type */2];
              var match = repr(expand_head_opt(env$1, ty));
              var match$1 = match[/* desc */0];
              if (typeof match$1 === "number" || match$1.tag !== 3) {
                return /* false */0;
              } else {
                return same(match$1[0], path_float);
              }
            }), lbls$prime) ? /* Record_float */1 : /* Record_regular */0;
      match$1 = /* tuple */[
        /* Ttype_record */Block.__(1, [lbls$1]),
        /* Type_record */Block.__(0, [
            lbls$prime,
            rep
          ])
      ];
    } else {
      var scstrs = match[0];
      if (!scstrs) {
        ill_formed_ast(sdecl[/* ptype_loc */7], "Variant types cannot be empty.");
      }
      var all_constrs = [/* Empty */0];
      List.iter((function (param) {
              var name = param[/* pcd_name */0][/* txt */0];
              if (mem$6(name, all_constrs[0])) {
                throw [
                      $$Error$8,
                      sdecl[/* ptype_loc */7],
                      /* Duplicate_constructor */Block.__(0, [name])
                    ];
              }
              all_constrs[0] = add$12(name, all_constrs[0]);
              return /* () */0;
            }), scstrs);
      if (List.length(List.filter((function (cd) {
                      return +(cd[/* pcd_args */1] !== /* [] */0);
                    }))(scstrs)) > 246) {
        throw [
              $$Error$8,
              sdecl[/* ptype_loc */7],
              /* Too_many_constructors */1
            ];
      }
      var make_cstr = function (scstr) {
        var name = create(scstr[/* pcd_name */0][/* txt */0]);
        var match = make_constructor(env, /* Pident */Block.__(0, [id]), params, scstr[/* pcd_args */1], scstr[/* pcd_res */2]);
        var tcstr_001 = /* cd_name */scstr[/* pcd_name */0];
        var tcstr_002 = /* cd_args */match[0];
        var tcstr_003 = /* cd_res */match[1];
        var tcstr_004 = /* cd_loc */scstr[/* pcd_loc */3];
        var tcstr_005 = /* cd_attributes */scstr[/* pcd_attributes */4];
        var tcstr = /* record */[
          /* cd_id */name,
          tcstr_001,
          tcstr_002,
          tcstr_003,
          tcstr_004,
          tcstr_005
        ];
        var cstr_001 = /* cd_args */match[2];
        var cstr_002 = /* cd_res */match[3];
        var cstr_003 = /* cd_loc */scstr[/* pcd_loc */3];
        var cstr_004 = /* cd_attributes */scstr[/* pcd_attributes */4];
        var cstr = /* record */[
          /* cd_id */name,
          cstr_001,
          cstr_002,
          cstr_003,
          cstr_004
        ];
        return /* tuple */[
                tcstr,
                cstr
              ];
      };
      var match$2 = List.split(List.map(make_cstr, scstrs));
      match$1 = /* tuple */[
        /* Ttype_variant */Block.__(0, [match$2[0]]),
        /* Type_variant */Block.__(1, [match$2[1]])
      ];
    }
    var match$3 = sdecl[/* ptype_manifest */5];
    var match$4;
    if (match$3) {
      var no_row = 1 - is_fixed_type(sdecl);
      var cty = transl_simple_type(env, no_row, match$3[0]);
      match$4 = /* tuple */[
        /* Some */[cty],
        /* Some */[cty[/* ctyp_type */1]]
      ];
    } else {
      match$4 = /* tuple */[
        /* None */0,
        /* None */0
      ];
    }
    var man = match$4[1];
    var decl_001 = /* type_arity */List.length(params);
    var decl_002 = /* type_kind */match$1[1];
    var decl_003 = /* type_private */sdecl[/* ptype_private */4];
    var decl_005 = /* type_variance */List.map((function () {
            return Types_003[/* full */1];
          }), params);
    var decl_007 = /* type_loc */sdecl[/* ptype_loc */7];
    var decl_008 = /* type_attributes */sdecl[/* ptype_attributes */6];
    var decl = /* record */[
      /* type_params */params,
      decl_001,
      decl_002,
      decl_003,
      /* type_manifest */man,
      decl_005,
      /* type_newtype_level : None */0,
      decl_007,
      decl_008
    ];
    List.iter((function (param) {
            var ty = param[0][/* ctyp_type */1];
            var ty$prime = param[1][/* ctyp_type */1];
            try {
              return unify$2(env, ty, ty$prime);
            }
            catch (raw_exn){
              var exn = Js_exn.internalToOCamlException(raw_exn);
              if (exn[0] === Unify) {
                throw [
                      $$Error$8,
                      param[2],
                      /* Inconsistent_constraint */Block.__(6, [
                          env,
                          exn[1]
                        ])
                    ];
              } else {
                throw exn;
              }
            }
          }), cstrs);
    end_def(/* () */0);
    if (is_fixed_type(sdecl)) {
      var match$5;
      try {
        match$5 = lookup_type$1(/* Lident */Block.__(0, [id[/* name */1] + "#row"]), env);
      }
      catch (exn){
        if (exn === Caml_builtin_exceptions.not_found) {
          throw [
                Caml_builtin_exceptions.assert_failure,
                [
                  "typedecl.ml",
                  301,
                  26
                ]
              ];
        } else {
          throw exn;
        }
      }
      set_fixed_row(env, sdecl[/* ptype_loc */7], match$5[0], decl);
    }
    if (man) {
      if (cyclic_abbrev(env, id, man[0])) {
        throw [
              $$Error$8,
              sdecl[/* ptype_loc */7],
              /* Recursive_abbrev */Block.__(2, [sdecl[/* ptype_name */0][/* txt */0]])
            ];
      }
      
    }
    return /* record */[
            /* typ_id */id,
            /* typ_name */sdecl[/* ptype_name */0],
            /* typ_params */tparams,
            /* typ_type */decl,
            /* typ_cstrs */cstrs,
            /* typ_kind */match$1[0],
            /* typ_private */sdecl[/* ptype_private */4],
            /* typ_manifest */match$4[0],
            /* typ_loc */sdecl[/* ptype_loc */7],
            /* typ_attributes */sdecl[/* ptype_attributes */6]
          ];
  };
  var tdecls = List.map2(transl_declaration, sdecl_list$1, List.map(id_slots, id_list));
  var decls = List.map((function (tdecl) {
          return /* tuple */[
                  tdecl[/* typ_id */0],
                  tdecl[/* typ_type */3]
                ];
        }), tdecls);
  current_slot[0] = /* None */0;
  check_duplicates(sdecl_list$1);
  var newenv = List.fold_right((function (param, env) {
          return add_type$1(/* true */1, param[0], param[1], env);
        }), decls, env);
  if (rec_flag !== 0) {
    List.iter2((function (id, sdecl) {
            var temp_env$1 = temp_env;
            var env = newenv;
            var id$1 = id;
            var loc = sdecl[/* ptype_loc */7];
            var path = /* Pident */Block.__(0, [id$1]);
            var decl = find_type_full(path, temp_env$1)[0];
            var match = decl[/* type_manifest */4];
            if (match) {
              var params = List.map((function () {
                      return newvar(/* None */0, /* () */0);
                    }), decl[/* type_params */0]);
              try {
                return unify$2(env, newconstr(path, params), match[0]);
              }
              catch (raw_exn){
                var exn = Js_exn.internalToOCamlException(raw_exn);
                if (exn[0] === Unify) {
                  throw [
                        $$Error$8,
                        loc,
                        /* Type_clash */Block.__(7, [
                            env,
                            exn[1]
                          ])
                      ];
                } else {
                  throw exn;
                }
              }
            } else {
              return /* () */0;
            }
          }), id_list, sdecl_list$1);
  }
  end_def(/* () */0);
  List.iter((function (param) {
          return generalize_decl(param[1]);
        }), decls);
  var id_loc_list = List.map2((function (id, sdecl) {
          return /* tuple */[
                  id,
                  sdecl[/* ptype_loc */7]
                ];
        }), id_list, sdecl_list$1);
  List.iter((function (param) {
          var id = param[0];
          var env = newenv;
          var loc = List.assoc(id, id_loc_list);
          var path = /* Pident */Block.__(0, [id]);
          var decl = param[1];
          if (decl[/* type_manifest */4]) {
            var args = List.map((function () {
                    return newvar(/* None */0, /* () */0);
                  }), decl[/* type_params */0]);
            return check_well_founded(env, loc, path, (function (param) {
                          return same(path, param);
                        }), newconstr(path, args));
          } else {
            return /* () */0;
          }
        }), decls);
  var to_check = function (param) {
    switch (param.tag | 0) {
      case 0 : 
          return List.mem_assoc(param[0], id_loc_list);
      case 1 : 
      case 2 : 
          return /* false */0;
      
    }
  };
  List.iter((function (param) {
          var id = param[0];
          return check_well_founded_decl(newenv, List.assoc(id, id_loc_list), /* Pident */Block.__(0, [id]), param[1], to_check);
        }), decls);
  List.iter((function (param) {
          var env = newenv;
          var id_loc_list$1 = id_loc_list;
          var to_check$1 = to_check;
          var tdecl = param;
          var decl = tdecl[/* typ_type */3];
          var id = tdecl[/* typ_id */0];
          return check_recursion(env, List.assoc(id, id_loc_list$1), /* Pident */Block.__(0, [id]), decl, to_check$1);
        }), tdecls);
  List.iter2((function (sdecl, tdecl) {
          var decl = tdecl[/* typ_type */3];
          var match = closed_type_decl(decl);
          if (match) {
            throw [
                  $$Error$8,
                  sdecl[/* ptype_loc */7],
                  /* Unbound_type_var */Block.__(9, [
                      match[0],
                      decl
                    ])
                ];
          } else {
            return /* () */0;
          }
        }), sdecl_list$1, tdecls);
  List.iter2((function (param, param$1) {
          var env = newenv;
          var sdecl = param;
          var param$2 = param$1;
          var decl = param$2[1];
          var visited = [/* Empty */0];
          var match = decl[/* type_kind */2];
          if (typeof match === "number") {
            +(match === 0);
          } else if (match.tag) {
            var find_pl = function (param) {
              if (typeof param === "number") {
                throw [
                      Caml_builtin_exceptions.assert_failure,
                      [
                        "typedecl.ml",
                        382,
                        58
                      ]
                    ];
              } else if (param.tag) {
                throw [
                      Caml_builtin_exceptions.assert_failure,
                      [
                        "typedecl.ml",
                        382,
                        58
                      ]
                    ];
              } else {
                return param[0];
              }
            };
            var pl = find_pl(sdecl[/* ptype_kind */3]);
            var foldf = function (acc, x) {
              return add$13(x[/* pcd_name */0][/* txt */0], x, acc);
            };
            var pl_index = List.fold_left(foldf, /* Empty */0, pl);
            List.iter((function (param) {
                    var ret_type = param[/* cd_res */2];
                    var match;
                    try {
                      match = find$6(param[/* cd_id */0][/* name */1], pl_index);
                    }
                    catch (exn){
                      if (exn === Caml_builtin_exceptions.not_found) {
                        throw [
                              Caml_builtin_exceptions.assert_failure,
                              [
                                "typedecl.ml",
                                395,
                                30
                              ]
                            ];
                      } else {
                        throw exn;
                      }
                    }
                    var sret_type = match[/* pcd_res */2];
                    List.iter2((function (sty, ty) {
                            return check_constraints_rec(env, sty[/* ptyp_loc */1], visited, ty);
                          }), match[/* pcd_args */1], param[/* cd_args */1]);
                    if (sret_type && ret_type) {
                      return check_constraints_rec(env, sret_type[0][/* ptyp_loc */1], visited, ret_type[0]);
                    } else {
                      return /* () */0;
                    }
                  }), match[0]);
          } else {
            var find_pl$1 = function (param) {
              if (typeof param === "number") {
                throw [
                      Caml_builtin_exceptions.assert_failure,
                      [
                        "typedecl.ml",
                        409,
                        59
                      ]
                    ];
              } else if (param.tag === 1) {
                return param[0];
              } else {
                throw [
                      Caml_builtin_exceptions.assert_failure,
                      [
                        "typedecl.ml",
                        409,
                        59
                      ]
                    ];
              }
            };
            var pl$1 = find_pl$1(sdecl[/* ptype_kind */3]);
            var get_loc = function (name, _param) {
              while(true) {
                var param = _param;
                if (param) {
                  var pld = param[0];
                  if (name === pld[/* pld_name */0][/* txt */0]) {
                    return pld[/* pld_type */2][/* ptyp_loc */1];
                  } else {
                    _param = param[1];
                    continue ;
                    
                  }
                } else {
                  throw [
                        Caml_builtin_exceptions.assert_failure,
                        [
                          "typedecl.ml",
                          413,
                          16
                        ]
                      ];
                }
              };
            };
            List.iter((function (param) {
                    return check_constraints_rec(env, get_loc(param[/* ld_id */0][/* name */1], pl$1), visited, param[/* ld_type */2]);
                  }), match[0]);
          }
          var match$1 = decl[/* type_manifest */4];
          if (match$1) {
            var match$2 = sdecl[/* ptype_manifest */5];
            var sty;
            if (match$2) {
              sty = match$2[0];
            } else {
              throw [
                    Caml_builtin_exceptions.assert_failure,
                    [
                      "typedecl.ml",
                      428,
                      63
                    ]
                  ];
            }
            return check_constraints_rec(env, sty[/* ptyp_loc */1], visited, match$1[0]);
          } else {
            return /* () */0;
          }
        }), sdecl_list$1, decls);
  var decls$1 = List.map2((function (sdecl, param) {
          var id = param[0];
          return /* tuple */[
                  id,
                  name_recursion(sdecl, id, param[1])
                ];
        }), sdecl_list$1, decls);
  var required = List.map((function (sdecl) {
          return /* tuple */[
                  add_injectivity(List.map((function (prim) {
                              return prim[1];
                            }), sdecl[/* ptype_params */1])),
                  sdecl[/* ptype_loc */7]
                ];
        }), sdecl_list$1);
  var match = compute_variance_fixpoint(env, decls$1, required, List.map(init_variance, decls$1));
  var final_env = match[1];
  var final_decls = match[0];
  List.iter2((function (param, param$1) {
          var env = final_env;
          var sdecl = param;
          var param$2 = param$1;
          return check_coherence(env, sdecl[/* ptype_loc */7], param$2[0], param$2[1]);
        }), sdecl_list$1, final_decls);
  var final_decls$1 = List.map2((function (tdecl, param) {
          var newrecord = tdecl.slice();
          newrecord[/* typ_type */3] = param[1];
          return newrecord;
        }), tdecls, final_decls);
  return /* tuple */[
          final_decls$1,
          final_env
        ];
}

function transl_extension_constructor(env, _, type_path, type_params, typext_params, priv, sext) {
  var id = create(sext[/* pext_name */0][/* txt */0]);
  var match = sext[/* pext_kind */1];
  var match$1;
  if (match.tag) {
    var lid = match[0];
    var cdescr = find_constructor(env, sext[/* pext_loc */2], lid[/* txt */0]);
    var usage = cdescr[/* cstr_private */10] === /* Private */0 || priv === /* Public */1 ? /* Positive */0 : /* Privatize */2;
    mark_constructor(usage, env, last$1(lid[/* txt */0]), cdescr);
    var match$2 = instance_constructor(/* None */0, cdescr);
    var args = match$2[0];
    var match$3;
    if (cdescr[/* cstr_generalized */9]) {
      var params = instance_list(env, type_params);
      var res = newconstr(type_path, params);
      var ret_type = /* Some */[newconstr(type_path, params)];
      match$3 = /* tuple */[
        res,
        ret_type
      ];
    } else {
      match$3 = /* tuple */[
        newconstr(type_path, typext_params),
        /* None */0
      ];
    }
    try {
      unify$2(env, match$2[1], match$3[0]);
    }
    catch (raw_exn){
      var exn = Js_exn.internalToOCamlException(raw_exn);
      if (exn[0] === Unify) {
        throw [
              $$Error$8,
              lid[/* loc */1],
              /* Rebind_wrong_type */Block.__(13, [
                  lid[/* txt */0],
                  env,
                  exn[1]
                ])
            ];
      } else {
        throw exn;
      }
    }
    if (!cdescr[/* cstr_generalized */9]) {
      var vars = free_variables$1(/* None */0, newty2(100000000, /* Ttuple */Block.__(2, [args])));
      List.iter((function (ty) {
              var match = ty[/* desc */0];
              if (typeof match === "number") {
                return /* () */0;
              } else if (match.tag) {
                return /* () */0;
              } else {
                var match$1 = match[0];
                if (match$1 && match$1[0] === "_" && List.memq(ty, vars)) {
                  ty[/* desc */0] = /* Tvar */Block.__(0, [/* None */0]);
                  return /* () */0;
                } else {
                  return /* () */0;
                }
              }
            }), typext_params);
    }
    var match$4 = cdescr[/* cstr_res */1][/* desc */0];
    var match$5;
    if (typeof match$4 === "number") {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "typedecl.ml",
              1162,
              17
            ]
          ];
    } else if (match$4.tag === 3) {
      var p = match$4[0];
      var decl = find_type_full(p, env)[0];
      match$5 = /* tuple */[
        p,
        decl[/* type_params */0]
      ];
    } else {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "typedecl.ml",
              1162,
              17
            ]
          ];
    }
    var cstr_type_params = match$5[1];
    var cstr_type_path = match$5[0];
    var cstr_types_000 = newty2(100000000, /* Tconstr */Block.__(3, [
            cstr_type_path,
            cstr_type_params,
            [/* Mnil */0]
          ]));
    var cstr_types = /* :: */[
      cstr_types_000,
      cstr_type_params
    ];
    var ext_types_000 = newty2(100000000, /* Tconstr */Block.__(3, [
            type_path,
            type_params,
            [/* Mnil */0]
          ]));
    var ext_types = /* :: */[
      ext_types_000,
      type_params
    ];
    if (!equal$4(env, /* true */1, cstr_types, ext_types)) {
      throw [
            $$Error$8,
            lid[/* loc */1],
            /* Rebind_mismatch */Block.__(14, [
                lid[/* txt */0],
                cstr_type_path,
                type_path
              ])
          ];
    }
    var match$6 = cdescr[/* cstr_private */10];
    if (!match$6) {
      if (priv !== 0) {
        throw [
              $$Error$8,
              lid[/* loc */1],
              /* Rebind_private */Block.__(15, [lid[/* txt */0]])
            ];
      }
      
    }
    var match$7 = cdescr[/* cstr_tag */5];
    var path;
    switch (match$7.tag | 0) {
      case 0 : 
      case 1 : 
          throw [
                Caml_builtin_exceptions.assert_failure,
                [
                  "typedecl.ml",
                  1187,
                  17
                ]
              ];
      case 2 : 
          path = match$7[0];
          break;
      
    }
    match$1 = /* tuple */[
      args,
      match$3[1],
      /* Text_rebind */Block.__(1, [
          path,
          lid
        ])
    ];
  } else {
    var match$8 = make_constructor(env, type_path, typext_params, match[0], match[1]);
    match$1 = /* tuple */[
      match$8[2],
      match$8[3],
      /* Text_decl */Block.__(0, [
          match$8[0],
          match$8[1]
        ])
    ];
  }
  var ext_002 = /* ext_args */match$1[0];
  var ext_003 = /* ext_ret_type */match$1[1];
  var ext_005 = /* ext_loc */sext[/* pext_loc */2];
  var ext_006 = /* ext_attributes */sext[/* pext_attributes */3];
  var ext = /* record */[
    /* ext_type_path */type_path,
    /* ext_type_params */typext_params,
    ext_002,
    ext_003,
    /* ext_private */priv,
    ext_005,
    ext_006
  ];
  return /* record */[
          /* ext_id */id,
          /* ext_name */sext[/* pext_name */0],
          /* ext_type */ext,
          /* ext_kind */match$1[2],
          /* ext_loc */sext[/* pext_loc */2],
          /* ext_attributes */sext[/* pext_attributes */3]
        ];
}

function transl_type_extension(check_open, env, loc, styext) {
  reset_type_variables(/* () */0);
  begin_def(/* () */0);
  var match = find_type(env, loc, styext[/* ptyext_path */0][/* txt */0]);
  var type_decl = match[1];
  var type_path = match[0];
  var match$1 = type_decl[/* type_kind */2];
  if (typeof match$1 === "number") {
    if (!match$1) {
      if (check_open) {
        try {
          var match$2 = List.find((function (param) {
                  if (param[/* pext_kind */1].tag) {
                    return /* false */0;
                  } else {
                    return /* true */1;
                  }
                }), styext[/* ptyext_constructors */2]);
          throw [
                $$Error$8,
                match$2[/* pext_loc */2],
                /* Not_open_type */Block.__(10, [type_path])
              ];
        }
        catch (exn){
          if (exn !== Caml_builtin_exceptions.not_found) {
            throw exn;
          }
          
        }
      }
      
    }
    
  } else {
    throw [
          $$Error$8,
          loc,
          /* Not_extensible_type */Block.__(11, [type_path])
        ];
  }
  var type_variance = List.map((function (v) {
          var match = Curry._1(Types_003[/* get_upper */10], v);
          return /* tuple */[
                  1 - match[1],
                  1 - match[0],
                  /* false */0
                ];
        }), type_decl[/* type_variance */5]);
  var err = type_decl[/* type_arity */1] !== List.length(styext[/* ptyext_params */1]) ? /* :: */[
      /* Arity */0,
      /* [] */0
    ] : (
      List.for_all2((function (param, param$1) {
              if (!param$1[0] || param[0]) {
                if (param$1[1]) {
                  return param[1];
                } else {
                  return /* true */1;
                }
              } else {
                return /* false */0;
              }
            }), type_variance, add_injectivity(List.map((function (prim) {
                      return prim[1];
                    }), styext[/* ptyext_params */1]))) ? /* [] */0 : /* :: */[
          /* Variance */5,
          /* [] */0
        ]
    );
  if (err !== /* [] */0) {
    throw [
          $$Error$8,
          loc,
          /* Extension_mismatch */Block.__(12, [
              type_path,
              err
            ])
        ];
  }
  var ttype_params = make_params(env, styext[/* ptyext_params */1]);
  var type_params = List.map((function (param) {
          return param[0][/* ctyp_type */1];
        }), ttype_params);
  List.iter2((function (param, param$1) {
          return unify_var(env, param, param$1);
        }), instance_list(env, type_decl[/* type_params */0]), type_params);
  var partial_arg = styext[/* ptyext_private */3];
  var partial_arg$1 = type_decl[/* type_params */0];
  var constructors = List.map((function (param) {
          return transl_extension_constructor(env, check_open, type_path, partial_arg$1, type_params, partial_arg, param);
        }), styext[/* ptyext_constructors */2]);
  end_def(/* () */0);
  List.iter(generalize, type_params);
  List.iter((function (ext) {
          List.iter(generalize, ext[/* ext_type */2][/* ext_args */2]);
          return may(generalize, ext[/* ext_type */2][/* ext_ret_type */3]);
        }), constructors);
  List.iter((function (ext) {
          var match = closed_extension_constructor(ext[/* ext_type */2]);
          if (match) {
            throw [
                  $$Error$8,
                  ext[/* ext_loc */4],
                  /* Unbound_type_var_ext */Block.__(19, [
                      match[0],
                      ext[/* ext_type */2]
                    ])
                ];
          } else {
            return /* () */0;
          }
        }), constructors);
  List.iter((function (ext) {
          compute_variance_extension(env, /* true */1, type_decl, ext[/* ext_type */2], /* tuple */[
                type_variance,
                loc
              ]);
          return /* () */0;
        }), constructors);
  var newenv = List.fold_left((function (env, ext) {
          return add_extension(/* true */1, ext[/* ext_id */0], ext[/* ext_type */2], env);
        }), env, constructors);
  var tyext_001 = /* tyext_txt */styext[/* ptyext_path */0];
  var tyext_004 = /* tyext_private */styext[/* ptyext_private */3];
  var tyext_005 = /* tyext_attributes */styext[/* ptyext_attributes */4];
  var tyext = /* record */[
    /* tyext_path */type_path,
    tyext_001,
    /* tyext_params */ttype_params,
    /* tyext_constructors */constructors,
    tyext_004,
    tyext_005
  ];
  return /* tuple */[
          tyext,
          newenv
        ];
}

function transl_exception(env, sext) {
  reset_type_variables(/* () */0);
  begin_def(/* () */0);
  var ext = transl_extension_constructor(env, /* false */0, path_exn, /* [] */0, /* [] */0, /* Public */1, sext);
  end_def(/* () */0);
  List.iter(generalize, ext[/* ext_type */2][/* ext_args */2]);
  may(generalize, ext[/* ext_type */2][/* ext_ret_type */3]);
  var match = closed_extension_constructor(ext[/* ext_type */2]);
  if (match) {
    throw [
          $$Error$8,
          ext[/* ext_loc */4],
          /* Unbound_type_var_ext */Block.__(19, [
              match[0],
              ext[/* ext_type */2]
            ])
        ];
  }
  var newenv = add_extension(/* true */1, ext[/* ext_id */0], ext[/* ext_type */2], env);
  return /* tuple */[
          ext,
          newenv
        ];
}

function transl_value_decl(env, loc, valdecl) {
  var cty = transl_type_scheme(env, valdecl[/* pval_type */1]);
  var ty = cty[/* ctyp_type */1];
  var decl = valdecl[/* pval_prim */2];
  var v;
  if (decl) {
    var arity$1 = arity(ty);
    var prim = parse_declaration(arity$1, decl);
    var prim_native_name = prim[/* prim_native_name */3];
    if (arity$1 === 0 && !(prim_native_name.length > 3 && prim_native_name[0] === "B" && prim_native_name[1] === "S" && prim_native_name[2] === ":") && Caml_string.get(prim[/* prim_name */0], 0) !== /* "%" */37) {
      throw [
            $$Error$8,
            valdecl[/* pval_type */1][/* ptyp_loc */1],
            /* Null_arity_external */2
          ];
    }
    if (native_code[0] && prim[/* prim_arity */1] > 5 && prim_native_name === "") {
      throw [
            $$Error$8,
            valdecl[/* pval_type */1][/* ptyp_loc */1],
            /* Missing_native_external */3
          ];
    }
    v = /* record */[
      /* val_type */ty,
      /* val_kind : Val_prim */Block.__(0, [prim]),
      /* val_loc */loc,
      /* val_attributes */valdecl[/* pval_attributes */3]
    ];
  } else {
    v = /* record */[
      /* val_type */ty,
      /* val_kind : Val_reg */0,
      /* val_loc */loc,
      /* val_attributes */valdecl[/* pval_attributes */3]
    ];
  }
  var partial_arg = /* Some */[(function (s) {
        return /* Unused_value_declaration */Block.__(16, [s]);
      })];
  var partial_arg$1 = function (param, param$1, param$2, param$3, param$4, param$5) {
    return store_value(partial_arg, param, param$1, param$2, param$3, param$4, param$5);
  };
  var match = (function (param, param$1, param$2) {
        return enter(partial_arg$1, param, param$1, param$2);
      })(valdecl[/* pval_name */0][/* txt */0], v, env);
  var desc_000 = /* val_id */match[0];
  var desc_001 = /* val_name */valdecl[/* pval_name */0];
  var desc_004 = /* val_prim */valdecl[/* pval_prim */2];
  var desc_005 = /* val_loc */valdecl[/* pval_loc */4];
  var desc_006 = /* val_attributes */valdecl[/* pval_attributes */3];
  var desc = /* record */[
    desc_000,
    desc_001,
    /* val_desc */cty,
    /* val_val */v,
    desc_004,
    desc_005,
    desc_006
  ];
  return /* tuple */[
          desc,
          match[1]
        ];
}

function transl_with_constraint(env, id, row_path, orig_decl, sdecl) {
  mark_type_used(env, id[/* name */1], orig_decl);
  reset_type_variables(/* () */0);
  begin_def(/* () */0);
  var tparams = make_params(env, sdecl[/* ptype_params */1]);
  var params = List.map((function (param) {
          return param[0][/* ctyp_type */1];
        }), tparams);
  var orig_decl$1 = instance_declaration(orig_decl);
  var arity_ok = +(List.length(params) === orig_decl$1[/* type_arity */1]);
  if (arity_ok) {
    List.iter2((function (param, param$1) {
            return unify_var(env, param, param$1);
          }), params, orig_decl$1[/* type_params */0]);
  }
  var constraints = List.map((function (param) {
          var loc = param[2];
          try {
            var cty = transl_simple_type(env, /* false */0, param[0]);
            var cty$prime = transl_simple_type(env, /* false */0, param[1]);
            var ty = cty[/* ctyp_type */1];
            var ty$prime = cty$prime[/* ctyp_type */1];
            unify$2(env, ty, ty$prime);
            return /* tuple */[
                    cty,
                    cty$prime,
                    loc
                  ];
          }
          catch (raw_exn){
            var exn = Js_exn.internalToOCamlException(raw_exn);
            if (exn[0] === Unify) {
              throw [
                    $$Error$8,
                    loc,
                    /* Inconsistent_constraint */Block.__(6, [
                        env,
                        exn[1]
                      ])
                  ];
            } else {
              throw exn;
            }
          }
        }), sdecl[/* ptype_cstrs */2]);
  var no_row = 1 - is_fixed_type(sdecl);
  var match = sdecl[/* ptype_manifest */5];
  var match$1;
  if (match) {
    var cty = transl_simple_type(env, no_row, match[0]);
    match$1 = /* tuple */[
      /* Some */[cty],
      /* Some */[cty[/* ctyp_type */1]]
    ];
  } else {
    match$1 = /* tuple */[
      /* None */0,
      /* None */0
    ];
  }
  var man = match$1[1];
  var priv = sdecl[/* ptype_private */4] ? (
      arity_ok && orig_decl$1[/* type_kind */2] !== /* Type_abstract */0 ? orig_decl$1[/* type_private */3] : sdecl[/* ptype_private */4]
    ) : /* Private */0;
  if (arity_ok && orig_decl$1[/* type_kind */2] !== /* Type_abstract */0 && sdecl[/* ptype_private */4] === /* Private */0) {
    prerr_warning(sdecl[/* ptype_loc */7], /* Deprecated */Block.__(0, ["spurious use of private"]));
  }
  var decl_001 = /* type_arity */List.length(params);
  var decl_002 = /* type_kind */arity_ok && man !== /* None */0 ? orig_decl$1[/* type_kind */2] : /* Type_abstract */0;
  var decl_007 = /* type_loc */sdecl[/* ptype_loc */7];
  var decl_008 = /* type_attributes */sdecl[/* ptype_attributes */6];
  var decl = /* record */[
    /* type_params */params,
    decl_001,
    decl_002,
    /* type_private */priv,
    /* type_manifest */man,
    /* type_variance : [] */0,
    /* type_newtype_level : None */0,
    decl_007,
    decl_008
  ];
  if (row_path) {
    set_fixed_row(env, sdecl[/* ptype_loc */7], row_path[0], decl);
  }
  var match$2 = closed_type_decl(decl);
  if (match$2) {
    throw [
          $$Error$8,
          sdecl[/* ptype_loc */7],
          /* Unbound_type_var */Block.__(9, [
              match$2[0],
              decl
            ])
        ];
  }
  var decl$1 = name_recursion(sdecl, id, decl);
  var newrecord = decl$1.slice();
  newrecord[/* type_variance */5] = compute_variance_decl(env, /* false */0, decl$1, /* tuple */[
        add_injectivity(List.map((function (prim) {
                    return prim[1];
                  }), sdecl[/* ptype_params */1])),
        sdecl[/* ptype_loc */7]
      ]);
  end_def(/* () */0);
  generalize_decl(newrecord);
  return /* record */[
          /* typ_id */id,
          /* typ_name */sdecl[/* ptype_name */0],
          /* typ_params */tparams,
          /* typ_type */newrecord,
          /* typ_cstrs */constraints,
          /* typ_kind : Ttype_abstract */0,
          /* typ_private */sdecl[/* ptype_private */4],
          /* typ_manifest */match$1[0],
          /* typ_loc */sdecl[/* ptype_loc */7],
          /* typ_attributes */sdecl[/* ptype_attributes */6]
        ];
}

function abstract_type_decl(arity) {
  var make_params = function (n) {
    if (n <= 0) {
      return /* [] */0;
    } else {
      return /* :: */[
              newvar(/* None */0, /* () */0),
              make_params(n - 1 | 0)
            ];
    }
  };
  begin_def(/* () */0);
  var decl_000 = /* type_params */make_params(arity);
  var decl_005 = /* type_variance */replicate_list(Types_003[/* full */1], arity);
  var decl = /* record */[
    decl_000,
    /* type_arity */arity,
    /* type_kind : Type_abstract */0,
    /* type_private : Public */1,
    /* type_manifest : None */0,
    decl_005,
    /* type_newtype_level : None */0,
    /* type_loc */none,
    /* type_attributes : [] */0
  ];
  end_def(/* () */0);
  generalize_decl(decl);
  return decl;
}

function approx_type_decl(_, sdecl_list) {
  return List.map((function (sdecl) {
                return /* tuple */[
                        create(sdecl[/* ptype_name */0][/* txt */0]),
                        abstract_type_decl(List.length(sdecl[/* ptype_params */1]))
                      ];
              }), sdecl_list);
}

function explain_unbound(ppf, tv, tl, typ, kwd, lab) {
  try {
    var ti = List.find((function (ti) {
            return deep_occur(tv, Curry._1(typ, ti));
          }), tl);
    var ty0 = newty2(100000000, /* Tobject */Block.__(4, [
            tv,
            [/* None */0]
          ]));
    reset_and_mark_loops_list(/* :: */[
          Curry._1(typ, ti),
          /* :: */[
            ty0,
            /* [] */0
          ]
        ]);
    return Curry._6(Format.fprintf(ppf, /* Format */[
                    /* Char_literal */Block.__(12, [
                        /* "." */46,
                        /* Formatting_lit */Block.__(17, [
                            /* Flush_newline */4,
                            /* Formatting_gen */Block.__(18, [
                                /* Open_box */Block.__(1, [/* Format */[
                                      /* String_literal */Block.__(11, [
                                          "<hov2>",
                                          /* End_of_format */0
                                        ]),
                                      "<hov2>"
                                    ]]),
                                /* String_literal */Block.__(11, [
                                    "In ",
                                    /* String */Block.__(2, [
                                        /* No_padding */0,
                                        /* Formatting_lit */Block.__(17, [
                                            /* Break */Block.__(0, [
                                                "@ ",
                                                1,
                                                0
                                              ]),
                                            /* String */Block.__(2, [
                                                /* No_padding */0,
                                                /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                        /* Break */Block.__(0, [
                                                            "@;<1 -2>",
                                                            1,
                                                            -2
                                                          ]),
                                                        /* String_literal */Block.__(11, [
                                                            "the variable ",
                                                            /* Alpha */Block.__(15, [/* String_literal */Block.__(11, [
                                                                    " is unbound",
                                                                    /* Formatting_lit */Block.__(17, [
                                                                        /* Close_box */0,
                                                                        /* End_of_format */0
                                                                      ])
                                                                  ])])
                                                          ])
                                                      ])])
                                              ])
                                          ])
                                      ])
                                  ])
                              ])
                          ])
                      ]),
                    ".@.@[<hov2>In %s@ %s%a@;<1 -2>the variable %a is unbound@]"
                  ]), kwd, Curry._1(lab, ti), type_expr$1, Curry._1(typ, ti), type_expr$1, tv);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return /* () */0;
    } else {
      throw exn;
    }
  }
}

function report_error$5(ppf, param) {
  if (typeof param === "number") {
    switch (param) {
      case 0 : 
          return Format.fprintf(ppf, /* Format */[
                      /* String_literal */Block.__(11, [
                          "A type parameter occurs several times",
                          /* End_of_format */0
                        ]),
                      "A type parameter occurs several times"
                    ]);
      case 1 : 
          return Curry._2(Format.fprintf(ppf, /* Format */[
                          /* Formatting_gen */Block.__(18, [
                              /* Open_box */Block.__(1, [/* Format */[
                                    /* End_of_format */0,
                                    ""
                                  ]]),
                              /* String_literal */Block.__(11, [
                                  "Too many non-constant constructors",
                                  /* Formatting_lit */Block.__(17, [
                                      /* Break */Block.__(0, [
                                          "@ ",
                                          1,
                                          0
                                        ]),
                                      /* String_literal */Block.__(11, [
                                          "-- maximum is ",
                                          /* Int */Block.__(4, [
                                              /* Int_i */3,
                                              /* No_padding */0,
                                              /* No_precision */0,
                                              /* Char_literal */Block.__(12, [
                                                  /* " " */32,
                                                  /* String */Block.__(2, [
                                                      /* No_padding */0,
                                                      /* Formatting_lit */Block.__(17, [
                                                          /* Close_box */0,
                                                          /* End_of_format */0
                                                        ])
                                                    ])
                                                ])
                                            ])
                                        ])
                                    ])
                                ])
                            ]),
                          "@[Too many non-constant constructors@ -- maximum is %i %s@]"
                        ]), 246, "non-constant constructors");
      case 2 : 
          return Format.fprintf(ppf, /* Format */[
                      /* String_literal */Block.__(11, [
                          "External identifiers must be functions",
                          /* End_of_format */0
                        ]),
                      "External identifiers must be functions"
                    ]);
      case 3 : 
          return Format.fprintf(ppf, /* Format */[
                      /* Formatting_gen */Block.__(18, [
                          /* Open_box */Block.__(1, [/* Format */[
                                /* String_literal */Block.__(11, [
                                    "<hv>",
                                    /* End_of_format */0
                                  ]),
                                "<hv>"
                              ]]),
                          /* String_literal */Block.__(11, [
                              "An external function with more than 5 arguments requires a second stub function",
                              /* Formatting_lit */Block.__(17, [
                                  /* Break */Block.__(0, [
                                      "@ ",
                                      1,
                                      0
                                    ]),
                                  /* String_literal */Block.__(11, [
                                      "for native-code compilation",
                                      /* Formatting_lit */Block.__(17, [
                                          /* Close_box */0,
                                          /* End_of_format */0
                                        ])
                                    ])
                                ])
                            ])
                        ]),
                      "@[<hv>An external function with more than 5 arguments requires a second stub function@ for native-code compilation@]"
                    ]);
      case 4 : 
          return Curry._3(Format.fprintf(ppf, /* Format */[
                          /* Formatting_gen */Block.__(18, [
                              /* Open_box */Block.__(1, [/* Format */[
                                    /* End_of_format */0,
                                    ""
                                  ]]),
                              /* String */Block.__(2, [
                                  /* No_padding */0,
                                  /* Formatting_lit */Block.__(17, [
                                      /* Break */Block.__(0, [
                                          "@ ",
                                          1,
                                          0
                                        ]),
                                      /* String */Block.__(2, [
                                          /* No_padding */0,
                                          /* Formatting_lit */Block.__(17, [
                                              /* Break */Block.__(0, [
                                                  "@ ",
                                                  1,
                                                  0
                                                ]),
                                              /* String */Block.__(2, [
                                                  /* No_padding */0,
                                                  /* Formatting_lit */Block.__(17, [
                                                      /* Close_box */0,
                                                      /* End_of_format */0
                                                    ])
                                                ])
                                            ])
                                        ])
                                    ])
                                ])
                            ]),
                          "@[%s@ %s@ %s@]"
                        ]), "In this GADT definition,", "the variance of some parameter", "cannot be checked");
      
    }
  } else {
    switch (param.tag | 0) {
      case 0 : 
          return Curry._1(Format.fprintf(ppf, /* Format */[
                          /* String_literal */Block.__(11, [
                              "Two constructors are named ",
                              /* String */Block.__(2, [
                                  /* No_padding */0,
                                  /* End_of_format */0
                                ])
                            ]),
                          "Two constructors are named %s"
                        ]), param[0]);
      case 1 : 
          return Curry._1(Format.fprintf(ppf, /* Format */[
                          /* String_literal */Block.__(11, [
                              "Two labels are named ",
                              /* String */Block.__(2, [
                                  /* No_padding */0,
                                  /* End_of_format */0
                                ])
                            ]),
                          "Two labels are named %s"
                        ]), param[0]);
      case 2 : 
          return Curry._1(Format.fprintf(ppf, /* Format */[
                          /* String_literal */Block.__(11, [
                              "The type abbreviation ",
                              /* String */Block.__(2, [
                                  /* No_padding */0,
                                  /* String_literal */Block.__(11, [
                                      " is cyclic",
                                      /* End_of_format */0
                                    ])
                                ])
                            ]),
                          "The type abbreviation %s is cyclic"
                        ]), param[0]);
      case 3 : 
          var ty = param[1];
          reset(/* () */0);
          mark_loops(ty);
          return Curry._3(Format.fprintf(ppf, /* Format */[
                          /* Formatting_gen */Block.__(18, [
                              /* Open_box */Block.__(1, [/* Format */[
                                    /* String_literal */Block.__(11, [
                                        "<v>",
                                        /* End_of_format */0
                                      ]),
                                    "<v>"
                                  ]]),
                              /* String_literal */Block.__(11, [
                                  "The definition of ",
                                  /* String */Block.__(2, [
                                      /* No_padding */0,
                                      /* String_literal */Block.__(11, [
                                          " contains a cycle:",
                                          /* Formatting_lit */Block.__(17, [
                                              /* Break */Block.__(0, [
                                                  "@ ",
                                                  1,
                                                  0
                                                ]),
                                              /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                      /* Close_box */0,
                                                      /* End_of_format */0
                                                    ])])
                                            ])
                                        ])
                                    ])
                                ])
                            ]),
                          "@[<v>The definition of %s contains a cycle:@ %a@]"
                        ]), param[0], type_expr$1, ty);
      case 4 : 
          var ty$1 = param[0];
          reset(/* () */0);
          mark_loops(ty$1);
          return Curry._6(Format.fprintf(ppf, /* Format */[
                          /* Formatting_gen */Block.__(18, [
                              /* Open_box */Block.__(1, [/* Format */[
                                    /* String_literal */Block.__(11, [
                                        "<v>",
                                        /* End_of_format */0
                                      ]),
                                    "<v>"
                                  ]]),
                              /* Formatting_gen */Block.__(18, [
                                  /* Open_box */Block.__(1, [/* Format */[
                                        /* String_literal */Block.__(11, [
                                            "<hov>",
                                            /* End_of_format */0
                                          ]),
                                        "<hov>"
                                      ]]),
                                  /* String */Block.__(2, [
                                      /* No_padding */0,
                                      /* Formatting_lit */Block.__(17, [
                                          /* Break */Block.__(0, [
                                              "@ ",
                                              1,
                                              0
                                            ]),
                                          /* String */Block.__(2, [
                                              /* No_padding */0,
                                              /* Formatting_lit */Block.__(17, [
                                                  /* Break */Block.__(0, [
                                                      "@;<1 2>",
                                                      1,
                                                      2
                                                    ]),
                                                  /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                          /* Close_box */0,
                                                          /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                  /* Close_box */0,
                                                                  /* End_of_format */0
                                                                ])])
                                                        ])])
                                                ])
                                            ])
                                        ])
                                    ])
                                ])
                            ]),
                          "@[<v>@[<hov>%s@ %s@;<1 2>%a@]%a@]"
                        ]), "This variant or record definition", "does not match that of type", type_expr$1, ty$1, (function (param) {
                        return report_type_mismatch("the original", "this", "definition", param);
                      }), param[1]);
      case 5 : 
          var ty$prime = param[1];
          var ty$2 = param[0];
          reset(/* () */0);
          mark_loops(ty$2);
          mark_loops(ty$prime);
          return Curry._5(Format.fprintf(ppf, /* Format */[
                          /* Formatting_gen */Block.__(18, [
                              /* Open_box */Block.__(1, [/* Format */[
                                    /* End_of_format */0,
                                    ""
                                  ]]),
                              /* String */Block.__(2, [
                                  /* No_padding */0,
                                  /* Formatting_lit */Block.__(17, [
                                      /* Break */Block.__(0, [
                                          "@ ",
                                          1,
                                          0
                                        ]),
                                      /* Formatting_gen */Block.__(18, [
                                          /* Open_box */Block.__(1, [/* Format */[
                                                /* String_literal */Block.__(11, [
                                                    "<hv>",
                                                    /* End_of_format */0
                                                  ]),
                                                "<hv>"
                                              ]]),
                                          /* String_literal */Block.__(11, [
                                              "Type",
                                              /* Formatting_lit */Block.__(17, [
                                                  /* Break */Block.__(0, [
                                                      "@ ",
                                                      1,
                                                      0
                                                    ]),
                                                  /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                          /* Break */Block.__(0, [
                                                              "@ ",
                                                              1,
                                                              0
                                                            ]),
                                                          /* String_literal */Block.__(11, [
                                                              "should be an instance of",
                                                              /* Formatting_lit */Block.__(17, [
                                                                  /* Break */Block.__(0, [
                                                                      "@ ",
                                                                      1,
                                                                      0
                                                                    ]),
                                                                  /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                          /* Close_box */0,
                                                                          /* Formatting_lit */Block.__(17, [
                                                                              /* Close_box */0,
                                                                              /* End_of_format */0
                                                                            ])
                                                                        ])])
                                                                ])
                                                            ])
                                                        ])])
                                                ])
                                            ])
                                        ])
                                    ])
                                ])
                            ]),
                          "@[%s@ @[<hv>Type@ %a@ should be an instance of@ %a@]@]"
                        ]), "Constraints are not satisfied in this type.", type_expr$1, ty$2, type_expr$1, ty$prime);
      case 6 : 
          Format.fprintf(ppf, /* Format */[
                /* String_literal */Block.__(11, [
                    "The type constraints are not consistent.",
                    /* Formatting_lit */Block.__(17, [
                        /* Flush_newline */4,
                        /* End_of_format */0
                      ])
                  ]),
                "The type constraints are not consistent.@."
              ]);
          return report_unification_error(ppf, param[0], /* None */0, param[1], (function (ppf) {
                        return Format.fprintf(ppf, /* Format */[
                                    /* String_literal */Block.__(11, [
                                        "Type",
                                        /* End_of_format */0
                                      ]),
                                    "Type"
                                  ]);
                      }), (function (ppf) {
                        return Format.fprintf(ppf, /* Format */[
                                    /* String_literal */Block.__(11, [
                                        "is not compatible with type",
                                        /* End_of_format */0
                                      ]),
                                    "is not compatible with type"
                                  ]);
                      }));
      case 7 : 
          return report_unification_error(ppf, param[0], /* None */0, param[1], (function (ppf) {
                        return Format.fprintf(ppf, /* Format */[
                                    /* String_literal */Block.__(11, [
                                        "This type constructor expands to type",
                                        /* End_of_format */0
                                      ]),
                                    "This type constructor expands to type"
                                  ]);
                      }), (function (ppf) {
                        return Format.fprintf(ppf, /* Format */[
                                    /* String_literal */Block.__(11, [
                                        "but is used here with type",
                                        /* End_of_format */0
                                      ]),
                                    "but is used here with type"
                                  ]);
                      }));
      case 8 : 
          var ty$prime$1 = param[2];
          var ty$3 = param[1];
          reset(/* () */0);
          mark_loops(ty$3);
          mark_loops(ty$prime$1);
          return Curry._5(Format.fprintf(ppf, /* Format */[
                          /* Formatting_gen */Block.__(18, [
                              /* Open_box */Block.__(1, [/* Format */[
                                    /* String_literal */Block.__(11, [
                                        "<hv>",
                                        /* End_of_format */0
                                      ]),
                                    "<hv>"
                                  ]]),
                              /* String_literal */Block.__(11, [
                                  "In the definition of ",
                                  /* String */Block.__(2, [
                                      /* No_padding */0,
                                      /* String_literal */Block.__(11, [
                                          ", type",
                                          /* Formatting_lit */Block.__(17, [
                                              /* Break */Block.__(0, [
                                                  "@ ",
                                                  1,
                                                  0
                                                ]),
                                              /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                      /* Break */Block.__(0, [
                                                          "@ ",
                                                          1,
                                                          0
                                                        ]),
                                                      /* String_literal */Block.__(11, [
                                                          "should be",
                                                          /* Formatting_lit */Block.__(17, [
                                                              /* Break */Block.__(0, [
                                                                  "@ ",
                                                                  1,
                                                                  0
                                                                ]),
                                                              /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                      /* Close_box */0,
                                                                      /* End_of_format */0
                                                                    ])])
                                                            ])
                                                        ])
                                                    ])])
                                            ])
                                        ])
                                    ])
                                ])
                            ]),
                          "@[<hv>In the definition of %s, type@ %a@ should be@ %a@]"
                        ]), name(/* None */0, param[0]), type_expr$1, ty$3, type_expr$1, ty$prime$1);
      case 9 : 
          var decl = param[1];
          Format.fprintf(ppf, /* Format */[
                /* String_literal */Block.__(11, [
                    "A type variable is unbound in this type declaration",
                    /* End_of_format */0
                  ]),
                "A type variable is unbound in this type declaration"
              ]);
          var ty$4 = repr(param[0]);
          var match = decl[/* type_kind */2];
          var match$1 = decl[/* type_manifest */4];
          if (typeof match === "number") {
            if (match === 0 && match$1) {
              var ppf$1 = ppf;
              var tv = ty$4;
              var ty$5 = match$1[0];
              var trivial = function (ty) {
                return explain_unbound(ppf$1, tv, /* :: */[
                            ty,
                            /* [] */0
                          ], (function (t) {
                              return t;
                            }), "type", (function () {
                              return "";
                            }));
              };
              var match$2 = repr(ty$5)[/* desc */0];
              if (typeof match$2 === "number") {
                return trivial(ty$5);
              } else {
                switch (match$2.tag | 0) {
                  case 4 : 
                      var match$3 = flatten_fields(match$2[0]);
                      if (match$3[1] === tv) {
                        return trivial(ty$5);
                      } else {
                        return explain_unbound(ppf$1, tv, match$3[0], (function (param) {
                                      return param[2];
                                    }), "method", (function (param) {
                                      return param[0] + ": ";
                                    }));
                      }
                  case 8 : 
                      var row = row_repr_aux(/* [] */0, match$2[0]);
                      if (row[/* row_more */1] === tv) {
                        return trivial(ty$5);
                      } else {
                        return explain_unbound(ppf$1, tv, row[/* row_fields */0], (function (param) {
                                      var match = row_field_repr_aux(/* [] */0, param[1]);
                                      if (typeof match === "number") {
                                        return newty2(100000000, /* Ttuple */Block.__(2, [/* [] */0]));
                                      } else if (match.tag) {
                                        var tl = match[1];
                                        if (tl) {
                                          if (tl[1]) {
                                            return newty2(100000000, /* Ttuple */Block.__(2, [tl]));
                                          } else {
                                            return tl[0];
                                          }
                                        } else {
                                          return newty2(100000000, /* Ttuple */Block.__(2, [tl]));
                                        }
                                      } else {
                                        var match$1 = match[0];
                                        if (match$1) {
                                          return match$1[0];
                                        } else {
                                          return newty2(100000000, /* Ttuple */Block.__(2, [/* [] */0]));
                                        }
                                      }
                                    }), "case", (function (param) {
                                      return "`" + (param[0] + " of ");
                                    }));
                      }
                  default:
                    return trivial(ty$5);
                }
              }
            } else {
              return /* () */0;
            }
          } else if (match.tag) {
            return explain_unbound(ppf, ty$4, match[0], (function (c) {
                          return newty2(100000000, /* Ttuple */Block.__(2, [c[/* cd_args */1]]));
                        }), "case", (function (c) {
                          return c[/* cd_id */0][/* name */1] + " of ";
                        }));
          } else {
            return explain_unbound(ppf, ty$4, match[0], (function (l) {
                          return l[/* ld_type */2];
                        }), "field", (function (l) {
                          return l[/* ld_id */0][/* name */1] + ": ";
                        }));
          }
          break;
      case 10 : 
          return Curry._3(Format.fprintf(ppf, /* Format */[
                          /* Formatting_gen */Block.__(18, [
                              /* Open_box */Block.__(1, [/* Format */[
                                    /* End_of_format */0,
                                    ""
                                  ]]),
                              /* String */Block.__(2, [
                                  /* No_padding */0,
                                  /* Formatting_lit */Block.__(17, [
                                      /* Break */Block.__(0, [
                                          "@ ",
                                          1,
                                          0
                                        ]),
                                      /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                              /* Close_box */0,
                                              /* End_of_format */0
                                            ])])
                                    ])
                                ])
                            ]),
                          "@[%s@ %a@]"
                        ]), "Cannot extend type definition", path, param[0]);
      case 11 : 
          return Curry._4(Format.fprintf(ppf, /* Format */[
                          /* Formatting_gen */Block.__(18, [
                              /* Open_box */Block.__(1, [/* Format */[
                                    /* End_of_format */0,
                                    ""
                                  ]]),
                              /* String */Block.__(2, [
                                  /* No_padding */0,
                                  /* Formatting_lit */Block.__(17, [
                                      /* Break */Block.__(0, [
                                          "@ ",
                                          1,
                                          0
                                        ]),
                                      /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                              /* Break */Block.__(0, [
                                                  "@ ",
                                                  1,
                                                  0
                                                ]),
                                              /* String */Block.__(2, [
                                                  /* No_padding */0,
                                                  /* Formatting_lit */Block.__(17, [
                                                      /* Close_box */0,
                                                      /* End_of_format */0
                                                    ])
                                                ])
                                            ])])
                                    ])
                                ])
                            ]),
                          "@[%s@ %a@ %s@]"
                        ]), "Type", path, param[0], "is not extensible");
      case 12 : 
          return Curry._5(Format.fprintf(ppf, /* Format */[
                          /* Formatting_gen */Block.__(18, [
                              /* Open_box */Block.__(1, [/* Format */[
                                    /* String_literal */Block.__(11, [
                                        "<v>",
                                        /* End_of_format */0
                                      ]),
                                    "<v>"
                                  ]]),
                              /* Formatting_gen */Block.__(18, [
                                  /* Open_box */Block.__(1, [/* Format */[
                                        /* String_literal */Block.__(11, [
                                            "<hov>",
                                            /* End_of_format */0
                                          ]),
                                        "<hov>"
                                      ]]),
                                  /* String */Block.__(2, [
                                      /* No_padding */0,
                                      /* Formatting_lit */Block.__(17, [
                                          /* Break */Block.__(0, [
                                              "@ ",
                                              1,
                                              0
                                            ]),
                                          /* String */Block.__(2, [
                                              /* No_padding */0,
                                              /* Formatting_lit */Block.__(17, [
                                                  /* Break */Block.__(0, [
                                                      "@;<1 2>",
                                                      1,
                                                      2
                                                    ]),
                                                  /* String */Block.__(2, [
                                                      /* No_padding */0,
                                                      /* Formatting_lit */Block.__(17, [
                                                          /* Close_box */0,
                                                          /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                  /* Close_box */0,
                                                                  /* End_of_format */0
                                                                ])])
                                                        ])
                                                    ])
                                                ])
                                            ])
                                        ])
                                    ])
                                ])
                            ]),
                          "@[<v>@[<hov>%s@ %s@;<1 2>%s@]%a@]"
                        ]), "This extension", "does not match the definition of type", name(/* None */0, param[0]), (function (param) {
                        return report_type_mismatch("the type", "this extension", "definition", param);
                      }), param[1]);
      case 13 : 
          var lid = param[0];
          return report_unification_error(ppf, param[1], /* None */0, param[2], (function (ppf) {
                        return Curry._2(Format.fprintf(ppf, /* Format */[
                                        /* String_literal */Block.__(11, [
                                            "The constructor ",
                                            /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                    /* Break */Block.__(0, [
                                                        "@ ",
                                                        1,
                                                        0
                                                      ]),
                                                    /* String_literal */Block.__(11, [
                                                        "has type",
                                                        /* End_of_format */0
                                                      ])
                                                  ])])
                                          ]),
                                        "The constructor %a@ has type"
                                      ]), longident, lid);
                      }), (function (ppf) {
                        return Format.fprintf(ppf, /* Format */[
                                    /* String_literal */Block.__(11, [
                                        "but was expected to be of type",
                                        /* End_of_format */0
                                      ]),
                                    "but was expected to be of type"
                                  ]);
                      }));
      case 14 : 
          return Curry._8(Format.fprintf(ppf, /* Format */[
                          /* Formatting_gen */Block.__(18, [
                              /* Open_box */Block.__(1, [/* Format */[
                                    /* End_of_format */0,
                                    ""
                                  ]]),
                              /* String */Block.__(2, [
                                  /* No_padding */0,
                                  /* Formatting_lit */Block.__(17, [
                                      /* Break */Block.__(0, [
                                          "@ ",
                                          1,
                                          0
                                        ]),
                                      /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                              /* Break */Block.__(0, [
                                                  "@ ",
                                                  1,
                                                  0
                                                ]),
                                              /* String */Block.__(2, [
                                                  /* No_padding */0,
                                                  /* Formatting_lit */Block.__(17, [
                                                      /* Break */Block.__(0, [
                                                          "@ ",
                                                          1,
                                                          0
                                                        ]),
                                                      /* String */Block.__(2, [
                                                          /* No_padding */0,
                                                          /* Formatting_lit */Block.__(17, [
                                                              /* Break */Block.__(0, [
                                                                  "@ ",
                                                                  1,
                                                                  0
                                                                ]),
                                                              /* String */Block.__(2, [
                                                                  /* No_padding */0,
                                                                  /* Formatting_lit */Block.__(17, [
                                                                      /* Break */Block.__(0, [
                                                                          "@ ",
                                                                          1,
                                                                          0
                                                                        ]),
                                                                      /* String */Block.__(2, [
                                                                          /* No_padding */0,
                                                                          /* Formatting_lit */Block.__(17, [
                                                                              /* Break */Block.__(0, [
                                                                                  "@ ",
                                                                                  1,
                                                                                  0
                                                                                ]),
                                                                              /* String */Block.__(2, [
                                                                                  /* No_padding */0,
                                                                                  /* Formatting_lit */Block.__(17, [
                                                                                      /* Close_box */0,
                                                                                      /* End_of_format */0
                                                                                    ])
                                                                                ])
                                                                            ])
                                                                        ])
                                                                    ])
                                                                ])
                                                            ])
                                                        ])
                                                    ])
                                                ])
                                            ])])
                                    ])
                                ])
                            ]),
                          "@[%s@ %a@ %s@ %s@ %s@ %s@ %s@]"
                        ]), "The constructor", longident, param[0], "extends type", name(/* None */0, param[1]), "whose declaration does not match", "the declaration of type", name(/* None */0, param[2]));
      case 15 : 
          return Curry._4(Format.fprintf(ppf, /* Format */[
                          /* Formatting_gen */Block.__(18, [
                              /* Open_box */Block.__(1, [/* Format */[
                                    /* End_of_format */0,
                                    ""
                                  ]]),
                              /* String */Block.__(2, [
                                  /* No_padding */0,
                                  /* Formatting_lit */Block.__(17, [
                                      /* Break */Block.__(0, [
                                          "@ ",
                                          1,
                                          0
                                        ]),
                                      /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                              /* Break */Block.__(0, [
                                                  "@ ",
                                                  1,
                                                  0
                                                ]),
                                              /* String */Block.__(2, [
                                                  /* No_padding */0,
                                                  /* Formatting_lit */Block.__(17, [
                                                      /* Close_box */0,
                                                      /* End_of_format */0
                                                    ])
                                                ])
                                            ])])
                                    ])
                                ])
                            ]),
                          "@[%s@ %a@ %s@]"
                        ]), "The constructor", longident, param[0], "is private");
      case 16 : 
          var n = param[0];
          var variance = function (param) {
            var n = param[1];
            var inj = param[2] ? "injective " : "";
            if (param[0] !== 0) {
              if (n !== 0) {
                return inj + "invariant";
              } else {
                return inj + "covariant";
              }
            } else if (n !== 0) {
              return inj + "contravariant";
            } else if (inj === "") {
              return "unrestricted";
            } else {
              return inj;
            }
          };
          var suffix = function (n) {
            var teen = +((n % 100 / 10 | 0) === 1);
            var match = n % 10;
            var switcher = match - 1 | 0;
            if (switcher > 2 || switcher < 0) {
              return "th";
            } else {
              switch (switcher) {
                case 0 : 
                    if (teen) {
                      return "th";
                    } else {
                      return "st";
                    }
                case 1 : 
                    if (teen) {
                      return "th";
                    } else {
                      return "nd";
                    }
                case 2 : 
                    if (teen) {
                      return "th";
                    } else {
                      return "rd";
                    }
                
              }
            }
          };
          if (n === -1) {
            Curry._2(Format.fprintf(ppf, /* Format */[
                      /* Formatting_gen */Block.__(18, [
                          /* Open_box */Block.__(1, [/* Format */[
                                /* End_of_format */0,
                                ""
                              ]]),
                          /* String */Block.__(2, [
                              /* No_padding */0,
                              /* Formatting_lit */Block.__(17, [
                                  /* Break */Block.__(0, [
                                      "@ ",
                                      1,
                                      0
                                    ]),
                                  /* String */Block.__(2, [
                                      /* No_padding */0,
                                      /* Formatting_lit */Block.__(17, [
                                          /* Break */Block.__(0, [
                                              "@ ",
                                              1,
                                              0
                                            ]),
                                          /* String_literal */Block.__(11, [
                                              "It",
                                              /* End_of_format */0
                                            ])
                                        ])
                                    ])
                                ])
                            ])
                        ]),
                      "@[%s@ %s@ It"
                    ]), "In this definition, a type variable has a variance that", "is not reflected by its occurrence in type parameters.");
          } else if (n === -2) {
            Curry._2(Format.fprintf(ppf, /* Format */[
                      /* Formatting_gen */Block.__(18, [
                          /* Open_box */Block.__(1, [/* Format */[
                                /* End_of_format */0,
                                ""
                              ]]),
                          /* String */Block.__(2, [
                              /* No_padding */0,
                              /* Formatting_lit */Block.__(17, [
                                  /* Break */Block.__(0, [
                                      "@ ",
                                      1,
                                      0
                                    ]),
                                  /* String */Block.__(2, [
                                      /* No_padding */0,
                                      /* Formatting_lit */Block.__(17, [
                                          /* Close_box */0,
                                          /* End_of_format */0
                                        ])
                                    ])
                                ])
                            ])
                        ]),
                      "@[%s@ %s@]"
                    ]), "In this definition, a type variable cannot be deduced", "from the type parameters.");
          } else if (n === -3) {
            Curry._2(Format.fprintf(ppf, /* Format */[
                      /* Formatting_gen */Block.__(18, [
                          /* Open_box */Block.__(1, [/* Format */[
                                /* End_of_format */0,
                                ""
                              ]]),
                          /* String */Block.__(2, [
                              /* No_padding */0,
                              /* Formatting_lit */Block.__(17, [
                                  /* Break */Block.__(0, [
                                      "@ ",
                                      1,
                                      0
                                    ]),
                                  /* String */Block.__(2, [
                                      /* No_padding */0,
                                      /* Formatting_lit */Block.__(17, [
                                          /* Break */Block.__(0, [
                                              "@ ",
                                              1,
                                              0
                                            ]),
                                          /* String_literal */Block.__(11, [
                                              "It",
                                              /* End_of_format */0
                                            ])
                                        ])
                                    ])
                                ])
                            ])
                        ]),
                      "@[%s@ %s@ It"
                    ]), "In this definition, a type variable has a variance that", "cannot be deduced from the type parameters.");
          } else {
            Curry._4(Format.fprintf(ppf, /* Format */[
                      /* Formatting_gen */Block.__(18, [
                          /* Open_box */Block.__(1, [/* Format */[
                                /* End_of_format */0,
                                ""
                              ]]),
                          /* String */Block.__(2, [
                              /* No_padding */0,
                              /* Formatting_lit */Block.__(17, [
                                  /* Break */Block.__(0, [
                                      "@ ",
                                      1,
                                      0
                                    ]),
                                  /* String */Block.__(2, [
                                      /* No_padding */0,
                                      /* Formatting_lit */Block.__(17, [
                                          /* Break */Block.__(0, [
                                              "@ ",
                                              1,
                                              0
                                            ]),
                                          /* String_literal */Block.__(11, [
                                              "The ",
                                              /* Int */Block.__(4, [
                                                  /* Int_d */0,
                                                  /* No_padding */0,
                                                  /* No_precision */0,
                                                  /* String */Block.__(2, [
                                                      /* No_padding */0,
                                                      /* String_literal */Block.__(11, [
                                                          " type parameter",
                                                          /* End_of_format */0
                                                        ])
                                                    ])
                                                ])
                                            ])
                                        ])
                                    ])
                                ])
                            ])
                        ]),
                      "@[%s@ %s@ The %d%s type parameter"
                    ]), "In this definition, expected parameter", "variances are not satisfied.", n, suffix(n));
          }
          if (n !== -2) {
            return Curry._2(Format.fprintf(ppf, /* Format */[
                            /* String_literal */Block.__(11, [
                                " was expected to be ",
                                /* String */Block.__(2, [
                                    /* No_padding */0,
                                    /* Char_literal */Block.__(12, [
                                        /* "," */44,
                                        /* Formatting_lit */Block.__(17, [
                                            /* Break */Block.__(0, [
                                                "@ ",
                                                1,
                                                0
                                              ]),
                                            /* String_literal */Block.__(11, [
                                                "but it is ",
                                                /* String */Block.__(2, [
                                                    /* No_padding */0,
                                                    /* Char_literal */Block.__(12, [
                                                        /* "." */46,
                                                        /* Formatting_lit */Block.__(17, [
                                                            /* Close_box */0,
                                                            /* End_of_format */0
                                                          ])
                                                      ])
                                                  ])
                                              ])
                                          ])
                                      ])
                                  ])
                              ]),
                            " was expected to be %s,@ but it is %s.@]"
                          ]), variance(param[2]), variance(param[1]));
          } else {
            return 0;
          }
      case 17 : 
          return Curry._2(Format.fprintf(ppf, /* Format */[
                          /* String_literal */Block.__(11, [
                              "The definition of type ",
                              /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                      /* Break */Block.__(0, [
                                          "@ ",
                                          1,
                                          0
                                        ]),
                                      /* String_literal */Block.__(11, [
                                          "is unavailable",
                                          /* End_of_format */0
                                        ])
                                    ])])
                            ]),
                          "The definition of type %a@ is unavailable"
                        ]), path, param[0]);
      case 18 : 
          return Curry._1(Format.fprintf(ppf, /* Format */[
                          /* String_literal */Block.__(11, [
                              "This fixed type ",
                              /* String */Block.__(2, [
                                  /* No_padding */0,
                                  /* End_of_format */0
                                ])
                            ]),
                          "This fixed type %s"
                        ]), param[0]);
      case 19 : 
          Format.fprintf(ppf, /* Format */[
                /* String_literal */Block.__(11, [
                    "A type variable is unbound in this extension constructor",
                    /* End_of_format */0
                  ]),
                "A type variable is unbound in this extension constructor"
              ]);
          return explain_unbound(ppf, param[0], param[1][/* ext_args */2], (function (c) {
                        return c;
                      }), "type", (function () {
                        return "";
                      }));
      
    }
  }
}

register_error_of_exn((function (param) {
        if (param[0] === $$Error$8) {
          return /* Some */[error_of_printer(param[1], report_error$5, param[2])];
        } else {
          return /* None */0;
        }
      }));

var $$Error$9 = Caml_exceptions.create("Ocaml_typedtree_test.Typeclass.Error");

var Error_forward$2 = Caml_exceptions.create("Ocaml_typedtree_test.Typeclass.Error_forward");

function ctyp(desc, typ, env, loc) {
  return /* record */[
          /* ctyp_desc */desc,
          /* ctyp_type */typ,
          /* ctyp_env */env,
          /* ctyp_loc */loc,
          /* ctyp_attributes : [] */0
        ];
}

var unbound_class = /* Pident */Block.__(0, [create("")]);

function scrape_class_type(_cty) {
  while(true) {
    var cty = _cty;
    switch (cty.tag | 0) {
      case 0 : 
          _cty = cty[2];
          continue ;
          case 1 : 
      case 2 : 
          return cty;
      
    }
  };
}

function generalize_class_type(vars) {
  var partial_arg = vars ? generalize : generalize_structure$2;
  return (function (param) {
      var gen = partial_arg;
      var _param = param;
      while(true) {
        var param$1 = _param;
        switch (param$1.tag | 0) {
          case 0 : 
              List.iter(gen, param$1[1]);
              _param = param$1[2];
              continue ;
              case 1 : 
              var match = param$1[0];
              Curry._1(gen, match[/* csig_self */0]);
              iter$1((function (_, param) {
                      return Curry._1(gen, param[2]);
                    }), match[/* csig_vars */1]);
              return List.iter((function (param) {
                            return List.iter(gen, param[1]);
                          }), match[/* csig_inher */3]);
          case 2 : 
              Curry._1(gen, param$1[1]);
              _param = param$1[2];
              continue ;
              
        }
      };
    });
}

function virtual_methods(sign) {
  var match = flatten_fields(object_fields(sign[/* csig_self */0]));
  return List.fold_left((function (virt, param) {
                var lab = param[0];
                if (lab === dummy_method || mem$2(lab, sign[/* csig_concr */2])) {
                  return virt;
                } else {
                  return /* :: */[
                          lab,
                          virt
                        ];
                }
              }), /* [] */0, match[0]);
}

function constructor_type(constr, _cty) {
  while(true) {
    var cty = _cty;
    switch (cty.tag | 0) {
      case 0 : 
          _cty = cty[2];
          continue ;
          case 1 : 
          return constr;
      case 2 : 
          var desc_000 = cty[0];
          var desc_001 = cty[1];
          var desc_002 = constructor_type(constr, cty[2]);
          var desc = /* Tarrow */Block.__(1, [
              desc_000,
              desc_001,
              desc_002,
              /* Cok */0
            ]);
          return newty2(current_level[0], desc);
      
    }
  };
}

function class_body(_cty) {
  while(true) {
    var cty = _cty;
    switch (cty.tag | 0) {
      case 0 : 
      case 1 : 
          return cty;
      case 2 : 
          _cty = cty[2];
          continue ;
          
    }
  };
}

function extract_constraints(cty) {
  var sign = signature_of_class_type(cty);
  var match = flatten_fields(object_fields(sign[/* csig_self */0]));
  return /* tuple */[
          fold((function (lab, _, vars) {
                  return /* :: */[
                          lab,
                          vars
                        ];
                }), sign[/* csig_vars */1], /* [] */0),
          List.fold_left((function (meths, param) {
                  var lab = param[0];
                  if (lab === dummy_method) {
                    return meths;
                  } else {
                    return /* :: */[
                            lab,
                            meths
                          ];
                  }
                }), /* [] */0, match[0]),
          sign[/* csig_concr */2]
        ];
}

function abbreviate_class_type(path, params, cty) {
  switch (cty.tag | 0) {
    case 0 : 
    case 1 : 
        return /* Cty_constr */Block.__(0, [
                  path,
                  params,
                  cty
                ]);
    case 2 : 
        return /* Cty_arrow */Block.__(2, [
                  cty[0],
                  cty[1],
                  abbreviate_class_type(path, params, cty[2])
                ]);
    
  }
}

function closed_class$1(cty) {
  if (List.for_all(closed_schema, cty[/* cty_params */0])) {
    var _param = cty[/* cty_type */1];
    while(true) {
      var param = _param;
      switch (param.tag | 0) {
        case 0 : 
            return List.for_all(closed_schema, param[1]);
        case 1 : 
            var sign = param[0];
            if (closed_schema(sign[/* csig_self */0])) {
              return fold((function (_, param, cc) {
                            if (closed_schema(param[2])) {
                              return cc;
                            } else {
                              return /* false */0;
                            }
                          }), sign[/* csig_vars */1], /* true */1);
            } else {
              return /* false */0;
            }
        case 2 : 
            if (closed_schema(param[1])) {
              _param = param[2];
              continue ;
              
            } else {
              return /* false */0;
            }
            break;
        
      }
    };
  } else {
    return /* false */0;
  }
}

function limited_generalize$1(rv, _param) {
  while(true) {
    var param = _param;
    switch (param.tag | 0) {
      case 0 : 
          List.iter((function (param) {
                  return limited_generalize(rv, param);
                }), param[1]);
          _param = param[2];
          continue ;
          case 1 : 
          var sign = param[0];
          limited_generalize(rv, sign[/* csig_self */0]);
          iter$1((function (_, param) {
                  return limited_generalize(rv, param[2]);
                }), sign[/* csig_vars */1]);
          return List.iter((function (param) {
                        return List.iter((function (param) {
                                      return limited_generalize(rv, param);
                                    }), param[1]);
                      }), sign[/* csig_inher */3]);
      case 2 : 
          limited_generalize(rv, param[1]);
          _param = param[2];
          continue ;
          
    }
  };
}

function rc(node) {
  add_saved_type(/* Partial_class_expr */Block.__(4, [node]));
  record$2(/* Ti_class */Block.__(2, [node]));
  return node;
}

function enter_met_env(check, loc, lab, kind, ty, val_env, met_env, par_env) {
  var param = /* record */[
    /* val_type */ty,
    /* val_kind : Val_unbound */1,
    /* val_loc */loc,
    /* val_attributes : [] */0
  ];
  var match = enter((function (param, param$1, param$2, param$3, param$4, param$5) {
          return store_value(/* None */0, param, param$1, param$2, param$3, param$4, param$5);
        }), lab, param, val_env);
  var id = match[0];
  return /* tuple */[
          id,
          match[1],
          add_value(check, id, /* record */[
                /* val_type */ty,
                /* val_kind */kind,
                /* val_loc */loc,
                /* val_attributes : [] */0
              ], met_env),
          add_value(/* None */0, id, /* record */[
                /* val_type */ty,
                /* val_kind : Val_unbound */1,
                /* val_loc */loc,
                /* val_attributes : [] */0
              ], par_env)
        ];
}

function enter_val(cl_num, vars, inh, lab, mut, virt, ty, val_env, met_env, par_env, loc) {
  var match;
  try {
    var match$1 = find(lab, vars[0]);
    var virt$prime = match$1[2];
    if (Caml_obj.caml_notequal(match$1[1], mut)) {
      throw [
            $$Error$9,
            loc,
            val_env,
            /* Mutability_mismatch */Block.__(22, [
                lab,
                mut
              ])
          ];
    }
    unify$2(val_env, instance(/* None */0, val_env, ty), instance(/* None */0, val_env, match$1[3]));
    match = /* tuple */[
      inh ? /* None */0 : /* Some */[match$1[0]],
      virt$prime === /* Concrete */1 ? virt$prime : virt
    ];
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === Unify) {
      throw [
            $$Error$9,
            loc,
            val_env,
            /* Field_type_mismatch */Block.__(1, [
                "instance variable",
                lab,
                exn[1]
              ])
          ];
    } else if (exn === Caml_builtin_exceptions.not_found) {
      match = /* tuple */[
        /* None */0,
        virt
      ];
    } else {
      throw exn;
    }
  }
  var id = match[0];
  var result = id ? /* tuple */[
      id[0],
      val_env,
      met_env,
      par_env
    ] : enter_met_env(/* None */0, none, lab, /* Val_ivar */Block.__(1, [
            mut,
            cl_num
          ]), ty, val_env, met_env, par_env);
  vars[0] = add$1(lab, /* tuple */[
        result[0],
        mut,
        match[1],
        ty
      ], vars[0]);
  return result;
}

function concr_vals(vars) {
  return fold((function (id, param, s) {
                if (param[1]) {
                  return add$2(id, s);
                } else {
                  return s;
                }
              }), vars, /* Empty */0);
}

function inheritance(self_type, env, ovf, concr_meths, warn_vals, loc, parent) {
  var match = scrape_class_type(parent);
  switch (match.tag | 0) {
    case 1 : 
        var cl_sig = match[0];
        try {
          unify$2(env, self_type, cl_sig[/* csig_self */0]);
        }
        catch (raw_exn){
          var exn = Js_exn.internalToOCamlException(raw_exn);
          if (exn[0] === Unify) {
            var trace = exn[1];
            var exit = 0;
            if (trace) {
              var match$1 = trace[1];
              if (match$1) {
                var match$2 = match$1[1];
                if (match$2) {
                  var match$3 = match$2[1];
                  if (match$3) {
                    var match$4 = match$3[0][0][/* desc */0];
                    if (typeof match$4 === "number") {
                      exit = 1;
                    } else if (match$4.tag === 5) {
                      throw [
                            $$Error$9,
                            loc,
                            env,
                            /* Field_type_mismatch */Block.__(1, [
                                "method",
                                match$4[0],
                                match$3[1]
                              ])
                          ];
                    } else {
                      exit = 1;
                    }
                  } else {
                    exit = 1;
                  }
                } else {
                  exit = 1;
                }
              } else {
                exit = 1;
              }
            } else {
              exit = 1;
            }
            if (exit === 1) {
              throw [
                    Caml_builtin_exceptions.assert_failure,
                    [
                      "typeclass.ml",
                      261,
                      12
                    ]
                  ];
            }
            
          } else {
            throw exn;
          }
        }
        var over_meths = inter$1(cl_sig[/* csig_concr */2], concr_meths);
        var concr_vals$1 = concr_vals(cl_sig[/* csig_vars */1]);
        var over_vals = inter$1(concr_vals$1, warn_vals);
        if (ovf) {
          if (ovf[0] !== 0) {
            var cname;
            switch (parent.tag | 0) {
              case 0 : 
                  cname = name(/* None */0, parent[0]);
                  break;
              case 1 : 
              case 2 : 
                  cname = "inherited";
                  break;
              
            }
            if (!(
                over_meths ? /* false */0 : /* true */1
              )) {
              prerr_warning(loc, /* Method_override */Block.__(2, [/* :: */[
                        cname,
                        elements_aux(/* [] */0, over_meths)
                      ]]));
            }
            if (!(
                over_vals ? /* false */0 : /* true */1
              )) {
              prerr_warning(loc, /* Instance_variable_override */Block.__(5, [/* :: */[
                        cname,
                        elements_aux(/* [] */0, over_vals)
                      ]]));
            }
            
          } else if ((
              over_meths ? /* false */0 : /* true */1
            ) && (
              over_vals ? /* false */0 : /* true */1
            )) {
            throw [
                  $$Error$9,
                  loc,
                  env,
                  /* No_overriding */Block.__(23, [
                      "",
                      ""
                    ])
                ];
          }
          
        }
        var concr_meths$1 = union$1(cl_sig[/* csig_concr */2], concr_meths);
        var warn_vals$1 = union$1(concr_vals$1, warn_vals);
        return /* tuple */[
                cl_sig,
                concr_meths$1,
                warn_vals$1
              ];
    case 0 : 
    case 2 : 
        throw [
              $$Error$9,
              loc,
              env,
              /* Structure_expected */Block.__(2, [parent])
            ];
    
  }
}

function virtual_method(val_env, meths, self_type, lab, priv, sty, loc) {
  var match = filter_self_method(val_env, lab, priv, meths, self_type);
  var sty$1 = force_poly(sty);
  var cty = transl_simple_type(val_env, /* false */0, sty$1);
  var ty = cty[/* ctyp_type */1];
  try {
    unify$2(val_env, ty, match[1]);
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === Unify) {
      throw [
            $$Error$9,
            loc,
            val_env,
            /* Field_type_mismatch */Block.__(1, [
                "method",
                lab,
                exn[1]
              ])
          ];
    } else {
      throw exn;
    }
  }
  return cty;
}

var delayed_meth_specs = [/* [] */0];

function declare_method(val_env, meths, self_type, lab, priv, sty, loc) {
  var match = filter_self_method(val_env, lab, priv, meths, self_type);
  var ty$prime = match[1];
  var unif = function (ty) {
    try {
      return unify$2(val_env, ty, ty$prime);
    }
    catch (raw_exn){
      var exn = Js_exn.internalToOCamlException(raw_exn);
      if (exn[0] === Unify) {
        throw [
              $$Error$9,
              loc,
              val_env,
              /* Field_type_mismatch */Block.__(1, [
                  "method",
                  lab,
                  exn[1]
                ])
            ];
      } else {
        throw exn;
      }
    }
  };
  var sty$1 = force_poly(sty);
  var match$1 = sty$1[/* ptyp_desc */0];
  var exit = 0;
  if (typeof match$1 === "number") {
    exit = 1;
  } else if (match$1.tag === 8) {
    if (match$1[0]) {
      exit = 1;
    } else if (priv !== 0) {
      var sty$prime = match$1[1];
      var returned_cty = ctyp(/* Ttyp_any */0, newty2(current_level[0], /* Tnil */0), val_env, loc);
      delayed_meth_specs[0] = /* :: */[
        Block.__(246, [(function () {
                var cty = transl_simple_type_univars(val_env, sty$prime);
                var ty = cty[/* ctyp_type */1];
                unif(ty);
                returned_cty[/* ctyp_desc */0] = /* Ttyp_poly */Block.__(8, [
                    /* [] */0,
                    cty
                  ]);
                returned_cty[/* ctyp_type */1] = ty;
                return /* () */0;
              })]),
        delayed_meth_specs[0]
      ];
      return returned_cty;
    } else {
      exit = 1;
    }
  } else {
    exit = 1;
  }
  if (exit === 1) {
    var cty = transl_simple_type(val_env, /* false */0, sty$1);
    var ty = cty[/* ctyp_type */1];
    unif(ty);
    return cty;
  }
  
}

function type_constraint(val_env, sty, sty$prime, loc) {
  var cty = transl_simple_type(val_env, /* false */0, sty);
  var ty = cty[/* ctyp_type */1];
  var cty$prime = transl_simple_type(val_env, /* false */0, sty$prime);
  var ty$prime = cty$prime[/* ctyp_type */1];
  try {
    unify$2(val_env, ty, ty$prime);
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === Unify) {
      throw [
            $$Error$9,
            loc,
            val_env,
            /* Unconsistent_constraint */Block.__(0, [exn[1]])
          ];
    } else {
      throw exn;
    }
  }
  return /* tuple */[
          cty,
          cty$prime
        ];
}

function make_method(loc, cl_num, expr) {
  return Curry._6(Ast_helper_004[/* fun_ */5], /* Some */[expr[/* pexp_loc */1]], /* None */0, "", /* None */0, alias$1(/* Some */[loc], /* None */0, $$var$1(/* Some */[loc], /* None */0, /* record */[
                      /* txt */"self-*",
                      /* loc */loc
                    ]), /* record */[
                  /* txt */"self-" + cl_num,
                  /* loc */loc
                ]), expr);
}

function add_val(_, _$1, lab, param, val_sig) {
  var virt = param[1];
  var virt$1;
  try {
    var match = find(lab, val_sig);
    var virt$prime = match[1];
    virt$1 = virt$prime === /* Concrete */1 ? virt$prime : virt;
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      virt$1 = virt;
    } else {
      throw exn;
    }
  }
  return add$1(lab, /* tuple */[
              param[0],
              virt$1,
              param[2]
            ], val_sig);
}

function class_signature$1(env, param) {
  var sty = param[/* pcsig_self */0];
  var meths = [/* Empty */0];
  var self_cty = transl_simple_type(env, /* false */0, sty);
  var self_cty$1 = /* record */[
    /* ctyp_desc */self_cty[/* ctyp_desc */0],
    /* ctyp_type */expand_head(env, self_cty[/* ctyp_type */1]),
    /* ctyp_env */self_cty[/* ctyp_env */2],
    /* ctyp_loc */self_cty[/* ctyp_loc */3],
    /* ctyp_attributes */self_cty[/* ctyp_attributes */4]
  ];
  var self_type = self_cty$1[/* ctyp_type */1];
  var dummy_obj = newvar(/* None */0, /* () */0);
  unify$2(env, filter_method(env, dummy_method, /* Private */0, dummy_obj), newty2(current_level[0], /* Ttuple */Block.__(2, [/* [] */0])));
  try {
    unify$2(env, self_type, dummy_obj);
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === Unify) {
      throw [
            $$Error$9,
            sty[/* ptyp_loc */1],
            env,
            /* Pattern_type_clash */Block.__(5, [self_type])
          ];
    } else {
      throw exn;
    }
  }
  warning_enter_scope(/* () */0);
  var match = List.fold_left((function (param, param$1) {
          var env$1 = env;
          var self_type$1 = self_type;
          var meths$1 = meths;
          var param$2 = param;
          var ctf = param$1;
          var inher = param$2[3];
          var concr_meths = param$2[2];
          var val_sig = param$2[1];
          var fields = param$2[0];
          var loc = ctf[/* pctf_loc */1];
          var mkctf = function (desc) {
            return /* record */[
                    /* ctf_desc */desc,
                    /* ctf_loc */loc,
                    /* ctf_attributes */ctf[/* pctf_attributes */2]
                  ];
          };
          var match = ctf[/* pctf_desc */0];
          switch (match.tag | 0) {
            case 0 : 
                var sparent = match[0];
                var parent = class_type$2(env$1, sparent);
                var match$1 = parent[/* cltyp_type */1];
                var inher$1;
                switch (match$1.tag | 0) {
                  case 0 : 
                      inher$1 = /* :: */[
                        /* tuple */[
                          match$1[0],
                          match$1[1]
                        ],
                        inher
                      ];
                      break;
                  case 1 : 
                  case 2 : 
                      inher$1 = inher;
                      break;
                  
                }
                var match$2 = inheritance(self_type$1, env$1, /* None */0, concr_meths, /* Empty */0, sparent[/* pcty_loc */1], parent[/* cltyp_type */1]);
                var partial_arg = sparent[/* pcty_loc */1];
                var val_sig$1 = fold((function (param, param$1, param$2) {
                        return add_val(env$1, partial_arg, param, param$1, param$2);
                      }), match$2[0][/* csig_vars */1], val_sig);
                return /* tuple */[
                        /* :: */[
                          mkctf(/* Tctf_inherit */Block.__(0, [parent])),
                          fields
                        ],
                        val_sig$1,
                        match$2[1],
                        inher$1
                      ];
            case 1 : 
                var match$3 = match[0];
                var virt = match$3[2];
                var mut = match$3[1];
                var lab = match$3[0];
                var cty = transl_simple_type(env$1, /* false */0, match$3[3]);
                var ty = cty[/* ctyp_type */1];
                return /* tuple */[
                        /* :: */[
                          mkctf(/* Tctf_val */Block.__(1, [/* tuple */[
                                    lab,
                                    mut,
                                    virt,
                                    cty
                                  ]])),
                          fields
                        ],
                        add_val(env$1, ctf[/* pctf_loc */1], lab, /* tuple */[
                              mut,
                              virt,
                              ty
                            ], val_sig),
                        concr_meths,
                        inher
                      ];
            case 2 : 
                var match$4 = match[0];
                var virt$1 = match$4[2];
                var priv = match$4[1];
                var lab$1 = match$4[0];
                var cty$1 = declare_method(env$1, meths$1, self_type$1, lab$1, priv, match$4[3], ctf[/* pctf_loc */1]);
                var concr_meths$1 = virt$1 !== 0 ? add$2(lab$1, concr_meths) : concr_meths;
                return /* tuple */[
                        /* :: */[
                          mkctf(/* Tctf_method */Block.__(2, [/* tuple */[
                                    lab$1,
                                    priv,
                                    virt$1,
                                    cty$1
                                  ]])),
                          fields
                        ],
                        val_sig,
                        concr_meths$1,
                        inher
                      ];
            case 3 : 
                var match$5 = match[0];
                var match$6 = type_constraint(env$1, match$5[0], match$5[1], ctf[/* pctf_loc */1]);
                return /* tuple */[
                        /* :: */[
                          mkctf(/* Tctf_constraint */Block.__(3, [/* tuple */[
                                    match$6[0],
                                    match$6[1]
                                  ]])),
                          fields
                        ],
                        val_sig,
                        concr_meths,
                        inher
                      ];
            case 4 : 
                var x = match[0];
                warning_attribute(/* :: */[
                      x,
                      /* [] */0
                    ]);
                return /* tuple */[
                        /* :: */[
                          mkctf(/* Tctf_attribute */Block.__(4, [x])),
                          fields
                        ],
                        val_sig,
                        concr_meths,
                        inher
                      ];
            case 5 : 
                throw [
                      Error_forward$2,
                      error_of_extension(match[0])
                    ];
            
          }
        }), /* tuple */[
        /* [] */0,
        /* Empty */0,
        /* Empty */0,
        /* [] */0
      ], param[/* pcsig_fields */1]);
  warning_leave_scope(/* () */0);
  var cty_001 = /* csig_vars */match[1];
  var cty_002 = /* csig_concr */match[2];
  var cty_003 = /* csig_inher */match[3];
  var cty = /* record */[
    /* csig_self */self_type,
    cty_001,
    cty_002,
    cty_003
  ];
  return /* record */[
          /* csig_self */self_cty$1,
          /* csig_fields */List.rev(match[0]),
          /* csig_type */cty
        ];
}

function class_type$2(env, scty) {
  var cltyp = function (desc, typ) {
    return /* record */[
            /* cltyp_desc */desc,
            /* cltyp_type */typ,
            /* cltyp_env */env,
            /* cltyp_loc */scty[/* pcty_loc */1],
            /* cltyp_attributes */scty[/* pcty_attributes */2]
          ];
  };
  var match = scty[/* pcty_desc */0];
  switch (match.tag | 0) {
    case 0 : 
        var styl = match[1];
        var lid = match[0];
        var match$1 = find_class_type(env, scty[/* pcty_loc */1], lid[/* txt */0]);
        var decl = match$1[1];
        var path = match$1[0];
        if (same(decl[/* clty_path */2], unbound_class)) {
          throw [
                $$Error$9,
                scty[/* pcty_loc */1],
                env,
                /* Unbound_class_type_2 */Block.__(7, [lid[/* txt */0]])
              ];
        }
        var match$2 = instance_class(decl[/* clty_params */0], decl[/* clty_type */1]);
        var params = match$2[0];
        if (List.length(params) !== List.length(styl)) {
          throw [
                $$Error$9,
                scty[/* pcty_loc */1],
                env,
                /* Parameter_arity_mismatch */Block.__(11, [
                    lid[/* txt */0],
                    List.length(params),
                    List.length(styl)
                  ])
              ];
        }
        var ctys = List.map2((function (sty, ty) {
                var cty$prime = transl_simple_type(env, /* false */0, sty);
                var ty$prime = cty$prime[/* ctyp_type */1];
                try {
                  unify$2(env, ty$prime, ty);
                }
                catch (raw_exn){
                  var exn = Js_exn.internalToOCamlException(raw_exn);
                  if (exn[0] === Unify) {
                    throw [
                          $$Error$9,
                          sty[/* ptyp_loc */1],
                          env,
                          /* Parameter_mismatch */Block.__(12, [exn[1]])
                        ];
                  } else {
                    throw exn;
                  }
                }
                return cty$prime;
              }), styl, params);
        var typ_002 = match$2[1];
        var typ = /* Cty_constr */Block.__(0, [
            path,
            params,
            typ_002
          ]);
        return cltyp(/* Tcty_constr */Block.__(0, [
                      path,
                      lid,
                      ctys
                    ]), typ);
    case 1 : 
        var clsig = class_signature$1(env, match[0]);
        var typ$1 = /* Cty_signature */Block.__(1, [clsig[/* csig_type */2]]);
        return cltyp(/* Tcty_signature */Block.__(1, [clsig]), typ$1);
    case 2 : 
        var l = match[0];
        var cty = transl_simple_type(env, /* false */0, match[1]);
        var ty = cty[/* ctyp_type */1];
        var clty = class_type$2(env, match[2]);
        var typ_002$1 = clty[/* cltyp_type */1];
        var typ$2 = /* Cty_arrow */Block.__(2, [
            l,
            ty,
            typ_002$1
          ]);
        return cltyp(/* Tcty_arrow */Block.__(2, [
                      l,
                      cty,
                      clty
                    ]), typ$2);
    case 3 : 
        throw [
              Error_forward$2,
              error_of_extension(match[0])
            ];
    
  }
}

function class_type$3(env, scty) {
  delayed_meth_specs[0] = /* [] */0;
  var cty = class_type$2(env, scty);
  List.iter((function (prim) {
          var tag = prim.tag | 0;
          if (tag === 250) {
            return prim[0];
          } else if (tag === 246) {
            return CamlinternalLazy.force_lazy_block(prim);
          } else {
            return prim;
          }
        }), List.rev(delayed_meth_specs[0]));
  delayed_meth_specs[0] = /* [] */0;
  return cty;
}

function class_structure(cl_num, $$final, val_env, met_env, loc, param) {
  var spat = param[/* pcstr_self */0];
  var init = spat[/* ppat_loc */1];
  var self_loc_000 = /* loc_start */init[/* loc_start */0];
  var self_loc_001 = /* loc_end */init[/* loc_end */1];
  var self_loc = /* record */[
    self_loc_000,
    self_loc_001,
    /* loc_ghost : true */1
  ];
  var self_type = newvar(/* None */0, /* () */0);
  unify$2(val_env, filter_method(val_env, dummy_method, /* Private */0, self_type), newty2(current_level[0], /* Ttuple */Block.__(2, [/* [] */0])));
  var private_self = $$final ? newvar(/* None */0, /* () */0) : self_type;
  var match = type_self_pattern(cl_num, private_self, val_env, met_env, met_env, spat);
  var val_env$1 = match[3];
  var vars = match[2];
  var meths = match[1];
  var pat = match[0];
  var public_self = pat[/* pat_type */3];
  var ty;
  if ($$final) {
    var desc_000 = newvar(/* None */0, /* () */0);
    var desc_001 = [/* None */0];
    var desc = /* Tobject */Block.__(4, [
        desc_000,
        desc_001
      ]);
    ty = newty2(current_level[0], desc);
  } else {
    ty = self_type;
  }
  try {
    unify$2(val_env$1, public_self, ty);
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === Unify) {
      throw [
            $$Error$9,
            spat[/* ppat_loc */1],
            val_env$1,
            /* Pattern_type_clash */Block.__(5, [public_self])
          ];
    } else {
      throw exn;
    }
  }
  var get_methods = function (ty) {
    return flatten_fields(object_fields(expand_head(val_env$1, ty)))[0];
  };
  if ($$final) {
    List.iter((function (param) {
            var k = field_kind_repr(param[1]) ? /* Private */0 : /* Public */1;
            try {
              return unify$2(val_env$1, param[2], filter_method(val_env$1, param[0], k, self_type));
            }
            catch (exn){
              throw [
                    Caml_builtin_exceptions.assert_failure,
                    [
                      "typeclass.ml",
                      760,
                      18
                    ]
                  ];
            }
          }), get_methods(public_self));
  }
  warning_enter_scope(/* () */0);
  var match$1 = List.fold_left((function (param, param$1) {
          var self_loc$1 = self_loc;
          var cl_num$1 = cl_num;
          var self_type$1 = self_type;
          var meths$1 = meths;
          var vars$1 = vars;
          var param$2 = param;
          var cf = param$1;
          var local_vals = param$2[8];
          var local_meths = param$2[7];
          var inher = param$2[6];
          var warn_vals = param$2[5];
          var concr_meths = param$2[4];
          var fields = param$2[3];
          var par_env = param$2[2];
          var met_env = param$2[1];
          var val_env = param$2[0];
          var loc = cf[/* pcf_loc */1];
          var mkcf = function (desc) {
            return /* record */[
                    /* cf_desc */desc,
                    /* cf_loc */loc,
                    /* cf_attributes */cf[/* pcf_attributes */2]
                  ];
          };
          var match = cf[/* pcf_desc */0];
          switch (match.tag | 0) {
            case 0 : 
                var $$super = match[2];
                var sparent = match[1];
                var ovf = match[0];
                var parent = class_expr(cl_num$1, val_env, par_env, sparent);
                var match$1 = parent[/* cl_type */2];
                var inher$1;
                switch (match$1.tag | 0) {
                  case 0 : 
                      inher$1 = /* :: */[
                        /* tuple */[
                          match$1[0],
                          match$1[1]
                        ],
                        inher
                      ];
                      break;
                  case 1 : 
                  case 2 : 
                      inher$1 = inher;
                      break;
                  
                }
                var match$2 = inheritance(self_type$1, val_env, /* Some */[ovf], concr_meths, warn_vals, sparent[/* pcl_loc */1], parent[/* cl_type */2]);
                var cl_sig = match$2[0];
                var match$3 = fold((function (lab, info, param) {
                        var match = enter_val(cl_num$1, vars$1, /* true */1, lab, info[0], info[1], info[2], param[0], param[1], param[2], sparent[/* pcl_loc */1]);
                        return /* tuple */[
                                match[1],
                                match[2],
                                match[3],
                                /* :: */[
                                  /* tuple */[
                                    lab,
                                    match[0]
                                  ],
                                  param[3]
                                ]
                              ];
                      }), cl_sig[/* csig_vars */1], /* tuple */[
                      val_env,
                      met_env,
                      par_env,
                      /* [] */0
                    ]);
                var inh_vars = match$3[3];
                var par_env$1 = match$3[2];
                var met_env$1 = match$3[1];
                var val_env$1 = match$3[0];
                var inh_meths = fold$1((function (lab, rem) {
                        return /* :: */[
                                /* tuple */[
                                  lab,
                                  create(lab)
                                ],
                                rem
                              ];
                      }), cl_sig[/* csig_concr */2], /* [] */0);
                var match$4;
                if ($$super) {
                  var match$5 = enter_met_env(/* Some */[(function (s) {
                            return /* Unused_ancestor */Block.__(20, [s]);
                          })], sparent[/* pcl_loc */1], $$super[0], /* Val_anc */Block.__(3, [
                          inh_meths,
                          cl_num$1
                        ]), self_type$1, val_env$1, met_env$1, par_env$1);
                  match$4 = /* tuple */[
                    match$5[1],
                    match$5[2],
                    match$5[3]
                  ];
                } else {
                  match$4 = /* tuple */[
                    val_env$1,
                    met_env$1,
                    par_env$1
                  ];
                }
                return /* tuple */[
                        match$4[0],
                        match$4[1],
                        match$4[2],
                        /* :: */[
                          Block.__(246, [(function () {
                                  return mkcf(/* Tcf_inherit */Block.__(0, [
                                                ovf,
                                                parent,
                                                $$super,
                                                inh_vars,
                                                inh_meths
                                              ]));
                                })]),
                          fields
                        ],
                        match$2[1],
                        match$2[2],
                        inher$1,
                        local_meths,
                        local_vals
                      ];
            case 1 : 
                var match$6 = match[0];
                var match$7 = match$6[2];
                var mut = match$6[1];
                var lab = match$6[0];
                if (match$7.tag) {
                  var ovf$1 = match$7[0];
                  if (mem$2(lab[/* txt */0], local_vals)) {
                    throw [
                          $$Error$9,
                          loc,
                          val_env,
                          /* Duplicate */Block.__(24, [
                              "instance variable",
                              lab[/* txt */0]
                            ])
                        ];
                  }
                  if (mem$2(lab[/* txt */0], warn_vals)) {
                    if (ovf$1 === /* Fresh */1) {
                      prerr_warning(lab[/* loc */1], /* Instance_variable_override */Block.__(5, [/* :: */[
                                lab[/* txt */0],
                                /* [] */0
                              ]]));
                    }
                    
                  } else if (!ovf$1) {
                    throw [
                          $$Error$9,
                          loc,
                          val_env,
                          /* No_overriding */Block.__(23, [
                              "instance variable",
                              lab[/* txt */0]
                            ])
                        ];
                  }
                  if (principal[0]) {
                    begin_def(/* () */0);
                  }
                  var exp;
                  try {
                    exp = type_exp(val_env, match$7[1]);
                  }
                  catch (raw_exn){
                    var exn = Js_exn.internalToOCamlException(raw_exn);
                    if (exn[0] === Unify) {
                      var match$8 = exn[1];
                      if (match$8) {
                        if (match$8[1]) {
                          throw exn;
                        } else {
                          throw [
                                $$Error$9,
                                loc,
                                val_env,
                                /* Make_nongen_seltype */Block.__(17, [match$8[0][0]])
                              ];
                        }
                      } else {
                        throw exn;
                      }
                    } else {
                      throw exn;
                    }
                  }
                  if (principal[0]) {
                    end_def(/* () */0);
                    generalize_structure$1(current_level[0], exp[/* exp_type */3]);
                  }
                  var match$9 = enter_val(cl_num$1, vars$1, /* false */0, lab[/* txt */0], mut, /* Concrete */1, exp[/* exp_type */3], val_env, met_env, par_env, loc);
                  var met_env$prime = match$9[2];
                  var id = match$9[0];
                  return /* tuple */[
                          match$9[1],
                          met_env$prime,
                          match$9[3],
                          /* :: */[
                            Block.__(246, [(function () {
                                    return mkcf(/* Tcf_val */Block.__(1, [
                                                  lab,
                                                  mut,
                                                  id,
                                                  /* Tcfk_concrete */Block.__(1, [
                                                      ovf$1,
                                                      exp
                                                    ]),
                                                  +(met_env === met_env$prime)
                                                ]));
                                  })]),
                            fields
                          ],
                          concr_meths,
                          add$2(lab[/* txt */0], warn_vals),
                          inher,
                          local_meths,
                          add$2(lab[/* txt */0], local_vals)
                        ];
                } else {
                  if (principal[0]) {
                    begin_def(/* () */0);
                  }
                  var cty = transl_simple_type(val_env, /* false */0, match$7[0]);
                  var ty = cty[/* ctyp_type */1];
                  if (principal[0]) {
                    end_def(/* () */0);
                    generalize_structure$1(current_level[0], ty);
                  }
                  var match$10 = enter_val(cl_num$1, vars$1, /* false */0, lab[/* txt */0], mut, /* Virtual */0, ty, val_env, met_env, par_env, loc);
                  var met_env$prime$1 = match$10[2];
                  var id$1 = match$10[0];
                  return /* tuple */[
                          match$10[1],
                          met_env$prime$1,
                          match$10[3],
                          /* :: */[
                            Block.__(246, [(function () {
                                    return mkcf(/* Tcf_val */Block.__(1, [
                                                  lab,
                                                  mut,
                                                  id$1,
                                                  /* Tcfk_virtual */Block.__(0, [cty]),
                                                  +(met_env === met_env$prime$1)
                                                ]));
                                  })]),
                            fields
                          ],
                          concr_meths,
                          warn_vals,
                          inher,
                          local_meths,
                          local_vals
                        ];
                }
                break;
            case 2 : 
                var match$11 = match[0];
                var match$12 = match$11[2];
                var priv = match$11[1];
                var lab$1 = match$11[0];
                if (match$12.tag) {
                  var expr = match$12[1];
                  var ovf$2 = match$12[0];
                  var match$13 = expr[/* pexp_desc */0];
                  var expr$1;
                  expr$1 = match$13.tag === 28 ? expr : Curry._4(Ast_helper_004[/* poly */30], /* Some */[expr[/* pexp_loc */1]], /* None */0, expr, /* None */0);
                  if (mem$2(lab$1[/* txt */0], local_meths)) {
                    throw [
                          $$Error$9,
                          loc,
                          val_env,
                          /* Duplicate */Block.__(24, [
                              "method",
                              lab$1[/* txt */0]
                            ])
                        ];
                  }
                  if (mem$2(lab$1[/* txt */0], concr_meths)) {
                    if (ovf$2 === /* Fresh */1) {
                      prerr_warning(loc, /* Method_override */Block.__(2, [/* :: */[
                                lab$1[/* txt */0],
                                /* [] */0
                              ]]));
                    }
                    
                  } else if (!ovf$2) {
                    throw [
                          $$Error$9,
                          loc,
                          val_env,
                          /* No_overriding */Block.__(23, [
                              "method",
                              lab$1[/* txt */0]
                            ])
                        ];
                  }
                  var match$14 = filter_self_method(val_env, lab$1[/* txt */0], priv, meths$1, self_type$1);
                  var ty$1 = match$14[1];
                  try {
                    var match$15 = expr$1[/* pexp_desc */0];
                    if (match$15.tag === 28) {
                      var sty = match$15[1];
                      var sbody = match$15[0];
                      if (sty) {
                        var sty$1 = force_poly(sty[0]);
                        var cty$prime = transl_simple_type(val_env, /* false */0, sty$1);
                        var ty$prime = cty$prime[/* ctyp_type */1];
                        unify$2(val_env, ty$prime, ty$1);
                      }
                      var match$16 = repr(ty$1)[/* desc */0];
                      if (typeof match$16 === "number") {
                        throw [
                              Caml_builtin_exceptions.assert_failure,
                              [
                                "typeclass.ml",
                                662,
                                17
                              ]
                            ];
                      } else {
                        switch (match$16.tag | 0) {
                          case 0 : 
                              var ty$prime$1 = newvar(/* None */0, /* () */0);
                              unify$2(val_env, newty2(current_level[0], /* Tpoly */Block.__(10, [
                                          ty$prime$1,
                                          /* [] */0
                                        ])), ty$1);
                              unify$2(val_env, type_approx(val_env, sbody), ty$prime$1);
                              break;
                          case 10 : 
                              var match$17 = instance_poly(/* None */0, /* false */0, match$16[1], match$16[0]);
                              var ty2 = type_approx(val_env, sbody);
                              unify$2(val_env, ty2, match$17[1]);
                              break;
                          default:
                            throw [
                                  Caml_builtin_exceptions.assert_failure,
                                  [
                                    "typeclass.ml",
                                    662,
                                    17
                                  ]
                                ];
                        }
                      }
                    } else {
                      throw [
                            Caml_builtin_exceptions.assert_failure,
                            [
                              "typeclass.ml",
                              664,
                              13
                            ]
                          ];
                    }
                  }
                  catch (raw_exn$1){
                    var exn$1 = Js_exn.internalToOCamlException(raw_exn$1);
                    if (exn$1[0] === Unify) {
                      throw [
                            $$Error$9,
                            loc,
                            val_env,
                            /* Field_type_mismatch */Block.__(1, [
                                "method",
                                lab$1[/* txt */0],
                                exn$1[1]
                              ])
                          ];
                    } else {
                      throw exn$1;
                    }
                  }
                  var meth_expr = make_method(self_loc$1, cl_num$1, expr$1);
                  var vars_local = vars$1[0];
                  var field = Block.__(246, [(function () {
                          var meth_type = newty2(100000000, /* Tarrow */Block.__(1, [
                                  "",
                                  self_type$1,
                                  ty$1,
                                  /* Cok */0
                                ]));
                          raise_nongen_level(/* () */0);
                          vars$1[0] = vars_local;
                          var texp = type_expect(/* None */0, met_env, meth_expr, meth_type);
                          end_def(/* () */0);
                          return mkcf(/* Tcf_method */Block.__(2, [
                                        lab$1,
                                        priv,
                                        /* Tcfk_concrete */Block.__(1, [
                                            ovf$2,
                                            texp
                                          ])
                                      ]));
                        })]);
                  return /* tuple */[
                          val_env,
                          met_env,
                          par_env,
                          /* :: */[
                            field,
                            fields
                          ],
                          add$2(lab$1[/* txt */0], concr_meths),
                          warn_vals,
                          inher,
                          add$2(lab$1[/* txt */0], local_meths),
                          local_vals
                        ];
                } else {
                  var cty$1 = virtual_method(val_env, meths$1, self_type$1, lab$1[/* txt */0], priv, match$12[0], loc);
                  return /* tuple */[
                          val_env,
                          met_env,
                          par_env,
                          /* :: */[
                            Block.__(246, [(function () {
                                    return mkcf(/* Tcf_method */Block.__(2, [
                                                  lab$1,
                                                  priv,
                                                  /* Tcfk_virtual */Block.__(0, [cty$1])
                                                ]));
                                  })]),
                            fields
                          ],
                          concr_meths,
                          warn_vals,
                          inher,
                          local_meths,
                          local_vals
                        ];
                }
                break;
            case 3 : 
                var match$18 = match[0];
                var match$19 = type_constraint(val_env, match$18[0], match$18[1], loc);
                var cty$prime$1 = match$19[1];
                var cty$2 = match$19[0];
                return /* tuple */[
                        val_env,
                        met_env,
                        par_env,
                        /* :: */[
                          Block.__(246, [(function () {
                                  return mkcf(/* Tcf_constraint */Block.__(3, [
                                                cty$2,
                                                cty$prime$1
                                              ]));
                                })]),
                          fields
                        ],
                        concr_meths,
                        warn_vals,
                        inher,
                        local_meths,
                        local_vals
                      ];
            case 4 : 
                var expr$2 = make_method(self_loc$1, cl_num$1, match[0]);
                var vars_local$1 = vars$1[0];
                var field$1 = Block.__(246, [(function () {
                        raise_nongen_level(/* () */0);
                        var desc_002 = instance_def(type_unit);
                        var desc = /* Tarrow */Block.__(1, [
                            "",
                            self_type$1,
                            desc_002,
                            /* Cok */0
                          ]);
                        var meth_type = newty2(current_level[0], desc);
                        vars$1[0] = vars_local$1;
                        var texp = type_expect(/* None */0, met_env, expr$2, meth_type);
                        end_def(/* () */0);
                        return mkcf(/* Tcf_initializer */Block.__(4, [texp]));
                      })]);
                return /* tuple */[
                        val_env,
                        met_env,
                        par_env,
                        /* :: */[
                          field$1,
                          fields
                        ],
                        concr_meths,
                        warn_vals,
                        inher,
                        local_meths,
                        local_vals
                      ];
            case 5 : 
                var x = match[0];
                warning_attribute(/* :: */[
                      x,
                      /* [] */0
                    ]);
                return /* tuple */[
                        val_env,
                        met_env,
                        par_env,
                        /* :: */[
                          Block.__(246, [(function () {
                                  return mkcf(/* Tcf_attribute */Block.__(5, [x]));
                                })]),
                          fields
                        ],
                        concr_meths,
                        warn_vals,
                        inher,
                        local_meths,
                        local_vals
                      ];
            case 6 : 
                throw [
                      Error_forward$2,
                      error_of_extension(match[0])
                    ];
            
          }
        }), /* tuple */[
        val_env$1,
        match[4],
        match[5],
        /* [] */0,
        /* Empty */0,
        /* Empty */0,
        /* [] */0,
        /* Empty */0,
        /* Empty */0
      ], param[/* pcstr_fields */1]);
  var inher = match$1[6];
  var concr_meths = match$1[4];
  warning_leave_scope(/* () */0);
  unify$2(val_env$1, self_type, newvar(/* None */0, /* () */0));
  var sign_001 = /* csig_vars */map((function (param) {
          return /* tuple */[
                  param[1],
                  param[2],
                  param[3]
                ];
        }), vars[0]);
  var sign = /* record */[
    /* csig_self */public_self,
    sign_001,
    /* csig_concr */concr_meths,
    /* csig_inher */inher
  ];
  var methods = get_methods(self_type);
  var priv_meths = List.filter((function (param) {
            return +(field_kind_repr(param[1]) !== /* Fpresent */0);
          }))(methods);
  if ($$final) {
    close_object(self_type);
    var mets = virtual_methods(/* record */[
          /* csig_self */self_type,
          sign_001,
          /* csig_concr */concr_meths,
          /* csig_inher */inher
        ]);
    var vals = fold((function (name, param, l) {
            if (param[1]) {
              return l;
            } else {
              return /* :: */[
                      name,
                      l
                    ];
            }
          }), sign_001, /* [] */0);
    if (mets !== /* [] */0 || vals !== /* [] */0) {
      throw [
            $$Error$9,
            loc,
            val_env$1,
            /* Virtual_class */Block.__(10, [
                /* true */1,
                $$final,
                mets,
                vals
              ])
          ];
    }
    var self_methods = List.fold_right((function (param, rem) {
            var kind = param[1];
            var lab = param[0];
            if (lab === dummy_method) {
              var match = field_kind_repr(kind);
              if (typeof match === "number") {
                return rem;
              } else {
                set_kind(match[0], /* Fabsent */1);
                return rem;
              }
            } else {
              var desc_001 = copy_kind(kind);
              var desc_002 = param[2];
              var desc = /* Tfield */Block.__(5, [
                  lab,
                  desc_001,
                  desc_002,
                  rem
                ]);
              return newty2(current_level[0], desc);
            }
          }), methods, newty2(current_level[0], /* Tnil */0));
    try {
      unify$2(val_env$1, private_self, newty2(current_level[0], /* Tobject */Block.__(4, [
                  self_methods,
                  [/* None */0]
                ])));
      unify$2(val_env$1, public_self, self_type);
    }
    catch (raw_exn$1){
      var exn$1 = Js_exn.internalToOCamlException(raw_exn$1);
      if (exn$1[0] === Unify) {
        throw [
              $$Error$9,
              loc,
              val_env$1,
              /* Final_self_clash */Block.__(21, [exn$1[1]])
            ];
      } else {
        throw exn$1;
      }
    }
  }
  if (principal[0]) {
    List.iter((function (param) {
            return generalize_spine(param[2]);
          }), methods);
  }
  var fields = List.map((function (prim) {
          var tag = prim.tag | 0;
          if (tag === 250) {
            return prim[0];
          } else if (tag === 246) {
            return CamlinternalLazy.force_lazy_block(prim);
          } else {
            return prim;
          }
        }), List.rev(match$1[3]));
  if (principal[0]) {
    List.iter((function (param) {
            return unify$2(val_env$1, param[2], newvar(/* None */0, /* () */0));
          }), methods);
  }
  var meths$1 = map((function (param) {
          return param[0];
        }), meths[0]);
  var pub_meths$prime = List.filter((function (param) {
            return +(field_kind_repr(param[1]) === /* Fpresent */0);
          }))(get_methods(public_self));
  var names = function (param) {
    return List.map((function (param) {
                  return param[0];
                }), param);
  };
  var l1 = names(priv_meths);
  var l2 = names(pub_meths$prime);
  var added = List.filter((function (x) {
            return List.mem(x, l1);
          }))(l2);
  if (added !== /* [] */0) {
    prerr_warning(loc, /* Implicit_public_methods */Block.__(6, [added]));
  }
  var sign$1 = $$final ? sign : /* record */[
      /* csig_self */expand_head(val_env$1, public_self),
      sign_001,
      /* csig_concr */concr_meths,
      /* csig_inher */inher
    ];
  return /* tuple */[
          /* record */[
            /* cstr_self */pat,
            /* cstr_fields */fields,
            /* cstr_type */sign$1,
            /* cstr_meths */meths$1
          ],
          sign$1
        ];
}

function class_expr(cl_num, val_env, met_env, _scl) {
  while(true) {
    var scl = _scl;
    var match = scl[/* pcl_desc */0];
    switch (match.tag | 0) {
      case 0 : 
          var lid = match[0];
          var match$1 = find_class$1(val_env, scl[/* pcl_loc */1], lid[/* txt */0]);
          var decl = match$1[1];
          var path = match$1[0];
          if (same(decl[/* cty_path */2], unbound_class)) {
            throw [
                  $$Error$9,
                  scl[/* pcl_loc */1],
                  val_env,
                  /* Unbound_class_2 */Block.__(6, [lid[/* txt */0]])
                ];
          }
          var tyl = List.map((function (sty) {
                  return transl_simple_type(val_env, /* false */0, sty);
                }), match[1]);
          var match$2 = instance_class(decl[/* cty_params */0], decl[/* cty_type */1]);
          var clty = match$2[1];
          var params = match$2[0];
          var clty$prime = abbreviate_class_type(path, params, clty);
          if (List.length(params) !== List.length(tyl)) {
            throw [
                  $$Error$9,
                  scl[/* pcl_loc */1],
                  val_env,
                  /* Parameter_arity_mismatch */Block.__(11, [
                      lid[/* txt */0],
                      List.length(params),
                      List.length(tyl)
                    ])
                ];
          }
          List.iter2((function (cty$prime, ty) {
                  var ty$prime = cty$prime[/* ctyp_type */1];
                  try {
                    return unify$2(val_env, ty$prime, ty);
                  }
                  catch (raw_exn){
                    var exn = Js_exn.internalToOCamlException(raw_exn);
                    if (exn[0] === Unify) {
                      throw [
                            $$Error$9,
                            cty$prime[/* ctyp_loc */3],
                            val_env,
                            /* Parameter_mismatch */Block.__(12, [exn[1]])
                          ];
                    } else {
                      throw exn;
                    }
                  }
                }), tyl, params);
          var cl = rc(/* record */[
                /* cl_desc : Tcl_ident */Block.__(0, [
                    path,
                    lid,
                    tyl
                  ]),
                /* cl_loc */scl[/* pcl_loc */1],
                /* cl_type */clty$prime,
                /* cl_env */val_env,
                /* cl_attributes */scl[/* pcl_attributes */2]
              ]);
          var match$3 = extract_constraints(clty);
          return rc(/* record */[
                      /* cl_desc : Tcl_constraint */Block.__(5, [
                          cl,
                          /* None */0,
                          match$3[0],
                          match$3[1],
                          match$3[2]
                        ]),
                      /* cl_loc */scl[/* pcl_loc */1],
                      /* cl_type */clty$prime,
                      /* cl_env */val_env,
                      /* cl_attributes : [] */0
                    ]);
      case 1 : 
          var match$4 = class_structure(cl_num, /* false */0, val_env, met_env, scl[/* pcl_loc */1], match[0]);
          return rc(/* record */[
                      /* cl_desc : Tcl_structure */Block.__(1, [match$4[0]]),
                      /* cl_loc */scl[/* pcl_loc */1],
                      /* cl_type : Cty_signature */Block.__(1, [match$4[1]]),
                      /* cl_env */val_env,
                      /* cl_attributes */scl[/* pcl_attributes */2]
                    ]);
      case 2 : 
          var match$5 = match[1];
          var l = match[0];
          if (match$5) {
            var $$default = match$5[0];
            var loc = $$default[/* pexp_loc */1];
            var scases_000 = Curry._3(Ast_helper_004[/* case */36], construct(/* Some */[loc], /* None */0, /* record */[
                      /* txt : Ldot */Block.__(1, [
                          /* Lident */Block.__(0, ["*predef*"]),
                          "Some"
                        ]),
                      /* loc */none
                    ], /* Some */[$$var$1(/* Some */[loc], /* None */0, /* record */[
                            /* txt */"*sth*",
                            /* loc */none
                          ])]), /* None */0, Curry._3(Ast_helper_004[/* ident */2], /* Some */[loc], /* None */0, /* record */[
                      /* txt : Lident */Block.__(0, ["*sth*"]),
                      /* loc */none
                    ]));
            var scases_001 = /* :: */[
              Curry._3(Ast_helper_004[/* case */36], construct(/* Some */[loc], /* None */0, /* record */[
                        /* txt : Ldot */Block.__(1, [
                            /* Lident */Block.__(0, ["*predef*"]),
                            "None"
                          ]),
                        /* loc */none
                      ], /* None */0), /* None */0, $$default),
              /* [] */0
            ];
            var scases = /* :: */[
              scases_000,
              scases_001
            ];
            var smatch = Curry._4(Ast_helper_004[/* match_ */8], /* Some */[loc], /* None */0, Curry._3(Ast_helper_004[/* ident */2], /* Some */[loc], /* None */0, /* record */[
                      /* txt : Lident */Block.__(0, ["*opt*"]),
                      /* loc */none
                    ]), scases);
            var sfun = fun_$1(/* Some */[scl[/* pcl_loc */1]], /* None */0, l, /* None */0, $$var$1(/* Some */[loc], /* None */0, /* record */[
                      /* txt */"*opt*",
                      /* loc */none
                    ]), let_$1(/* Some */[scl[/* pcl_loc */1]], /* None */0, /* Nonrecursive */0, /* :: */[
                      mk$17(/* None */0, /* None */0, /* None */0, /* None */0, match[2], smatch),
                      /* [] */0
                    ], match[3]));
            _scl = sfun;
            continue ;
            
          } else {
            if (principal[0]) {
              begin_def(/* () */0);
            }
            var match$6 = type_class_arg_pattern(cl_num, val_env, met_env, l, match[2]);
            var val_env$prime = match$6[2];
            var pat = match$6[0];
            if (principal[0]) {
              end_def(/* () */0);
              iter_pattern((function (param) {
                      return generalize_structure$1(current_level[0], param[/* pat_type */3]);
                    }), pat);
            }
            var pv = List.map((function(val_env$prime){
                return function (param) {
                  var id = param[0];
                  var path = /* Pident */Block.__(0, [param[2]]);
                  var vd = find_value(path, val_env$prime);
                  return /* tuple */[
                          id,
                          param[1],
                          /* record */[
                            /* exp_desc : Texp_ident */Block.__(0, [
                                path,
                                /* record */[
                                  /* txt : Lident */Block.__(0, [id[/* name */1]]),
                                  /* loc */none
                                ],
                                vd
                              ]),
                            /* exp_loc */none,
                            /* exp_extra : [] */0,
                            /* exp_type */instance(/* None */0, val_env$prime, vd[/* val_type */0]),
                            /* exp_env */val_env$prime,
                            /* exp_attributes : [] */0
                          ]
                        ];
                }
                }(val_env$prime)), match$6[1]);
            var not_function = function (param) {
              switch (param.tag | 0) {
                case 0 : 
                case 1 : 
                    return /* true */1;
                case 2 : 
                    return /* false */0;
                
              }
            };
            var partial = check_partial$1(/* None */0, val_env, pat[/* pat_type */3])(pat[/* pat_loc */1], /* :: */[
                  /* record */[
                    /* c_lhs */pat,
                    /* c_guard : None */0,
                    /* c_rhs : record */[
                      /* exp_desc : Texp_constant */Block.__(1, [/* Const_int */Block.__(0, [1])]),
                      /* exp_loc */none,
                      /* exp_extra : [] */0,
                      /* exp_type */none$2,
                      /* exp_env */empty,
                      /* exp_attributes : [] */0
                    ]
                  ],
                  /* [] */0
                ]);
            raise_nongen_level(/* () */0);
            var cl$1 = class_expr(cl_num, val_env$prime, match$6[3], match[3]);
            end_def(/* () */0);
            if (is_optional(l) && not_function(cl$1[/* cl_type */2])) {
              prerr_warning(pat[/* pat_loc */1], /* Unerasable_optional_argument */8);
            }
            return rc(/* record */[
                        /* cl_desc : Tcl_fun */Block.__(2, [
                            l,
                            pat,
                            pv,
                            cl$1,
                            partial
                          ]),
                        /* cl_loc */scl[/* pcl_loc */1],
                        /* cl_type : Cty_arrow */Block.__(2, [
                            l,
                            instance_def(pat[/* pat_type */3]),
                            cl$1[/* cl_type */2]
                          ]),
                        /* cl_env */val_env,
                        /* cl_attributes */scl[/* pcl_attributes */2]
                      ]);
          }
          break;
      case 3 : 
          var sargs = match[1];
          if (!sargs) {
            ill_formed_ast(scl[/* pcl_loc */1], "Function application with no argument.");
          }
          if (principal[0]) {
            begin_def(/* () */0);
          }
          var cl$2 = class_expr(cl_num, val_env, met_env, match[0]);
          if (principal[0]) {
            end_def(/* () */0);
            generalize_class_type(/* false */0)(cl$2[/* cl_type */2]);
          }
          var nonopt_labels = function (_ls, _ty_fun) {
            while(true) {
              var ty_fun = _ty_fun;
              var ls = _ls;
              switch (ty_fun.tag | 0) {
                case 0 : 
                case 1 : 
                    return ls;
                case 2 : 
                    var ty_res = ty_fun[2];
                    var l = ty_fun[0];
                    if (is_optional(l)) {
                      _ty_fun = ty_res;
                      continue ;
                      
                    } else {
                      _ty_fun = ty_res;
                      _ls = /* :: */[
                        l,
                        ls
                      ];
                      continue ;
                      
                    }
                    break;
                
              }
            };
          };
          var labels = nonopt_labels(/* [] */0, cl$2[/* cl_type */2]);
          var ignore_labels = classic[0] || +(List.length(labels) === List.length(sargs)) && List.for_all((function (param) {
                  return +(param[0] === "");
                }), sargs) && List.exists((function (l) {
                  return +(l !== "");
                }), labels) && (prerr_warning(cl$2[/* cl_loc */1], /* Labels_omitted */3), /* true */1);
          var type_args = (function(cl$2,ignore_labels){
          return function type_args(_args, _omitted, _ty_fun, _ty_fun0, _sargs, _more_sargs) {
            while(true) {
              var more_sargs = _more_sargs;
              var sargs = _sargs;
              var ty_fun0 = _ty_fun0;
              var ty_fun = _ty_fun;
              var omitted = _omitted;
              var args = _args;
              var exit = 0;
              switch (ty_fun.tag | 0) {
                case 0 : 
                case 1 : 
                    exit = 1;
                    break;
                case 2 : 
                    var ty = ty_fun[1];
                    var l = ty_fun[0];
                    switch (ty_fun0.tag | 0) {
                      case 0 : 
                      case 1 : 
                          exit = 1;
                          break;
                      case 2 : 
                          if (sargs !== /* [] */0 || more_sargs !== /* [] */0) {
                            var ty0 = ty_fun0[1];
                            var name = label_name(l);
                            var optional = is_optional(l) ? /* Optional */1 : /* Required */0;
                            var match;
                            if (ignore_labels && !is_optional(l)) {
                              if (sargs) {
                                var match$1 = sargs[0];
                                throw [
                                      $$Error$9,
                                      match$1[1][/* pexp_loc */1],
                                      val_env,
                                      /* Apply_wrong_label */Block.__(4, [match$1[0]])
                                    ];
                              } else if (more_sargs) {
                                var match$2 = more_sargs[0];
                                var sarg0 = match$2[1];
                                var l$prime = match$2[0];
                                if (l !== l$prime && l$prime !== "") {
                                  throw [
                                        $$Error$9,
                                        sarg0[/* pexp_loc */1],
                                        val_env,
                                        /* Apply_wrong_label */Block.__(4, [l$prime])
                                      ];
                                } else {
                                  match = /* tuple */[
                                    /* [] */0,
                                    more_sargs[1],
                                    /* Some */[type_argument(val_env, sarg0, ty, ty0)]
                                  ];
                                }
                              } else {
                                throw [
                                      Caml_builtin_exceptions.assert_failure,
                                      [
                                        "typeclass.ml",
                                        1017,
                                        20
                                      ]
                                    ];
                              }
                            } else {
                              try {
                                var match$3;
                                try {
                                  var match$4 = extract_label_aux(/* [] */0, name, sargs);
                                  match$3 = /* tuple */[
                                    match$4[0],
                                    match$4[1],
                                    Pervasives.$at(match$4[2], match$4[3]),
                                    more_sargs
                                  ];
                                }
                                catch (exn){
                                  if (exn === Caml_builtin_exceptions.not_found) {
                                    var match$5 = extract_label_aux(/* [] */0, name, more_sargs);
                                    match$3 = /* tuple */[
                                      match$5[0],
                                      match$5[1],
                                      Pervasives.$at(sargs, match$5[2]),
                                      match$5[3]
                                    ];
                                  } else {
                                    throw exn;
                                  }
                                }
                                var sarg0$1 = match$3[1];
                                var l$prime$1 = match$3[0];
                                if (optional === /* Required */0 && is_optional(l$prime$1)) {
                                  prerr_warning(sarg0$1[/* pexp_loc */1], /* Nonoptional_label */Block.__(26, [l]));
                                }
                                var $js;
                                if (optional === /* Required */0 || is_optional(l$prime$1)) {
                                  $js = /* Some */[type_argument(val_env, sarg0$1, ty, ty0)];
                                } else {
                                  var ty$prime = extract_option_type(val_env, ty);
                                  var ty0$prime = extract_option_type(val_env, ty0);
                                  var arg = type_argument(val_env, sarg0$1, ty$prime, ty0$prime);
                                  $js = /* Some */[option_some(arg)];
                                }
                                match = /* tuple */[
                                  match$3[2],
                                  match$3[3],
                                  $js
                                ];
                              }
                              catch (exn$1){
                                if (exn$1 === Caml_builtin_exceptions.not_found) {
                                  match = /* tuple */[
                                    sargs,
                                    more_sargs,
                                    is_optional(l) && (List.mem_assoc("", sargs) || List.mem_assoc("", more_sargs)) ? /* Some */[option_none(ty0, none)] : /* None */0
                                  ];
                                } else {
                                  throw exn$1;
                                }
                              }
                            }
                            var arg$1 = match[2];
                            var omitted$1 = arg$1 ? omitted : /* :: */[
                                /* tuple */[
                                  l,
                                  ty0
                                ],
                                omitted
                              ];
                            _more_sargs = match[1];
                            _sargs = match[0];
                            _ty_fun0 = ty_fun0[2];
                            _ty_fun = ty_fun[2];
                            _omitted = omitted$1;
                            _args = /* :: */[
                              /* tuple */[
                                l,
                                arg$1,
                                optional
                              ],
                              args
                            ];
                            continue ;
                            
                          } else {
                            exit = 1;
                          }
                          break;
                      
                    }
                    break;
                
              }
              if (exit === 1) {
                var match$6 = Pervasives.$at(sargs, more_sargs);
                if (match$6) {
                  if (omitted !== /* [] */0) {
                    var match$7 = match$6[0];
                    throw [
                          $$Error$9,
                          match$7[1][/* pexp_loc */1],
                          val_env,
                          /* Apply_wrong_label */Block.__(4, [match$7[0]])
                        ];
                  } else {
                    throw [
                          $$Error$9,
                          cl$2[/* cl_loc */1],
                          val_env,
                          /* Cannot_apply */Block.__(3, [cl$2[/* cl_type */2]])
                        ];
                  }
                } else {
                  return /* tuple */[
                          List.rev(args),
                          List.fold_left((function (ty_fun, param) {
                                  return /* Cty_arrow */Block.__(2, [
                                            param[0],
                                            param[1],
                                            ty_fun
                                          ]);
                                }), ty_fun0, omitted)
                        ];
                }
              }
              
            };
          }
          }(cl$2,ignore_labels));
          var match$7 = instance_class(/* [] */0, cl$2[/* cl_type */2]);
          var ty_fun0 = match$7[1];
          var match$8 = ignore_labels ? type_args(/* [] */0, /* [] */0, cl$2[/* cl_type */2], ty_fun0, /* [] */0, sargs) : type_args(/* [] */0, /* [] */0, cl$2[/* cl_type */2], ty_fun0, sargs, /* [] */0);
          return rc(/* record */[
                      /* cl_desc : Tcl_apply */Block.__(3, [
                          cl$2,
                          match$8[0]
                        ]),
                      /* cl_loc */scl[/* pcl_loc */1],
                      /* cl_type */match$8[1],
                      /* cl_env */val_env,
                      /* cl_attributes */scl[/* pcl_attributes */2]
                    ]);
      case 4 : 
          var rec_flag = match[0];
          var match$9;
          try {
            match$9 = type_let$1(val_env, rec_flag, match[1], /* None */0);
          }
          catch (raw_exn){
            var exn = Js_exn.internalToOCamlException(raw_exn);
            if (exn[0] === Unify) {
              var match$10 = exn[1];
              if (match$10) {
                if (match$10[1]) {
                  throw exn;
                } else {
                  throw [
                        $$Error$9,
                        scl[/* pcl_loc */1],
                        val_env,
                        /* Make_nongen_seltype */Block.__(17, [match$10[0][0]])
                      ];
                }
              } else {
                throw exn;
              }
            } else {
              throw exn;
            }
          }
          var val_env$1 = match$9[1];
          var defs = match$9[0];
          var match$11 = List.fold_right((function(val_env$1){
              return function (param, param$1) {
                var id = param[0];
                var path = /* Pident */Block.__(0, [id]);
                var vd = find_value(path, val_env$1);
                begin_def(/* () */0);
                var expr_000 = /* exp_desc : Texp_ident */Block.__(0, [
                    path,
                    /* record */[
                      /* txt : Lident */Block.__(0, [id[/* name */1]]),
                      /* loc */none
                    ],
                    vd
                  ]);
                var expr_003 = /* exp_type */instance(/* None */0, val_env$1, vd[/* val_type */0]);
                var expr = /* record */[
                  expr_000,
                  /* exp_loc */none,
                  /* exp_extra : [] */0,
                  expr_003,
                  /* exp_env */val_env$1,
                  /* exp_attributes : [] */0
                ];
                end_def(/* () */0);
                iter_generalize$1([/* [] */0], expr_003);
                var desc_000 = expr_003;
                var desc_001 = /* val_kind : Val_ivar */Block.__(1, [
                    /* Immutable */0,
                    cl_num
                  ]);
                var desc_002 = /* val_loc */vd[/* val_loc */2];
                var desc = /* record */[
                  desc_000,
                  desc_001,
                  desc_002,
                  /* val_attributes : [] */0
                ];
                var id$prime = create(id[/* name */1]);
                return /* tuple */[
                        /* :: */[
                          /* tuple */[
                            id$prime,
                            param[1],
                            expr
                          ],
                          param$1[0]
                        ],
                        add_value(/* None */0, id$prime, desc, param$1[1])
                      ];
              }
              }(val_env$1)), List.rev(rev_let_bound_idents_with_loc(defs)), /* tuple */[
                /* [] */0,
                met_env
              ]);
          var cl$3 = class_expr(cl_num, val_env$1, match$11[1], match[2]);
          return rc(/* record */[
                      /* cl_desc : Tcl_let */Block.__(4, [
                          rec_flag,
                          defs,
                          match$11[0],
                          cl$3
                        ]),
                      /* cl_loc */scl[/* pcl_loc */1],
                      /* cl_type */cl$3[/* cl_type */2],
                      /* cl_env */val_env$1,
                      /* cl_attributes */scl[/* pcl_attributes */2]
                    ]);
      case 5 : 
          begin_class_def(/* () */0);
          var context = narrow(/* () */0);
          var cl$4 = class_expr(cl_num, val_env, met_env, match[0]);
          widen(context);
          var context$1 = narrow(/* () */0);
          var clty$1 = class_type$3(val_env, match[1]);
          widen(context$1);
          end_def(/* () */0);
          limited_generalize$1(row_variable(repr(signature_of_class_type(cl$4[/* cl_type */2])[/* csig_self */0])), cl$4[/* cl_type */2]);
          limited_generalize$1(row_variable(repr(signature_of_class_type(clty$1[/* cltyp_type */1])[/* csig_self */0])), clty$1[/* cltyp_type */1]);
          var error = class_types(val_env, cl$4[/* cl_type */2], clty$1[/* cltyp_type */1]);
          if (error) {
            throw [
                  $$Error$9,
                  cl$4[/* cl_loc */1],
                  val_env,
                  /* Class_match_failure */Block.__(14, [error])
                ];
          }
          var match$12 = extract_constraints(clty$1[/* cltyp_type */1]);
          return rc(/* record */[
                      /* cl_desc : Tcl_constraint */Block.__(5, [
                          cl$4,
                          /* Some */[clty$1],
                          match$12[0],
                          match$12[1],
                          match$12[2]
                        ]),
                      /* cl_loc */scl[/* pcl_loc */1],
                      /* cl_type */instance_class(/* [] */0, clty$1[/* cltyp_type */1])[1],
                      /* cl_env */val_env,
                      /* cl_attributes */scl[/* pcl_attributes */2]
                    ]);
      case 6 : 
          throw [
                Error_forward$2,
                error_of_extension(match[0])
              ];
      
    }
  };
}

var var_option = type_option(newty2(100000000, /* Tvar */Block.__(0, [/* None */0])));

function approx_declaration(_cl) {
  while(true) {
    var cl = _cl;
    var match = cl[/* pcl_desc */0];
    switch (match.tag | 0) {
      case 2 : 
          var l = match[0];
          var arg = is_optional(l) ? instance_def(var_option) : newvar(/* None */0, /* () */0);
          var desc_002 = approx_declaration(match[3]);
          var desc = /* Tarrow */Block.__(1, [
              l,
              arg,
              desc_002,
              /* Cok */0
            ]);
          return newty2(current_level[0], desc);
      case 4 : 
          _cl = match[2];
          continue ;
          case 5 : 
          _cl = match[0];
          continue ;
          default:
        return newvar(/* None */0, /* () */0);
    }
  };
}

function approx_description(ct) {
  var match = ct[/* pcty_desc */0];
  if (match.tag === 2) {
    var l = match[0];
    var arg = is_optional(l) ? instance_def(var_option) : newvar(/* None */0, /* () */0);
    var desc_002 = approx_description(match[2]);
    var desc = /* Tarrow */Block.__(1, [
        l,
        arg,
        desc_002,
        /* Cok */0
      ]);
    return newty2(current_level[0], desc);
  } else {
    return newvar(/* None */0, /* () */0);
  }
}

function temp_abbrev(loc, env, id, arity) {
  var params = /* [] */0;
  for(var _i = 1; _i <= arity; ++_i){
    params = /* :: */[
      newvar(/* None */0, /* () */0),
      params
    ];
  }
  var ty = newobj(newvar(/* None */0, /* () */0));
  var env$1 = add_type$1(/* true */1, id, /* record */[
        /* type_params */params,
        /* type_arity */arity,
        /* type_kind : Type_abstract */0,
        /* type_private : Public */1,
        /* type_manifest : Some */[ty],
        /* type_variance */replicate_list(Types_003[/* full */1], arity),
        /* type_newtype_level : None */0,
        /* type_loc */loc,
        /* type_attributes : [] */0
      ], env);
  return /* tuple */[
          params,
          ty,
          env$1
        ];
}

function extract_type_decls(param, decls) {
  return /* :: */[
          /* tuple */[
            param[5],
            param[6],
            param[8],
            param[2],
            param[4],
            param[13]
          ],
          decls
        ];
}

function merge_type_decls(param, param$1) {
  return /* tuple */[
          param[0],
          param[1],
          param$1[2],
          param[3],
          param$1[3],
          param[5],
          param$1[0],
          param[7],
          param$1[1],
          param[9],
          param[10],
          param[11],
          param[12],
          param[13]
        ];
}

function type_classes(define_class, approx, kind, env, cls) {
  var cls$1 = List.map((function (cl) {
          return /* tuple */[
                  cl,
                  create(cl[/* pci_name */2][/* txt */0]),
                  create(cl[/* pci_name */2][/* txt */0]),
                  create(cl[/* pci_name */2][/* txt */0]),
                  create("#" + cl[/* pci_name */2][/* txt */0])
                ];
        }), cls);
  init_def(currentstamp[0]);
  begin_class_def(/* () */0);
  var match = List.fold_left((function (param, param$1) {
          var define_class$1 = define_class;
          var approx$1 = approx;
          var param$2 = param;
          var param$3 = param$1;
          var cl_id = param$3[4];
          var obj_id = param$3[3];
          var ty_id = param$3[2];
          var id = param$3[1];
          var cl = param$3[0];
          var arity = List.length(cl[/* pci_params */1]);
          var match = temp_abbrev(cl[/* pci_loc */4], param$2[1], obj_id, arity);
          var match$1 = temp_abbrev(cl[/* pci_loc */4], match[2], cl_id, arity);
          var env = match$1[2];
          var constr_type = Curry._1(approx$1, cl[/* pci_expr */3]);
          if (principal[0]) {
            generalize_spine(constr_type);
          }
          var dummy_cty = /* Cty_signature */Block.__(1, [/* record */[
                /* csig_self */newvar(/* None */0, /* () */0),
                /* csig_vars : Empty */0,
                /* csig_concr : Empty */0,
                /* csig_inher : [] */0
              ]]);
          var match$2 = cl[/* pci_virt */0];
          var dummy_class = /* record */[
            /* cty_params : [] */0,
            /* cty_type */dummy_cty,
            /* cty_path */unbound_class,
            /* cty_new */match$2 !== 0 ? /* Some */[constr_type] : /* None */0,
            /* cty_variance : [] */0,
            /* cty_loc */none,
            /* cty_attributes : [] */0
          ];
          var env$1 = add_cltype(ty_id, /* record */[
                /* clty_params : [] */0,
                /* clty_type */dummy_cty,
                /* clty_path */unbound_class,
                /* clty_variance : [] */0,
                /* clty_loc */none,
                /* clty_attributes : [] */0
              ], define_class$1 ? add_class(id, dummy_class, env) : env);
          return /* tuple */[
                  /* :: */[
                    /* tuple */[
                      cl,
                      id,
                      ty_id,
                      obj_id,
                      match[0],
                      match[1],
                      cl_id,
                      match$1[0],
                      match$1[1],
                      constr_type,
                      dummy_class
                    ],
                    param$2[0]
                  ],
                  env$1
                ];
        }), /* tuple */[
        /* [] */0,
        env
      ], cls$1);
  var match$1 = List.fold_right((function (param, param$1) {
          var define_class$1 = define_class;
          var kind$1 = kind;
          var param$2 = param;
          var param$3 = param$1;
          var env = param$3[1];
          var constr_type = param$2[9];
          var cl_ty = param$2[8];
          var cl_params = param$2[7];
          var cl_id = param$2[6];
          var obj_ty = param$2[5];
          var obj_params = param$2[4];
          var obj_id = param$2[3];
          var ty_id = param$2[2];
          var id = param$2[1];
          var cl = param$2[0];
          reset_type_variables(/* () */0);
          begin_class_def(/* () */0);
          var make_param = function (param) {
            var sty = param[0];
            try {
              return /* tuple */[
                      transl_type_param(env, sty),
                      param[1]
                    ];
            }
            catch (exn){
              if (exn === Already_bound) {
                throw [
                      $$Error$9,
                      sty[/* ptyp_loc */1],
                      env,
                      /* Repeated_parameter */0
                    ];
              } else {
                throw exn;
              }
            }
          };
          var ci_params = List.map(make_param, cl[/* pci_params */1]);
          var params = List.map((function (param) {
                  return param[0][/* ctyp_type */1];
                }), ci_params);
          var coercion_locs = [/* [] */0];
          var match;
          try {
            self_coercion[0] = /* :: */[
              /* tuple */[
                /* Pident */Block.__(0, [obj_id]),
                coercion_locs
              ],
              self_coercion[0]
            ];
            var res = Curry._2(kind$1, env, cl[/* pci_expr */3]);
            self_coercion[0] = List.tl(self_coercion[0]);
            match = res;
          }
          catch (exn){
            self_coercion[0] = /* [] */0;
            throw exn;
          }
          var typ = match[1];
          end_def(/* () */0);
          var sty = repr(signature_of_class_type(typ)[/* csig_self */0]);
          var match$1 = flatten_fields(object_fields(sty));
          List.iter((function (param) {
                  if (param[0] === dummy_method) {
                    return iter_generalize$1([/* [] */0], param[2]);
                  } else {
                    return 0;
                  }
                }), match$1[0]);
          var rv = row_variable(sty);
          List.iter((function (param) {
                  return limited_generalize(rv, param);
                }), params);
          limited_generalize$1(rv, typ);
          var match$2 = instance_class(params, typ);
          var obj_type = match$2[1];
          var obj_params$prime = match$2[0];
          var constr = newconstr(/* Pident */Block.__(0, [obj_id]), obj_params);
          var ty = repr(signature_of_class_type(obj_type)[/* csig_self */0]);
          hide_private_methods(ty);
          close_object(ty);
          try {
            List.iter2((function (param, param$1) {
                    return unify$2(env, param, param$1);
                  }), obj_params, obj_params$prime);
          }
          catch (raw_exn){
            var exn$1 = Js_exn.internalToOCamlException(raw_exn);
            if (exn$1[0] === Unify) {
              throw [
                    $$Error$9,
                    cl[/* pci_loc */4],
                    env,
                    /* Bad_parameters */Block.__(13, [
                        obj_id,
                        constr,
                        newconstr(/* Pident */Block.__(0, [obj_id]), obj_params$prime)
                      ])
                  ];
            } else {
              throw exn$1;
            }
          }
          try {
            unify$2(env, ty, constr);
          }
          catch (raw_exn$1){
            var exn$2 = Js_exn.internalToOCamlException(raw_exn$1);
            if (exn$2[0] === Unify) {
              throw [
                    $$Error$9,
                    cl[/* pci_loc */4],
                    env,
                    /* Abbrev_type_clash */Block.__(8, [
                        constr,
                        ty,
                        expand_head(env, constr)
                      ])
                  ];
            } else {
              throw exn$2;
            }
          }
          var match$3 = instance_class(params, typ);
          var cl_params$prime = match$3[0];
          var ty$1 = repr(signature_of_class_type(match$3[1])[/* csig_self */0]);
          hide_private_methods(ty$1);
          set_object_name(obj_id, row_variable(ty$1), cl_params, ty$1);
          try {
            List.iter2((function (param, param$1) {
                    return unify$2(env, param, param$1);
                  }), cl_params, cl_params$prime);
          }
          catch (raw_exn$2){
            var exn$3 = Js_exn.internalToOCamlException(raw_exn$2);
            if (exn$3[0] === Unify) {
              throw [
                    $$Error$9,
                    cl[/* pci_loc */4],
                    env,
                    /* Bad_parameters */Block.__(13, [
                        cl_id,
                        newconstr(/* Pident */Block.__(0, [cl_id]), cl_params),
                        newconstr(/* Pident */Block.__(0, [cl_id]), cl_params$prime)
                      ])
                  ];
            } else {
              throw exn$3;
            }
          }
          try {
            unify$2(env, ty$1, cl_ty);
          }
          catch (raw_exn$3){
            var exn$4 = Js_exn.internalToOCamlException(raw_exn$3);
            if (exn$4[0] === Unify) {
              var constr$1 = newconstr(/* Pident */Block.__(0, [cl_id]), params);
              throw [
                    $$Error$9,
                    cl[/* pci_loc */4],
                    env,
                    /* Abbrev_type_clash */Block.__(8, [
                        constr$1,
                        ty$1,
                        cl_ty
                      ])
                  ];
            } else {
              throw exn$4;
            }
          }
          try {
            unify$2(env, constructor_type(constr, obj_type), instance(/* None */0, env, constr_type));
          }
          catch (raw_exn$4){
            var exn$5 = Js_exn.internalToOCamlException(raw_exn$4);
            if (exn$5[0] === Unify) {
              throw [
                    $$Error$9,
                    cl[/* pci_loc */4],
                    env,
                    /* Constructor_type_mismatch */Block.__(9, [
                        cl[/* pci_name */2][/* txt */0],
                        exn$5[1]
                      ])
                  ];
            } else {
              throw exn$5;
            }
          }
          var cty_variance = List.map((function () {
                  return Types_003[/* full */1];
                }), params);
          var cltydef_001 = /* clty_type */class_body(typ);
          var cltydef_002 = /* clty_path : Pident */Block.__(0, [obj_id]);
          var cltydef_004 = /* clty_loc */cl[/* pci_loc */4];
          var cltydef_005 = /* clty_attributes */cl[/* pci_attributes */5];
          var cltydef = /* record */[
            /* clty_params */params,
            cltydef_001,
            cltydef_002,
            /* clty_variance */cty_variance,
            cltydef_004,
            cltydef_005
          ];
          var match$4 = cl[/* pci_virt */0];
          var clty = /* record */[
            /* cty_params */params,
            /* cty_type */typ,
            /* cty_path : Pident */Block.__(0, [obj_id]),
            /* cty_new */match$4 !== 0 ? /* Some */[constr_type] : /* None */0,
            /* cty_variance */cty_variance,
            /* cty_loc */cl[/* pci_loc */4],
            /* cty_attributes */cl[/* pci_attributes */5]
          ];
          param$2[10][/* cty_type */1] = typ;
          var env$1 = add_cltype(ty_id, cltydef, define_class$1 ? add_class(id, clty, env) : env);
          if (cl[/* pci_virt */0] === /* Concrete */1) {
            var sign = signature_of_class_type(typ);
            var mets = virtual_methods(sign);
            var vals = fold((function (name, param, l) {
                    if (param[1]) {
                      return l;
                    } else {
                      return /* :: */[
                              name,
                              l
                            ];
                    }
                  }), sign[/* csig_vars */1], /* [] */0);
            if (mets !== /* [] */0 || vals !== /* [] */0) {
              throw [
                    $$Error$9,
                    cl[/* pci_loc */4],
                    env$1,
                    /* Virtual_class */Block.__(10, [
                        define_class$1,
                        /* false */0,
                        mets,
                        vals
                      ])
                  ];
            }
            
          }
          var arity = class_type_arity(typ);
          var match$5 = flatten_fields(object_fields(expand_head(env$1, obj_ty)));
          var pub_meths = List.map((function (param) {
                  return param[0];
                }), match$5[0]);
          var match$6 = instance_class(params, typ);
          var typ$prime = match$6[1];
          var params$prime = match$6[0];
          var cltydef_001$1 = /* clty_type */class_body(typ$prime);
          var cltydef_002$1 = /* clty_path : Pident */Block.__(0, [obj_id]);
          var cltydef_004$1 = /* clty_loc */cl[/* pci_loc */4];
          var cltydef_005$1 = /* clty_attributes */cl[/* pci_attributes */5];
          var cltydef$1 = /* record */[
            /* clty_params */params$prime,
            cltydef_001$1,
            cltydef_002$1,
            /* clty_variance */cty_variance,
            cltydef_004$1,
            cltydef_005$1
          ];
          var match$7 = cl[/* pci_virt */0];
          var clty$1 = /* record */[
            /* cty_params */params$prime,
            /* cty_type */typ$prime,
            /* cty_path : Pident */Block.__(0, [obj_id]),
            /* cty_new */match$7 !== 0 ? /* Some */[instance(/* None */0, env$1, constr_type)] : /* None */0,
            /* cty_variance */cty_variance,
            /* cty_loc */cl[/* pci_loc */4],
            /* cty_attributes */cl[/* pci_attributes */5]
          ];
          var obj_abbr_001 = /* type_arity */List.length(obj_params);
          var obj_abbr_004 = /* type_manifest : Some */[obj_ty];
          var obj_abbr_005 = /* type_variance */List.map((function () {
                  return Types_003[/* full */1];
                }), obj_params);
          var obj_abbr_007 = /* type_loc */cl[/* pci_loc */4];
          var obj_abbr = /* record */[
            /* type_params */obj_params,
            obj_abbr_001,
            /* type_kind : Type_abstract */0,
            /* type_private : Public */1,
            obj_abbr_004,
            obj_abbr_005,
            /* type_newtype_level : None */0,
            obj_abbr_007,
            /* type_attributes : [] */0
          ];
          var match$8 = instance_parameterized_type(/* None */0, params, repr(signature_of_class_type(typ)[/* csig_self */0]));
          var cl_ty$1 = match$8[1];
          var cl_params$1 = match$8[0];
          hide_private_methods(cl_ty$1);
          set_object_name(obj_id, row_variable(cl_ty$1), cl_params$1, cl_ty$1);
          var cl_abbr_001 = /* type_arity */List.length(cl_params$1);
          var cl_abbr_004 = /* type_manifest : Some */[cl_ty$1];
          var cl_abbr_005 = /* type_variance */List.map((function () {
                  return Types_003[/* full */1];
                }), cl_params$1);
          var cl_abbr_007 = /* type_loc */cl[/* pci_loc */4];
          var cl_abbr = /* record */[
            /* type_params */cl_params$1,
            cl_abbr_001,
            /* type_kind : Type_abstract */0,
            /* type_private : Public */1,
            cl_abbr_004,
            cl_abbr_005,
            /* type_newtype_level : None */0,
            cl_abbr_007,
            /* type_attributes : [] */0
          ];
          return /* tuple */[
                  /* :: */[
                    /* tuple */[
                      cl,
                      id,
                      clty$1,
                      ty_id,
                      cltydef$1,
                      obj_id,
                      obj_abbr,
                      cl_id,
                      cl_abbr,
                      ci_params,
                      arity,
                      pub_meths,
                      List.rev(coercion_locs[0]),
                      match[0]
                    ],
                    param$3[0]
                  ],
                  env$1
                ];
        }), match[0], /* tuple */[
        /* [] */0,
        match[1]
      ]);
  var env$1 = match$1[1];
  end_def(/* () */0);
  var res = List.rev_map((function (param) {
          var env$2 = env$1;
          var define_class$1 = define_class;
          var param$1 = param;
          var expr = param$1[13];
          var cl_abbr = param$1[8];
          var cl_id = param$1[7];
          var obj_abbr = param$1[6];
          var obj_id = param$1[5];
          var cltydef = param$1[4];
          var ty_id = param$1[3];
          var clty = param$1[2];
          var id = param$1[1];
          var cl = param$1[0];
          try {
            collapse_conj_params(env$2, clty[/* cty_params */0]);
          }
          catch (raw_exn){
            var exn = Js_exn.internalToOCamlException(raw_exn);
            if (exn[0] === Unify) {
              throw [
                    $$Error$9,
                    cl[/* pci_loc */4],
                    env$2,
                    /* Non_collapsable_conjunction */Block.__(20, [
                        id,
                        clty,
                        exn[1]
                      ])
                  ];
            } else {
              throw exn;
            }
          }
          List.iter(generalize, clty[/* cty_params */0]);
          generalize_class_type(/* true */1)(clty[/* cty_type */1]);
          may(generalize, clty[/* cty_new */3]);
          List.iter(generalize, obj_abbr[/* type_params */0]);
          may(generalize, obj_abbr[/* type_manifest */4]);
          List.iter(generalize, cl_abbr[/* type_params */0]);
          may(generalize, cl_abbr[/* type_manifest */4]);
          if (!closed_class$1(clty)) {
            throw [
                  $$Error$9,
                  cl[/* pci_loc */4],
                  env$2,
                  /* Non_generalizable_class */Block.__(18, [
                      id,
                      clty
                    ])
                ];
          }
          var match = closed_class(clty[/* cty_params */0], signature_of_class_type(clty[/* cty_type */1]));
          if (match) {
            var printer = define_class$1 ? (function (ppf) {
                  return class_declaration$1(id, ppf, clty);
                }) : (function (ppf) {
                  return cltype_declaration$1(id, ppf, cltydef);
                });
            throw [
                  $$Error$9,
                  cl[/* pci_loc */4],
                  env$2,
                  /* Unbound_type_var */Block.__(16, [
                      printer,
                      match[0]
                    ])
                ];
          }
          return /* tuple */[
                  id,
                  cl[/* pci_name */2],
                  clty,
                  ty_id,
                  cltydef,
                  obj_id,
                  obj_abbr,
                  cl_id,
                  cl_abbr,
                  param$1[10],
                  param$1[11],
                  param$1[12],
                  expr,
                  /* record */[
                    /* ci_virt */cl[/* pci_virt */0],
                    /* ci_params */param$1[9],
                    /* ci_id_name */cl[/* pci_name */2],
                    /* ci_id_class */id,
                    /* ci_id_class_type */ty_id,
                    /* ci_id_object */obj_id,
                    /* ci_id_typesharp */cl_id,
                    /* ci_expr */expr,
                    /* ci_decl */clty,
                    /* ci_type_decl */cltydef,
                    /* ci_loc */cl[/* pci_loc */4],
                    /* ci_attributes */cl[/* pci_attributes */5]
                  ]
                ];
        }), match$1[0]);
  var decls = List.fold_right(extract_type_decls, res, /* [] */0);
  var decls$1 = compute_variance_decls(env$1, decls);
  var res$1 = List.map2(merge_type_decls, res, decls$1);
  var env$2 = List.fold_left((function (param, param$1) {
          var define_class$1 = define_class;
          var env = param;
          var param$2 = param$1;
          return add_type$1(/* true */1, param$2[5], type_declaration(identity, param$2[6]), add_type$1(/* true */1, param$2[7], type_declaration(identity, param$2[8]), add_cltype(param$2[3], cltype_declaration(identity, param$2[4]), define_class$1 ? add_class(param$2[0], class_declaration(identity, param$2[2]), env) : env)));
        }), env$1, res$1);
  var res$2 = List.map((function (param) {
          var env$3 = env$2;
          var param$1 = param;
          var coercion_locs = param$1[11];
          var cl_abbr = param$1[8];
          var obj_abbr = param$1[6];
          if (coercion_locs) {
            var loc = coercion_locs[0];
            var match = cl_abbr[/* type_manifest */4];
            var match$1 = obj_abbr[/* type_manifest */4];
            var match$2;
            if (match) {
              if (match$1) {
                var match$3 = instance_parameterized_type(/* None */0, cl_abbr[/* type_params */0], match[0]);
                var match$4 = instance_parameterized_type(/* None */0, obj_abbr[/* type_params */0], match$1[0]);
                List.iter2((function (param, param$1) {
                        return unify$2(env$3, param, param$1);
                      }), match$3[0], match$4[0]);
                match$2 = /* tuple */[
                  match$3[1],
                  match$4[1]
                ];
              } else {
                throw [
                      Caml_builtin_exceptions.assert_failure,
                      [
                        "typeclass.ml",
                        1562,
                        15
                      ]
                    ];
              }
            } else {
              throw [
                    Caml_builtin_exceptions.assert_failure,
                    [
                      "typeclass.ml",
                      1562,
                      15
                    ]
                  ];
            }
            var obj_ty = match$2[1];
            var cl_ty = match$2[0];
            try {
              subtype(env$3, cl_ty, obj_ty)(/* () */0);
            }
            catch (raw_exn){
              var exn = Js_exn.internalToOCamlException(raw_exn);
              if (exn[0] === Subtype) {
                throw [
                      $$Error$7,
                      loc,
                      env$3,
                      /* Not_subtype */Block.__(23, [
                          exn[1],
                          exn[2]
                        ])
                    ];
              } else {
                throw exn;
              }
            }
            if (!opened_object(cl_ty)) {
              throw [
                    $$Error$9,
                    loc,
                    env$3,
                    /* Cannot_coerce_self */Block.__(19, [obj_ty])
                  ];
            }
            
          }
          return /* tuple */[
                  param$1[0],
                  param$1[1],
                  param$1[2],
                  param$1[3],
                  param$1[4],
                  param$1[5],
                  obj_abbr,
                  param$1[7],
                  cl_abbr,
                  param$1[9],
                  param$1[10],
                  param$1[13]
                ];
        }), res$1);
  return /* tuple */[
          res$2,
          env$2
        ];
}

var class_num = [0];

function class_declaration$2(env, sexpr) {
  class_num[0] = class_num[0] + 1 | 0;
  var expr = class_expr("" + class_num[0], env, env, sexpr);
  return /* tuple */[
          expr,
          expr[/* cl_type */2]
        ];
}

function class_description(env, sexpr) {
  var expr = class_type$3(env, sexpr);
  return /* tuple */[
          expr,
          expr[/* cltyp_type */1]
        ];
}

function class_declarations$2(env, cls) {
  return type_classes(/* true */1, approx_declaration, class_declaration$2, env, cls);
}

function class_descriptions(env, cls) {
  return type_classes(/* true */1, approx_description, class_description, env, cls);
}

function class_type_declarations$2(env, cls) {
  var match = type_classes(/* false */0, approx_description, class_description, env, cls);
  return /* tuple */[
          List.map((function (param) {
                  return /* tuple */[
                          param[3],
                          param[1],
                          param[4],
                          param[5],
                          param[6],
                          param[7],
                          param[8],
                          param[11]
                        ];
                }), match[0]),
          match[1]
        ];
}

function unify_parents_struct(env, ty, st) {
  return List.iter((function (param) {
                var match = param[/* cf_desc */0];
                if (match.tag) {
                  return /* () */0;
                } else {
                  var env$1 = env;
                  var ty$1 = ty;
                  var _cl = match[1];
                  while(true) {
                    var cl = _cl;
                    var match$1 = cl[/* cl_desc */0];
                    switch (match$1.tag | 0) {
                      case 0 : 
                          try {
                            var decl = find_class(match$1[0], env$1);
                            var match$2 = find_cltype_for_path(env$1, decl[/* cty_path */2]);
                            return unify$2(env$1, ty$1, instance(/* None */0, env$1, match$2[1]));
                          }
                          catch (exn){
                            if (exn === Caml_builtin_exceptions.not_found) {
                              return /* () */0;
                            } else {
                              throw [
                                    Caml_builtin_exceptions.assert_failure,
                                    [
                                      "typeclass.ml",
                                      1639,
                                      15
                                    ]
                                  ];
                            }
                          }
                          break;
                      case 1 : 
                          return unify_parents_struct(env$1, ty$1, match$1[0]);
                      case 2 : 
                      case 4 : 
                          _cl = match$1[3];
                          continue ;
                          case 3 : 
                      case 5 : 
                          _cl = match$1[0];
                          continue ;
                          
                    }
                  };
                }
              }), st[/* cstr_fields */1]);
}

function type_object$1(env, loc, s) {
  class_num[0] = class_num[0] + 1 | 0;
  var match = class_structure("" + class_num[0], /* true */1, env, env, loc, s);
  var sign = match[1];
  var desc = match[0];
  var sty = expand_head(env, sign[/* csig_self */0]);
  hide_private_methods(sty);
  var match$1 = flatten_fields(object_fields(sty));
  var meths = List.map((function (param) {
          return param[0];
        }), match$1[0]);
  unify_parents_struct(env, sign[/* csig_self */0], desc);
  return /* tuple */[
          desc,
          sign,
          meths
        ];
}

type_object[0] = type_object$1;

function approx_class(sdecl) {
  var self$prime = mk(/* None */0, /* None */0, /* Ptyp_any */0);
  var clty$prime = signature$1(/* Some */[sdecl[/* pci_expr */3][/* pcty_loc */1]], /* None */0, /* record */[
        /* pcsig_self */self$prime,
        /* pcsig_fields : [] */0
      ]);
  var newrecord = sdecl.slice();
  newrecord[/* pci_expr */3] = clty$prime;
  return newrecord;
}

function approx_class_declarations(env, sdecls) {
  return class_type_declarations$2(env, List.map(approx_class, sdecls))[0];
}

register_error_of_exn((function (param) {
        if (param[0] === $$Error$9) {
          var env = param[2];
          return /* Some */[error_of_printer(param[1], (function (param, param$1) {
                          var env$1 = env;
                          var ppf = param;
                          var err = param$1;
                          return wrap_printing_env(env$1, (function () {
                                        var env$2 = env$1;
                                        var ppf$1 = ppf;
                                        var param = err;
                                        if (typeof param === "number") {
                                          return Format.fprintf(ppf$1, /* Format */[
                                                      /* String_literal */Block.__(11, [
                                                          "A type parameter occurs several times",
                                                          /* End_of_format */0
                                                        ]),
                                                      "A type parameter occurs several times"
                                                    ]);
                                        } else {
                                          switch (param.tag | 0) {
                                            case 0 : 
                                                Format.fprintf(ppf$1, /* Format */[
                                                      /* String_literal */Block.__(11, [
                                                          "The class constraints are not consistent.",
                                                          /* Formatting_lit */Block.__(17, [
                                                              /* Flush_newline */4,
                                                              /* End_of_format */0
                                                            ])
                                                        ]),
                                                      "The class constraints are not consistent.@."
                                                    ]);
                                                return report_unification_error(ppf$1, env$2, /* None */0, param[0], (function (ppf) {
                                                              return Format.fprintf(ppf, /* Format */[
                                                                          /* String_literal */Block.__(11, [
                                                                              "Type",
                                                                              /* End_of_format */0
                                                                            ]),
                                                                          "Type"
                                                                        ]);
                                                            }), (function (ppf) {
                                                              return Format.fprintf(ppf, /* Format */[
                                                                          /* String_literal */Block.__(11, [
                                                                              "is not compatible with type",
                                                                              /* End_of_format */0
                                                                            ]),
                                                                          "is not compatible with type"
                                                                        ]);
                                                            }));
                                            case 1 : 
                                                var m = param[1];
                                                var k = param[0];
                                                return report_unification_error(ppf$1, env$2, /* None */0, param[2], (function (ppf) {
                                                              return Curry._2(Format.fprintf(ppf, /* Format */[
                                                                              /* String_literal */Block.__(11, [
                                                                                  "The ",
                                                                                  /* String */Block.__(2, [
                                                                                      /* No_padding */0,
                                                                                      /* Char_literal */Block.__(12, [
                                                                                          /* " " */32,
                                                                                          /* String */Block.__(2, [
                                                                                              /* No_padding */0,
                                                                                              /* Formatting_lit */Block.__(17, [
                                                                                                  /* Break */Block.__(0, [
                                                                                                      "@ ",
                                                                                                      1,
                                                                                                      0
                                                                                                    ]),
                                                                                                  /* String_literal */Block.__(11, [
                                                                                                      "has type",
                                                                                                      /* End_of_format */0
                                                                                                    ])
                                                                                                ])
                                                                                            ])
                                                                                        ])
                                                                                    ])
                                                                                ]),
                                                                              "The %s %s@ has type"
                                                                            ]), k, m);
                                                            }), (function (ppf) {
                                                              return Format.fprintf(ppf, /* Format */[
                                                                          /* String_literal */Block.__(11, [
                                                                              "but is expected to have type",
                                                                              /* End_of_format */0
                                                                            ]),
                                                                          "but is expected to have type"
                                                                        ]);
                                                            }));
                                            case 2 : 
                                                return Curry._2(Format.fprintf(ppf$1, /* Format */[
                                                                /* Formatting_gen */Block.__(18, [
                                                                    /* Open_box */Block.__(1, [/* Format */[
                                                                          /* End_of_format */0,
                                                                          ""
                                                                        ]]),
                                                                    /* String_literal */Block.__(11, [
                                                                        "This class expression is not a class structure; it has type",
                                                                        /* Formatting_lit */Block.__(17, [
                                                                            /* Break */Block.__(0, [
                                                                                "@ ",
                                                                                1,
                                                                                0
                                                                              ]),
                                                                            /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                                    /* Close_box */0,
                                                                                    /* End_of_format */0
                                                                                  ])])
                                                                          ])
                                                                      ])
                                                                  ]),
                                                                "@[This class expression is not a class structure; it has type@ %a@]"
                                                              ]), class_type$1, param[0]);
                                            case 3 : 
                                                return Format.fprintf(ppf$1, /* Format */[
                                                            /* String_literal */Block.__(11, [
                                                                "This class expression is not a class function, it cannot be applied",
                                                                /* End_of_format */0
                                                              ]),
                                                            "This class expression is not a class function, it cannot be applied"
                                                          ]);
                                            case 4 : 
                                                var mark_label = function (l) {
                                                  if (l === "") {
                                                    return "out label";
                                                  } else {
                                                    return Curry._1(Format.sprintf(/* Format */[
                                                                    /* String_literal */Block.__(11, [
                                                                        " label ~",
                                                                        /* String */Block.__(2, [
                                                                            /* No_padding */0,
                                                                            /* End_of_format */0
                                                                          ])
                                                                      ]),
                                                                    " label ~%s"
                                                                  ]), l);
                                                  }
                                                };
                                                return Curry._1(Format.fprintf(ppf$1, /* Format */[
                                                                /* String_literal */Block.__(11, [
                                                                    "This argument cannot be applied with",
                                                                    /* String */Block.__(2, [
                                                                        /* No_padding */0,
                                                                        /* End_of_format */0
                                                                      ])
                                                                  ]),
                                                                "This argument cannot be applied with%s"
                                                              ]), mark_label(param[0]));
                                            case 5 : 
                                                var ty = param[0];
                                                reset(/* () */0);
                                                mark_loops(ty);
                                                return Curry._3(Format.fprintf(ppf$1, /* Format */[
                                                                /* Formatting_gen */Block.__(18, [
                                                                    /* Open_box */Block.__(1, [/* Format */[
                                                                          /* End_of_format */0,
                                                                          ""
                                                                        ]]),
                                                                    /* String */Block.__(2, [
                                                                        /* No_padding */0,
                                                                        /* Formatting_lit */Block.__(17, [
                                                                            /* Break */Block.__(0, [
                                                                                "@ ",
                                                                                1,
                                                                                0
                                                                              ]),
                                                                            /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                                    /* Close_box */0,
                                                                                    /* End_of_format */0
                                                                                  ])])
                                                                          ])
                                                                      ])
                                                                  ]),
                                                                "@[%s@ %a@]"
                                                              ]), "This pattern cannot match self: it only matches values of type", type_expr$1, ty);
                                            case 6 : 
                                                return Curry._2(Format.fprintf(ppf$1, /* Format */[
                                                                /* Formatting_gen */Block.__(18, [
                                                                    /* Open_box */Block.__(1, [/* Format */[
                                                                          /* End_of_format */0,
                                                                          ""
                                                                        ]]),
                                                                    /* String_literal */Block.__(11, [
                                                                        "The class",
                                                                        /* Formatting_lit */Block.__(17, [
                                                                            /* Break */Block.__(0, [
                                                                                "@ ",
                                                                                1,
                                                                                0
                                                                              ]),
                                                                            /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                                    /* Break */Block.__(0, [
                                                                                        "@ ",
                                                                                        1,
                                                                                        0
                                                                                      ]),
                                                                                    /* String_literal */Block.__(11, [
                                                                                        "is not yet completely defined",
                                                                                        /* Formatting_lit */Block.__(17, [
                                                                                            /* Close_box */0,
                                                                                            /* End_of_format */0
                                                                                          ])
                                                                                      ])
                                                                                  ])])
                                                                          ])
                                                                      ])
                                                                  ]),
                                                                "@[The class@ %a@ is not yet completely defined@]"
                                                              ]), longident, param[0]);
                                            case 7 : 
                                                return Curry._2(Format.fprintf(ppf$1, /* Format */[
                                                                /* Formatting_gen */Block.__(18, [
                                                                    /* Open_box */Block.__(1, [/* Format */[
                                                                          /* End_of_format */0,
                                                                          ""
                                                                        ]]),
                                                                    /* String_literal */Block.__(11, [
                                                                        "The class type",
                                                                        /* Formatting_lit */Block.__(17, [
                                                                            /* Break */Block.__(0, [
                                                                                "@ ",
                                                                                1,
                                                                                0
                                                                              ]),
                                                                            /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                                    /* Break */Block.__(0, [
                                                                                        "@ ",
                                                                                        1,
                                                                                        0
                                                                                      ]),
                                                                                    /* String_literal */Block.__(11, [
                                                                                        "is not yet completely defined",
                                                                                        /* Formatting_lit */Block.__(17, [
                                                                                            /* Close_box */0,
                                                                                            /* End_of_format */0
                                                                                          ])
                                                                                      ])
                                                                                  ])])
                                                                          ])
                                                                      ])
                                                                  ]),
                                                                "@[The class type@ %a@ is not yet completely defined@]"
                                                              ]), longident, param[0]);
                                            case 8 : 
                                                var expected = param[2];
                                                var actual = param[1];
                                                var abbrev = param[0];
                                                reset_and_mark_loops_list(/* :: */[
                                                      abbrev,
                                                      /* :: */[
                                                        actual,
                                                        /* :: */[
                                                          expected,
                                                          /* [] */0
                                                        ]
                                                      ]
                                                    ]);
                                                return Curry._6(Format.fprintf(ppf$1, /* Format */[
                                                                /* Formatting_gen */Block.__(18, [
                                                                    /* Open_box */Block.__(1, [/* Format */[
                                                                          /* End_of_format */0,
                                                                          ""
                                                                        ]]),
                                                                    /* String_literal */Block.__(11, [
                                                                        "The abbreviation",
                                                                        /* Formatting_lit */Block.__(17, [
                                                                            /* Break */Block.__(0, [
                                                                                "@ ",
                                                                                1,
                                                                                0
                                                                              ]),
                                                                            /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                                    /* Break */Block.__(0, [
                                                                                        "@ ",
                                                                                        1,
                                                                                        0
                                                                                      ]),
                                                                                    /* String_literal */Block.__(11, [
                                                                                        "expands to type",
                                                                                        /* Formatting_lit */Block.__(17, [
                                                                                            /* Break */Block.__(0, [
                                                                                                "@ ",
                                                                                                1,
                                                                                                0
                                                                                              ]),
                                                                                            /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                                                    /* Break */Block.__(0, [
                                                                                                        "@ ",
                                                                                                        1,
                                                                                                        0
                                                                                                      ]),
                                                                                                    /* String_literal */Block.__(11, [
                                                                                                        "but is used with type",
                                                                                                        /* Formatting_lit */Block.__(17, [
                                                                                                            /* Break */Block.__(0, [
                                                                                                                "@ ",
                                                                                                                1,
                                                                                                                0
                                                                                                              ]),
                                                                                                            /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                                                                    /* Close_box */0,
                                                                                                                    /* End_of_format */0
                                                                                                                  ])])
                                                                                                          ])
                                                                                                      ])
                                                                                                  ])])
                                                                                          ])
                                                                                      ])
                                                                                  ])])
                                                                          ])
                                                                      ])
                                                                  ]),
                                                                "@[The abbreviation@ %a@ expands to type@ %a@ but is used with type@ %a@]"
                                                              ]), type_expr$1, abbrev, type_expr$1, actual, type_expr$1, expected);
                                            case 9 : 
                                                var c = param[0];
                                                return report_unification_error(ppf$1, env$2, /* None */0, param[1], (function (ppf) {
                                                              return Curry._1(Format.fprintf(ppf, /* Format */[
                                                                              /* String_literal */Block.__(11, [
                                                                                  "The expression \"new ",
                                                                                  /* String */Block.__(2, [
                                                                                      /* No_padding */0,
                                                                                      /* String_literal */Block.__(11, [
                                                                                          "\" has type",
                                                                                          /* End_of_format */0
                                                                                        ])
                                                                                    ])
                                                                                ]),
                                                                              "The expression \"new %s\" has type"
                                                                            ]), c);
                                                            }), (function (ppf) {
                                                              return Format.fprintf(ppf, /* Format */[
                                                                          /* String_literal */Block.__(11, [
                                                                              "but is used with type",
                                                                              /* End_of_format */0
                                                                            ]),
                                                                          "but is used with type"
                                                                        ]);
                                                            }));
                                            case 10 : 
                                                var vals = param[3];
                                                var mets = param[2];
                                                var imm = param[1];
                                                var cl = param[0];
                                                var print_mets = function (ppf, mets) {
                                                  return List.iter((function (met) {
                                                                return Curry._1(Format.fprintf(ppf, /* Format */[
                                                                                /* Formatting_lit */Block.__(17, [
                                                                                    /* Break */Block.__(0, [
                                                                                        "@ ",
                                                                                        1,
                                                                                        0
                                                                                      ]),
                                                                                    /* String */Block.__(2, [
                                                                                        /* No_padding */0,
                                                                                        /* End_of_format */0
                                                                                      ])
                                                                                  ]),
                                                                                "@ %s"
                                                                              ]), met);
                                                              }), mets);
                                                };
                                                var missings = mets ? (
                                                    vals ? "methods and variables" : "methods"
                                                  ) : "variables";
                                                var print_msg = function (ppf) {
                                                  if (imm) {
                                                    return Curry._1(Format.fprintf(ppf, /* Format */[
                                                                    /* String_literal */Block.__(11, [
                                                                        "This object has virtual ",
                                                                        /* String */Block.__(2, [
                                                                            /* No_padding */0,
                                                                            /* End_of_format */0
                                                                          ])
                                                                      ]),
                                                                    "This object has virtual %s"
                                                                  ]), missings);
                                                  } else if (cl) {
                                                    return Format.fprintf(ppf, /* Format */[
                                                                /* String_literal */Block.__(11, [
                                                                    "This class should be virtual",
                                                                    /* End_of_format */0
                                                                  ]),
                                                                "This class should be virtual"
                                                              ]);
                                                  } else {
                                                    return Format.fprintf(ppf, /* Format */[
                                                                /* String_literal */Block.__(11, [
                                                                    "This class type should be virtual",
                                                                    /* End_of_format */0
                                                                  ]),
                                                                "This class type should be virtual"
                                                              ]);
                                                  }
                                                };
                                                return Curry._4(Format.fprintf(ppf$1, /* Format */[
                                                                /* Formatting_gen */Block.__(18, [
                                                                    /* Open_box */Block.__(1, [/* Format */[
                                                                          /* End_of_format */0,
                                                                          ""
                                                                        ]]),
                                                                    /* Theta */Block.__(16, [/* Char_literal */Block.__(12, [
                                                                            /* "." */46,
                                                                            /* Formatting_lit */Block.__(17, [
                                                                                /* Break */Block.__(0, [
                                                                                    "@ ",
                                                                                    1,
                                                                                    0
                                                                                  ]),
                                                                                /* Formatting_gen */Block.__(18, [
                                                                                    /* Open_box */Block.__(1, [/* Format */[
                                                                                          /* String_literal */Block.__(11, [
                                                                                              "<2>",
                                                                                              /* End_of_format */0
                                                                                            ]),
                                                                                          "<2>"
                                                                                        ]]),
                                                                                    /* String_literal */Block.__(11, [
                                                                                        "The following ",
                                                                                        /* String */Block.__(2, [
                                                                                            /* No_padding */0,
                                                                                            /* String_literal */Block.__(11, [
                                                                                                " are undefined :",
                                                                                                /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                                                        /* Close_box */0,
                                                                                                        /* Formatting_lit */Block.__(17, [
                                                                                                            /* Close_box */0,
                                                                                                            /* End_of_format */0
                                                                                                          ])
                                                                                                      ])])
                                                                                              ])
                                                                                          ])
                                                                                      ])
                                                                                  ])
                                                                              ])
                                                                          ])])
                                                                  ]),
                                                                "@[%t.@ @[<2>The following %s are undefined :%a@]@]"
                                                              ]), print_msg, missings, print_mets, Pervasives.$at(mets, vals));
                                            case 11 : 
                                                return Curry._4(Format.fprintf(ppf$1, /* Format */[
                                                                /* Formatting_gen */Block.__(18, [
                                                                    /* Open_box */Block.__(1, [/* Format */[
                                                                          /* End_of_format */0,
                                                                          ""
                                                                        ]]),
                                                                    /* String_literal */Block.__(11, [
                                                                        "The class constructor ",
                                                                        /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                                /* Break */Block.__(0, [
                                                                                    "@ ",
                                                                                    1,
                                                                                    0
                                                                                  ]),
                                                                                /* String_literal */Block.__(11, [
                                                                                    "expects ",
                                                                                    /* Int */Block.__(4, [
                                                                                        /* Int_i */3,
                                                                                        /* No_padding */0,
                                                                                        /* No_precision */0,
                                                                                        /* String_literal */Block.__(11, [
                                                                                            " type argument(s),",
                                                                                            /* Formatting_lit */Block.__(17, [
                                                                                                /* Break */Block.__(0, [
                                                                                                    "@ ",
                                                                                                    1,
                                                                                                    0
                                                                                                  ]),
                                                                                                /* String_literal */Block.__(11, [
                                                                                                    "but is here applied to ",
                                                                                                    /* Int */Block.__(4, [
                                                                                                        /* Int_i */3,
                                                                                                        /* No_padding */0,
                                                                                                        /* No_precision */0,
                                                                                                        /* String_literal */Block.__(11, [
                                                                                                            " type argument(s)",
                                                                                                            /* Formatting_lit */Block.__(17, [
                                                                                                                /* Close_box */0,
                                                                                                                /* End_of_format */0
                                                                                                              ])
                                                                                                          ])
                                                                                                      ])
                                                                                                  ])
                                                                                              ])
                                                                                          ])
                                                                                      ])
                                                                                  ])
                                                                              ])])
                                                                      ])
                                                                  ]),
                                                                "@[The class constructor %a@ expects %i type argument(s),@ but is here applied to %i type argument(s)@]"
                                                              ]), longident, param[0], param[1], param[2]);
                                            case 12 : 
                                                return report_unification_error(ppf$1, env$2, /* None */0, param[0], (function (ppf) {
                                                              return Format.fprintf(ppf, /* Format */[
                                                                          /* String_literal */Block.__(11, [
                                                                              "The type parameter",
                                                                              /* End_of_format */0
                                                                            ]),
                                                                          "The type parameter"
                                                                        ]);
                                                            }), (function (ppf) {
                                                              return Format.fprintf(ppf, /* Format */[
                                                                          /* String_literal */Block.__(11, [
                                                                              "does not meet its constraint: it should be",
                                                                              /* End_of_format */0
                                                                            ]),
                                                                          "does not meet its constraint: it should be"
                                                                        ]);
                                                            }));
                                            case 13 : 
                                                var cstrs = param[2];
                                                var params = param[1];
                                                reset_and_mark_loops_list(/* :: */[
                                                      params,
                                                      /* :: */[
                                                        cstrs,
                                                        /* [] */0
                                                      ]
                                                    ]);
                                                return Curry._6(Format.fprintf(ppf$1, /* Format */[
                                                                /* Formatting_gen */Block.__(18, [
                                                                    /* Open_box */Block.__(1, [/* Format */[
                                                                          /* End_of_format */0,
                                                                          ""
                                                                        ]]),
                                                                    /* String_literal */Block.__(11, [
                                                                        "The abbreviation ",
                                                                        /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                                /* Break */Block.__(0, [
                                                                                    "@ ",
                                                                                    1,
                                                                                    0
                                                                                  ]),
                                                                                /* String_literal */Block.__(11, [
                                                                                    "is used with parameters",
                                                                                    /* Formatting_lit */Block.__(17, [
                                                                                        /* Break */Block.__(0, [
                                                                                            "@ ",
                                                                                            1,
                                                                                            0
                                                                                          ]),
                                                                                        /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                                                /* Break */Block.__(0, [
                                                                                                    "@ ",
                                                                                                    1,
                                                                                                    0
                                                                                                  ]),
                                                                                                /* String_literal */Block.__(11, [
                                                                                                    "wich are incompatible with constraints",
                                                                                                    /* Formatting_lit */Block.__(17, [
                                                                                                        /* Break */Block.__(0, [
                                                                                                            "@ ",
                                                                                                            1,
                                                                                                            0
                                                                                                          ]),
                                                                                                        /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                                                                /* Close_box */0,
                                                                                                                /* End_of_format */0
                                                                                                              ])])
                                                                                                      ])
                                                                                                  ])
                                                                                              ])])
                                                                                      ])
                                                                                  ])
                                                                              ])])
                                                                      ])
                                                                  ]),
                                                                "@[The abbreviation %a@ is used with parameters@ %a@ wich are incompatible with constraints@ %a@]"
                                                              ]), ident$3, param[0], type_expr$1, params, type_expr$1, cstrs);
                                            case 14 : 
                                                return report_error$3(ppf$1, param[0]);
                                            case 15 : 
                                                return Curry._1(Format.fprintf(ppf$1, /* Format */[
                                                                /* String_literal */Block.__(11, [
                                                                    "Unbound instance variable ",
                                                                    /* String */Block.__(2, [
                                                                        /* No_padding */0,
                                                                        /* End_of_format */0
                                                                      ])
                                                                  ]),
                                                                "Unbound instance variable %s"
                                                              ]), param[0]);
                                            case 16 : 
                                                var print_common = function (ppf, kind, ty0, real, lab, ty) {
                                                  var ty1 = real ? ty0 : newty2(100000000, /* Tobject */Block.__(4, [
                                                            ty0,
                                                            [/* None */0]
                                                          ]));
                                                  mark_loops(ty1);
                                                  return Curry._6(Format.fprintf(ppf, /* Format */[
                                                                  /* String_literal */Block.__(11, [
                                                                      "The ",
                                                                      /* String */Block.__(2, [
                                                                          /* No_padding */0,
                                                                          /* Char_literal */Block.__(12, [
                                                                              /* " " */32,
                                                                              /* String */Block.__(2, [
                                                                                  /* No_padding */0,
                                                                                  /* Formatting_lit */Block.__(17, [
                                                                                      /* Break */Block.__(0, [
                                                                                          "@ ",
                                                                                          1,
                                                                                          0
                                                                                        ]),
                                                                                      /* String_literal */Block.__(11, [
                                                                                          "has type",
                                                                                          /* Formatting_lit */Block.__(17, [
                                                                                              /* Break */Block.__(0, [
                                                                                                  "@;<1 2>",
                                                                                                  1,
                                                                                                  2
                                                                                                ]),
                                                                                              /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                                                      /* Break */Block.__(0, [
                                                                                                          "@ ",
                                                                                                          1,
                                                                                                          0
                                                                                                        ]),
                                                                                                      /* String_literal */Block.__(11, [
                                                                                                          "where",
                                                                                                          /* Formatting_lit */Block.__(17, [
                                                                                                              /* Break */Block.__(0, [
                                                                                                                  "@ ",
                                                                                                                  1,
                                                                                                                  0
                                                                                                                ]),
                                                                                                              /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                                                                      /* Break */Block.__(0, [
                                                                                                                          "@ ",
                                                                                                                          1,
                                                                                                                          0
                                                                                                                        ]),
                                                                                                                      /* String_literal */Block.__(11, [
                                                                                                                          "is unbound",
                                                                                                                          /* End_of_format */0
                                                                                                                        ])
                                                                                                                    ])])
                                                                                                            ])
                                                                                                        ])
                                                                                                    ])])
                                                                                            ])
                                                                                        ])
                                                                                    ])
                                                                                ])
                                                                            ])
                                                                        ])
                                                                    ]),
                                                                  "The %s %s@ has type@;<1 2>%a@ where@ %a@ is unbound"
                                                                ]), kind, lab, type_expr$1, ty, type_expr$1, ty0);
                                                };
                                                var print_reason = function (ppf, param) {
                                                  if (param.tag) {
                                                    return print_common(ppf, "instance variable", param[0], param[1], param[2], param[3]);
                                                  } else {
                                                    return print_common(ppf, "method", param[0], param[1], param[2], param[3]);
                                                  }
                                                };
                                                reset(/* () */0);
                                                return Curry._3(Format.fprintf(ppf$1, /* Format */[
                                                                /* Formatting_gen */Block.__(18, [
                                                                    /* Open_box */Block.__(1, [/* Format */[
                                                                          /* String_literal */Block.__(11, [
                                                                              "<v>",
                                                                              /* End_of_format */0
                                                                            ]),
                                                                          "<v>"
                                                                        ]]),
                                                                    /* Formatting_gen */Block.__(18, [
                                                                        /* Open_box */Block.__(1, [/* Format */[
                                                                              /* End_of_format */0,
                                                                              ""
                                                                            ]]),
                                                                        /* String_literal */Block.__(11, [
                                                                            "Some type variables are unbound in this type:",
                                                                            /* Formatting_lit */Block.__(17, [
                                                                                /* Break */Block.__(0, [
                                                                                    "@;<1 2>",
                                                                                    1,
                                                                                    2
                                                                                  ]),
                                                                                /* Theta */Block.__(16, [/* Formatting_lit */Block.__(17, [
                                                                                        /* Close_box */0,
                                                                                        /* Formatting_lit */Block.__(17, [
                                                                                            /* Break */Block.__(0, [
                                                                                                "@ ",
                                                                                                1,
                                                                                                0
                                                                                              ]),
                                                                                            /* Formatting_gen */Block.__(18, [
                                                                                                /* Open_box */Block.__(1, [/* Format */[
                                                                                                      /* End_of_format */0,
                                                                                                      ""
                                                                                                    ]]),
                                                                                                /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                                                        /* Close_box */0,
                                                                                                        /* Formatting_lit */Block.__(17, [
                                                                                                            /* Close_box */0,
                                                                                                            /* End_of_format */0
                                                                                                          ])
                                                                                                      ])])
                                                                                              ])
                                                                                          ])
                                                                                      ])])
                                                                              ])
                                                                          ])
                                                                      ])
                                                                  ]),
                                                                "@[<v>@[Some type variables are unbound in this type:@;<1 2>%t@]@ @[%a@]@]"
                                                              ]), param[0], print_reason, param[1]);
                                            case 17 : 
                                                return Curry._2(Format.fprintf(ppf$1, /* Format */[
                                                                /* Formatting_gen */Block.__(18, [
                                                                    /* Open_box */Block.__(1, [/* Format */[
                                                                          /* String_literal */Block.__(11, [
                                                                              "<v>",
                                                                              /* End_of_format */0
                                                                            ]),
                                                                          "<v>"
                                                                        ]]),
                                                                    /* Formatting_gen */Block.__(18, [
                                                                        /* Open_box */Block.__(1, [/* Format */[
                                                                              /* End_of_format */0,
                                                                              ""
                                                                            ]]),
                                                                        /* String_literal */Block.__(11, [
                                                                            "Self type should not occur in the non-generic type",
                                                                            /* Formatting_lit */Block.__(17, [
                                                                                /* Break */Block.__(0, [
                                                                                    "@;<1 2>",
                                                                                    1,
                                                                                    2
                                                                                  ]),
                                                                                /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                                        /* Close_box */0,
                                                                                        /* Formatting_lit */Block.__(17, [
                                                                                            /* Break */Block.__(0, [
                                                                                                "@,",
                                                                                                0,
                                                                                                0
                                                                                              ]),
                                                                                            /* String_literal */Block.__(11, [
                                                                                                "It would escape the scope of its class",
                                                                                                /* Formatting_lit */Block.__(17, [
                                                                                                    /* Close_box */0,
                                                                                                    /* End_of_format */0
                                                                                                  ])
                                                                                              ])
                                                                                          ])
                                                                                      ])])
                                                                              ])
                                                                          ])
                                                                      ])
                                                                  ]),
                                                                "@[<v>@[Self type should not occur in the non-generic type@;<1 2>%a@]@,It would escape the scope of its class@]"
                                                              ]), type_scheme, param[0]);
                                            case 18 : 
                                                var id = param[0];
                                                return Curry._2(Format.fprintf(ppf$1, /* Format */[
                                                                /* Formatting_gen */Block.__(18, [
                                                                    /* Open_box */Block.__(1, [/* Format */[
                                                                          /* End_of_format */0,
                                                                          ""
                                                                        ]]),
                                                                    /* String_literal */Block.__(11, [
                                                                        "The type of this class,",
                                                                        /* Formatting_lit */Block.__(17, [
                                                                            /* Break */Block.__(0, [
                                                                                "@ ",
                                                                                1,
                                                                                0
                                                                              ]),
                                                                            /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                                                                    /* "," */44,
                                                                                    /* Formatting_lit */Block.__(17, [
                                                                                        /* Break */Block.__(0, [
                                                                                            "@ ",
                                                                                            1,
                                                                                            0
                                                                                          ]),
                                                                                        /* String_literal */Block.__(11, [
                                                                                            "contains type variables that cannot be generalized",
                                                                                            /* Formatting_lit */Block.__(17, [
                                                                                                /* Close_box */0,
                                                                                                /* End_of_format */0
                                                                                              ])
                                                                                          ])
                                                                                      ])
                                                                                  ])])
                                                                          ])
                                                                      ])
                                                                  ]),
                                                                "@[The type of this class,@ %a,@ contains type variables that cannot be generalized@]"
                                                              ]), (function (param, param$1) {
                                                              return class_declaration$1(id, param, param$1);
                                                            }), param[1]);
                                            case 19 : 
                                                return Curry._2(Format.fprintf(ppf$1, /* Format */[
                                                                /* Formatting_gen */Block.__(18, [
                                                                    /* Open_box */Block.__(1, [/* Format */[
                                                                          /* End_of_format */0,
                                                                          ""
                                                                        ]]),
                                                                    /* String_literal */Block.__(11, [
                                                                        "The type of self cannot be coerced to",
                                                                        /* Formatting_lit */Block.__(17, [
                                                                            /* Break */Block.__(0, [
                                                                                "@ ",
                                                                                1,
                                                                                0
                                                                              ]),
                                                                            /* String_literal */Block.__(11, [
                                                                                "the type of the current class:",
                                                                                /* Formatting_lit */Block.__(17, [
                                                                                    /* Break */Block.__(0, [
                                                                                        "@ ",
                                                                                        1,
                                                                                        0
                                                                                      ]),
                                                                                    /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                                                                            /* "." */46,
                                                                                            /* Formatting_lit */Block.__(17, [
                                                                                                /* Flush_newline */4,
                                                                                                /* String_literal */Block.__(11, [
                                                                                                    "Some occurrences are contravariant",
                                                                                                    /* Formatting_lit */Block.__(17, [
                                                                                                        /* Close_box */0,
                                                                                                        /* End_of_format */0
                                                                                                      ])
                                                                                                  ])
                                                                                              ])
                                                                                          ])])
                                                                                  ])
                                                                              ])
                                                                          ])
                                                                      ])
                                                                  ]),
                                                                "@[The type of self cannot be coerced to@ the type of the current class:@ %a.@.Some occurrences are contravariant@]"
                                                              ]), type_scheme, param[0]);
                                            case 20 : 
                                                var id$1 = param[0];
                                                Curry._2(Format.fprintf(ppf$1, /* Format */[
                                                          /* Formatting_gen */Block.__(18, [
                                                              /* Open_box */Block.__(1, [/* Format */[
                                                                    /* End_of_format */0,
                                                                    ""
                                                                  ]]),
                                                              /* String_literal */Block.__(11, [
                                                                  "The type of this class,",
                                                                  /* Formatting_lit */Block.__(17, [
                                                                      /* Break */Block.__(0, [
                                                                          "@ ",
                                                                          1,
                                                                          0
                                                                        ]),
                                                                      /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                                                              /* "," */44,
                                                                              /* Formatting_lit */Block.__(17, [
                                                                                  /* Break */Block.__(0, [
                                                                                      "@ ",
                                                                                      1,
                                                                                      0
                                                                                    ]),
                                                                                  /* String_literal */Block.__(11, [
                                                                                      "contains non-collapsible conjunctive types in constraints",
                                                                                      /* Formatting_lit */Block.__(17, [
                                                                                          /* Close_box */0,
                                                                                          /* End_of_format */0
                                                                                        ])
                                                                                    ])
                                                                                ])
                                                                            ])])
                                                                    ])
                                                                ])
                                                            ]),
                                                          "@[The type of this class,@ %a,@ contains non-collapsible conjunctive types in constraints@]"
                                                        ]), (function (param, param$1) {
                                                        return class_declaration$1(id$1, param, param$1);
                                                      }), param[1]);
                                                return report_unification_error(ppf$1, env$2, /* None */0, param[2], (function (ppf) {
                                                              return Format.fprintf(ppf, /* Format */[
                                                                          /* String_literal */Block.__(11, [
                                                                              "Type",
                                                                              /* End_of_format */0
                                                                            ]),
                                                                          "Type"
                                                                        ]);
                                                            }), (function (ppf) {
                                                              return Format.fprintf(ppf, /* Format */[
                                                                          /* String_literal */Block.__(11, [
                                                                              "is not compatible with type",
                                                                              /* End_of_format */0
                                                                            ]),
                                                                          "is not compatible with type"
                                                                        ]);
                                                            }));
                                            case 21 : 
                                                return report_unification_error(ppf$1, env$2, /* None */0, param[0], (function (ppf) {
                                                              return Format.fprintf(ppf, /* Format */[
                                                                          /* String_literal */Block.__(11, [
                                                                              "This object is expected to have type",
                                                                              /* End_of_format */0
                                                                            ]),
                                                                          "This object is expected to have type"
                                                                        ]);
                                                            }), (function (ppf) {
                                                              return Format.fprintf(ppf, /* Format */[
                                                                          /* String_literal */Block.__(11, [
                                                                              "but actually has type",
                                                                              /* End_of_format */0
                                                                            ]),
                                                                          "but actually has type"
                                                                        ]);
                                                            }));
                                            case 22 : 
                                                var match = param[1] ? /* tuple */[
                                                    "immutable",
                                                    "mutable"
                                                  ] : /* tuple */[
                                                    "mutable",
                                                    "immutable"
                                                  ];
                                                return Curry._2(Format.fprintf(ppf$1, /* Format */[
                                                                /* Formatting_gen */Block.__(18, [
                                                                    /* Open_box */Block.__(1, [/* Format */[
                                                                          /* End_of_format */0,
                                                                          ""
                                                                        ]]),
                                                                    /* String_literal */Block.__(11, [
                                                                        "The instance variable is ",
                                                                        /* String */Block.__(2, [
                                                                            /* No_padding */0,
                                                                            /* Char_literal */Block.__(12, [
                                                                                /* ";" */59,
                                                                                /* Formatting_lit */Block.__(17, [
                                                                                    /* Break */Block.__(0, [
                                                                                        "@ ",
                                                                                        1,
                                                                                        0
                                                                                      ]),
                                                                                    /* String_literal */Block.__(11, [
                                                                                        "it cannot be redefined as ",
                                                                                        /* String */Block.__(2, [
                                                                                            /* No_padding */0,
                                                                                            /* Formatting_lit */Block.__(17, [
                                                                                                /* Close_box */0,
                                                                                                /* End_of_format */0
                                                                                              ])
                                                                                          ])
                                                                                      ])
                                                                                  ])
                                                                              ])
                                                                          ])
                                                                      ])
                                                                  ]),
                                                                "@[The instance variable is %s;@ it cannot be redefined as %s@]"
                                                              ]), match[0], match[1]);
                                            case 23 : 
                                                var name = param[1];
                                                if (name === "") {
                                                  return Curry._1(Format.fprintf(ppf$1, /* Format */[
                                                                  /* Formatting_gen */Block.__(18, [
                                                                      /* Open_box */Block.__(1, [/* Format */[
                                                                            /* End_of_format */0,
                                                                            ""
                                                                          ]]),
                                                                      /* String_literal */Block.__(11, [
                                                                          "This inheritance does not override any method",
                                                                          /* Formatting_lit */Block.__(17, [
                                                                              /* Break */Block.__(0, [
                                                                                  "@ ",
                                                                                  1,
                                                                                  0
                                                                                ]),
                                                                              /* String */Block.__(2, [
                                                                                  /* No_padding */0,
                                                                                  /* Formatting_lit */Block.__(17, [
                                                                                      /* Close_box */0,
                                                                                      /* End_of_format */0
                                                                                    ])
                                                                                ])
                                                                            ])
                                                                        ])
                                                                    ]),
                                                                  "@[This inheritance does not override any method@ %s@]"
                                                                ]), "instance variable");
                                                } else {
                                                  return Curry._2(Format.fprintf(ppf$1, /* Format */[
                                                                  /* Formatting_gen */Block.__(18, [
                                                                      /* Open_box */Block.__(1, [/* Format */[
                                                                            /* End_of_format */0,
                                                                            ""
                                                                          ]]),
                                                                      /* String_literal */Block.__(11, [
                                                                          "The ",
                                                                          /* String */Block.__(2, [
                                                                              /* No_padding */0,
                                                                              /* String_literal */Block.__(11, [
                                                                                  " `",
                                                                                  /* String */Block.__(2, [
                                                                                      /* No_padding */0,
                                                                                      /* Char_literal */Block.__(12, [
                                                                                          /* "'" */39,
                                                                                          /* Formatting_lit */Block.__(17, [
                                                                                              /* Break */Block.__(0, [
                                                                                                  "@ ",
                                                                                                  1,
                                                                                                  0
                                                                                                ]),
                                                                                              /* String_literal */Block.__(11, [
                                                                                                  "has no previous definition",
                                                                                                  /* Formatting_lit */Block.__(17, [
                                                                                                      /* Close_box */0,
                                                                                                      /* End_of_format */0
                                                                                                    ])
                                                                                                ])
                                                                                            ])
                                                                                        ])
                                                                                    ])
                                                                                ])
                                                                            ])
                                                                        ])
                                                                    ]),
                                                                  "@[The %s `%s'@ has no previous definition@]"
                                                                ]), param[0], name);
                                                }
                                                break;
                                            case 24 : 
                                                return Curry._2(Format.fprintf(ppf$1, /* Format */[
                                                                /* Formatting_gen */Block.__(18, [
                                                                    /* Open_box */Block.__(1, [/* Format */[
                                                                          /* End_of_format */0,
                                                                          ""
                                                                        ]]),
                                                                    /* String_literal */Block.__(11, [
                                                                        "The ",
                                                                        /* String */Block.__(2, [
                                                                            /* No_padding */0,
                                                                            /* String_literal */Block.__(11, [
                                                                                " `",
                                                                                /* String */Block.__(2, [
                                                                                    /* No_padding */0,
                                                                                    /* Char_literal */Block.__(12, [
                                                                                        /* "'" */39,
                                                                                        /* Formatting_lit */Block.__(17, [
                                                                                            /* Break */Block.__(0, [
                                                                                                "@ ",
                                                                                                1,
                                                                                                0
                                                                                              ]),
                                                                                            /* String_literal */Block.__(11, [
                                                                                                "has multiple definitions in this object",
                                                                                                /* Formatting_lit */Block.__(17, [
                                                                                                    /* Close_box */0,
                                                                                                    /* End_of_format */0
                                                                                                  ])
                                                                                              ])
                                                                                          ])
                                                                                      ])
                                                                                  ])
                                                                              ])
                                                                          ])
                                                                      ])
                                                                  ]),
                                                                "@[The %s `%s'@ has multiple definitions in this object@]"
                                                              ]), param[0], param[1]);
                                            
                                          }
                                        }
                                      }));
                        }), param[3])];
        } else if (param[0] === Error_forward$2) {
          return /* Some */[param[1]];
        } else {
          return /* None */0;
        }
      }));

var $$Error$10 = Caml_exceptions.create("Ocaml_typedtree_test.Typemod.Error");

var Error_forward$3 = Caml_exceptions.create("Ocaml_typedtree_test.Typemod.Error_forward");

function fst3(param) {
  return param[0];
}

function path_concat(head, p) {
  switch (p.tag | 0) {
    case 0 : 
        return /* Pdot */Block.__(1, [
                  /* Pident */Block.__(0, [head]),
                  p[0][/* name */1],
                  0
                ]);
    case 1 : 
        return /* Pdot */Block.__(1, [
                  path_concat(head, p[0]),
                  p[1],
                  p[2]
                ]);
    case 2 : 
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "typemod.ml",
                54,
                16
              ]
            ];
    
  }
}

function extract_sig(env, loc, mty) {
  var match = scrape_alias(env, /* None */0, mty);
  if (match.tag === 1) {
    return match[0];
  } else {
    throw [
          $$Error$10,
          loc,
          env,
          /* Signature_expected */0
        ];
  }
}

function extract_sig_open(env, loc, mty) {
  var match = scrape_alias(env, /* None */0, mty);
  if (match.tag === 1) {
    return match[0];
  } else {
    throw [
          $$Error$10,
          loc,
          env,
          /* Structure_expected */Block.__(3, [mty])
        ];
  }
}

function type_open_(toplevel, ovf, env, loc, lid) {
  var match = find_module$1(env, lid[/* loc */1], lid[/* txt */0]);
  var path = match[0];
  var sg = extract_sig_open(env, lid[/* loc */1], match[1][/* md_type */0]);
  return /* tuple */[
          path,
          open_signature$1(/* Some */[loc], toplevel, ovf, path, sg, env)
        ];
}

function type_open$1(toplevel, env, sod) {
  var match = type_open_(toplevel, sod[/* popen_override */1], env, sod[/* popen_loc */2], sod[/* popen_lid */0]);
  var path = match[0];
  var od_001 = /* open_txt */sod[/* popen_lid */0];
  var od_002 = /* open_override */sod[/* popen_override */1];
  var od_003 = /* open_loc */sod[/* popen_loc */2];
  var od_004 = /* open_attributes */sod[/* popen_attributes */3];
  var od = /* record */[
    /* open_path */path,
    od_001,
    od_002,
    od_003,
    od_004
  ];
  return /* tuple */[
          path,
          match[1],
          od
        ];
}

function rm(node) {
  record$2(/* Ti_mod */Block.__(3, [node]));
  return node;
}

var type_module_type_of_fwd = [(function (_, _$1) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "typemod.ml",
              99,
              22
            ]
          ];
    })];

function add_rec_types(_env, _param) {
  while(true) {
    var param = _param;
    var env = _env;
    if (param) {
      var match = param[0];
      if (match.tag === 1) {
        if (match[2] >= 2) {
          _param = param[1];
          _env = add_type$1(/* true */1, match[0], match[1], env);
          continue ;
          
        } else {
          return env;
        }
      } else {
        return env;
      }
    } else {
      return env;
    }
  };
}

function check_type_decl(env, loc, id, row_id, newdecl, decl, rs, rem) {
  var env$1 = add_type$1(/* true */1, id, newdecl, env);
  var env$2 = row_id ? add_type$1(/* true */1, row_id[0], newdecl, env$1) : env$1;
  var env$3 = rs ? add_rec_types(env$2, rem) : env$2;
  type_declarations$3(env$3, id, newdecl, decl);
  return check_coherence(env$3, loc, id, newdecl);
}

function update_rec_next(rs, rem) {
  if (rs >= 2) {
    return rem;
  } else if (rem) {
    var match = rem[0];
    switch (match.tag | 0) {
      case 1 : 
          if (match[2] >= 2) {
            return /* :: */[
                    /* Sig_type */Block.__(1, [
                        match[0],
                        match[1],
                        rs
                      ]),
                    rem[1]
                  ];
          } else {
            return rem;
          }
      case 3 : 
          if (match[2] >= 2) {
            return /* :: */[
                    /* Sig_module */Block.__(3, [
                        match[0],
                        match[1],
                        rs
                      ]),
                    rem[1]
                  ];
          } else {
            return rem;
          }
      default:
        return rem;
    }
  } else {
    return rem;
  }
}

function merge_constraint(initial_env, loc, sg, constr) {
  var lid;
  switch (constr.tag | 0) {
    case 0 : 
    case 1 : 
        lid = constr[0];
        break;
    case 2 : 
        var s = constr[0][/* ptype_name */0];
        lid = /* record */[
          /* txt : Lident */Block.__(0, [s[/* txt */0]]),
          /* loc */s[/* loc */1]
        ];
        break;
    case 3 : 
        var s$1 = constr[0];
        lid = /* record */[
          /* txt : Lident */Block.__(0, [s$1[/* txt */0]]),
          /* loc */s$1[/* loc */1]
        ];
        break;
    
  }
  var real_id = [/* None */0];
  var merge = function (env, _sg, namelist, _row_id) {
    while(true) {
      var row_id = _row_id;
      var sg = _sg;
      if (sg) {
        var item = sg[0];
        var exit = 0;
        switch (item.tag | 0) {
          case 1 : 
              if (namelist) {
                if (namelist[1]) {
                  exit = 1;
                } else {
                  var s = namelist[0];
                  var rem = sg[1];
                  var rs = item[2];
                  var decl = item[1];
                  var id = item[0];
                  var exit$1 = 0;
                  switch (constr.tag | 0) {
                    case 0 : 
                        var sdecl = constr[1];
                        var match = sdecl[/* ptype_kind */3];
                        var exit$2 = 0;
                        if (typeof match === "number") {
                          if (match !== 0) {
                            exit$2 = 3;
                          } else if (id[/* name */1] === s && is_fixed_type(sdecl)) {
                            var decl_row_000 = /* type_params */List.map((function () {
                                    return newty2(100000000, /* Tvar */Block.__(0, [/* None */0]));
                                  }), sdecl[/* ptype_params */1]);
                            var decl_row_001 = /* type_arity */List.length(sdecl[/* ptype_params */1]);
                            var decl_row_005 = /* type_variance */List.map((function (param) {
                                    var match;
                                    switch (param[1]) {
                                      case 0 : 
                                          match = /* tuple */[
                                            /* true */1,
                                            /* false */0
                                          ];
                                          break;
                                      case 1 : 
                                          match = /* tuple */[
                                            /* false */0,
                                            /* true */1
                                          ];
                                          break;
                                      case 2 : 
                                          match = /* tuple */[
                                            /* false */0,
                                            /* false */0
                                          ];
                                          break;
                                      
                                    }
                                    var p = 1 - match[1];
                                    var n = 1 - match[0];
                                    var i = /* false */0;
                                    return Curry._3(Types_003[/* set */7], /* May_pos */0, p, Curry._3(Types_003[/* set */7], /* May_neg */1, n, Curry._3(Types_003[/* set */7], /* May_weak */2, n, Curry._3(Types_003[/* set */7], /* Inj */3, i, Types_003[/* null */0]))));
                                  }), sdecl[/* ptype_params */1]);
                            var decl_row_007 = /* type_loc */sdecl[/* ptype_loc */7];
                            var decl_row = /* record */[
                              decl_row_000,
                              decl_row_001,
                              /* type_kind : Type_abstract */0,
                              /* type_private : Private */0,
                              /* type_manifest : None */0,
                              decl_row_005,
                              /* type_newtype_level : None */0,
                              decl_row_007,
                              /* type_attributes : [] */0
                            ];
                            var id_row = create(s + "#row");
                            var initial_env$1 = add_type$1(/* true */1, id_row, decl_row, initial_env);
                            var tdecl = transl_with_constraint(initial_env$1, id, /* Some */[/* Pident */Block.__(0, [id_row])], decl, sdecl);
                            var newdecl = tdecl[/* typ_type */3];
                            check_type_decl(env, sdecl[/* ptype_loc */7], id, row_id, newdecl, decl, rs, rem);
                            var newrecord = decl_row.slice();
                            newrecord[/* type_params */0] = newdecl[/* type_params */0];
                            var rs$prime = rs === /* Trec_first */1 ? /* Trec_not */0 : rs;
                            return /* tuple */[
                                    /* tuple */[
                                      /* Pident */Block.__(0, [id]),
                                      lid,
                                      /* Twith_type */Block.__(0, [tdecl])
                                    ],
                                    /* :: */[
                                      /* Sig_type */Block.__(1, [
                                          id_row,
                                          newrecord,
                                          rs$prime
                                        ]),
                                      /* :: */[
                                        /* Sig_type */Block.__(1, [
                                            id,
                                            newdecl,
                                            rs
                                          ]),
                                        rem
                                      ]
                                    ]
                                  ];
                          } else {
                            exit$2 = 3;
                          }
                        } else {
                          exit$2 = 3;
                        }
                        if (exit$2 === 3) {
                          if (id[/* name */1] === s) {
                            var tdecl$1 = transl_with_constraint(initial_env, id, /* None */0, decl, sdecl);
                            var newdecl$1 = tdecl$1[/* typ_type */3];
                            check_type_decl(env, sdecl[/* ptype_loc */7], id, row_id, newdecl$1, decl, rs, rem);
                            return /* tuple */[
                                    /* tuple */[
                                      /* Pident */Block.__(0, [id]),
                                      lid,
                                      /* Twith_type */Block.__(0, [tdecl$1])
                                    ],
                                    /* :: */[
                                      /* Sig_type */Block.__(1, [
                                          id,
                                          newdecl$1,
                                          rs
                                        ]),
                                      rem
                                    ]
                                  ];
                          } else {
                            exit$1 = 2;
                          }
                        }
                        break;
                    case 2 : 
                        exit$1 = 2;
                        break;
                    case 1 : 
                    case 3 : 
                        exit = 1;
                        break;
                    
                  }
                  if (exit$1 === 2) {
                    if (id[/* name */1] === s + "#row") {
                      _row_id = /* Some */[id];
                      _sg = rem;
                      continue ;
                      
                    } else if (constr.tag) {
                      var sdecl$1 = constr[0];
                      if (id[/* name */1] === s) {
                        var tdecl$2 = transl_with_constraint(initial_env, id, /* None */0, decl, sdecl$1);
                        var newdecl$2 = tdecl$2[/* typ_type */3];
                        check_type_decl(env, sdecl$1[/* ptype_loc */7], id, row_id, newdecl$2, decl, rs, rem);
                        real_id[0] = /* Some */[id];
                        return /* tuple */[
                                /* tuple */[
                                  /* Pident */Block.__(0, [id]),
                                  lid,
                                  /* Twith_typesubst */Block.__(2, [tdecl$2])
                                ],
                                update_rec_next(rs, rem)
                              ];
                      } else {
                        exit = 1;
                      }
                    } else {
                      exit = 1;
                    }
                  }
                  
                }
              } else {
                exit = 1;
              }
              break;
          case 3 : 
              if (namelist) {
                var namelist$1 = namelist[1];
                var s$1 = namelist[0];
                var rem$1 = sg[1];
                var rs$1 = item[2];
                var md = item[1];
                var id$1 = item[0];
                var exit$3 = 0;
                if (namelist$1) {
                  exit$3 = 2;
                } else {
                  switch (constr.tag | 0) {
                    case 1 : 
                        var lid$prime = constr[1];
                        if (id$1[/* name */1] === s$1) {
                          var match$1 = find_module$1(initial_env, loc, lid$prime[/* txt */0]);
                          var md$prime = match$1[1];
                          var path = match$1[0];
                          var md$prime$prime_000 = /* md_type */remove_aliases$1(env, md$prime[/* md_type */0]);
                          var md$prime$prime_001 = /* md_attributes */md$prime[/* md_attributes */1];
                          var md$prime$prime_002 = /* md_loc */md$prime[/* md_loc */2];
                          var md$prime$prime = /* record */[
                            md$prime$prime_000,
                            md$prime$prime_001,
                            md$prime$prime_002
                          ];
                          var newmd = strengthen_decl(env, md$prime$prime, path);
                          modtypes$1(env, newmd[/* md_type */0], md[/* md_type */0]);
                          return /* tuple */[
                                  /* tuple */[
                                    /* Pident */Block.__(0, [id$1]),
                                    lid,
                                    /* Twith_module */Block.__(1, [
                                        path,
                                        lid$prime
                                      ])
                                  ],
                                  /* :: */[
                                    /* Sig_module */Block.__(3, [
                                        id$1,
                                        newmd,
                                        rs$1
                                      ]),
                                    rem$1
                                  ]
                                ];
                        } else {
                          exit$3 = 2;
                        }
                        break;
                    case 0 : 
                    case 2 : 
                        exit$3 = 2;
                        break;
                    case 3 : 
                        var lid$prime$1 = constr[1];
                        if (id$1[/* name */1] === s$1) {
                          var match$2 = find_module$1(initial_env, loc, lid$prime$1[/* txt */0]);
                          var path$1 = match$2[0];
                          var newmd$1 = strengthen_decl(env, match$2[1], path$1);
                          modtypes$1(env, newmd$1[/* md_type */0], md[/* md_type */0]);
                          real_id[0] = /* Some */[id$1];
                          return /* tuple */[
                                  /* tuple */[
                                    /* Pident */Block.__(0, [id$1]),
                                    lid,
                                    /* Twith_modsubst */Block.__(3, [
                                        path$1,
                                        lid$prime$1
                                      ])
                                  ],
                                  update_rec_next(rs$1, rem$1)
                                ];
                        } else {
                          exit$3 = 2;
                        }
                        break;
                    
                  }
                }
                if (exit$3 === 2) {
                  if (id$1[/* name */1] === s$1) {
                    var match$3 = merge(env, extract_sig(env, loc, md[/* md_type */0]), namelist$1, /* None */0);
                    var match$4 = match$3[0];
                    return /* tuple */[
                            /* tuple */[
                              path_concat(id$1, match$4[0]),
                              lid,
                              match$4[2]
                            ],
                            /* :: */[
                              /* Sig_module */Block.__(3, [
                                  id$1,
                                  /* record */[
                                    /* md_type : Mty_signature */Block.__(1, [match$3[1]]),
                                    /* md_attributes */md[/* md_attributes */1],
                                    /* md_loc */md[/* md_loc */2]
                                  ],
                                  rs$1
                                ]),
                              rem$1
                            ]
                          ];
                  } else {
                    exit = 1;
                  }
                }
                
              } else {
                exit = 1;
              }
              break;
          default:
            exit = 1;
        }
        if (exit === 1) {
          var match$5 = merge(add_item(item, env), sg[1], namelist, row_id);
          return /* tuple */[
                  match$5[0],
                  /* :: */[
                    item,
                    match$5[1]
                  ]
                ];
        }
        
      } else {
        throw [
              $$Error$10,
              loc,
              env,
              /* With_no_component */Block.__(4, [lid[/* txt */0]])
            ];
      }
    };
  };
  try {
    var names = flat(/* [] */0, lid[/* txt */0]);
    var match = merge(initial_env, sg, names, /* None */0);
    var sg$1 = match[1];
    var sg$2;
    if (names) {
      if (names[1]) {
        sg$2 = sg$1;
      } else {
        switch (constr.tag | 0) {
          case 0 : 
          case 1 : 
              sg$2 = sg$1;
              break;
          case 2 : 
              var sdecl = constr[0];
              var match$1 = real_id[0];
              var id;
              if (match$1) {
                id = match$1[0];
              } else {
                throw [
                      Caml_builtin_exceptions.assert_failure,
                      [
                        "typemod.ml",
                        246,
                        38
                      ]
                    ];
              }
              var lid$1;
              try {
                var match$2 = sdecl[/* ptype_manifest */5];
                if (match$2) {
                  var match$3 = match$2[0][/* ptyp_desc */0];
                  if (typeof match$3 === "number") {
                    throw Pervasives.Exit;
                  } else if (match$3.tag === 3) {
                    var stl = match$3[1];
                    if (List.length(stl) === List.length(sdecl[/* ptype_params */1])) {
                      List.iter2((function (x, param) {
                              var match = x[/* ptyp_desc */0];
                              if (typeof match === "number") {
                                throw Pervasives.Exit;
                              } else if (match.tag) {
                                throw Pervasives.Exit;
                              } else {
                                var match$1 = param[0][/* ptyp_desc */0];
                                if (typeof match$1 === "number") {
                                  throw Pervasives.Exit;
                                } else if (match$1.tag) {
                                  throw Pervasives.Exit;
                                } else if (match[0] === match$1[0]) {
                                  return /* () */0;
                                } else {
                                  throw Pervasives.Exit;
                                }
                              }
                            }), stl, sdecl[/* ptype_params */1]);
                      lid$1 = match$3[0];
                    } else {
                      throw Pervasives.Exit;
                    }
                  } else {
                    throw Pervasives.Exit;
                  }
                } else {
                  throw Pervasives.Exit;
                }
              }
              catch (exn){
                if (exn === Pervasives.Exit) {
                  throw [
                        $$Error$10,
                        sdecl[/* ptype_loc */7],
                        initial_env,
                        /* With_need_typeconstr */2
                      ];
                } else {
                  throw exn;
                }
              }
              var match$4;
              try {
                match$4 = lookup_type$1(lid$1[/* txt */0], initial_env);
              }
              catch (exn$1){
                if (exn$1 === Caml_builtin_exceptions.not_found) {
                  throw [
                        Caml_builtin_exceptions.assert_failure,
                        [
                          "typemod.ml",
                          263,
                          68
                        ]
                      ];
                } else {
                  throw exn$1;
                }
              }
              var sub = add_type(id, match$4[0], identity);
              sg$2 = signature$2(sub, sg$1);
              break;
          case 3 : 
              var match$5 = real_id[0];
              var id$1;
              if (match$5) {
                id$1 = match$5[0];
              } else {
                throw [
                      Caml_builtin_exceptions.assert_failure,
                      [
                        "typemod.ml",
                        269,
                        38
                      ]
                    ];
              }
              var path = lookup_module$1(/* None */0, initial_env, loc, constr[1][/* txt */0]);
              var sub$1 = add_module(id$1, path, identity);
              sg$2 = signature$2(sub$1, sg$1);
              break;
          
        }
      }
    } else {
      sg$2 = sg$1;
    }
    return /* tuple */[
            match[0],
            sg$2
          ];
  }
  catch (raw_exn){
    var exn$2 = Js_exn.internalToOCamlException(raw_exn);
    if (exn$2[0] === $$Error$5) {
      throw [
            $$Error$10,
            loc,
            initial_env,
            /* With_mismatch */Block.__(5, [
                lid[/* txt */0],
                exn$2[1]
              ])
          ];
    } else {
      throw exn$2;
    }
  }
}

function map_rec(fn, decls, rem) {
  if (decls) {
    return /* :: */[
            Curry._2(fn, /* Trec_first */1, decls[0]),
            map_end(Curry._1(fn, /* Trec_next */2), decls[1], rem)
          ];
  } else {
    return rem;
  }
}

function map_rec_type(rec_flag, fn, decls, rem) {
  if (decls) {
    var first = rec_flag !== 0 ? /* Trec_first */1 : /* Trec_not */0;
    return /* :: */[
            Curry._2(fn, first, decls[0]),
            map_end(Curry._1(fn, /* Trec_next */2), decls[1], rem)
          ];
  } else {
    return rem;
  }
}

function map_rec_type_with_row_types(rec_flag, fn, decls, rem) {
  if (decls) {
    var d1 = decls[0];
    if (is_row_name(d1[/* typ_id */0][/* name */1])) {
      return /* :: */[
              Curry._2(fn, /* Trec_not */0, d1),
              map_rec_type_with_row_types(rec_flag, fn, decls[1], rem)
            ];
    } else {
      return map_rec_type(rec_flag, fn, decls, rem);
    }
  } else {
    return rem;
  }
}

function rec_flag_of_ptype_declarations(tds) {
  var is_nonrec = List.exists((function (td) {
          return List.exists((function (param) {
                        return +(param[0][/* txt */0] === "nonrec");
                      }), td[/* ptype_attributes */6]);
        }), tds);
  if (is_nonrec) {
    return /* Nonrecursive */0;
  } else {
    return /* Recursive */1;
  }
}

function map_ext(fn, exts, rem) {
  if (exts) {
    return /* :: */[
            Curry._2(fn, /* Text_first */0, exts[0]),
            map_end(Curry._1(fn, /* Text_next */1), exts[1], rem)
          ];
  } else {
    return rem;
  }
}

function approx_modtype(env, _smty) {
  while(true) {
    var smty = _smty;
    var match = smty[/* pmty_desc */0];
    switch (match.tag | 0) {
      case 0 : 
          var match$1 = find_modtype$1(env, smty[/* pmty_loc */1], match[0][/* txt */0]);
          return /* Mty_ident */Block.__(0, [match$1[0]]);
      case 1 : 
          return /* Mty_signature */Block.__(1, [approx_sig(env, match[0])]);
      case 2 : 
          var arg = may_map((function (param) {
                  return approx_modtype(env, param);
                }), match[1]);
          var match$2 = enter_module(/* Some */[/* true */1], match[0][/* txt */0], default_mty(arg), env);
          var res = approx_modtype(match$2[1], match[2]);
          return /* Mty_functor */Block.__(2, [
                    match$2[0],
                    arg,
                    res
                  ]);
      case 3 : 
          _smty = match[0];
          continue ;
          case 4 : 
          return Curry._2(type_module_type_of_fwd[0], env, match[0])[1];
      case 5 : 
          throw [
                Error_forward$3,
                error_of_extension(match[0])
              ];
      case 6 : 
          var path = lookup_module$1(/* None */0, env, smty[/* pmty_loc */1], match[0][/* txt */0]);
          return /* Mty_alias */Block.__(3, [path]);
      
    }
  };
}

function approx_module_declaration(env, pmd) {
  return /* record */[
          /* md_type */approx_modtype(env, pmd[/* pmd_type */1]),
          /* md_attributes */pmd[/* pmd_attributes */2],
          /* md_loc */pmd[/* pmd_loc */3]
        ];
}

function approx_sig(_env, _ssg) {
  while(true) {
    var ssg = _ssg;
    var env = _env;
    if (ssg) {
      var srem = ssg[1];
      var match = ssg[0][/* psig_desc */0];
      var exit = 0;
      switch (match.tag | 0) {
        case 1 : 
            var sdecls = match[0];
            var rec_flag = rec_flag_of_ptype_declarations(sdecls);
            var decls = approx_type_decl(env, sdecls);
            var rem = approx_sig(env, srem);
            return map_rec_type(rec_flag, (function (rs, param) {
                          return /* Sig_type */Block.__(1, [
                                    param[0],
                                    param[1],
                                    rs
                                  ]);
                        }), decls, rem);
        case 4 : 
            var pmd = match[0];
            var md = approx_module_declaration(env, pmd);
            var match$1 = enter_module_declaration(/* None */0, pmd[/* pmd_name */0][/* txt */0], md, env);
            return /* :: */[
                    /* Sig_module */Block.__(3, [
                        match$1[0],
                        md,
                        /* Trec_not */0
                      ]),
                    approx_sig(match$1[1], srem)
                  ];
        case 5 : 
            var decls$1 = List.map((function(env){
                return function (pmd) {
                  return /* tuple */[
                          create(pmd[/* pmd_name */0][/* txt */0]),
                          approx_module_declaration(env, pmd)
                        ];
                }
                }(env)), match[0]);
            var newenv = List.fold_left((function (env, param) {
                    return add_module_declaration(/* None */0, param[0], param[1], env);
                  }), env, decls$1);
            return map_rec((function (rs, param) {
                          return /* Sig_module */Block.__(3, [
                                    param[0],
                                    param[1],
                                    rs
                                  ]);
                        }), decls$1, approx_sig(newenv, srem));
        case 6 : 
            var d = match[0];
            var info = approx_modtype_info(env, d);
            var match$2 = enter_modtype(d[/* pmtd_name */0][/* txt */0], info, env);
            return /* :: */[
                    /* Sig_modtype */Block.__(4, [
                        match$2[0],
                        info
                      ]),
                    approx_sig(match$2[1], srem)
                  ];
        case 7 : 
            var match$3 = type_open$1(/* None */0, env, match[0]);
            _ssg = srem;
            _env = match$3[1];
            continue ;
            case 8 : 
            var smty = match[0][/* pincl_mod */0];
            var mty = approx_modtype(env, smty);
            var sg = signature$2(identity, extract_sig(env, smty[/* pmty_loc */1], mty));
            var newenv$1 = add_signature(sg, env);
            return Pervasives.$at(sg, approx_sig(newenv$1, srem));
        case 9 : 
        case 10 : 
            exit = 1;
            break;
        default:
          _ssg = srem;
          continue ;
          
      }
      if (exit === 1) {
        var decls$2 = approx_class_declarations(env, match[0]);
        var rem$1 = approx_sig(env, srem);
        return List.flatten(map_rec((function (rs, param) {
                          return /* :: */[
                                  /* Sig_class_type */Block.__(6, [
                                      param[0],
                                      param[2],
                                      rs
                                    ]),
                                  /* :: */[
                                    /* Sig_type */Block.__(1, [
                                        param[3],
                                        param[4],
                                        rs
                                      ]),
                                    /* :: */[
                                      /* Sig_type */Block.__(1, [
                                          param[5],
                                          param[6],
                                          rs
                                        ]),
                                      /* [] */0
                                    ]
                                  ]
                                ];
                        }), decls$2, /* :: */[
                        rem$1,
                        /* [] */0
                      ]));
      }
      
    } else {
      return /* [] */0;
    }
  };
}

function approx_modtype_info(env, sinfo) {
  return /* record */[
          /* mtd_type */may_map((function (param) {
                  return approx_modtype(env, param);
                }), sinfo[/* pmtd_type */1]),
          /* mtd_attributes */sinfo[/* pmtd_attributes */2],
          /* mtd_loc */sinfo[/* pmtd_loc */3]
        ];
}

function check_recmod_typedecls(env, sdecls, decls) {
  var recmod_ids = List.map(fst3, decls);
  return List.iter2((function (pmd, param) {
                var mty = param[2][/* mty_type */1];
                return List.iter((function (path) {
                              var env$1 = env;
                              var loc = pmd[/* pmd_type */1][/* pmty_loc */1];
                              var recmod_ids$1 = recmod_ids;
                              var path$1 = path;
                              var decl = find_type_full(path, env)[0];
                              var to_check = function (path) {
                                return List.exists((function (id) {
                                              return isfree(id, path);
                                            }), recmod_ids$1);
                              };
                              check_well_founded_decl(env$1, loc, path$1, decl, to_check);
                              return check_recursion(env$1, loc, path$1, decl, to_check);
                            }), type_paths(env, /* Pident */Block.__(0, [param[0]]), mty));
              }), sdecls, decls);
}

function height$12(param) {
  if (param) {
    return param[3];
  } else {
    return 0;
  }
}

function create$13(l, v, r) {
  var hl = l ? l[3] : 0;
  var hr = r ? r[3] : 0;
  return /* Node */[
          l,
          v,
          r,
          hl >= hr ? hl + 1 | 0 : hr + 1 | 0
        ];
}

function bal$12(l, v, r) {
  var hl = l ? l[3] : 0;
  var hr = r ? r[3] : 0;
  if (hl > (hr + 2 | 0)) {
    if (l) {
      var lr = l[2];
      var lv = l[1];
      var ll = l[0];
      if (height$12(ll) >= height$12(lr)) {
        return create$13(ll, lv, create$13(lr, v, r));
      } else if (lr) {
        return create$13(create$13(ll, lv, lr[0]), lr[1], create$13(lr[2], v, r));
      } else {
        throw [
              Caml_builtin_exceptions.invalid_argument,
              "Set.bal"
            ];
      }
    } else {
      throw [
            Caml_builtin_exceptions.invalid_argument,
            "Set.bal"
          ];
    }
  } else if (hr > (hl + 2 | 0)) {
    if (r) {
      var rr = r[2];
      var rv = r[1];
      var rl = r[0];
      if (height$12(rr) >= height$12(rl)) {
        return create$13(create$13(l, v, rl), rv, rr);
      } else if (rl) {
        return create$13(create$13(l, v, rl[0]), rl[1], create$13(rl[2], rv, rr));
      } else {
        throw [
              Caml_builtin_exceptions.invalid_argument,
              "Set.bal"
            ];
      }
    } else {
      throw [
            Caml_builtin_exceptions.invalid_argument,
            "Set.bal"
          ];
    }
  } else {
    return /* Node */[
            l,
            v,
            r,
            hl >= hr ? hl + 1 | 0 : hr + 1 | 0
          ];
  }
}

function add$14(x, t) {
  if (t) {
    var r = t[2];
    var v = t[1];
    var l = t[0];
    var c = Caml_string.caml_string_compare(x, v);
    if (c) {
      if (c < 0) {
        return bal$12(add$14(x, l), v, r);
      } else {
        return bal$12(l, v, add$14(x, r));
      }
    } else {
      return t;
    }
  } else {
    return /* Node */[
            /* Empty */0,
            x,
            /* Empty */0,
            1
          ];
  }
}

function mem$7(x, _param) {
  while(true) {
    var param = _param;
    if (param) {
      var c = Caml_string.caml_string_compare(x, param[1]);
      if (c) {
        _param = c < 0 ? param[0] : param[2];
        continue ;
        
      } else {
        return /* true */1;
      }
    } else {
      return /* false */0;
    }
  };
}

function check(cl, loc, set_ref, name) {
  if (mem$7(name, set_ref[0])) {
    throw [
          $$Error$10,
          loc,
          empty,
          /* Repeated_name */Block.__(6, [
              cl,
              name
            ])
        ];
  } else {
    set_ref[0] = add$14(name, set_ref[0]);
    return /* () */0;
  }
}

function check_name(cl, set_ref, name) {
  return check(cl, name[/* loc */1], set_ref, name[/* txt */0]);
}

function check_sig_item(type_names, module_names, modtype_names, loc, param) {
  switch (param.tag | 0) {
    case 1 : 
        return check("type", loc, type_names, param[0][/* name */1]);
    case 3 : 
        return check("module", loc, module_names, param[0][/* name */1]);
    case 4 : 
        return check("module type", loc, modtype_names, param[0][/* name */1]);
    default:
      return /* () */0;
  }
}

function remove_duplicates(val_ids, ext_ids, _param) {
  while(true) {
    var param = _param;
    if (param) {
      var f = param[0];
      var exit = 0;
      switch (f.tag | 0) {
        case 0 : 
            var id = f[0];
            if (List.exists((function(id){
                  return function (param) {
                    return equal(id, param);
                  }
                  }(id)), val_ids)) {
              _param = param[1];
              continue ;
              
            } else {
              exit = 1;
            }
            break;
        case 2 : 
            var id$1 = f[0];
            var exit$1 = 0;
            if (f[2] !== 0) {
              exit$1 = 2;
            } else {
              var match = param[1];
              if (match) {
                var match$1 = match[0];
                if (match$1.tag === 2) {
                  if (match$1[2] !== 1) {
                    exit$1 = 2;
                  } else if (List.exists((function(id$1){
                        return function (param) {
                          return equal(id$1, param);
                        }
                        }(id$1)), ext_ids)) {
                    _param = /* :: */[
                      /* Sig_typext */Block.__(2, [
                          match$1[0],
                          match$1[1],
                          /* Text_first */0
                        ]),
                      match[1]
                    ];
                    continue ;
                    
                  } else {
                    exit$1 = 2;
                  }
                } else {
                  exit$1 = 2;
                }
              } else {
                exit$1 = 2;
              }
            }
            if (exit$1 === 2) {
              if (List.exists((function(id$1){
                    return function (param) {
                      return equal(id$1, param);
                    }
                    }(id$1)), ext_ids)) {
                _param = param[1];
                continue ;
                
              } else {
                exit = 1;
              }
            }
            break;
        default:
          exit = 1;
      }
      if (exit === 1) {
        return /* :: */[
                f,
                remove_duplicates(val_ids, ext_ids, param[1])
              ];
      }
      
    } else {
      return /* [] */0;
    }
  };
}

function get_values(_param) {
  while(true) {
    var param = _param;
    if (param) {
      var f = param[0];
      if (f.tag) {
        _param = param[1];
        continue ;
        
      } else {
        return /* :: */[
                f[0],
                get_values(param[1])
              ];
      }
    } else {
      return /* [] */0;
    }
  };
}

function get_extension_constructors(_param) {
  while(true) {
    var param = _param;
    if (param) {
      var f = param[0];
      if (f.tag === 2) {
        return /* :: */[
                f[0],
                get_extension_constructors(param[1])
              ];
      } else {
        _param = param[1];
        continue ;
        
      }
    } else {
      return /* [] */0;
    }
  };
}

function transl_modtype_longident$1(loc, env, lid) {
  return find_modtype$1(env, loc, lid)[0];
}

function transl_module_alias(loc, env, lid) {
  return lookup_module$1(/* None */0, env, loc, lid);
}

function mkmty$1(desc, typ, env, loc, attrs) {
  var mty = /* record */[
    /* mty_desc */desc,
    /* mty_type */typ,
    /* mty_env */env,
    /* mty_loc */loc,
    /* mty_attributes */attrs
  ];
  add_saved_type(/* Partial_module_type */Block.__(7, [mty]));
  return mty;
}

function mksig$1(desc, env, loc) {
  var sg = /* record */[
    /* sig_desc */desc,
    /* sig_env */env,
    /* sig_loc */loc
  ];
  add_saved_type(/* Partial_signature_item */Block.__(6, [sg]));
  return sg;
}

function transl_modtype$1(env, smty) {
  var loc = smty[/* pmty_loc */1];
  var match = smty[/* pmty_desc */0];
  switch (match.tag | 0) {
    case 0 : 
        var lid = match[0];
        var path = transl_modtype_longident$1(loc, env, lid[/* txt */0]);
        return mkmty$1(/* Tmty_ident */Block.__(0, [
                      path,
                      lid
                    ]), /* Mty_ident */Block.__(0, [path]), env, loc, smty[/* pmty_attributes */2]);
    case 1 : 
        var sg = transl_signature(env, match[0]);
        return mkmty$1(/* Tmty_signature */Block.__(1, [sg]), /* Mty_signature */Block.__(1, [sg[/* sig_type */1]]), env, loc, smty[/* pmty_attributes */2]);
    case 2 : 
        var param = match[0];
        var arg = may_map((function (param) {
                return transl_modtype$1(env, param);
              }), match[1]);
        var ty_arg = may_map((function (m) {
                return m[/* mty_type */1];
              }), arg);
        var match$1 = enter_module(/* Some */[/* true */1], param[/* txt */0], default_mty(ty_arg), env);
        var id = match$1[0];
        init_def(currentstamp[0]);
        var res = transl_modtype$1(match$1[1], match[2]);
        return mkmty$1(/* Tmty_functor */Block.__(2, [
                      id,
                      param,
                      arg,
                      res
                    ]), /* Mty_functor */Block.__(2, [
                      id,
                      ty_arg,
                      res[/* mty_type */1]
                    ]), env, loc, smty[/* pmty_attributes */2]);
    case 3 : 
        var sbody = match[0];
        var body = transl_modtype$1(env, sbody);
        var init_sg = extract_sig(env, sbody[/* pmty_loc */1], body[/* mty_type */1]);
        var match$2 = List.fold_left((function (param, sdecl) {
                var match = merge_constraint(env, smty[/* pmty_loc */1], param[1], sdecl);
                return /* tuple */[
                        /* :: */[
                          match[0],
                          param[0]
                        ],
                        match[1]
                      ];
              }), /* tuple */[
              /* [] */0,
              init_sg
            ], match[1]);
        return mkmty$1(/* Tmty_with */Block.__(3, [
                      body,
                      List.rev(match$2[0])
                    ]), freshen(/* Mty_signature */Block.__(1, [match$2[1]])), env, loc, smty[/* pmty_attributes */2]);
    case 4 : 
        var match$3 = Curry._2(type_module_type_of_fwd[0], env, match[0]);
        return mkmty$1(/* Tmty_typeof */Block.__(4, [match$3[0]]), match$3[1], env, loc, smty[/* pmty_attributes */2]);
    case 5 : 
        throw [
              Error_forward$3,
              error_of_extension(match[0])
            ];
    case 6 : 
        var lid$1 = match[0];
        var path$1 = transl_module_alias(loc, env, lid$1[/* txt */0]);
        return mkmty$1(/* Tmty_alias */Block.__(5, [
                      path$1,
                      lid$1
                    ]), /* Mty_alias */Block.__(3, [path$1]), env, loc, smty[/* pmty_attributes */2]);
    
  }
}

function transl_signature(env, sg) {
  var type_names = [/* Empty */0];
  var module_names = [/* Empty */0];
  var modtype_names = [/* Empty */0];
  var transl_sig = function (env, sg) {
    init_def(currentstamp[0]);
    if (sg) {
      var srem = sg[1];
      var item = sg[0];
      var loc = item[/* psig_loc */1];
      var match = item[/* psig_desc */0];
      switch (match.tag | 0) {
        case 0 : 
            var match$1 = transl_value_decl(env, item[/* psig_loc */1], match[0]);
            var tdesc = match$1[0];
            var match$2 = transl_sig(match$1[1], srem);
            var rem = match$2[1];
            var partial_arg = tdesc[/* val_id */0];
            return /* tuple */[
                    /* :: */[
                      mksig$1(/* Tsig_value */Block.__(0, [tdesc]), env, loc),
                      match$2[0]
                    ],
                    List.exists((function (param) {
                            return equal(partial_arg, param);
                          }), get_values(rem)) ? rem : /* :: */[
                        /* Sig_value */Block.__(0, [
                            tdesc[/* val_id */0],
                            tdesc[/* val_val */3]
                          ]),
                        rem
                      ],
                    match$2[2]
                  ];
        case 1 : 
            var sdecls = match[0];
            var rec_flag = rec_flag_of_ptype_declarations(sdecls);
            List.iter((function (decl) {
                    return check_name("type", type_names, decl[/* ptype_name */0]);
                  }), sdecls);
            var match$3 = transl_type_decl(env, rec_flag, sdecls);
            var decls = match$3[0];
            var match$4 = transl_sig(match$3[1], srem);
            return /* tuple */[
                    /* :: */[
                      mksig$1(/* Tsig_type */Block.__(1, [decls]), env, loc),
                      match$4[0]
                    ],
                    map_rec_type_with_row_types(rec_flag, (function (rs, td) {
                            return /* Sig_type */Block.__(1, [
                                      td[/* typ_id */0],
                                      td[/* typ_type */3],
                                      rs
                                    ]);
                          }), decls, match$4[1]),
                    match$4[2]
                  ];
        case 2 : 
            var match$5 = transl_type_extension(/* false */0, env, item[/* psig_loc */1], match[0]);
            var tyext = match$5[0];
            var match$6 = transl_sig(match$5[1], srem);
            var rem$1 = match$6[1];
            var constructors = List.filter((function (ext) {
                      var partial_arg = ext[/* ext_id */0];
                      return 1 - List.exists((function (param) {
                                    return equal(partial_arg, param);
                                  }), get_extension_constructors(rem$1));
                    }))(tyext[/* tyext_constructors */3]);
            return /* tuple */[
                    /* :: */[
                      mksig$1(/* Tsig_typext */Block.__(2, [tyext]), env, loc),
                      match$6[0]
                    ],
                    map_ext((function (es, ext) {
                            return /* Sig_typext */Block.__(2, [
                                      ext[/* ext_id */0],
                                      ext[/* ext_type */2],
                                      es
                                    ]);
                          }), constructors, rem$1),
                    match$6[2]
                  ];
        case 3 : 
            var match$7 = transl_exception(env, match[0]);
            var ext = match$7[0];
            var match$8 = transl_sig(match$7[1], srem);
            var rem$2 = match$8[1];
            var partial_arg$1 = ext[/* ext_id */0];
            var shadowed = List.exists((function (param) {
                    return equal(partial_arg$1, param);
                  }), get_extension_constructors(rem$2));
            return /* tuple */[
                    /* :: */[
                      mksig$1(/* Tsig_exception */Block.__(3, [ext]), env, loc),
                      match$8[0]
                    ],
                    shadowed ? rem$2 : /* :: */[
                        /* Sig_typext */Block.__(2, [
                            ext[/* ext_id */0],
                            ext[/* ext_type */2],
                            /* Text_exception */2
                          ]),
                        rem$2
                      ],
                    match$8[2]
                  ];
        case 4 : 
            var pmd = match[0];
            check_name("module", module_names, pmd[/* pmd_name */0]);
            var tmty = transl_modtype$1(env, pmd[/* pmd_type */1]);
            var md_000 = /* md_type */tmty[/* mty_type */1];
            var md_001 = /* md_attributes */pmd[/* pmd_attributes */2];
            var md_002 = /* md_loc */pmd[/* pmd_loc */3];
            var md = /* record */[
              md_000,
              md_001,
              md_002
            ];
            var match$9 = enter_module_declaration(/* None */0, pmd[/* pmd_name */0][/* txt */0], md, env);
            var id = match$9[0];
            var match$10 = transl_sig(match$9[1], srem);
            return /* tuple */[
                    /* :: */[
                      mksig$1(/* Tsig_module */Block.__(4, [/* record */[
                                /* md_id */id,
                                /* md_name */pmd[/* pmd_name */0],
                                /* md_type */tmty,
                                /* md_attributes */pmd[/* pmd_attributes */2],
                                /* md_loc */pmd[/* pmd_loc */3]
                              ]]), env, loc),
                      match$10[0]
                    ],
                    /* :: */[
                      /* Sig_module */Block.__(3, [
                          id,
                          md,
                          /* Trec_not */0
                        ]),
                      match$10[1]
                    ],
                    match$10[2]
                  ];
        case 5 : 
            var sdecls$1 = match[0];
            List.iter((function (pmd) {
                    return check_name("module", module_names, pmd[/* pmd_name */0]);
                  }), sdecls$1);
            var match$11 = transl_recmodule_modtypes(item[/* psig_loc */1], env, sdecls$1);
            var decls$1 = match$11[0];
            var match$12 = transl_sig(match$11[1], srem);
            return /* tuple */[
                    /* :: */[
                      mksig$1(/* Tsig_recmodule */Block.__(5, [decls$1]), env, loc),
                      match$12[0]
                    ],
                    map_rec((function (rs, md) {
                            var d_000 = /* md_type */md[/* md_type */2][/* mty_type */1];
                            var d_001 = /* md_attributes */md[/* md_attributes */3];
                            var d_002 = /* md_loc */md[/* md_loc */4];
                            var d = /* record */[
                              d_000,
                              d_001,
                              d_002
                            ];
                            return /* Sig_module */Block.__(3, [
                                      md[/* md_id */0],
                                      d,
                                      rs
                                    ]);
                          }), decls$1, match$12[1]),
                    match$12[2]
                  ];
        case 6 : 
            var match$13 = transl_modtype_decl(modtype_names, env, item[/* psig_loc */1], match[0]);
            var match$14 = transl_sig(match$13[0], srem);
            return /* tuple */[
                    /* :: */[
                      mksig$1(/* Tsig_modtype */Block.__(6, [match$13[1]]), env, loc),
                      match$14[0]
                    ],
                    /* :: */[
                      match$13[2],
                      match$14[1]
                    ],
                    match$14[2]
                  ];
        case 7 : 
            var match$15 = type_open$1(/* None */0, env, match[0]);
            var match$16 = transl_sig(match$15[1], srem);
            return /* tuple */[
                    /* :: */[
                      mksig$1(/* Tsig_open */Block.__(7, [match$15[2]]), env, loc),
                      match$16[0]
                    ],
                    match$16[1],
                    match$16[2]
                  ];
        case 8 : 
            var sincl = match[0];
            var smty = sincl[/* pincl_mod */0];
            var tmty$1 = transl_modtype$1(env, smty);
            var mty = tmty$1[/* mty_type */1];
            var sg$1 = signature$2(identity, extract_sig(env, smty[/* pmty_loc */1], mty));
            var partial_arg$2 = item[/* psig_loc */1];
            List.iter((function (param) {
                    return check_sig_item(type_names, module_names, modtype_names, partial_arg$2, param);
                  }), sg$1);
            var newenv = add_signature(sg$1, env);
            var incl_002 = /* incl_loc */sincl[/* pincl_loc */1];
            var incl_003 = /* incl_attributes */sincl[/* pincl_attributes */2];
            var incl = /* record */[
              /* incl_mod */tmty$1,
              /* incl_type */sg$1,
              incl_002,
              incl_003
            ];
            var match$17 = transl_sig(newenv, srem);
            var rem$3 = match$17[1];
            return /* tuple */[
                    /* :: */[
                      mksig$1(/* Tsig_include */Block.__(8, [incl]), env, loc),
                      match$17[0]
                    ],
                    Pervasives.$at(remove_duplicates(get_values(rem$3), get_extension_constructors(rem$3), sg$1), rem$3),
                    match$17[2]
                  ];
        case 9 : 
            var cl = match[0];
            List.iter((function (param) {
                    return check_name("type", type_names, param[/* pci_name */2]);
                  }), cl);
            var match$18 = class_descriptions(env, cl);
            var classes = match$18[0];
            var match$19 = transl_sig(match$18[1], srem);
            return /* tuple */[
                    /* :: */[
                      mksig$1(/* Tsig_class */Block.__(9, [List.map2((function (_, tcl) {
                                      return tcl[11];
                                    }), cl, classes)]), env, loc),
                      match$19[0]
                    ],
                    List.flatten(map_rec((function (rs, param) {
                                return /* :: */[
                                        /* Sig_class */Block.__(5, [
                                            param[0],
                                            param[2],
                                            rs
                                          ]),
                                        /* :: */[
                                          /* Sig_class_type */Block.__(6, [
                                              param[3],
                                              param[4],
                                              rs
                                            ]),
                                          /* :: */[
                                            /* Sig_type */Block.__(1, [
                                                param[5],
                                                param[6],
                                                rs
                                              ]),
                                            /* :: */[
                                              /* Sig_type */Block.__(1, [
                                                  param[7],
                                                  param[8],
                                                  rs
                                                ]),
                                              /* [] */0
                                            ]
                                          ]
                                        ]
                                      ];
                              }), classes, /* :: */[
                              match$19[1],
                              /* [] */0
                            ])),
                    match$19[2]
                  ];
        case 10 : 
            var cl$1 = match[0];
            List.iter((function (param) {
                    return check_name("type", type_names, param[/* pci_name */2]);
                  }), cl$1);
            var match$20 = class_type_declarations$2(env, cl$1);
            var classes$1 = match$20[0];
            var match$21 = transl_sig(match$20[1], srem);
            return /* tuple */[
                    /* :: */[
                      mksig$1(/* Tsig_class_type */Block.__(10, [List.map2((function (_, tcl) {
                                      return tcl[7];
                                    }), cl$1, classes$1)]), env, loc),
                      match$21[0]
                    ],
                    List.flatten(map_rec((function (rs, param) {
                                return /* :: */[
                                        /* Sig_class_type */Block.__(6, [
                                            param[0],
                                            param[2],
                                            rs
                                          ]),
                                        /* :: */[
                                          /* Sig_type */Block.__(1, [
                                              param[3],
                                              param[4],
                                              rs
                                            ]),
                                          /* :: */[
                                            /* Sig_type */Block.__(1, [
                                                param[5],
                                                param[6],
                                                rs
                                              ]),
                                            /* [] */0
                                          ]
                                        ]
                                      ];
                              }), classes$1, /* :: */[
                              match$21[1],
                              /* [] */0
                            ])),
                    match$21[2]
                  ];
        case 11 : 
            var x = match[0];
            warning_attribute(/* :: */[
                  x,
                  /* [] */0
                ]);
            var match$22 = transl_sig(env, srem);
            return /* tuple */[
                    /* :: */[
                      mksig$1(/* Tsig_attribute */Block.__(11, [x]), env, loc),
                      match$22[0]
                    ],
                    match$22[1],
                    match$22[2]
                  ];
        case 12 : 
            throw [
                  Error_forward$3,
                  error_of_extension(match[0])
                ];
        
      }
    } else {
      return /* tuple */[
              /* [] */0,
              /* [] */0,
              env
            ];
    }
  };
  var previous_saved_types = saved_types[0];
  warning_enter_scope(/* () */0);
  var match = transl_sig(in_signature(env), sg);
  var sg_000 = /* sig_items */match[0];
  var sg_001 = /* sig_type */match[1];
  var sg_002 = /* sig_final_env */match[2];
  var sg$1 = /* record */[
    sg_000,
    sg_001,
    sg_002
  ];
  warning_leave_scope(/* () */0);
  saved_types[0] = /* :: */[
    /* Partial_signature */Block.__(5, [sg$1]),
    previous_saved_types
  ];
  return sg$1;
}

function transl_modtype_decl(modtype_names, env, _, param) {
  var pmtd_loc = param[/* pmtd_loc */3];
  var pmtd_attributes = param[/* pmtd_attributes */2];
  var pmtd_name = param[/* pmtd_name */0];
  check_name("module type", modtype_names, pmtd_name);
  var tmty = may_map((function (param) {
          return transl_modtype$1(env, param);
        }), param[/* pmtd_type */1]);
  var decl_000 = /* mtd_type */may_map((function (t) {
          return t[/* mty_type */1];
        }), tmty);
  var decl = /* record */[
    decl_000,
    /* mtd_attributes */pmtd_attributes,
    /* mtd_loc */pmtd_loc
  ];
  var match = enter_modtype(pmtd_name[/* txt */0], decl, env);
  var id = match[0];
  var mtd = /* record */[
    /* mtd_id */id,
    /* mtd_name */pmtd_name,
    /* mtd_type */tmty,
    /* mtd_attributes */pmtd_attributes,
    /* mtd_loc */pmtd_loc
  ];
  return /* tuple */[
          match[1],
          mtd,
          /* Sig_modtype */Block.__(4, [
              id,
              decl
            ])
        ];
}

function transl_recmodule_modtypes(_, env, sdecls) {
  var make_env = function (curr) {
    return List.fold_left((function (env, param) {
                  return add_module$1(/* Some */[/* true */1], param[0], param[2], env);
                }), env, curr);
  };
  var make_env2 = function (curr) {
    return List.fold_left((function (env, param) {
                  return add_module$1(/* Some */[/* true */1], param[0], param[2][/* mty_type */1], env);
                }), env, curr);
  };
  var transition = function (env_c, curr) {
    return List.map2((function (pmd, param) {
                  return /* tuple */[
                          param[0],
                          param[1],
                          transl_modtype$1(env_c, pmd[/* pmd_type */1])
                        ];
                }), sdecls, curr);
  };
  var ids = List.map((function (x) {
          return create(x[/* pmd_name */0][/* txt */0]);
        }), sdecls);
  var approx_env = List.fold_left((function (env, id) {
          var dummy = /* Mty_ident */Block.__(0, [/* Pident */Block.__(0, [create("#recmod#")])]);
          return add_module$1(/* Some */[/* true */1], id, dummy, env);
        }), env, ids);
  var init = List.map2((function (id, pmd) {
          return /* tuple */[
                  id,
                  pmd[/* pmd_name */0],
                  approx_modtype(approx_env, pmd[/* pmd_type */1])
                ];
        }), ids, sdecls);
  var env0 = make_env(init);
  var dcl1 = transition(env0, init);
  var env1 = make_env2(dcl1);
  check_recmod_typedecls(env1, sdecls, dcl1);
  var dcl2 = transition(env1, dcl1);
  var env2 = make_env2(dcl2);
  check_recmod_typedecls(env2, sdecls, dcl2);
  var dcl2$1 = List.map2((function (pmd, param) {
          return /* record */[
                  /* md_id */param[0],
                  /* md_name */param[1],
                  /* md_type */param[2],
                  /* md_attributes */pmd[/* pmd_attributes */2],
                  /* md_loc */pmd[/* pmd_loc */3]
                ];
        }), sdecls, dcl2);
  return /* tuple */[
          dcl2$1,
          env2
        ];
}

function simplify_signature(sg) {
  var aux = function (param) {
    if (param) {
      var component = param[0];
      switch (component.tag | 0) {
        case 0 : 
            var k = aux(param[1]);
            var val_names = k[1];
            var name = component[0][/* name */1];
            if (mem$7(name, val_names)) {
              return k;
            } else {
              return /* tuple */[
                      /* :: */[
                        component,
                        k[0]
                      ],
                      add$14(name, val_names),
                      k[2]
                    ];
            }
        case 2 : 
            var k$1 = aux(param[1]);
            var ext_names = k$1[2];
            var val_names$1 = k$1[1];
            var sg = k$1[0];
            var name$1 = component[0][/* name */1];
            if (mem$7(name$1, ext_names)) {
              if (component[2] !== 0) {
                return k$1;
              } else if (sg) {
                var match = sg[0];
                if (match.tag === 2 && match[2] === 1) {
                  return /* tuple */[
                          /* :: */[
                            /* Sig_typext */Block.__(2, [
                                match[0],
                                match[1],
                                /* Text_first */0
                              ]),
                            sg[1]
                          ],
                          val_names$1,
                          ext_names
                        ];
                } else {
                  return k$1;
                }
              } else {
                return k$1;
              }
            } else {
              return /* tuple */[
                      /* :: */[
                        component,
                        sg
                      ],
                      val_names$1,
                      add$14(name$1, ext_names)
                    ];
            }
            break;
        default:
          var match$1 = aux(param[1]);
          return /* tuple */[
                  /* :: */[
                    component,
                    match$1[0]
                  ],
                  match$1[1],
                  match$1[2]
                ];
      }
    } else {
      return /* tuple */[
              /* [] */0,
              /* Empty */0,
              /* Empty */0
            ];
    }
  };
  return aux(sg)[0];
}

var Not_a_path = Caml_exceptions.create("Ocaml_typedtree_test.Typemod.Not_a_path");

function path_of_module(_mexp) {
  while(true) {
    var mexp = _mexp;
    var match = mexp[/* mod_desc */0];
    switch (match.tag | 0) {
      case 0 : 
          return match[0];
      case 3 : 
          if (applicative_functors[0]) {
            return /* Papply */Block.__(2, [
                      path_of_module(match[0]),
                      path_of_module(match[1])
                    ]);
          } else {
            throw Not_a_path;
          }
          break;
      case 4 : 
          _mexp = match[0];
          continue ;
          default:
        throw Not_a_path;
    }
  };
}

function path_of_module$1(mexp) {
  try {
    return /* Some */[path_of_module(mexp)];
  }
  catch (exn){
    if (exn === Not_a_path) {
      return /* None */0;
    } else {
      throw exn;
    }
  }
}

function closed_modtype(_param) {
  while(true) {
    var param = _param;
    switch (param.tag | 0) {
      case 1 : 
          return List.for_all(closed_signature_item, param[0]);
      case 2 : 
          _param = param[2];
          continue ;
          case 0 : 
      case 3 : 
          return /* true */1;
      
    }
  };
}

function closed_signature_item(param) {
  switch (param.tag | 0) {
    case 0 : 
        return closed_schema(param[1][/* val_type */0]);
    case 3 : 
        return closed_modtype(param[1][/* md_type */0]);
    default:
      return /* true */1;
  }
}

function anchor_submodule(name, anchor) {
  if (anchor) {
    return /* Some */[/* Pdot */Block.__(1, [
                anchor[0],
                name,
                -1
              ])];
  } else {
    return /* None */0;
  }
}

function enrich_type_decls(anchor, decls, oldenv, newenv) {
  if (anchor) {
    var p = anchor[0];
    return List.fold_left((function (e, info) {
                  var id = info[/* typ_id */0];
                  var info$prime = enrich_typedecl(oldenv, /* Pdot */Block.__(1, [
                          p,
                          id[/* name */1],
                          -1
                        ]), info[/* typ_type */3]);
                  return add_type$1(/* true */1, id, info$prime, e);
                }), oldenv, decls);
  } else {
    return newenv;
  }
}

function enrich_module_type(anchor, name, mty, env) {
  if (anchor) {
    return enrich_modtype(env, /* Pdot */Block.__(1, [
                  anchor[0],
                  name,
                  -1
                ]), mty);
  } else {
    return mty;
  }
}

function check_recmodule_inclusion(env, bindings) {
  var subst_and_strengthen = function (env, s, id, mty) {
    return strengthen$1(env, modtype(s, mty), module_path(s, /* Pident */Block.__(0, [id])));
  };
  var _first_time = /* true */1;
  var _n = List.length(bindings);
  var _env = env;
  var _s = identity;
  while(true) {
    var s = _s;
    var env$1 = _env;
    var n = _n;
    var first_time = _first_time;
    if (n > 0) {
      var bindings1 = List.map((function (param) {
              var id = param[0];
              return /* tuple */[
                      id,
                      rename(id),
                      param[4]
                    ];
            }), bindings);
      var env$prime = List.fold_left((function(first_time,s){
          return function (env, param) {
            var mty_actual = param[2];
            var mty_actual$prime = first_time ? mty_actual : subst_and_strengthen(env, s, param[0], mty_actual);
            return add_module$1(/* Some */[/* false */0], param[1], mty_actual$prime, env);
          }
          }(first_time,s)), env$1, bindings1);
      var s$prime = List.fold_left((function (s, param) {
              return add_module(param[0], /* Pident */Block.__(0, [param[1]]), s);
            }), identity, bindings1);
      _s = s$prime;
      _env = env$prime;
      _n = n - 1 | 0;
      _first_time = /* false */0;
      continue ;
      
    } else {
      var check_inclusion = (function(env$1,s){
      return function check_inclusion(param) {
        var modl = param[3];
        var mty_decl = param[2];
        var id = param[0];
        var mty_decl$prime = modtype(s, mty_decl[/* mty_type */1]);
        var mty_actual$prime = subst_and_strengthen(env$1, s, id, param[4]);
        var coercion;
        try {
          coercion = modtypes$1(env$1, mty_actual$prime, mty_decl$prime);
        }
        catch (raw_exn){
          var exn = Js_exn.internalToOCamlException(raw_exn);
          if (exn[0] === $$Error$5) {
            throw [
                  $$Error$10,
                  modl[/* mod_loc */1],
                  env$1,
                  /* Not_included */Block.__(1, [exn[1]])
                ];
          } else {
            throw exn;
          }
        }
        var modl$prime_000 = /* mod_desc : Tmod_constraint */Block.__(4, [
            modl,
            mty_decl[/* mty_type */1],
            /* Tmodtype_explicit */[mty_decl],
            coercion
          ]);
        var modl$prime_001 = /* mod_loc */modl[/* mod_loc */1];
        var modl$prime_002 = /* mod_type */mty_decl[/* mty_type */1];
        var modl$prime = /* record */[
          modl$prime_000,
          modl$prime_001,
          modl$prime_002,
          /* mod_env */env$1,
          /* mod_attributes : [] */0
        ];
        return /* record */[
                /* mb_id */id,
                /* mb_name */param[1],
                /* mb_expr */modl$prime,
                /* mb_attributes */param[5],
                /* mb_loc */param[6]
              ];
      }
      }(env$1,s));
      return List.map(check_inclusion, bindings);
    }
  };
}

function package_constraints(env, loc, mty, constrs) {
  if (constrs) {
    var sg = extract_sig(env, loc, mty);
    var sg$prime = List.map((function (item) {
            switch (item.tag | 0) {
              case 1 : 
                  var td = item[1];
                  if (td[/* type_params */0]) {
                    return item;
                  } else {
                    var id = item[0];
                    if (List.mem_assoc(/* :: */[
                            id[/* name */1],
                            /* [] */0
                          ], constrs)) {
                      var ty = List.assoc(/* :: */[
                            id[/* name */1],
                            /* [] */0
                          ], constrs);
                      var newrecord = td.slice();
                      return /* Sig_type */Block.__(1, [
                                id,
                                (newrecord[/* type_manifest */4] = /* Some */[ty], newrecord),
                                item[2]
                              ]);
                    } else {
                      return item;
                    }
                  }
                  break;
              case 3 : 
                  var md = item[1];
                  var id$1 = item[0];
                  var aux = function (_param) {
                    while(true) {
                      var param = _param;
                      if (param) {
                        var match = param[0];
                        var match$1 = match[0];
                        if (match$1) {
                          var l = match$1[1];
                          if (l) {
                            if (match$1[0] === id$1[/* name */1]) {
                              return /* :: */[
                                      /* tuple */[
                                        l,
                                        match[1]
                                      ],
                                      aux(param[1])
                                    ];
                            } else {
                              _param = param[1];
                              continue ;
                              
                            }
                          } else {
                            _param = param[1];
                            continue ;
                            
                          }
                        } else {
                          _param = param[1];
                          continue ;
                          
                        }
                      } else {
                        return /* [] */0;
                      }
                    };
                  };
                  var md_000 = /* md_type */package_constraints(env, loc, md[/* md_type */0], aux(constrs));
                  var md_001 = /* md_attributes */md[/* md_attributes */1];
                  var md_002 = /* md_loc */md[/* md_loc */2];
                  var md$1 = /* record */[
                    md_000,
                    md_001,
                    md_002
                  ];
                  return /* Sig_module */Block.__(3, [
                            id$1,
                            md$1,
                            item[2]
                          ]);
              default:
                return item;
            }
          }), sg);
    return /* Mty_signature */Block.__(1, [sg$prime]);
  } else {
    return mty;
  }
}

function modtype_of_package(env, loc, p, nl, tl) {
  try {
    var match = find_modtype(p, env)[/* mtd_type */0];
    var exit = 0;
    if (match) {
      if (nl !== /* [] */0) {
        return package_constraints(env, loc, match[0], List.combine(List.map(flatten, nl), tl));
      } else {
        exit = 1;
      }
    } else {
      exit = 1;
    }
    if (exit === 1) {
      if (nl) {
        throw [
              $$Error$10,
              loc,
              env,
              /* Signature_expected */0
            ];
      } else {
        return /* Mty_ident */Block.__(0, [p]);
      }
    }
    
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      var error = /* Unbound_modtype */Block.__(22, [lid_of_path(/* None */0, p)]);
      throw [
            $$Error$6,
            loc,
            env,
            error
          ];
    } else {
      throw exn;
    }
  }
}

function package_subtype$1(env, p1, nl1, tl1, p2, nl2, tl2) {
  var mkmty = function (p, nl, tl) {
    var ntl = List.filter((function (param) {
              return +(free_variables$1(/* None */0, param[1]) === /* [] */0);
            }))(List.combine(nl, tl));
    var match = List.split(ntl);
    return modtype_of_package(env, none, p, match[0], match[1]);
  };
  var mty1 = mkmty(p1, nl1, tl1);
  var mty2 = mkmty(p2, nl2, tl2);
  try {
    return +(modtypes$1(env, mty1, mty2) === /* Tcoerce_none */0);
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === $$Error$5) {
      return /* false */0;
    } else {
      throw exn;
    }
  }
}

package_subtype[0] = package_subtype$1;

function wrap_constraint(env, arg, mty, explicit) {
  var coercion;
  try {
    coercion = modtypes$1(env, arg[/* mod_type */2], mty);
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === $$Error$5) {
      throw [
            $$Error$10,
            arg[/* mod_loc */1],
            env,
            /* Not_included */Block.__(1, [exn[1]])
          ];
    } else {
      throw exn;
    }
  }
  return /* record */[
          /* mod_desc : Tmod_constraint */Block.__(4, [
              arg,
              mty,
              explicit,
              coercion
            ]),
          /* mod_loc */arg[/* mod_loc */1],
          /* mod_type */mty,
          /* mod_env */env,
          /* mod_attributes : [] */0
        ];
}

function type_module$1($staropt$star, sttn, funct_body, anchor, env, smod) {
  var alias = $staropt$star ? $staropt$star[0] : /* false */0;
  var match = smod[/* pmod_desc */0];
  switch (match.tag | 0) {
    case 0 : 
        var lid = match[0];
        var path = lookup_module$1(/* Some */[1 - alias], env, smod[/* pmod_loc */1], lid[/* txt */0]);
        var md_000 = /* mod_desc : Tmod_ident */Block.__(0, [
            path,
            lid
          ]);
        var md_001 = /* mod_loc */smod[/* pmod_loc */1];
        var md_002 = /* mod_type : Mty_alias */Block.__(3, [path]);
        var md_004 = /* mod_attributes */smod[/* pmod_attributes */2];
        var md = /* record */[
          md_000,
          md_001,
          md_002,
          /* mod_env */env,
          md_004
        ];
        var $js;
        if (alias && !is_functor_arg(path, env)) {
          add_required_global(head(path));
          $js = md;
        } else {
          var mty = find_module(/* false */0, path, env)[/* md_type */0];
          var exit = 0;
          if (mty.tag === 3) {
            if (alias) {
              exit = 1;
            } else {
              var p1 = normalize_path$1(/* Some */[smod[/* pmod_loc */1]], env, mty[0]);
              var mty$1 = expand_module_alias(env, /* [] */0, p1);
              $js = /* record */[
                /* mod_desc : Tmod_constraint */Block.__(4, [
                    md,
                    mty$1,
                    /* Tmodtype_implicit */0,
                    /* Tcoerce_alias */Block.__(3, [
                        p1,
                        /* Tcoerce_none */0
                      ])
                  ]),
                md_001,
                /* mod_type */sttn ? strengthen$1(env, mty$1, p1) : mty$1,
                /* mod_env */env,
                md_004
              ];
            }
          } else {
            exit = 1;
          }
          if (exit === 1) {
            var mty$2 = sttn ? strengthen$1(env, mty, path) : mty;
            $js = /* record */[
              md_000,
              md_001,
              /* mod_type */mty$2,
              /* mod_env */env,
              md_004
            ];
          }
          
        }
        return rm($js);
    case 1 : 
        var match$1 = type_structure(/* None */0, funct_body, anchor, env, match[0], smod[/* pmod_loc */1]);
        var sg = match$1[1];
        var md$1 = rm(/* record */[
              /* mod_desc : Tmod_structure */Block.__(1, [match$1[0]]),
              /* mod_loc */smod[/* pmod_loc */1],
              /* mod_type : Mty_signature */Block.__(1, [sg]),
              /* mod_env */env,
              /* mod_attributes */smod[/* pmod_attributes */2]
            ]);
        var sg$prime = simplify_signature(sg);
        if (List.length(sg$prime) === List.length(sg)) {
          return md$1;
        } else {
          return wrap_constraint(implicit_coercion(env), md$1, /* Mty_signature */Block.__(1, [sg$prime]), /* Tmodtype_implicit */0);
        }
    case 2 : 
        var name = match[0];
        var mty$3 = may_map((function (param) {
                return transl_modtype$1(env, param);
              }), match[1]);
        var ty_arg = may_map((function (m) {
                return m[/* mty_type */1];
              }), mty$3);
        var match$2 = ty_arg ? /* tuple */[
            enter_module(/* Some */[/* true */1], name[/* txt */0], ty_arg[0], env),
            /* true */1
          ] : /* tuple */[
            /* tuple */[
              create("*"),
              env
            ],
            /* false */0
          ];
        var match$3 = match$2[0];
        var id = match$3[0];
        var body = type_module$1(/* None */0, sttn, match$2[1], /* None */0, match$3[1], match[2]);
        return rm(/* record */[
                    /* mod_desc : Tmod_functor */Block.__(2, [
                        id,
                        name,
                        mty$3,
                        body
                      ]),
                    /* mod_loc */smod[/* pmod_loc */1],
                    /* mod_type : Mty_functor */Block.__(2, [
                        id,
                        ty_arg,
                        body[/* mod_type */2]
                      ]),
                    /* mod_env */env,
                    /* mod_attributes */smod[/* pmod_attributes */2]
                  ]);
    case 3 : 
        var sarg = match[1];
        var sfunct = match[0];
        var arg = type_module$1(/* None */0, /* true */1, funct_body, /* None */0, env, sarg);
        var path$1 = path_of_module$1(arg);
        var funct = type_module$1(/* None */0, sttn && +(path$1 !== /* None */0), funct_body, /* None */0, env, sfunct);
        var mty_functor = scrape_alias(env, /* None */0, funct[/* mod_type */2]);
        if (mty_functor.tag === 2) {
          var mty_res = mty_functor[2];
          var mty_param = mty_functor[1];
          var param = mty_functor[0];
          var match_000 = +(mty_param === /* None */0);
          var match_001 = default_mty(mty_param);
          var generative = match_000;
          if (generative) {
            if (Caml_obj.caml_notequal(sarg[/* pmod_desc */0], /* Pmod_structure */Block.__(1, [/* [] */0]))) {
              throw [
                    $$Error$10,
                    sfunct[/* pmod_loc */1],
                    env,
                    /* Apply_generative */4
                  ];
            }
            if (funct_body && contains_type$1(env, funct[/* mod_type */2])) {
              throw [
                    $$Error$10,
                    smod[/* pmod_loc */1],
                    env,
                    /* Not_allowed_in_functor_body */1
                  ];
            }
            
          }
          var coercion;
          try {
            coercion = modtypes$1(env, arg[/* mod_type */2], match_001);
          }
          catch (raw_exn){
            var exn = Js_exn.internalToOCamlException(raw_exn);
            if (exn[0] === $$Error$5) {
              throw [
                    $$Error$10,
                    sarg[/* pmod_loc */1],
                    env,
                    /* Not_included */Block.__(1, [exn[1]])
                  ];
            } else {
              throw exn;
            }
          }
          var mty_appl;
          if (path$1) {
            mty_appl = modtype(add_module(param, path$1[0], identity), mty_res);
          } else if (generative) {
            mty_appl = mty_res;
          } else {
            try {
              mty_appl = nondep_supertype(add_module$1(/* Some */[/* true */1], param, arg[/* mod_type */2], env), param, mty_res);
            }
            catch (exn$1){
              if (exn$1 === Caml_builtin_exceptions.not_found) {
                throw [
                      $$Error$10,
                      smod[/* pmod_loc */1],
                      env,
                      /* Cannot_eliminate_dependency */Block.__(2, [mty_functor])
                    ];
              } else {
                throw exn$1;
              }
            }
          }
          return rm(/* record */[
                      /* mod_desc : Tmod_apply */Block.__(3, [
                          funct,
                          arg,
                          coercion
                        ]),
                      /* mod_loc */smod[/* pmod_loc */1],
                      /* mod_type */mty_appl,
                      /* mod_env */env,
                      /* mod_attributes */smod[/* pmod_attributes */2]
                    ]);
        } else {
          throw [
                $$Error$10,
                sfunct[/* pmod_loc */1],
                env,
                /* Cannot_apply */Block.__(0, [funct[/* mod_type */2]])
              ];
        }
        break;
    case 4 : 
        var arg$1 = type_module$1(/* Some */[alias], /* true */1, funct_body, anchor, env, match[0]);
        var mty$4 = transl_modtype$1(env, match[1]);
        var init = wrap_constraint(env, arg$1, mty$4[/* mty_type */1], /* Tmodtype_explicit */[mty$4]);
        return rm(/* record */[
                    /* mod_desc */init[/* mod_desc */0],
                    /* mod_loc */smod[/* pmod_loc */1],
                    /* mod_type */init[/* mod_type */2],
                    /* mod_env */init[/* mod_env */3],
                    /* mod_attributes */smod[/* pmod_attributes */2]
                  ]);
    case 5 : 
        if (principal[0]) {
          begin_def(/* () */0);
        }
        var exp = type_exp(env, match[0]);
        if (principal[0]) {
          end_def(/* () */0);
          generalize_structure$1(current_level[0], exp[/* exp_type */3]);
        }
        var match$4 = expand_head(env, exp[/* exp_type */3]);
        var match$5 = match$4[/* desc */0];
        var mty$5;
        var exit$1 = 0;
        if (typeof match$5 === "number") {
          exit$1 = 1;
        } else {
          switch (match$5.tag | 0) {
            case 0 : 
                throw [
                      $$Error$7,
                      smod[/* pmod_loc */1],
                      env,
                      /* Cannot_infer_signature */3
                    ];
            case 11 : 
                var tl = match$5[2];
                if (List.exists((function (t) {
                          return +(free_variables$1(/* None */0, t) !== /* [] */0);
                        }), tl)) {
                  throw [
                        $$Error$10,
                        smod[/* pmod_loc */1],
                        env,
                        /* Incomplete_packed_module */Block.__(13, [exp[/* exp_type */3]])
                      ];
                }
                if (principal[0] && !generalizable(99999999, exp[/* exp_type */3])) {
                  prerr_warning(smod[/* pmod_loc */1], /* Not_principal */Block.__(8, ["this module unpacking"]));
                }
                mty$5 = modtype_of_package(env, smod[/* pmod_loc */1], match$5[0], match$5[1], tl);
                break;
            default:
              exit$1 = 1;
          }
        }
        if (exit$1 === 1) {
          throw [
                $$Error$10,
                smod[/* pmod_loc */1],
                env,
                /* Not_a_packed_module */Block.__(12, [exp[/* exp_type */3]])
              ];
        }
        if (funct_body && contains_type$1(env, mty$5)) {
          throw [
                $$Error$10,
                smod[/* pmod_loc */1],
                env,
                /* Not_allowed_in_functor_body */1
              ];
        }
        return rm(/* record */[
                    /* mod_desc : Tmod_unpack */Block.__(5, [
                        exp,
                        mty$5
                      ]),
                    /* mod_loc */smod[/* pmod_loc */1],
                    /* mod_type */mty$5,
                    /* mod_env */env,
                    /* mod_attributes */smod[/* pmod_attributes */2]
                  ]);
    case 6 : 
        throw [
              Error_forward$3,
              error_of_extension(match[0])
            ];
    
  }
}

function type_structure($staropt$star, funct_body, anchor, env, sstr, scope) {
  var toplevel = $staropt$star ? $staropt$star[0] : /* false */0;
  var type_names = [/* Empty */0];
  var module_names = [/* Empty */0];
  var modtype_names = [/* Empty */0];
  var type_str_item = function (env, srem, param) {
    var loc = param[/* pstr_loc */1];
    var desc = param[/* pstr_desc */0];
    switch (desc.tag | 0) {
      case 0 : 
          var expr = type_expression(env, desc[0]);
          return /* tuple */[
                  /* Tstr_eval */Block.__(0, [
                      expr,
                      desc[1]
                    ]),
                  /* [] */0,
                  env
                ];
      case 1 : 
          var rec_flag = desc[0];
          var scope$1;
          if (rec_flag !== 0) {
            scope$1 = /* Some */[/* Idef */Block.__(1, [/* record */[
                    /* loc_start */loc[/* loc_start */0],
                    /* loc_end */scope[/* loc_end */1],
                    /* loc_ghost */scope[/* loc_ghost */2]
                  ]])];
          } else {
            var start = srem ? srem[0][/* pstr_loc */1][/* loc_start */0] : loc[/* loc_end */1];
            scope$1 = /* Some */[/* Idef */Block.__(1, [/* record */[
                    /* loc_start */start,
                    /* loc_end */scope[/* loc_end */1],
                    /* loc_ghost */scope[/* loc_ghost */2]
                  ]])];
          }
          var match = type_binding(env, rec_flag, desc[1], scope$1);
          var newenv = match[1];
          var defs = match[0];
          return /* tuple */[
                  /* Tstr_value */Block.__(1, [
                      rec_flag,
                      defs
                    ]),
                  List.map((function (id) {
                          return /* Sig_value */Block.__(0, [
                                    id,
                                    find_value(/* Pident */Block.__(0, [id]), newenv)
                                  ]);
                        }), let_bound_idents(defs)),
                  newenv
                ];
      case 2 : 
          var match$1 = transl_value_decl(env, loc, desc[0]);
          var desc$1 = match$1[0];
          return /* tuple */[
                  /* Tstr_primitive */Block.__(2, [desc$1]),
                  /* :: */[
                    /* Sig_value */Block.__(0, [
                        desc$1[/* val_id */0],
                        desc$1[/* val_val */3]
                      ]),
                    /* [] */0
                  ],
                  match$1[1]
                ];
      case 3 : 
          var sdecls = desc[0];
          var rec_flag$1 = rec_flag_of_ptype_declarations(sdecls);
          List.iter((function (decl) {
                  return check_name("type", type_names, decl[/* ptype_name */0]);
                }), sdecls);
          var match$2 = transl_type_decl(env, rec_flag$1, sdecls);
          var decls = match$2[0];
          return /* tuple */[
                  /* Tstr_type */Block.__(3, [decls]),
                  map_rec_type_with_row_types(rec_flag$1, (function (rs, info) {
                          return /* Sig_type */Block.__(1, [
                                    info[/* typ_id */0],
                                    info[/* typ_type */3],
                                    rs
                                  ]);
                        }), decls, /* [] */0),
                  enrich_type_decls(anchor, decls, env, match$2[1])
                ];
      case 4 : 
          var match$3 = transl_type_extension(/* true */1, env, loc, desc[0]);
          var tyext = match$3[0];
          return /* tuple */[
                  /* Tstr_typext */Block.__(4, [tyext]),
                  map_ext((function (es, ext) {
                          return /* Sig_typext */Block.__(2, [
                                    ext[/* ext_id */0],
                                    ext[/* ext_type */2],
                                    es
                                  ]);
                        }), tyext[/* tyext_constructors */3], /* [] */0),
                  match$3[1]
                ];
      case 5 : 
          var match$4 = transl_exception(env, desc[0]);
          var ext = match$4[0];
          return /* tuple */[
                  /* Tstr_exception */Block.__(5, [ext]),
                  /* :: */[
                    /* Sig_typext */Block.__(2, [
                        ext[/* ext_id */0],
                        ext[/* ext_type */2],
                        /* Text_exception */2
                      ]),
                    /* [] */0
                  ],
                  match$4[1]
                ];
      case 6 : 
          var match$5 = desc[0];
          var pmb_loc = match$5[/* pmb_loc */3];
          var attrs = match$5[/* pmb_attributes */2];
          var name = match$5[/* pmb_name */0];
          check_name("module", module_names, name);
          var modl = type_module$1(/* Some */[/* true */1], /* true */1, funct_body, anchor_submodule(name[/* txt */0], anchor), env, match$5[/* pmb_expr */1]);
          var md_000 = /* md_type */enrich_module_type(anchor, name[/* txt */0], modl[/* mod_type */2], env);
          var md = /* record */[
            md_000,
            /* md_attributes */attrs,
            /* md_loc */pmb_loc
          ];
          var match$6 = enter_module_declaration(/* None */0, name[/* txt */0], md, env);
          var id = match$6[0];
          return /* tuple */[
                  /* Tstr_module */Block.__(6, [/* record */[
                        /* mb_id */id,
                        /* mb_name */name,
                        /* mb_expr */modl,
                        /* mb_attributes */attrs,
                        /* mb_loc */pmb_loc
                      ]]),
                  /* :: */[
                    /* Sig_module */Block.__(3, [
                        id,
                        /* record */[
                          /* md_type */modl[/* mod_type */2],
                          /* md_attributes */attrs,
                          /* md_loc */pmb_loc
                        ],
                        /* Trec_not */0
                      ]),
                    /* [] */0
                  ],
                  match$6[1]
                ];
      case 7 : 
          var sbind = List.map((function (mb) {
                  var match = mb[/* pmb_expr */1][/* pmod_desc */0];
                  if (match.tag === 4) {
                    return /* tuple */[
                            mb[/* pmb_name */0],
                            match[1],
                            match[0],
                            mb[/* pmb_attributes */2],
                            mb[/* pmb_loc */3]
                          ];
                  } else {
                    throw [
                          $$Error$10,
                          mb[/* pmb_expr */1][/* pmod_loc */1],
                          env,
                          /* Recursive_module_require_explicit_type */3
                        ];
                  }
                }), desc[0]);
          List.iter((function (param) {
                  return check_name("module", module_names, param[0]);
                }), sbind);
          var match$7 = transl_recmodule_modtypes(loc, env, List.map((function (param) {
                      return /* record */[
                              /* pmd_name */param[0],
                              /* pmd_type */param[1],
                              /* pmd_attributes */param[3],
                              /* pmd_loc */param[4]
                            ];
                    }), sbind));
          var newenv$1 = match$7[1];
          var decls$1 = match$7[0];
          var bindings1 = List.map2((function (param, param$1) {
                  var id = param[/* md_id */0];
                  var modl = type_module$1(/* None */0, /* true */1, funct_body, /* Some */[/* Pident */Block.__(0, [id])], newenv$1, param$1[2]);
                  var mty$prime = enrich_module_type(anchor, id[/* name */1], modl[/* mod_type */2], newenv$1);
                  return /* tuple */[
                          id,
                          param$1[0],
                          param[/* md_type */2],
                          modl,
                          mty$prime,
                          param$1[3],
                          param$1[4]
                        ];
                }), decls$1, sbind);
          var newenv$2 = List.fold_left((function (env, md) {
                  var mdecl_000 = /* md_type */md[/* md_type */2][/* mty_type */1];
                  var mdecl_001 = /* md_attributes */md[/* md_attributes */3];
                  var mdecl_002 = /* md_loc */md[/* md_loc */4];
                  var mdecl = /* record */[
                    mdecl_000,
                    mdecl_001,
                    mdecl_002
                  ];
                  return add_module_declaration(/* None */0, md[/* md_id */0], mdecl, env);
                }), env, decls$1);
          var bindings2 = check_recmodule_inclusion(newenv$2, bindings1);
          return /* tuple */[
                  /* Tstr_recmodule */Block.__(7, [bindings2]),
                  map_rec((function (rs, mb) {
                          return /* Sig_module */Block.__(3, [
                                    mb[/* mb_id */0],
                                    /* record */[
                                      /* md_type */mb[/* mb_expr */2][/* mod_type */2],
                                      /* md_attributes */mb[/* mb_attributes */3],
                                      /* md_loc */mb[/* mb_loc */4]
                                    ],
                                    rs
                                  ]);
                        }), bindings2, /* [] */0),
                  newenv$2
                ];
      case 8 : 
          var match$8 = transl_modtype_decl(modtype_names, env, loc, desc[0]);
          return /* tuple */[
                  /* Tstr_modtype */Block.__(8, [match$8[1]]),
                  /* :: */[
                    match$8[2],
                    /* [] */0
                  ],
                  match$8[0]
                ];
      case 9 : 
          var match$9 = type_open$1(/* Some */[toplevel], env, desc[0]);
          return /* tuple */[
                  /* Tstr_open */Block.__(9, [match$9[2]]),
                  /* [] */0,
                  match$9[1]
                ];
      case 10 : 
          var cl = desc[0];
          List.iter((function (param) {
                  return check_name("type", type_names, param[/* pci_name */2]);
                }), cl);
          var match$10 = class_declarations$2(env, cl);
          var classes = match$10[0];
          return /* tuple */[
                  /* Tstr_class */Block.__(10, [List.map((function (param) {
                              var vf = param[2][/* cty_new */3] ? /* Concrete */1 : /* Virtual */0;
                              return /* tuple */[
                                      param[11],
                                      param[10],
                                      vf
                                    ];
                            }), classes)]),
                  List.flatten(map_rec((function (rs, param) {
                              return /* :: */[
                                      /* Sig_class */Block.__(5, [
                                          param[0],
                                          param[2],
                                          rs
                                        ]),
                                      /* :: */[
                                        /* Sig_class_type */Block.__(6, [
                                            param[3],
                                            param[4],
                                            rs
                                          ]),
                                        /* :: */[
                                          /* Sig_type */Block.__(1, [
                                              param[5],
                                              param[6],
                                              rs
                                            ]),
                                          /* :: */[
                                            /* Sig_type */Block.__(1, [
                                                param[7],
                                                param[8],
                                                rs
                                              ]),
                                            /* [] */0
                                          ]
                                        ]
                                      ]
                                    ];
                            }), classes, /* [] */0)),
                  match$10[1]
                ];
      case 11 : 
          var cl$1 = desc[0];
          List.iter((function (param) {
                  return check_name("type", type_names, param[/* pci_name */2]);
                }), cl$1);
          var match$11 = class_type_declarations$2(env, cl$1);
          var classes$1 = match$11[0];
          return /* tuple */[
                  /* Tstr_class_type */Block.__(11, [List.map((function (param) {
                              return /* tuple */[
                                      param[0],
                                      param[1],
                                      param[7]
                                    ];
                            }), classes$1)]),
                  List.flatten(map_rec((function (rs, param) {
                              return /* :: */[
                                      /* Sig_class_type */Block.__(6, [
                                          param[0],
                                          param[2],
                                          rs
                                        ]),
                                      /* :: */[
                                        /* Sig_type */Block.__(1, [
                                            param[3],
                                            param[4],
                                            rs
                                          ]),
                                        /* :: */[
                                          /* Sig_type */Block.__(1, [
                                              param[5],
                                              param[6],
                                              rs
                                            ]),
                                          /* [] */0
                                        ]
                                      ]
                                    ];
                            }), classes$1, /* [] */0)),
                  match$11[1]
                ];
      case 12 : 
          var sincl = desc[0];
          var smodl = sincl[/* pincl_mod */0];
          var modl$1 = type_module$1(/* None */0, /* true */1, funct_body, /* None */0, env, smodl);
          var sg = signature$2(identity, extract_sig_open(env, smodl[/* pmod_loc */1], modl$1[/* mod_type */2]));
          var match$12 = modl$1[/* mod_desc */0];
          var sg$1;
          if (match$12.tag) {
            sg$1 = sg;
          } else {
            var p = match$12[0];
            if (is_functor_arg(p, env)) {
              sg$1 = sg;
            } else {
              add_required_global(head(p));
              var pos = [0];
              sg$1 = List.map((function (it) {
                      switch (it.tag | 0) {
                        case 0 : 
                            var match = it[1][/* val_kind */1];
                            if (typeof match === "number" && match === 0) {
                              pos[0] = pos[0] + 1 | 0;
                              return it;
                            } else {
                              return it;
                            }
                        case 3 : 
                            var md = it[1];
                            var id = it[0];
                            var n = pos[0];
                            pos[0] = pos[0] + 1 | 0;
                            return /* Sig_module */Block.__(3, [
                                      id,
                                      /* record */[
                                        /* md_type : Mty_alias */Block.__(3, [/* Pdot */Block.__(1, [
                                                p,
                                                id[/* name */1],
                                                n
                                              ])]),
                                        /* md_attributes */md[/* md_attributes */1],
                                        /* md_loc */md[/* md_loc */2]
                                      ],
                                      it[2]
                                    ]);
                        case 2 : 
                        case 5 : 
                            pos[0] = pos[0] + 1 | 0;
                            return it;
                        default:
                          return it;
                      }
                    }), sg);
            }
          }
          List.iter((function (param) {
                  return check_sig_item(type_names, module_names, modtype_names, loc, param);
                }), sg$1);
          var new_env = add_signature(sg$1, env);
          var incl_002 = /* incl_loc */sincl[/* pincl_loc */1];
          var incl_003 = /* incl_attributes */sincl[/* pincl_attributes */2];
          var incl = /* record */[
            /* incl_mod */modl$1,
            /* incl_type */sg$1,
            incl_002,
            incl_003
          ];
          return /* tuple */[
                  /* Tstr_include */Block.__(12, [incl]),
                  sg$1,
                  new_env
                ];
      case 13 : 
          var x = desc[0];
          warning_attribute(/* :: */[
                x,
                /* [] */0
              ]);
          return /* tuple */[
                  /* Tstr_attribute */Block.__(13, [x]),
                  /* [] */0,
                  env
                ];
      case 14 : 
          throw [
                Error_forward$3,
                error_of_extension(desc[0])
              ];
      
    }
  };
  var type_struct = function (env, sstr) {
    init_def(currentstamp[0]);
    if (sstr) {
      var srem = sstr[1];
      var pstr = sstr[0];
      var previous_saved_types = saved_types[0];
      var match = type_str_item(env, srem, pstr);
      var str_000 = /* str_desc */match[0];
      var str_001 = /* str_loc */pstr[/* pstr_loc */1];
      var str = /* record */[
        str_000,
        str_001,
        /* str_env */env
      ];
      saved_types[0] = /* :: */[
        /* Partial_structure_item */Block.__(1, [str]),
        previous_saved_types
      ];
      var match$1 = type_struct(match[2], srem);
      return /* tuple */[
              /* :: */[
                str,
                match$1[0]
              ],
              Pervasives.$at(match[1], match$1[1]),
              match$1[2]
            ];
    } else {
      return /* tuple */[
              /* [] */0,
              /* [] */0,
              env
            ];
    }
  };
  if (annotations[0]) {
    List.iter((function (param) {
            var loc = param[/* pstr_loc */1];
            if (annotations[0]) {
              phrases[0] = /* :: */[
                loc,
                phrases[0]
              ];
              return /* () */0;
            } else {
              return 0;
            }
          }), sstr);
  }
  var previous_saved_types = saved_types[0];
  warning_enter_scope(/* () */0);
  var match = type_struct(env, sstr);
  var final_env = match[2];
  var sg = match[1];
  var str_000 = /* str_items */match[0];
  var str = /* record */[
    str_000,
    /* str_type */sg,
    /* str_final_env */final_env
  ];
  warning_leave_scope(/* () */0);
  saved_types[0] = /* :: */[
    /* Partial_structure */Block.__(0, [str]),
    previous_saved_types
  ];
  return /* tuple */[
          str,
          sg,
          final_env
        ];
}

function type_module$2(param, param$1) {
  return type_module$1(/* None */0, /* true */1, /* false */0, /* None */0, param, param$1);
}

function type_structure$1(param, param$1, param$2) {
  return type_structure(/* None */0, /* false */0, /* None */0, param, param$1, param$2);
}

function normalize_signature_item(env, param) {
  switch (param.tag | 0) {
    case 0 : 
        return normalize_type(env, param[1][/* val_type */0]);
    case 3 : 
        var env$1 = env;
        var _param = param[1][/* md_type */0];
        while(true) {
          var param$1 = _param;
          switch (param$1.tag | 0) {
            case 1 : 
                return List.iter((function (param) {
                              return normalize_signature_item(env$1, param);
                            }), param$1[0]);
            case 2 : 
                _param = param$1[2];
                continue ;
                case 0 : 
            case 3 : 
                return /* () */0;
            
          }
        };
    default:
      return /* () */0;
  }
}

function type_module_type_of(env, smod) {
  var match = smod[/* pmod_desc */0];
  var tmty;
  if (match.tag) {
    tmty = type_module$2(env, smod);
  } else {
    var lid = match[0];
    var match$1 = find_module$1(env, smod[/* pmod_loc */1], lid[/* txt */0]);
    tmty = rm(/* record */[
          /* mod_desc : Tmod_ident */Block.__(0, [
              match$1[0],
              lid
            ]),
          /* mod_loc */smod[/* pmod_loc */1],
          /* mod_type */match$1[1][/* md_type */0],
          /* mod_env */env,
          /* mod_attributes */smod[/* pmod_attributes */2]
        ]);
  }
  var mty = tmty[/* mod_type */2];
  var mty$1 = remove_aliases$1(env, mty);
  if (!closed_modtype(mty$1)) {
    throw [
          $$Error$10,
          smod[/* pmod_loc */1],
          env,
          /* Non_generalizable_module */Block.__(9, [mty$1])
        ];
  }
  return /* tuple */[
          tmty,
          mty$1
        ];
}

function type_package$1(env, m, p, nl, _) {
  var lv = current_level[0];
  begin_def(/* () */0);
  set_current_time(lv);
  var context = narrow(/* () */0);
  var modl = type_module$2(env, m);
  init_def(currentstamp[0]);
  widen(context);
  var match = modl[/* mod_desc */0];
  var match$1;
  if (match.tag) {
    var match$2 = enter_module(/* Some */[/* true */1], "%M", modl[/* mod_type */2], env);
    match$1 = /* tuple */[
      /* Pident */Block.__(0, [match$2[0]]),
      match$2[1]
    ];
  } else {
    match$1 = /* tuple */[
      match[0],
      env
    ];
  }
  var env$1 = match$1[1];
  var mp = match$1[0];
  var mkpath = function (mp, param) {
    switch (param.tag | 0) {
      case 0 : 
          return /* Pdot */Block.__(1, [
                    mp,
                    param[0],
                    -1
                  ]);
      case 1 : 
          return /* Pdot */Block.__(1, [
                    mkpath(mp, param[0]),
                    param[1],
                    -1
                  ]);
      case 2 : 
          throw [
                Caml_builtin_exceptions.assert_failure,
                [
                  "typemod.ml",
                  1565,
                  11
                ]
              ];
      
    }
  };
  var tl$prime = List.map((function (name) {
          return newty2(100000000, /* Tconstr */Block.__(3, [
                        mkpath(mp, name),
                        /* [] */0,
                        [/* Mnil */0]
                      ]));
        }), nl);
  end_def(/* () */0);
  if (nl) {
    var mty = modtype_of_package(env$1, modl[/* mod_loc */1], p, nl, tl$prime);
    List.iter2((function (n, ty) {
            try {
              return unify$2(env$1, ty, newvar(/* None */0, /* () */0));
            }
            catch (raw_exn){
              var exn = Js_exn.internalToOCamlException(raw_exn);
              if (exn[0] === Unify) {
                throw [
                      $$Error$10,
                      m[/* pmod_loc */1],
                      env$1,
                      /* Scoping_pack */Block.__(14, [
                          n,
                          ty
                        ])
                    ];
              } else {
                throw exn;
              }
            }
          }), nl, tl$prime);
    return /* tuple */[
            wrap_constraint(env$1, modl, mty, /* Tmodtype_implicit */0),
            tl$prime
          ];
  } else {
    return /* tuple */[
            wrap_constraint(env$1, modl, /* Mty_ident */Block.__(0, [p]), /* Tmodtype_implicit */0),
            /* [] */0
          ];
  }
}

type_module[0] = type_module$2;

transl_modtype_longident[0] = transl_modtype_longident$1;

transl_modtype[0] = transl_modtype$1;

type_open[0] = (function (param, param$1, param$2, param$3) {
    return type_open_(/* None */0, param, param$1, param$2, param$3);
  });

type_package[0] = type_package$1;

type_module_type_of_fwd[0] = type_module_type_of;

function type_implementation_more(sourcefile, outputprefix, modulename, initial_env, ast) {
  clear(/* () */0);
  try {
    delayed_checks[0] = /* [] */0;
    required_globals[0] = /* [] */0;
    Curry._2(newrecord$3[/* structure */31], newrecord$3, ast);
    var match = type_structure$1(initial_env, ast, in_file(sourcefile));
    var finalenv = match[2];
    var sg = match[1];
    var str = match[0];
    var simple_sg = simplify_signature(sg);
    if (print_types[0]) {
      wrap_printing_env(initial_env, (function () {
              return Curry._2(Format.fprintf(Format.std_formatter, /* Format */[
                              /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                      /* Flush_newline */4,
                                      /* End_of_format */0
                                    ])]),
                              "%a@."
                            ]), signature$3, simple_sg);
            }));
      return /* tuple */[
              str,
              /* Tcoerce_none */0,
              finalenv,
              simple_sg
            ];
    } else {
      var sourceintf = chop_extension_if_any(sourcefile) + interface_suffix[0];
      var mli_status = assume_no_mli[0];
      if (mli_status === /* Mli_na */0 && Caml_missing_polyfill.not_implemented("caml_sys_file_exists not implemented by bucklescript yet\n") || mli_status === /* Mli_exists */1) {
        var intf_file;
        try {
          intf_file = find_in_path_uncap(load_path[0], modulename + ".cmi");
        }
        catch (exn){
          if (exn === Caml_builtin_exceptions.not_found) {
            throw [
                  $$Error$10,
                  in_file(sourcefile),
                  empty,
                  /* Interface_not_compiled */Block.__(11, [sourceintf])
                ];
          } else {
            throw exn;
          }
        }
        var dclsig = read_signature(modulename, intf_file);
        var coercion = compunit(initial_env, sourcefile, sg, intf_file, dclsig);
        force_delayed_checks(/* () */0);
        save_cmt(outputprefix + ".cmt", modulename, /* Implementation */Block.__(1, [str]), /* Some */[sourcefile], initial_env, /* None */0);
        return /* tuple */[
                str,
                coercion,
                finalenv,
                dclsig
              ];
      } else {
        List.iter((function (param) {
                var env = finalenv;
                var str = param;
                var match = str[/* str_desc */0];
                switch (match.tag | 0) {
                  case 1 : 
                      return List.iter((function (param) {
                                    var exp = param[/* vb_expr */1];
                                    if (closed_schema(exp[/* exp_type */3])) {
                                      return 0;
                                    } else {
                                      throw [
                                            $$Error$10,
                                            exp[/* exp_loc */1],
                                            env,
                                            /* Non_generalizable */Block.__(7, [exp[/* exp_type */3]])
                                          ];
                                    }
                                  }), match[1]);
                  case 6 : 
                      var md = match[0][/* mb_expr */2];
                      if (closed_modtype(md[/* mod_type */2])) {
                        return 0;
                      } else {
                        throw [
                              $$Error$10,
                              md[/* mod_loc */1],
                              env,
                              /* Non_generalizable_module */Block.__(9, [md[/* mod_type */2]])
                            ];
                      }
                      break;
                  default:
                    return /* () */0;
                }
              }), str[/* str_items */0]);
        List.iter((function (param) {
                return normalize_signature_item(finalenv, param);
              }), simple_sg);
        var coercion$1 = compunit(initial_env, sourcefile, sg, "(inferred signature)", simple_sg);
        force_delayed_checks(/* () */0);
        if (!dont_write_files[0]) {
          var sg$1 = save_signature(simple_sg, modulename, outputprefix + ".cmi");
          save_cmt(outputprefix + ".cmt", modulename, /* Implementation */Block.__(1, [str]), /* Some */[sourcefile], initial_env, /* Some */[sg$1]);
        }
        return /* tuple */[
                str,
                coercion$1,
                finalenv,
                simple_sg
              ];
      }
    }
  }
  catch (e){
    save_cmt(outputprefix + ".cmt", modulename, /* Partial_implementation */Block.__(3, [$$Array.of_list(saved_types[0])]), /* Some */[sourcefile], initial_env, /* None */0);
    throw e;
  }
}

function type_implementation(sourcefile, outputprefix, modulename, initial_env, ast) {
  var match = type_implementation_more(sourcefile, outputprefix, modulename, initial_env, ast);
  return /* tuple */[
          match[0],
          match[1]
        ];
}

register_error_of_exn((function (param) {
        if (param[0] === $$Error$10) {
          var env = param[2];
          return /* Some */[error_of_printer(param[1], (function (param, param$1) {
                          var env$1 = env;
                          var ppf = param;
                          var err = param$1;
                          return wrap_printing_env(env$1, (function () {
                                        var ppf$1 = ppf;
                                        var param = err;
                                        if (typeof param === "number") {
                                          switch (param) {
                                            case 0 : 
                                                return Format.fprintf(ppf$1, /* Format */[
                                                            /* String_literal */Block.__(11, [
                                                                "This module type is not a signature",
                                                                /* End_of_format */0
                                                              ]),
                                                            "This module type is not a signature"
                                                          ]);
                                            case 1 : 
                                                return Curry._1(Format.fprintf(ppf$1, /* Format */[
                                                                /* Formatting_gen */Block.__(18, [
                                                                    /* Open_box */Block.__(1, [/* Format */[
                                                                          /* End_of_format */0,
                                                                          ""
                                                                        ]]),
                                                                    /* String_literal */Block.__(11, [
                                                                        "This expression creates fresh types.",
                                                                        /* Formatting_lit */Block.__(17, [
                                                                            /* Break */Block.__(0, [
                                                                                "@ ",
                                                                                1,
                                                                                0
                                                                              ]),
                                                                            /* String */Block.__(2, [
                                                                                /* No_padding */0,
                                                                                /* Formatting_lit */Block.__(17, [
                                                                                    /* Close_box */0,
                                                                                    /* End_of_format */0
                                                                                  ])
                                                                              ])
                                                                          ])
                                                                      ])
                                                                  ]),
                                                                "@[This expression creates fresh types.@ %s@]"
                                                              ]), "It is not allowed inside applicative functors.");
                                            case 2 : 
                                                return Format.fprintf(ppf$1, /* Format */[
                                                            /* String_literal */Block.__(11, [
                                                                "Only type constructors with identical parameters can be substituted.",
                                                                /* End_of_format */0
                                                              ]),
                                                            "Only type constructors with identical parameters can be substituted."
                                                          ]);
                                            case 3 : 
                                                return Format.fprintf(ppf$1, /* Format */[
                                                            /* String_literal */Block.__(11, [
                                                                "Recursive modules require an explicit module type.",
                                                                /* End_of_format */0
                                                              ]),
                                                            "Recursive modules require an explicit module type."
                                                          ]);
                                            case 4 : 
                                                return Format.fprintf(ppf$1, /* Format */[
                                                            /* String_literal */Block.__(11, [
                                                                "This is a generative functor. It can only be applied to ()",
                                                                /* End_of_format */0
                                                              ]),
                                                            "This is a generative functor. It can only be applied to ()"
                                                          ]);
                                            
                                          }
                                        } else {
                                          switch (param.tag | 0) {
                                            case 0 : 
                                                return Curry._2(Format.fprintf(ppf$1, /* Format */[
                                                                /* Formatting_gen */Block.__(18, [
                                                                    /* Open_box */Block.__(1, [/* Format */[
                                                                          /* End_of_format */0,
                                                                          ""
                                                                        ]]),
                                                                    /* String_literal */Block.__(11, [
                                                                        "This module is not a functor; it has type",
                                                                        /* Formatting_lit */Block.__(17, [
                                                                            /* Break */Block.__(0, [
                                                                                "@ ",
                                                                                1,
                                                                                0
                                                                              ]),
                                                                            /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                                    /* Close_box */0,
                                                                                    /* End_of_format */0
                                                                                  ])])
                                                                          ])
                                                                      ])
                                                                  ]),
                                                                "@[This module is not a functor; it has type@ %a@]"
                                                              ]), modtype$1, param[0]);
                                            case 1 : 
                                                return Curry._2(Format.fprintf(ppf$1, /* Format */[
                                                                /* Formatting_gen */Block.__(18, [
                                                                    /* Open_box */Block.__(1, [/* Format */[
                                                                          /* String_literal */Block.__(11, [
                                                                              "<v>",
                                                                              /* End_of_format */0
                                                                            ]),
                                                                          "<v>"
                                                                        ]]),
                                                                    /* String_literal */Block.__(11, [
                                                                        "Signature mismatch:",
                                                                        /* Formatting_lit */Block.__(17, [
                                                                            /* Break */Block.__(0, [
                                                                                "@ ",
                                                                                1,
                                                                                0
                                                                              ]),
                                                                            /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                                    /* Close_box */0,
                                                                                    /* End_of_format */0
                                                                                  ])])
                                                                          ])
                                                                      ])
                                                                  ]),
                                                                "@[<v>Signature mismatch:@ %a@]"
                                                              ]), report_error$4, param[0]);
                                            case 2 : 
                                                return Curry._2(Format.fprintf(ppf$1, /* Format */[
                                                                /* Formatting_gen */Block.__(18, [
                                                                    /* Open_box */Block.__(1, [/* Format */[
                                                                          /* End_of_format */0,
                                                                          ""
                                                                        ]]),
                                                                    /* String_literal */Block.__(11, [
                                                                        "This functor has type",
                                                                        /* Formatting_lit */Block.__(17, [
                                                                            /* Break */Block.__(0, [
                                                                                "@ ",
                                                                                1,
                                                                                0
                                                                              ]),
                                                                            /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                                    /* Break */Block.__(0, [
                                                                                        "@ ",
                                                                                        1,
                                                                                        0
                                                                                      ]),
                                                                                    /* String_literal */Block.__(11, [
                                                                                        "The parameter cannot be eliminated in the result type.",
                                                                                        /* Formatting_lit */Block.__(17, [
                                                                                            /* Break */Block.__(0, [
                                                                                                "@ ",
                                                                                                1,
                                                                                                0
                                                                                              ]),
                                                                                            /* String_literal */Block.__(11, [
                                                                                                " Please bind the argument to a module identifier.",
                                                                                                /* Formatting_lit */Block.__(17, [
                                                                                                    /* Close_box */0,
                                                                                                    /* End_of_format */0
                                                                                                  ])
                                                                                              ])
                                                                                          ])
                                                                                      ])
                                                                                  ])])
                                                                          ])
                                                                      ])
                                                                  ]),
                                                                "@[This functor has type@ %a@ The parameter cannot be eliminated in the result type.@  Please bind the argument to a module identifier.@]"
                                                              ]), modtype$1, param[0]);
                                            case 3 : 
                                                return Curry._2(Format.fprintf(ppf$1, /* Format */[
                                                                /* Formatting_gen */Block.__(18, [
                                                                    /* Open_box */Block.__(1, [/* Format */[
                                                                          /* End_of_format */0,
                                                                          ""
                                                                        ]]),
                                                                    /* String_literal */Block.__(11, [
                                                                        "This module is not a structure; it has type",
                                                                        /* Formatting_lit */Block.__(17, [
                                                                            /* Break */Block.__(0, [
                                                                                "@ ",
                                                                                1,
                                                                                0
                                                                              ]),
                                                                            /* Alpha */Block.__(15, [/* End_of_format */0])
                                                                          ])
                                                                      ])
                                                                  ]),
                                                                "@[This module is not a structure; it has type@ %a"
                                                              ]), modtype$1, param[0]);
                                            case 4 : 
                                                return Curry._2(Format.fprintf(ppf$1, /* Format */[
                                                                /* Formatting_gen */Block.__(18, [
                                                                    /* Open_box */Block.__(1, [/* Format */[
                                                                          /* End_of_format */0,
                                                                          ""
                                                                        ]]),
                                                                    /* String_literal */Block.__(11, [
                                                                        "The signature constrained by `with' has no component named ",
                                                                        /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                                /* Close_box */0,
                                                                                /* End_of_format */0
                                                                              ])])
                                                                      ])
                                                                  ]),
                                                                "@[The signature constrained by `with' has no component named %a@]"
                                                              ]), longident, param[0]);
                                            case 5 : 
                                                return Curry._4(Format.fprintf(ppf$1, /* Format */[
                                                                /* Formatting_gen */Block.__(18, [
                                                                    /* Open_box */Block.__(1, [/* Format */[
                                                                          /* String_literal */Block.__(11, [
                                                                              "<v>",
                                                                              /* End_of_format */0
                                                                            ]),
                                                                          "<v>"
                                                                        ]]),
                                                                    /* Formatting_gen */Block.__(18, [
                                                                        /* Open_box */Block.__(1, [/* Format */[
                                                                              /* End_of_format */0,
                                                                              ""
                                                                            ]]),
                                                                        /* String_literal */Block.__(11, [
                                                                            "In this `with' constraint, the new definition of ",
                                                                            /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                                    /* Break */Block.__(0, [
                                                                                        "@ ",
                                                                                        1,
                                                                                        0
                                                                                      ]),
                                                                                    /* String_literal */Block.__(11, [
                                                                                        "does not match its original definition",
                                                                                        /* Formatting_lit */Block.__(17, [
                                                                                            /* Break */Block.__(0, [
                                                                                                "@ ",
                                                                                                1,
                                                                                                0
                                                                                              ]),
                                                                                            /* String_literal */Block.__(11, [
                                                                                                "in the constrained signature:",
                                                                                                /* Formatting_lit */Block.__(17, [
                                                                                                    /* Close_box */0,
                                                                                                    /* Formatting_lit */Block.__(17, [
                                                                                                        /* Break */Block.__(0, [
                                                                                                            "@ ",
                                                                                                            1,
                                                                                                            0
                                                                                                          ]),
                                                                                                        /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                                                                /* Close_box */0,
                                                                                                                /* End_of_format */0
                                                                                                              ])])
                                                                                                      ])
                                                                                                  ])
                                                                                              ])
                                                                                          ])
                                                                                      ])
                                                                                  ])])
                                                                          ])
                                                                      ])
                                                                  ]),
                                                                "@[<v>@[In this `with' constraint, the new definition of %a@ does not match its original definition@ in the constrained signature:@]@ %a@]"
                                                              ]), longident, param[0], report_error$4, param[1]);
                                            case 6 : 
                                                return Curry._2(Format.fprintf(ppf$1, /* Format */[
                                                                /* Formatting_gen */Block.__(18, [
                                                                    /* Open_box */Block.__(1, [/* Format */[
                                                                          /* End_of_format */0,
                                                                          ""
                                                                        ]]),
                                                                    /* String_literal */Block.__(11, [
                                                                        "Multiple definition of the ",
                                                                        /* String */Block.__(2, [
                                                                            /* No_padding */0,
                                                                            /* String_literal */Block.__(11, [
                                                                                " name ",
                                                                                /* String */Block.__(2, [
                                                                                    /* No_padding */0,
                                                                                    /* Char_literal */Block.__(12, [
                                                                                        /* "." */46,
                                                                                        /* Formatting_lit */Block.__(17, [
                                                                                            /* Break */Block.__(0, [
                                                                                                "@ ",
                                                                                                1,
                                                                                                0
                                                                                              ]),
                                                                                            /* String_literal */Block.__(11, [
                                                                                                "Names must be unique in a given structure or signature.",
                                                                                                /* Formatting_lit */Block.__(17, [
                                                                                                    /* Close_box */0,
                                                                                                    /* End_of_format */0
                                                                                                  ])
                                                                                              ])
                                                                                          ])
                                                                                      ])
                                                                                  ])
                                                                              ])
                                                                          ])
                                                                      ])
                                                                  ]),
                                                                "@[Multiple definition of the %s name %s.@ Names must be unique in a given structure or signature.@]"
                                                              ]), param[0], param[1]);
                                            case 7 : 
                                                return Curry._2(Format.fprintf(ppf$1, /* Format */[
                                                                /* Formatting_gen */Block.__(18, [
                                                                    /* Open_box */Block.__(1, [/* Format */[
                                                                          /* End_of_format */0,
                                                                          ""
                                                                        ]]),
                                                                    /* String_literal */Block.__(11, [
                                                                        "The type of this expression,",
                                                                        /* Formatting_lit */Block.__(17, [
                                                                            /* Break */Block.__(0, [
                                                                                "@ ",
                                                                                1,
                                                                                0
                                                                              ]),
                                                                            /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                                                                    /* "," */44,
                                                                                    /* Formatting_lit */Block.__(17, [
                                                                                        /* Break */Block.__(0, [
                                                                                            "@ ",
                                                                                            1,
                                                                                            0
                                                                                          ]),
                                                                                        /* String_literal */Block.__(11, [
                                                                                            "contains type variables that cannot be generalized",
                                                                                            /* Formatting_lit */Block.__(17, [
                                                                                                /* Close_box */0,
                                                                                                /* End_of_format */0
                                                                                              ])
                                                                                          ])
                                                                                      ])
                                                                                  ])])
                                                                          ])
                                                                      ])
                                                                  ]),
                                                                "@[The type of this expression,@ %a,@ contains type variables that cannot be generalized@]"
                                                              ]), type_scheme, param[0]);
                                            case 8 : 
                                                var id = param[0];
                                                return Curry._2(Format.fprintf(ppf$1, /* Format */[
                                                                /* Formatting_gen */Block.__(18, [
                                                                    /* Open_box */Block.__(1, [/* Format */[
                                                                          /* End_of_format */0,
                                                                          ""
                                                                        ]]),
                                                                    /* String_literal */Block.__(11, [
                                                                        "The type of this class,",
                                                                        /* Formatting_lit */Block.__(17, [
                                                                            /* Break */Block.__(0, [
                                                                                "@ ",
                                                                                1,
                                                                                0
                                                                              ]),
                                                                            /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                                                                    /* "," */44,
                                                                                    /* Formatting_lit */Block.__(17, [
                                                                                        /* Break */Block.__(0, [
                                                                                            "@ ",
                                                                                            1,
                                                                                            0
                                                                                          ]),
                                                                                        /* String_literal */Block.__(11, [
                                                                                            "contains type variables that cannot be generalized",
                                                                                            /* Formatting_lit */Block.__(17, [
                                                                                                /* Close_box */0,
                                                                                                /* End_of_format */0
                                                                                              ])
                                                                                          ])
                                                                                      ])
                                                                                  ])])
                                                                          ])
                                                                      ])
                                                                  ]),
                                                                "@[The type of this class,@ %a,@ contains type variables that cannot be generalized@]"
                                                              ]), (function (param, param$1) {
                                                              return class_declaration$1(id, param, param$1);
                                                            }), param[1]);
                                            case 9 : 
                                                return Curry._2(Format.fprintf(ppf$1, /* Format */[
                                                                /* Formatting_gen */Block.__(18, [
                                                                    /* Open_box */Block.__(1, [/* Format */[
                                                                          /* End_of_format */0,
                                                                          ""
                                                                        ]]),
                                                                    /* String_literal */Block.__(11, [
                                                                        "The type of this module,",
                                                                        /* Formatting_lit */Block.__(17, [
                                                                            /* Break */Block.__(0, [
                                                                                "@ ",
                                                                                1,
                                                                                0
                                                                              ]),
                                                                            /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                                                                    /* "," */44,
                                                                                    /* Formatting_lit */Block.__(17, [
                                                                                        /* Break */Block.__(0, [
                                                                                            "@ ",
                                                                                            1,
                                                                                            0
                                                                                          ]),
                                                                                        /* String_literal */Block.__(11, [
                                                                                            "contains type variables that cannot be generalized",
                                                                                            /* Formatting_lit */Block.__(17, [
                                                                                                /* Close_box */0,
                                                                                                /* End_of_format */0
                                                                                              ])
                                                                                          ])
                                                                                      ])
                                                                                  ])])
                                                                          ])
                                                                      ])
                                                                  ]),
                                                                "@[The type of this module,@ %a,@ contains type variables that cannot be generalized@]"
                                                              ]), modtype$1, param[0]);
                                            case 10 : 
                                                return Curry._2(Format.fprintf(ppf$1, /* Format */[
                                                                /* Formatting_gen */Block.__(18, [
                                                                    /* Open_box */Block.__(1, [/* Format */[
                                                                          /* End_of_format */0,
                                                                          ""
                                                                        ]]),
                                                                    /* String_literal */Block.__(11, [
                                                                        "The interface ",
                                                                        /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                                /* Break */Block.__(0, [
                                                                                    "@ ",
                                                                                    1,
                                                                                    0
                                                                                  ]),
                                                                                /* String_literal */Block.__(11, [
                                                                                    "declares values, not just types.",
                                                                                    /* Formatting_lit */Block.__(17, [
                                                                                        /* Break */Block.__(0, [
                                                                                            "@ ",
                                                                                            1,
                                                                                            0
                                                                                          ]),
                                                                                        /* String_literal */Block.__(11, [
                                                                                            "An implementation must be provided.",
                                                                                            /* Formatting_lit */Block.__(17, [
                                                                                                /* Close_box */0,
                                                                                                /* End_of_format */0
                                                                                              ])
                                                                                          ])
                                                                                      ])
                                                                                  ])
                                                                              ])])
                                                                      ])
                                                                  ]),
                                                                "@[The interface %a@ declares values, not just types.@ An implementation must be provided.@]"
                                                              ]), print_filename, param[0]);
                                            case 11 : 
                                                return Curry._2(Format.fprintf(ppf$1, /* Format */[
                                                                /* Formatting_gen */Block.__(18, [
                                                                    /* Open_box */Block.__(1, [/* Format */[
                                                                          /* End_of_format */0,
                                                                          ""
                                                                        ]]),
                                                                    /* String_literal */Block.__(11, [
                                                                        "Could not find the .cmi file for interface",
                                                                        /* Formatting_lit */Block.__(17, [
                                                                            /* Break */Block.__(0, [
                                                                                "@ ",
                                                                                1,
                                                                                0
                                                                              ]),
                                                                            /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                                                                    /* "." */46,
                                                                                    /* Formatting_lit */Block.__(17, [
                                                                                        /* Close_box */0,
                                                                                        /* End_of_format */0
                                                                                      ])
                                                                                  ])])
                                                                          ])
                                                                      ])
                                                                  ]),
                                                                "@[Could not find the .cmi file for interface@ %a.@]"
                                                              ]), print_filename, param[0]);
                                            case 12 : 
                                                return Curry._2(Format.fprintf(ppf$1, /* Format */[
                                                                /* String_literal */Block.__(11, [
                                                                    "This expression is not a packed module. It has type",
                                                                    /* Formatting_lit */Block.__(17, [
                                                                        /* Break */Block.__(0, [
                                                                            "@ ",
                                                                            1,
                                                                            0
                                                                          ]),
                                                                        /* Alpha */Block.__(15, [/* End_of_format */0])
                                                                      ])
                                                                  ]),
                                                                "This expression is not a packed module. It has type@ %a"
                                                              ]), type_expr$1, param[0]);
                                            case 13 : 
                                                return Curry._2(Format.fprintf(ppf$1, /* Format */[
                                                                /* String_literal */Block.__(11, [
                                                                    "The type of this packed module contains variables:",
                                                                    /* Formatting_lit */Block.__(17, [
                                                                        /* Break */Block.__(0, [
                                                                            "@ ",
                                                                            1,
                                                                            0
                                                                          ]),
                                                                        /* Alpha */Block.__(15, [/* End_of_format */0])
                                                                      ])
                                                                  ]),
                                                                "The type of this packed module contains variables:@ %a"
                                                              ]), type_expr$1, param[0]);
                                            case 14 : 
                                                Curry._2(Format.fprintf(ppf$1, /* Format */[
                                                          /* String_literal */Block.__(11, [
                                                              "The type ",
                                                              /* Alpha */Block.__(15, [/* String_literal */Block.__(11, [
                                                                      " in this module cannot be exported.",
                                                                      /* Formatting_lit */Block.__(17, [
                                                                          /* Break */Block.__(0, [
                                                                              "@ ",
                                                                              1,
                                                                              0
                                                                            ]),
                                                                          /* End_of_format */0
                                                                        ])
                                                                    ])])
                                                            ]),
                                                          "The type %a in this module cannot be exported.@ "
                                                        ]), longident, param[0]);
                                                return Curry._2(Format.fprintf(ppf$1, /* Format */[
                                                                /* String_literal */Block.__(11, [
                                                                    "Its type contains local dependencies:",
                                                                    /* Formatting_lit */Block.__(17, [
                                                                        /* Break */Block.__(0, [
                                                                            "@ ",
                                                                            1,
                                                                            0
                                                                          ]),
                                                                        /* Alpha */Block.__(15, [/* End_of_format */0])
                                                                      ])
                                                                  ]),
                                                                "Its type contains local dependencies:@ %a"
                                                              ]), type_expr$1, param[1]);
                                            
                                          }
                                        }
                                      }));
                        }), param[3])];
        } else if (param[0] === Error_forward$3) {
          return /* Some */[param[1]];
        } else {
          return /* None */0;
        }
      }));

var suites = [/* [] */0];

var test_id = [0];

function eq(loc, x, y) {
  test_id[0] = test_id[0] + 1 | 0;
  suites[0] = /* :: */[
    /* tuple */[
      loc + (" id " + test_id[0]),
      (function () {
          return /* Eq */Block.__(0, [
                    x,
                    y
                  ]);
        })
    ],
    suites[0]
  ];
  return /* () */0;
}

dont_write_files[0] = /* true */1;

unsafe_string = /* false */0;

debug = /* true */1;

record_event_when_debug = /* false */0;

binary_annotations[0] = /* false */0;

nopervasives = /* true */1;

assume_no_mli[0] = /* Mli_non_exists */2;

var modulename = "Test";

var x = type_implementation(modulename, modulename, modulename, empty, wrap$1(implementation, Lexing.from_string("\ntype int\nexternal ( ~- ) : int -> int = \"%negint\"\nexternal ( ~+ ) : int -> int = \"%identity\"\nexternal succ : int -> int = \"%succint\"\nexternal pred : int -> int = \"%predint\"\nexternal ( + ) : int -> int -> int = \"%addint\"\nexternal ( - ) : int -> int -> int = \"%subint\"\nexternal ( * ) : int -> int -> int = \"%mulint\"\nexternal ( / ) : int -> int -> int = \"%divint\"\nexternal ( mod ) : int -> int -> int = \"%modint\"\n let f x y = x + y")));

var match$1 = x[0][/* str_items */0];

if (match$1) {
  var match$2 = match$1[0];
  var match$3 = match$2[/* str_desc */0];
  if (match$3.tag === 3) {
    var match$4 = match$3[0];
    if (match$4) {
      var match$5 = match$4[0];
      var match$6 = match$5[/* typ_id */0];
      if (match$6[/* name */1] === "int") {
        var match$7 = match$6[/* flags */2];
        if (match$7 !== 0) {
          eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
        } else {
          var match$8 = match$5[/* typ_name */1];
          if (match$8[/* txt */0] === "int") {
            var match$9 = match$8[/* loc */1];
            var match$10 = match$9[/* loc_start */0];
            if (match$10[/* pos_fname */0] === "") {
              if (match$10[/* pos_lnum */1] !== 2) {
                eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
              } else if (match$10[/* pos_bol */2] !== 1) {
                eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
              } else if (match$10[/* pos_cnum */3] !== 6) {
                eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
              } else {
                var match$11 = match$9[/* loc_end */1];
                if (match$11[/* pos_fname */0] === "") {
                  if (match$11[/* pos_lnum */1] !== 2) {
                    eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                  } else if (match$11[/* pos_bol */2] !== 1) {
                    eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                  } else if (match$11[/* pos_cnum */3] !== 9) {
                    eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                  } else if (match$9[/* loc_ghost */2] !== 0) {
                    eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                  } else if (match$5[/* typ_params */2]) {
                    eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                  } else {
                    var match$12 = match$5[/* typ_type */3];
                    if (match$12[/* type_params */0]) {
                      eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                    } else if (match$12[/* type_arity */1] !== 0) {
                      eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                    } else {
                      var match$13 = match$12[/* type_kind */2];
                      if (typeof match$13 === "number") {
                        if (match$13 !== 0) {
                          eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                        } else if (match$12[/* type_private */3] !== 0) {
                          if (match$12[/* type_manifest */4]) {
                            eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                          } else if (match$12[/* type_variance */5]) {
                            eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                          } else if (match$12[/* type_newtype_level */6]) {
                            eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                          } else {
                            var match$14 = match$12[/* type_loc */7];
                            var match$15 = match$14[/* loc_start */0];
                            if (match$15[/* pos_fname */0] === "") {
                              if (match$15[/* pos_lnum */1] !== 2) {
                                eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                              } else if (match$15[/* pos_bol */2] !== 1) {
                                eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                              } else if (match$15[/* pos_cnum */3] !== 1) {
                                eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                              } else {
                                var match$16 = match$14[/* loc_end */1];
                                if (match$16[/* pos_fname */0] === "") {
                                  if (match$16[/* pos_lnum */1] !== 2) {
                                    eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                  } else if (match$16[/* pos_bol */2] !== 1) {
                                    eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                  } else if (match$16[/* pos_cnum */3] !== 9) {
                                    eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                  } else if (match$14[/* loc_ghost */2] !== 0) {
                                    eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                  } else if (match$12[/* type_attributes */8]) {
                                    eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                  } else if (match$5[/* typ_cstrs */4]) {
                                    eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                  } else {
                                    var match$17 = match$5[/* typ_kind */5];
                                    if (typeof match$17 === "number") {
                                      if (match$17 !== 0) {
                                        eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                      } else if (match$5[/* typ_private */6] !== 0) {
                                        if (match$5[/* typ_manifest */7]) {
                                          eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                        } else {
                                          var match$18 = match$5[/* typ_loc */8];
                                          var match$19 = match$18[/* loc_start */0];
                                          if (match$19[/* pos_fname */0] === "") {
                                            if (match$19[/* pos_lnum */1] !== 2) {
                                              eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                            } else if (match$19[/* pos_bol */2] !== 1) {
                                              eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                            } else if (match$19[/* pos_cnum */3] !== 1) {
                                              eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                            } else {
                                              var match$20 = match$18[/* loc_end */1];
                                              if (match$20[/* pos_fname */0] === "") {
                                                if (match$20[/* pos_lnum */1] !== 2) {
                                                  eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                } else if (match$20[/* pos_bol */2] !== 1) {
                                                  eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                } else if (match$20[/* pos_cnum */3] !== 9) {
                                                  eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                } else if (match$18[/* loc_ghost */2] !== 0) {
                                                  eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                } else if (match$5[/* typ_attributes */9]) {
                                                  eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                } else if (match$4[1]) {
                                                  eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                } else {
                                                  var match$21 = match$2[/* str_loc */1];
                                                  var match$22 = match$21[/* loc_start */0];
                                                  if (match$22[/* pos_fname */0] === "") {
                                                    if (match$22[/* pos_lnum */1] !== 2) {
                                                      eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                    } else if (match$22[/* pos_bol */2] !== 1) {
                                                      eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                    } else if (match$22[/* pos_cnum */3] !== 1) {
                                                      eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                    } else {
                                                      var match$23 = match$21[/* loc_end */1];
                                                      if (match$23[/* pos_fname */0] === "") {
                                                        if (match$23[/* pos_lnum */1] !== 2) {
                                                          eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                        } else if (match$23[/* pos_bol */2] !== 1) {
                                                          eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                        } else if (match$23[/* pos_cnum */3] !== 9) {
                                                          eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                        } else if (match$21[/* loc_ghost */2] !== 0) {
                                                          eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                        } else {
                                                          var match$24 = match$1[1];
                                                          if (match$24) {
                                                            var match$25 = match$24[0][/* str_desc */0];
                                                            if (match$25.tag === 2) {
                                                              var match$26 = match$25[0];
                                                              var match$27 = match$26[/* val_id */0];
                                                              if (match$27[/* name */1] === "~-") {
                                                                var match$28 = match$27[/* flags */2];
                                                                if (match$28 !== 0) {
                                                                  eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                } else {
                                                                  var match$29 = match$26[/* val_name */1];
                                                                  if (match$29[/* txt */0] === "~-") {
                                                                    var match$30 = match$29[/* loc */1];
                                                                    var match$31 = match$30[/* loc_start */0];
                                                                    if (match$31[/* pos_fname */0] === "") {
                                                                      if (match$31[/* pos_lnum */1] !== 3) {
                                                                        eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                      } else if (match$31[/* pos_bol */2] !== 10) {
                                                                        eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                      } else if (match$31[/* pos_cnum */3] !== 19) {
                                                                        eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                      } else {
                                                                        var match$32 = match$30[/* loc_end */1];
                                                                        if (match$32[/* pos_fname */0] === "") {
                                                                          if (match$32[/* pos_lnum */1] !== 3) {
                                                                            eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                          } else if (match$32[/* pos_bol */2] !== 10) {
                                                                            eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                          } else if (match$32[/* pos_cnum */3] !== 25) {
                                                                            eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                          } else if (match$30[/* loc_ghost */2] !== 0) {
                                                                            eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                          } else {
                                                                            var match$33 = match$26[/* val_desc */2];
                                                                            var match$34 = match$33[/* ctyp_desc */0];
                                                                            if (typeof match$34 === "number") {
                                                                              eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                            } else if (match$34.tag === 1) {
                                                                              if (match$34[0] === "") {
                                                                                var match$35 = match$34[1];
                                                                                var match$36 = match$35[/* ctyp_desc */0];
                                                                                if (typeof match$36 === "number") {
                                                                                  eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                } else if (match$36.tag === 3) {
                                                                                  var match$37 = match$36[0];
                                                                                  switch (match$37.tag | 0) {
                                                                                    case 0 : 
                                                                                        var match$38 = match$37[0];
                                                                                        if (match$38[/* name */1] === "int") {
                                                                                          var match$39 = match$38[/* flags */2];
                                                                                          if (match$39 !== 0) {
                                                                                            eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                          } else {
                                                                                            var match$40 = match$36[1];
                                                                                            var match$41 = match$40[/* txt */0];
                                                                                            switch (match$41.tag | 0) {
                                                                                              case 0 : 
                                                                                                  if (match$41[0] === "int") {
                                                                                                    var match$42 = match$40[/* loc */1];
                                                                                                    var match$43 = match$42[/* loc_start */0];
                                                                                                    if (match$43[/* pos_fname */0] === "") {
                                                                                                      if (match$43[/* pos_lnum */1] !== 3) {
                                                                                                        eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                      } else if (match$43[/* pos_bol */2] !== 10) {
                                                                                                        eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                      } else if (match$43[/* pos_cnum */3] !== 28) {
                                                                                                        eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                      } else {
                                                                                                        var match$44 = match$42[/* loc_end */1];
                                                                                                        if (match$44[/* pos_fname */0] === "") {
                                                                                                          if (match$44[/* pos_lnum */1] !== 3) {
                                                                                                            eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                          } else if (match$44[/* pos_bol */2] !== 10) {
                                                                                                            eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                          } else if (match$44[/* pos_cnum */3] !== 31) {
                                                                                                            eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                          } else if (match$42[/* loc_ghost */2] !== 0) {
                                                                                                            eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                          } else if (match$36[2]) {
                                                                                                            eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                          } else {
                                                                                                            var match$45 = match$35[/* ctyp_type */1];
                                                                                                            var match$46 = match$45[/* desc */0];
                                                                                                            if (typeof match$46 === "number") {
                                                                                                              eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                            } else if (match$46.tag === 3) {
                                                                                                              var match$47 = match$46[0];
                                                                                                              switch (match$47.tag | 0) {
                                                                                                                case 0 : 
                                                                                                                    var match$48 = match$47[0];
                                                                                                                    if (match$48[/* name */1] === "int") {
                                                                                                                      var match$49 = match$48[/* flags */2];
                                                                                                                      if (match$49 !== 0) {
                                                                                                                        eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                      } else if (match$46[1]) {
                                                                                                                        eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                      } else {
                                                                                                                        var match$50 = match$46[2][/* contents */0];
                                                                                                                        if (typeof match$50 === "number") {
                                                                                                                          var match$51 = match$35[/* ctyp_loc */3];
                                                                                                                          var match$52 = match$51[/* loc_start */0];
                                                                                                                          if (match$52[/* pos_fname */0] === "") {
                                                                                                                            if (match$52[/* pos_lnum */1] !== 3) {
                                                                                                                              eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                            } else if (match$52[/* pos_bol */2] !== 10) {
                                                                                                                              eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                            } else if (match$52[/* pos_cnum */3] !== 28) {
                                                                                                                              eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                            } else {
                                                                                                                              var match$53 = match$51[/* loc_end */1];
                                                                                                                              if (match$53[/* pos_fname */0] === "") {
                                                                                                                                if (match$53[/* pos_lnum */1] !== 3) {
                                                                                                                                  eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                } else if (match$53[/* pos_bol */2] !== 10) {
                                                                                                                                  eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                } else if (match$53[/* pos_cnum */3] !== 31) {
                                                                                                                                  eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                } else if (match$51[/* loc_ghost */2] !== 0) {
                                                                                                                                  eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                } else if (match$35[/* ctyp_attributes */4]) {
                                                                                                                                  eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                } else {
                                                                                                                                  var match$54 = match$34[2];
                                                                                                                                  var match$55 = match$54[/* ctyp_desc */0];
                                                                                                                                  if (typeof match$55 === "number") {
                                                                                                                                    eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                  } else if (match$55.tag === 3) {
                                                                                                                                    var match$56 = match$55[0];
                                                                                                                                    switch (match$56.tag | 0) {
                                                                                                                                      case 0 : 
                                                                                                                                          var match$57 = match$56[0];
                                                                                                                                          if (match$57[/* name */1] === "int") {
                                                                                                                                            var match$58 = match$57[/* flags */2];
                                                                                                                                            if (match$58 !== 0) {
                                                                                                                                              eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                            } else {
                                                                                                                                              var match$59 = match$55[1];
                                                                                                                                              var match$60 = match$59[/* txt */0];
                                                                                                                                              switch (match$60.tag | 0) {
                                                                                                                                                case 0 : 
                                                                                                                                                    if (match$60[0] === "int") {
                                                                                                                                                      var match$61 = match$59[/* loc */1];
                                                                                                                                                      var match$62 = match$61[/* loc_start */0];
                                                                                                                                                      if (match$62[/* pos_fname */0] === "") {
                                                                                                                                                        if (match$62[/* pos_lnum */1] !== 3) {
                                                                                                                                                          eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                                        } else if (match$62[/* pos_bol */2] !== 10) {
                                                                                                                                                          eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                                        } else if (match$62[/* pos_cnum */3] !== 35) {
                                                                                                                                                          eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                                        } else {
                                                                                                                                                          var match$63 = match$61[/* loc_end */1];
                                                                                                                                                          if (match$63[/* pos_fname */0] === "") {
                                                                                                                                                            if (match$63[/* pos_lnum */1] !== 3) {
                                                                                                                                                              eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                                            } else if (match$63[/* pos_bol */2] !== 10) {
                                                                                                                                                              eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                                            } else if (match$63[/* pos_cnum */3] !== 38) {
                                                                                                                                                              eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                                            } else if (match$61[/* loc_ghost */2] !== 0) {
                                                                                                                                                              eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                                            } else if (match$55[2]) {
                                                                                                                                                              eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                                            } else {
                                                                                                                                                              var match$64 = match$54[/* ctyp_type */1];
                                                                                                                                                              var match$65 = match$64[/* desc */0];
                                                                                                                                                              if (typeof match$65 === "number") {
                                                                                                                                                                eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                                              } else if (match$65.tag === 3) {
                                                                                                                                                                var match$66 = match$65[0];
                                                                                                                                                                switch (match$66.tag | 0) {
                                                                                                                                                                  case 0 : 
                                                                                                                                                                      var match$67 = match$66[0];
                                                                                                                                                                      if (match$67[/* name */1] === "int") {
                                                                                                                                                                        var match$68 = match$67[/* flags */2];
                                                                                                                                                                        if (match$68 !== 0) {
                                                                                                                                                                          eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                                                        } else if (match$65[1]) {
                                                                                                                                                                          eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                                                        } else {
                                                                                                                                                                          var match$69 = match$65[2][/* contents */0];
                                                                                                                                                                          if (typeof match$69 === "number") {
                                                                                                                                                                            var match$70 = match$54[/* ctyp_loc */3];
                                                                                                                                                                            var match$71 = match$70[/* loc_start */0];
                                                                                                                                                                            if (match$71[/* pos_fname */0] === "") {
                                                                                                                                                                              if (match$71[/* pos_lnum */1] !== 3) {
                                                                                                                                                                                eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                                                              } else if (match$71[/* pos_bol */2] !== 10) {
                                                                                                                                                                                eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                                                              } else if (match$71[/* pos_cnum */3] !== 35) {
                                                                                                                                                                                eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                                                              } else {
                                                                                                                                                                                var match$72 = match$70[/* loc_end */1];
                                                                                                                                                                                if (match$72[/* pos_fname */0] === "") {
                                                                                                                                                                                  if (match$72[/* pos_lnum */1] !== 3) {
                                                                                                                                                                                    eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                                                                  } else if (match$72[/* pos_bol */2] !== 10) {
                                                                                                                                                                                    eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                                                                  } else if (match$72[/* pos_cnum */3] !== 38) {
                                                                                                                                                                                    eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                                                                  } else if (match$70[/* loc_ghost */2] !== 0) {
                                                                                                                                                                                    eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                                                                  } else if (match$54[/* ctyp_attributes */4]) {
                                                                                                                                                                                    eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                                                                  } else {
                                                                                                                                                                                    var match$73 = match$33[/* ctyp_type */1];
                                                                                                                                                                                    var match$74 = match$73[/* desc */0];
                                                                                                                                                                                    if (typeof match$74 === "number") {
                                                                                                                                                                                      eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                                                                    } else if (match$74.tag === 1) {
                                                                                                                                                                                      if (match$74[0] === "") {
                                                                                                                                                                                        var match$75 = match$74[1][/* desc */0];
                                                                                                                                                                                        if (typeof match$75 === "number") {
                                                                                                                                                                                          eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                                                                        } else if (match$75.tag === 3) {
                                                                                                                                                                                          var match$76 = match$75[0];
                                                                                                                                                                                          switch (match$76.tag | 0) {
                                                                                                                                                                                            case 0 : 
                                                                                                                                                                                                var match$77 = match$76[0];
                                                                                                                                                                                                if (match$77[/* name */1] === "int") {
                                                                                                                                                                                                  var match$78 = match$77[/* flags */2];
                                                                                                                                                                                                  if (match$78 !== 0) {
                                                                                                                                                                                                    eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                                                                                  } else if (match$75[1]) {
                                                                                                                                                                                                    eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                                                                                  } else {
                                                                                                                                                                                                    var match$79 = match$75[2][/* contents */0];
                                                                                                                                                                                                    if (typeof match$79 === "number") {
                                                                                                                                                                                                      var match$80 = match$74[2][/* desc */0];
                                                                                                                                                                                                      if (typeof match$80 === "number") {
                                                                                                                                                                                                        eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                                                                                      } else if (match$80.tag === 3) {
                                                                                                                                                                                                        var match$81 = match$80[0];
                                                                                                                                                                                                        switch (match$81.tag | 0) {
                                                                                                                                                                                                          case 0 : 
                                                                                                                                                                                                              var match$82 = match$81[0];
                                                                                                                                                                                                              if (match$82[/* name */1] === "int") {
                                                                                                                                                                                                                var match$83 = match$82[/* flags */2];
                                                                                                                                                                                                                if (match$83 !== 0) {
                                                                                                                                                                                                                  eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                                                                                                } else if (match$80[1]) {
                                                                                                                                                                                                                  eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                                                                                                } else {
                                                                                                                                                                                                                  var match$84 = match$80[2][/* contents */0];
                                                                                                                                                                                                                  if (typeof match$84 === "number") {
                                                                                                                                                                                                                    var match$85 = match$74[3];
                                                                                                                                                                                                                    if (typeof match$85 === "number") {
                                                                                                                                                                                                                      if (match$85 !== 0) {
                                                                                                                                                                                                                        eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                                                                                                      } else {
                                                                                                                                                                                                                        var match$86 = match$33[/* ctyp_loc */3];
                                                                                                                                                                                                                        var match$87 = match$86[/* loc_start */0];
                                                                                                                                                                                                                        if (match$87[/* pos_fname */0] === "") {
                                                                                                                                                                                                                          if (match$87[/* pos_lnum */1] !== 3) {
                                                                                                                                                                                                                            eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                                                                                                          } else if (match$87[/* pos_bol */2] !== 10) {
                                                                                                                                                                                                                            eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                                                                                                          } else if (match$87[/* pos_cnum */3] !== 28) {
                                                                                                                                                                                                                            eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                                                                                                          } else {
                                                                                                                                                                                                                            var match$88 = match$86[/* loc_end */1];
                                                                                                                                                                                                                            if (match$88[/* pos_fname */0] === "") {
                                                                                                                                                                                                                              if (match$88[/* pos_lnum */1] !== 3) {
                                                                                                                                                                                                                                eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                                                                                                              } else if (match$88[/* pos_bol */2] !== 10) {
                                                                                                                                                                                                                                eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                                                                                                              } else if (match$88[/* pos_cnum */3] !== 38) {
                                                                                                                                                                                                                                eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                                                                                                              } else if (match$86[/* loc_ghost */2] !== 0) {
                                                                                                                                                                                                                                eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                                                                                                              } else if (match$33[/* ctyp_attributes */4]) {
                                                                                                                                                                                                                                eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                                                                                                              } else {
                                                                                                                                                                                                                                var match$89 = match$26[/* val_val */3];
                                                                                                                                                                                                                                var match$90 = match$89[/* val_type */0][/* desc */0];
                                                                                                                                                                                                                                if (typeof match$90 === "number") {
                                                                                                                                                                                                                                  eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                                                                                                                } else if (match$90.tag === 1) {
                                                                                                                                                                                                                                  if (match$90[0] === "") {
                                                                                                                                                                                                                                    var match$91 = match$90[1][/* desc */0];
                                                                                                                                                                                                                                    if (typeof match$91 === "number") {
                                                                                                                                                                                                                                      eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                                                                                                                    } else if (match$91.tag === 3) {
                                                                                                                                                                                                                                      var match$92 = match$91[0];
                                                                                                                                                                                                                                      switch (match$92.tag | 0) {
                                                                                                                                                                                                                                        case 0 : 
                                                                                                                                                                                                                                            var match$93 = match$92[0];
                                                                                                                                                                                                                                            if (match$93[/* name */1] === "int") {
                                                                                                                                                                                                                                              var match$94 = match$93[/* flags */2];
                                                                                                                                                                                                                                              if (match$94 !== 0) {
                                                                                                                                                                                                                                                eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                                                                                                                              } else if (match$91[1]) {
                                                                                                                                                                                                                                                eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                                                                                                                              } else {
                                                                                                                                                                                                                                                var match$95 = match$91[2][/* contents */0];
                                                                                                                                                                                                                                                if (typeof match$95 === "number") {
                                                                                                                                                                                                                                                  var match$96 = match$90[2][/* desc */0];
                                                                                                                                                                                                                                                  if (typeof match$96 === "number") {
                                                                                                                                                                                                                                                    eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                                                                                                                                  } else if (match$96.tag === 3) {
                                                                                                                                                                                                                                                    var match$97 = match$96[0];
                                                                                                                                                                                                                                                    switch (match$97.tag | 0) {
                                                                                                                                                                                                                                                      case 0 : 
                                                                                                                                                                                                                                                          var match$98 = match$97[0];
                                                                                                                                                                                                                                                          if (match$98[/* name */1] === "int") {
                                                                                                                                                                                                                                                            var match$99 = match$98[/* flags */2];
                                                                                                                                                                                                                                                            if (match$99 !== 0) {
                                                                                                                                                                                                                                                              eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                                                                                                                                            } else if (match$96[1]) {
                                                                                                                                                                                                                                                              eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                                                                                                                                            } else {
                                                                                                                                                                                                                                                              var match$100 = match$96[2][/* contents */0];
                                                                                                                                                                                                                                                              if (typeof match$100 === "number") {
                                                                                                                                                                                                                                                                var match$101 = match$90[3];
                                                                                                                                                                                                                                                                if (typeof match$101 === "number") {
                                                                                                                                                                                                                                                                  if (match$101 !== 0) {
                                                                                                                                                                                                                                                                    eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                                                                                                                                                  } else {
                                                                                                                                                                                                                                                                    var match$102 = match$89[/* val_kind */1];
                                                                                                                                                                                                                                                                    if (typeof match$102 === "number") {
                                                                                                                                                                                                                                                                      eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                                                                                                                                                    } else if (match$102.tag) {
                                                                                                                                                                                                                                                                      eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                                                                                                                                                    } else {
                                                                                                                                                                                                                                                                      var match$103 = match$102[0];
                                                                                                                                                                                                                                                                      if (match$103[/* prim_name */0] === "%negint") {
                                                                                                                                                                                                                                                                        if (match$103[/* prim_arity */1] !== 1) {
                                                                                                                                                                                                                                                                          eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                                                                                                                                                        } else if (match$103[/* prim_alloc */2] !== 0) {
                                                                                                                                                                                                                                                                          if (match$103[/* prim_native_name */3] === "") {
                                                                                                                                                                                                                                                                            if (match$103[/* prim_native_float */4] !== 0) {
                                                                                                                                                                                                                                                                              eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                                                                                                                                                            } else {
                                                                                                                                                                                                                                                                              var match$104 = match$89[/* val_loc */2];
                                                                                                                                                                                                                                                                              var match$105 = match$104[/* loc_start */0];
                                                                                                                                                                                                                                                                              if (match$105[/* pos_fname */0] === "") {
                                                                                                                                                                                                                                                                                if (match$105[/* pos_lnum */1] !== 3) {
                                                                                                                                                                                                                                                                                  eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                                                                                                                                                                } else if (match$105[/* pos_bol */2] !== 10) {
                                                                                                                                                                                                                                                                                  eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                                                                                                                                                                } else if (match$105[/* pos_cnum */3] !== 10) {
                                                                                                                                                                                                                                                                                  eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                                                                                                                                                                } else {
                                                                                                                                                                                                                                                                                  var match$106 = match$104[/* loc_end */1];
                                                                                                                                                                                                                                                                                  if (match$106[/* pos_fname */0] === "") {
                                                                                                                                                                                                                                                                                    if (match$106[/* pos_lnum */1] !== 3) {
                                                                                                                                                                                                                                                                                      eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                                                                                                                                                                    } else if (match$106[/* pos_bol */2] !== 10) {
                                                                                                                                                                                                                                                                                      eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                                                                                                                                                                    } else if (match$106[/* pos_cnum */3] !== 50) {
                                                                                                                                                                                                                                                                                      eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                                                                                                                                                                    } else if (match$104[/* loc_ghost */2] !== 0) {
                                                                                                                                                                                                                                                                                      eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                                                                                                                                                                    } else if (match$89[/* val_attributes */3]) {
                                                                                                                                                                                                                                                                                      eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                                                                                                                                                                    } else {
                                                                                                                                                                                                                                                                                      eq("File \"ocaml_typed_tree_main.ml\", line 220, characters 14-21", /* true */1, /* true */1);
                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                  } else {
                                                                                                                                                                                                                                                                                    eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                                                                                                                                                                  }
                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                              } else {
                                                                                                                                                                                                                                                                                eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                                                                                                                                                              }
                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                          } else {
                                                                                                                                                                                                                                                                            eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                                                                                                                                                          }
                                                                                                                                                                                                                                                                        } else {
                                                                                                                                                                                                                                                                          eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                      } else {
                                                                                                                                                                                                                                                                        eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                                                                                                                                                      }
                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                  }
                                                                                                                                                                                                                                                                } else {
                                                                                                                                                                                                                                                                  eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                              } else {
                                                                                                                                                                                                                                                                eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                                                                                                                                              }
                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                          } else {
                                                                                                                                                                                                                                                            eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                                                                                                                                          }
                                                                                                                                                                                                                                                          break;
                                                                                                                                                                                                                                                      case 1 : 
                                                                                                                                                                                                                                                      case 2 : 
                                                                                                                                                                                                                                                          eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                                                                                                                                          break;
                                                                                                                                                                                                                                                      
                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                  } else {
                                                                                                                                                                                                                                                    eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                                                                                                                                  }
                                                                                                                                                                                                                                                } else {
                                                                                                                                                                                                                                                  eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                              }
                                                                                                                                                                                                                                            } else {
                                                                                                                                                                                                                                              eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                            break;
                                                                                                                                                                                                                                        case 1 : 
                                                                                                                                                                                                                                        case 2 : 
                                                                                                                                                                                                                                            eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                                                                                                                            break;
                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                      }
                                                                                                                                                                                                                                    } else {
                                                                                                                                                                                                                                      eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                  } else {
                                                                                                                                                                                                                                    eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                                                                                                                  }
                                                                                                                                                                                                                                } else {
                                                                                                                                                                                                                                  eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                                                                                                                }
                                                                                                                                                                                                                              }
                                                                                                                                                                                                                            } else {
                                                                                                                                                                                                                              eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                                                                                                            }
                                                                                                                                                                                                                          }
                                                                                                                                                                                                                        } else {
                                                                                                                                                                                                                          eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                                                                                                        }
                                                                                                                                                                                                                      }
                                                                                                                                                                                                                    } else {
                                                                                                                                                                                                                      eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                                                                                                    }
                                                                                                                                                                                                                  } else {
                                                                                                                                                                                                                    eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                                                                                                  }
                                                                                                                                                                                                                }
                                                                                                                                                                                                              } else {
                                                                                                                                                                                                                eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                                                                                              }
                                                                                                                                                                                                              break;
                                                                                                                                                                                                          case 1 : 
                                                                                                                                                                                                          case 2 : 
                                                                                                                                                                                                              eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                                                                                              break;
                                                                                                                                                                                                          
                                                                                                                                                                                                        }
                                                                                                                                                                                                      } else {
                                                                                                                                                                                                        eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                                                                                      }
                                                                                                                                                                                                    } else {
                                                                                                                                                                                                      eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                                                                                    }
                                                                                                                                                                                                  }
                                                                                                                                                                                                } else {
                                                                                                                                                                                                  eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                                                                                }
                                                                                                                                                                                                break;
                                                                                                                                                                                            case 1 : 
                                                                                                                                                                                            case 2 : 
                                                                                                                                                                                                eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                                                                                break;
                                                                                                                                                                                            
                                                                                                                                                                                          }
                                                                                                                                                                                        } else {
                                                                                                                                                                                          eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                                                                        }
                                                                                                                                                                                      } else {
                                                                                                                                                                                        eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                                                                      }
                                                                                                                                                                                    } else {
                                                                                                                                                                                      eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                                                                    }
                                                                                                                                                                                  }
                                                                                                                                                                                } else {
                                                                                                                                                                                  eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                                                                }
                                                                                                                                                                              }
                                                                                                                                                                            } else {
                                                                                                                                                                              eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                                                            }
                                                                                                                                                                          } else {
                                                                                                                                                                            eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                                                          }
                                                                                                                                                                        }
                                                                                                                                                                      } else {
                                                                                                                                                                        eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                                                      }
                                                                                                                                                                      break;
                                                                                                                                                                  case 1 : 
                                                                                                                                                                  case 2 : 
                                                                                                                                                                      eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                                                      break;
                                                                                                                                                                  
                                                                                                                                                                }
                                                                                                                                                              } else {
                                                                                                                                                                eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                                              }
                                                                                                                                                            }
                                                                                                                                                          } else {
                                                                                                                                                            eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                                          }
                                                                                                                                                        }
                                                                                                                                                      } else {
                                                                                                                                                        eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                                      }
                                                                                                                                                    } else {
                                                                                                                                                      eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                                    }
                                                                                                                                                    break;
                                                                                                                                                case 1 : 
                                                                                                                                                case 2 : 
                                                                                                                                                    eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                                    break;
                                                                                                                                                
                                                                                                                                              }
                                                                                                                                            }
                                                                                                                                          } else {
                                                                                                                                            eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                          }
                                                                                                                                          break;
                                                                                                                                      case 1 : 
                                                                                                                                      case 2 : 
                                                                                                                                          eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                          break;
                                                                                                                                      
                                                                                                                                    }
                                                                                                                                  } else {
                                                                                                                                    eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                                  }
                                                                                                                                }
                                                                                                                              } else {
                                                                                                                                eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                              }
                                                                                                                            }
                                                                                                                          } else {
                                                                                                                            eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                          }
                                                                                                                        } else {
                                                                                                                          eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                        }
                                                                                                                      }
                                                                                                                    } else {
                                                                                                                      eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                    }
                                                                                                                    break;
                                                                                                                case 1 : 
                                                                                                                case 2 : 
                                                                                                                    eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                                    break;
                                                                                                                
                                                                                                              }
                                                                                                            } else {
                                                                                                              eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                            }
                                                                                                          }
                                                                                                        } else {
                                                                                                          eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                        }
                                                                                                      }
                                                                                                    } else {
                                                                                                      eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                    }
                                                                                                  } else {
                                                                                                    eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                  }
                                                                                                  break;
                                                                                              case 1 : 
                                                                                              case 2 : 
                                                                                                  eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                                  break;
                                                                                              
                                                                                            }
                                                                                          }
                                                                                        } else {
                                                                                          eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                        }
                                                                                        break;
                                                                                    case 1 : 
                                                                                    case 2 : 
                                                                                        eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                        break;
                                                                                    
                                                                                  }
                                                                                } else {
                                                                                  eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                                }
                                                                              } else {
                                                                                eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                              }
                                                                            } else {
                                                                              eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                            }
                                                                          }
                                                                        } else {
                                                                          eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                        }
                                                                      }
                                                                    } else {
                                                                      eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                    }
                                                                  } else {
                                                                    eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                                  }
                                                                }
                                                              } else {
                                                                eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                              }
                                                            } else {
                                                              eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                            }
                                                          } else {
                                                            eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                          }
                                                        }
                                                      } else {
                                                        eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                      }
                                                    }
                                                  } else {
                                                    eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                                  }
                                                }
                                              } else {
                                                eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                              }
                                            }
                                          } else {
                                            eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                          }
                                        }
                                      } else {
                                        eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                      }
                                    } else {
                                      eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                    }
                                  }
                                } else {
                                  eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                                }
                              }
                            } else {
                              eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                            }
                          }
                        } else {
                          eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                        }
                      } else {
                        eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                      }
                    }
                  }
                } else {
                  eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
                }
              }
            } else {
              eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
            }
          } else {
            eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
          }
        }
      } else {
        eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
      }
    } else {
      eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
    }
  } else {
    eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
  }
} else {
  eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", /* true */1, /* false */0);
}

from_pair_suites("ocaml_typed_tree_main.ml", suites[0]);

/*  Not a pure module */
